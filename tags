!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/danielsuh/comp_programming/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	/p5.9.20210905.0/
('n',	.config/nvim/init.vim	/^    map('n', '<A-i>', '<CMD>lua require("FTerm").toggle()<CR>', opts)$/;"	m
('n',	dotfiles/init.vim	/^    map('n', '<A-i>', '<CMD>lua require("FTerm").toggle()<CR>', opts)$/;"	m
('n',	dotfiles/macinit.vim	/^    map('n', '<A-i>', '<CMD>lua require("FTerm").toggle()<CR>', opts)$/;"	m
('t',	.config/nvim/init.vim	/^    map('t', '<A-i>', '<C-\\\\><C-n><CMD>lua require("FTerm").toggle()<CR>', opts)$/;"	m
('t',	dotfiles/init.vim	/^    map('t', '<A-i>', '<C-\\\\><C-n><CMD>lua require("FTerm").toggle()<CR>', opts)$/;"	m
('t',	dotfiles/macinit.vim	/^    map('t', '<A-i>', '<C-\\\\><C-n><CMD>lua require("FTerm").toggle()<CR>', opts)$/;"	m
0	practice/cf/random/1700/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	o	array:tests
0	practice/cf/random/1700/1618E/problem.json	/^{"name": "E. Singers' Tour", "group": "Codeforces - Codeforces Round #760 (Div. 3)", "url": "htt/;"	o	array:tests
0	practice/cf/random/coloring/problem.json	/^{"name": "A. Dreamoon Likes Coloring", "group": "Codeforces - Codeforces Round #631 (Div. 1) - T/;"	o	array:tests
0	practice/cf/random/diane/problem.json	/^{"name": "D. Diane", "group": "Codeforces - Codeforces Round #735 (Div. 2)", "url": "https:\/\/c/;"	o	array:tests
0	practice/cf/random/pink/problem.json	/^{"name": "C. Pinkie Pie Eats Patty-cakes", "group": "Codeforces - Codeforces Round #662 (Div. 2)/;"	o	array:tests
0	practice/cf/stuff/dec 20 2021/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	o	array:tests
0	practice/usacoguide/gold/SP/dining/problem.json	/^{"name": "Problem 1. Fine Dining", "group": "USACO - USACO 2018 December Contest, Gold", "url": /;"	o	array:tests
0	practice/usacoguide/gold/SP/visitfj/problem.json	/^{"name": "Problem 1. Why Did the Cow Cross the Road", "group": "USACO - USACO 2017 February Cont/;"	o	array:tests
0	practice/usacoguide/gold/bfs/cownav/problem.json	/^{"name": "Problem 3. Cow Navigation", "group": "USACO - USACO 2017 January Contest, Gold", "url"/;"	o	array:tests
0	practice/usacoguide/gold/bfs/swap/problem.json	/^{"name": "Swap Game", "group": "CSES - CSES Problem Set", "url": "https:\/\/cses.fi\/problemset\//;"	o	array:tests
0	practice/usacoguide/gold/dsu/closing/problem.json	/^{"name": "Problem 2. Closing the Farm", "group": "USACO - USACO 2016 US Open Contest, Gold", "ur/;"	o	array:tests
0	practice/usacoguide/gold/dsu/moocast/problem.json	/^{"name": "Problem 1. Moocast", "group": "USACO - USACO 2016 December Contest, Gold", "url": "htt/;"	o	array:tests
0	practice/usacoguide/gold/dsu/mootube/problem.json	/^{"name": "Problem 1. MooTube", "group": "USACO - USACO 2018 January Contest, Gold", "url": "http/;"	o	array:tests
0	practice/usacoguide/gold/dsu/wormhole/problem.json	/^{"name": "Problem 3. Wormhole Sort", "group": "USACO - USACO 2020 January Contest, Silver", "url/;"	o	array:tests
0	practice/usacoguide/silver/idk/maze/problem.json	/^{"name": "Problem 1. Maze Tac Toe", "group": "USACO - USACO 2021 US Open, Silver", "url": "http:/;"	o	array:tests
1	practice/cf/random/coloring/problem.json	/^{"name": "A. Dreamoon Likes Coloring", "group": "Codeforces - Codeforces Round #631 (Div. 1) - T/;"	o	array:tests
1	practice/usacoguide/gold/dsu/wormhole/problem.json	/^{"name": "Problem 3. Wormhole Sort", "group": "USACO - USACO 2020 January Contest, Silver", "url/;"	o	array:tests
<C-f>	dotfiles/macinit.vim	/^nnoremap <C-f> <cmd>Telescope find_files<cr>$/;"	m
<C-h>	.compilingScripts/init.vim	/^nmap <C-h> <C-w>h$/;"	m
<C-h>	.config/nvim/init.vim	/^nmap <C-h> <C-w>h$/;"	m
<C-h>	dotfiles/init.vim	/^nmap <C-h> <C-w>h$/;"	m
<C-h>	dotfiles/macinit.vim	/^nmap <C-h> <C-w>h$/;"	m
<C-j>	.compilingScripts/init.vim	/^nmap <C-j> <C-w>j$/;"	m
<C-j>	.config/nvim/init.vim	/^imap <expr> <C-j>   vsnip#expandable()  ? '<Plug>(vsnip-expand)'         : '<C-j>'$/;"	m
<C-j>	.config/nvim/init.vim	/^nmap <C-j> <C-w>j$/;"	m
<C-j>	.config/nvim/init.vim	/^smap <expr> <C-j>   vsnip#expandable()  ? '<Plug>(vsnip-expand)'         : '<C-j>'$/;"	m
<C-j>	dotfiles/init.vim	/^imap <expr> <C-j>   vsnip#expandable()  ? '<Plug>(vsnip-expand)'         : '<C-j>'$/;"	m
<C-j>	dotfiles/init.vim	/^nmap <C-j> <C-w>j$/;"	m
<C-j>	dotfiles/init.vim	/^smap <expr> <C-j>   vsnip#expandable()  ? '<Plug>(vsnip-expand)'         : '<C-j>'$/;"	m
<C-j>	dotfiles/macinit.vim	/^nmap <C-j> <C-w>j$/;"	m
<C-k>	.compilingScripts/init.vim	/^nmap <C-k> <C-w>k$/;"	m
<C-k>	.config/nvim/init.vim	/^nmap <C-k> <C-w>k$/;"	m
<C-k>	dotfiles/init.vim	/^nmap <C-k> <C-w>k$/;"	m
<C-k>	dotfiles/macinit.vim	/^nmap <C-k> <C-w>k$/;"	m
<C-l>	.compilingScripts/init.vim	/^nmap <C-l> <C-w>l$/;"	m
<C-l>	.config/nvim/init.vim	/^imap <expr> <C-l>   vsnip#available(1)  ? '<Plug>(vsnip-expand-or-jump)' : '<C-l>'$/;"	m
<C-l>	.config/nvim/init.vim	/^nmap <C-l> <C-w>l$/;"	m
<C-l>	.config/nvim/init.vim	/^smap <expr> <C-l>   vsnip#available(1)  ? '<Plug>(vsnip-expand-or-jump)' : '<C-l>'$/;"	m
<C-l>	dotfiles/init.vim	/^imap <expr> <C-l>   vsnip#available(1)  ? '<Plug>(vsnip-expand-or-jump)' : '<C-l>'$/;"	m
<C-l>	dotfiles/init.vim	/^nmap <C-l> <C-w>l$/;"	m
<C-l>	dotfiles/init.vim	/^smap <expr> <C-l>   vsnip#available(1)  ? '<Plug>(vsnip-expand-or-jump)' : '<C-l>'$/;"	m
<C-l>	dotfiles/macinit.vim	/^nmap <C-l> <C-w>l$/;"	m
<C-n>	dotfiles/macinit.vim	/^nnoremap <C-n> :NvimTreeToggle<CR>$/;"	m
<C-p>	dotfiles/macinit.vim	/^nnoremap <C-p> <cmd>Telescope buffers<cr>$/;"	m
<C-t>	.config/nvim/init.vim	/^nmap <C-t> <CMD>lua require("FTerm").toggle()<CR>$/;"	m
<C-t>	dotfiles/init.vim	/^nmap <C-t> <CMD>lua require("FTerm").toggle()<CR>$/;"	m
<C-t>	dotfiles/macinit.vim	/^nmap <C-t> :Todoist CP<CR>$/;"	m
<C-t>	dotfiles/macinit.vim	/^nmap <C-t> <CMD>lua require("FTerm").toggle()<CR>$/;"	m
<Esc>	.config/nvim/init.vim	/^inoremap <Esc> <space><BS><Esc>$/;"	m
<Esc>	dotfiles/init.vim	/^inoremap <Esc> <space><BS><Esc>$/;"	m
<Esc>	dotfiles/macinit.vim	/^inoremap <Esc> <space><BS><Esc>$/;"	m
<S-Tab>	.config/nvim/init.vim	/^imap <expr> <S-Tab> vsnip#jumpable(-1)  ? '<Plug>(vsnip-jump-prev)'      : '<S-Tab>'$/;"	m
<S-Tab>	.config/nvim/init.vim	/^smap <expr> <S-Tab> vsnip#jumpable(-1)  ? '<Plug>(vsnip-jump-prev)'      : '<S-Tab>'$/;"	m
<S-Tab>	dotfiles/init.vim	/^imap <expr> <S-Tab> vsnip#jumpable(-1)  ? '<Plug>(vsnip-jump-prev)'      : '<S-Tab>'$/;"	m
<S-Tab>	dotfiles/init.vim	/^smap <expr> <S-Tab> vsnip#jumpable(-1)  ? '<Plug>(vsnip-jump-prev)'      : '<S-Tab>'$/;"	m
<Tab>	.config/nvim/init.vim	/^imap <expr> <Tab>   vsnip#jumpable(1)   ? '<Plug>(vsnip-jump-next)'      : '<Tab>'$/;"	m
<Tab>	.config/nvim/init.vim	/^smap <expr> <Tab>   vsnip#jumpable(1)   ? '<Plug>(vsnip-jump-next)'      : '<Tab>'$/;"	m
<Tab>	dotfiles/init.vim	/^imap <expr> <Tab>   vsnip#jumpable(1)   ? '<Plug>(vsnip-jump-next)'      : '<Tab>'$/;"	m
<Tab>	dotfiles/init.vim	/^smap <expr> <Tab>   vsnip#jumpable(1)   ? '<Plug>(vsnip-jump-next)'      : '<Tab>'$/;"	m
<leader>n	dotfiles/macinit.vim	/^nnoremap <leader>n :NvimTreeFindFile<CR>$/;"	m
<leader>r	dotfiles/macinit.vim	/^nnoremap <leader>r :NvimTreeRefresh<CR>$/;"	m
<s-tab>	.compilingScripts/init.vim	/^nnoremap  <silent> <s-tab>  :if &modifiable && !&readonly && &modified <CR> :write<CR> :endif<CR/;"	m
<s-tab>	.config/nvim/init.vim	/^nnoremap  <silent> <s-tab>  :if &modifiable && !&readonly && &modified <CR> :write<CR> :endif<CR/;"	m
<s-tab>	dotfiles/init.vim	/^nnoremap  <silent> <s-tab>  :if &modifiable && !&readonly && &modified <CR> :write<CR> :endif<CR/;"	m
<s-tab>	dotfiles/macinit.vim	/^nnoremap  <silent> <s-tab>  :if &modifiable && !&readonly && &modified <CR> :write<CR> :endif<CR/;"	m
<tab>	.compilingScripts/init.vim	/^nnoremap  <silent>   <tab>  :if &modifiable && !&readonly && &modified <CR> :write<CR> :endif<CR/;"	m
<tab>	.config/nvim/init.vim	/^nnoremap  <silent>   <tab>  :if &modifiable && !&readonly && &modified <CR> :write<CR> :endif<CR/;"	m
<tab>	dotfiles/init.vim	/^nnoremap  <silent>   <tab>  :if &modifiable && !&readonly && &modified <CR> :write<CR> :endif<CR/;"	m
<tab>	dotfiles/macinit.vim	/^nnoremap  <silent>   <tab>  :if &modifiable && !&readonly && &modified <CR> :write<CR> :endif<CR/;"	m
A	code-library/Data Structures/BIT 2D with Range Update and Range Query.cpp	/^  long long M[N][N][2], A[N][N][2];$/;"	m	struct:BIT2D	typeref:typename:long long[][][2]	file:
A	code-library/Data Structures/BIT with Range Update and Range Query.cpp	/^  long long M[N], A[N];$/;"	m	struct:BIT	typeref:typename:long long[]	file:
A	code-library/Dynamic Programming Optimizations/XOR Equation.cpp	/^vector<long long> A;$/;"	v	typeref:typename:vector<long long>
A	code-library/Miscellaneous/XOR Equation Arbitrary Range.cpp	/^vector<long long> A;$/;"	v	typeref:typename:vector<long long>
A	code-library/Strings/Aho Corasick.cpp	/^  const int A = 26;$/;"	m	struct:AC	typeref:typename:const int	file:
A	code-library/Strings/Palindromic Tree Persistent.cpp	/^  static const int A = 2;$/;"	m	struct:PalindromicTree	typeref:typename:const int	file:
A	code/Data Structures/BIT 2D with Range Update and Range Query.cpp	/^  long long M[N][N][2], A[N][N][2];$/;"	m	struct:BIT2D	typeref:typename:long long[][][2]	file:
A	code/Data Structures/BIT with Range Update and Range Query.cpp	/^  long long M[N], A[N];$/;"	m	struct:BIT	typeref:typename:long long[]	file:
A	code/Dynamic Programming Optimizations/XOR Equation.cpp	/^vector<long long> A;$/;"	v	typeref:typename:vector<long long>
A	code/Miscellaneous/XOR Equation Arbitrary Range.cpp	/^vector<long long> A;$/;"	v	typeref:typename:vector<long long>
A	code/Strings/Aho Corasick.cpp	/^  const int A = 26;$/;"	m	struct:AC	typeref:typename:const int	file:
A	code/Strings/Palindromic Tree Persistent.cpp	/^  static const int A = 2;$/;"	m	struct:PalindromicTree	typeref:typename:const int	file:
A	contests/Codeforces/1622/C/sol.cpp	/^vector<int> A;$/;"	v	typeref:typename:vector<int>
A	contests/Codeforces/1622/C_new/sol.cpp	/^vector<int> A;$/;"	v	typeref:typename:vector<int>
A	contests/Codeforces/1623/new_C/sol.cpp	/^vector<int> A;$/;"	v	typeref:typename:vector<int>
A	practice/cf/random/1700/4.cpp	/^vector<int> A, subtree_xor, dist;$/;"	v	typeref:typename:vector<int>
A	practice/cf/random/pink/main.cpp	/^vector<int> A, cnt;$/;"	v	typeref:typename:vector<int>
A	practice/december2021/DP/removal_game/sol.cpp	/^vector<ll> A;$/;"	v	typeref:typename:vector<ll>
A	practice/usacoguide/gold/dsu/moocast/main.cpp	/^vector<pair<int, int>> A;$/;"	v	typeref:typename:vector<pair<int,int>>
A	practice/usacoguide/silver/binsearch/sabotage.cpp	/^vector<int> A;$/;"	v	typeref:typename:vector<int>
AC	code-library/Strings/Aho Corasick.cpp	/^  AC(): N(0), P(0) {node();}$/;"	f	struct:AC	file:
AC	code-library/Strings/Aho Corasick.cpp	/^struct AC {$/;"	s	file:
AC	code/Strings/Aho Corasick.cpp	/^  AC(): N(0), P(0) {node();}$/;"	f	struct:AC	file:
AC	code/Strings/Aho Corasick.cpp	/^struct AC {$/;"	s	file:
ADD	code-library/Geometry/Delaunay Triangulation.cpp	/^	#define ADD /;"	d	file:
ADD	code-library/Geometry/Point Location.cpp	/^enum EventType { DEL = 2, ADD = 3, GET = 1, VERT = 0 };$/;"	e	enum:EventType	file:
ADD	code-library/Geometry/Voronoi Diagram.cpp	/^	#define ADD /;"	d	file:
ADD	code/Geometry/Delaunay Triangulation.cpp	/^	#define ADD /;"	d	file:
ADD	code/Geometry/Point Location.cpp	/^enum EventType { DEL = 2, ADD = 3, GET = 1, VERT = 0 };$/;"	e	enum:EventType	file:
ADD	code/Geometry/Voronoi Diagram.cpp	/^	#define ADD /;"	d	file:
AND	code-library/Math/FWHT.cpp	/^#define AND /;"	d	file:
AND	code/Math/FWHT.cpp	/^#define AND /;"	d	file:
AhoCorasick	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  AhoCorasick() {$/;"	f	struct:AhoCorasick	file:
AhoCorasick	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^struct AhoCorasick {$/;"	s	file:
AhoCorasick	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  AhoCorasick() {$/;"	f	struct:AhoCorasick	file:
AhoCorasick	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^struct AhoCorasick {$/;"	s	file:
Angle	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    Angle(double x, double y) : x(x), y(y) {}$/;"	f	struct:Angle	file:
Angle	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^struct Angle {$/;"	s	file:
Angle	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    Angle(double x, double y) : x(x), y(y) {}$/;"	f	struct:Angle	file:
Angle	code/Geometry/Half Plane Intersection Dynamic.cpp	/^struct Angle {$/;"	s	file:
B	code-library/Data Structures/MOs Algorithm.cpp	/^const int N = 1e6 + 9, B = 440;$/;"	v	typeref:typename:const int
B	code-library/Data Structures/MOs Online.cpp	/^const int N = 1e5 + 1, B = 4500, C = N \/ B + 1;$/;"	v	typeref:typename:const int
B	code-library/Data Structures/MOs on tree.cpp	/^const int B = 320;$/;"	v	typeref:typename:const int
B	code-library/Data Structures/MOs with Update.cpp	/^const int B = 2500;$/;"	v	typeref:typename:const int
B	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^const int N = 1e5 + 9, B = 330;$/;"	v	typeref:typename:const int
B	code-library/Data Structures/Trie.cpp	/^  static const int B = 31;$/;"	m	struct:Trie	typeref:typename:const int	file:
B	code-library/Dynamic Programming Optimizations/SOS convolutions.cpp	/^const int B = 20; \/\/ Every input vector must need to be of size 1<<B$/;"	v	namespace:SOS	typeref:typename:const int
B	code-library/Math/Basis Vector Reduced Row Echelon Form.cpp	/^  static const int B = 30;$/;"	m	struct:Basis	typeref:typename:const int	file:
B	code-library/Math/Basis Vector ft Weighted Linearly Independent Vectors.cpp	/^  static const int B = 127;$/;"	m	struct:Basis	typeref:typename:const int	file:
B	code-library/Math/Finite Field Arithmetic Binary.cpp	/^  const int B = 30, mask = (1 << B) - 1;$/;"	v	namespace:FFA	typeref:typename:const int
B	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^const int N = 1e5 + 9, B = 330, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
B	code/Data Structures/MOs Algorithm.cpp	/^const int N = 1e6 + 9, B = 440;$/;"	v	typeref:typename:const int
B	code/Data Structures/MOs Online.cpp	/^const int N = 1e5 + 1, B = 4500, C = N \/ B + 1;$/;"	v	typeref:typename:const int
B	code/Data Structures/MOs on tree.cpp	/^const int B = 320;$/;"	v	typeref:typename:const int
B	code/Data Structures/MOs with Update.cpp	/^const int B = 2500;$/;"	v	typeref:typename:const int
B	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^const int N = 1e5 + 9, B = 330;$/;"	v	typeref:typename:const int
B	code/Data Structures/Trie.cpp	/^  static const int B = 31;$/;"	m	struct:Trie	typeref:typename:const int	file:
B	code/Dynamic Programming Optimizations/SOS convolutions.cpp	/^const int B = 20; \/\/ Every input vector must need to be of size 1<<B$/;"	v	namespace:SOS	typeref:typename:const int
B	code/Math/Basis Vector Reduced Row Echelon Form.cpp	/^  static const int B = 30;$/;"	m	struct:Basis	typeref:typename:const int	file:
B	code/Math/Basis Vector ft Weighted Linearly Independent Vectors.cpp	/^  static const int B = 127;$/;"	m	struct:Basis	typeref:typename:const int	file:
B	code/Math/Finite Field Arithmetic Binary.cpp	/^  const int B = 30, mask = (1 << B) - 1;$/;"	v	namespace:FFA	typeref:typename:const int
B	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^const int N = 1e5 + 9, B = 330, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
BASE	code-library/Miscellaneous/BigInt.cpp	/^const int BASE = 1e9, FBASE = 1e4;$/;"	v	typeref:typename:const int
BASE	code/Miscellaneous/BigInt.cpp	/^const int BASE = 1e9, FBASE = 1e4;$/;"	v	typeref:typename:const int
BC	code-library/Data Structures/MOs Online.cpp	/^int st[C], en[C], BC = 0;$/;"	v	typeref:typename:int
BC	code/Data Structures/MOs Online.cpp	/^int st[C], en[C], BC = 0;$/;"	v	typeref:typename:int
BFS	contests/LIT2021/C.cpp	/^void BFS() {$/;"	f	typeref:typename:void
BFS	practice/usacoguide/gold/dsu/tractor/main.cpp	/^void BFS(int r, int c, DSU &dsu, int max_dist) {$/;"	f	typeref:typename:void
BIT	code-library/Data Structures/BIT with Range Update and Range Query.cpp	/^  BIT() {$/;"	f	struct:BIT	file:
BIT	code-library/Data Structures/BIT with Range Update and Range Query.cpp	/^struct BIT {$/;"	s	file:
BIT	code-library/Data Structures/BIT.cpp	/^  BIT() {}$/;"	f	struct:BIT	file:
BIT	code-library/Data Structures/BIT.cpp	/^  BIT(int _n) {$/;"	f	struct:BIT	file:
BIT	code-library/Data Structures/BIT.cpp	/^struct BIT { \/\/1-indexed$/;"	s	file:
BIT	code-library/Math/FWHT in Ternary Base.cpp	/^  const int BIT = 11; \/\/ log2(MAX VALUE)$/;"	m	struct:FWHT	typeref:typename:const int	file:
BIT	code-library/Miscellaneous/Parallel Binary Search.cpp	/^struct BIT {$/;"	s	file:
BIT	code/Data Structures/BIT with Range Update and Range Query.cpp	/^  BIT() {$/;"	f	struct:BIT	file:
BIT	code/Data Structures/BIT with Range Update and Range Query.cpp	/^struct BIT {$/;"	s	file:
BIT	code/Data Structures/BIT.cpp	/^  BIT() {}$/;"	f	struct:BIT	file:
BIT	code/Data Structures/BIT.cpp	/^  BIT(int _n) {$/;"	f	struct:BIT	file:
BIT	code/Data Structures/BIT.cpp	/^struct BIT { \/\/1-indexed$/;"	s	file:
BIT	code/Math/FWHT in Ternary Base.cpp	/^  const int BIT = 11; \/\/ log2(MAX VALUE)$/;"	m	struct:FWHT	typeref:typename:const int	file:
BIT	code/Miscellaneous/Parallel Binary Search.cpp	/^struct BIT {$/;"	s	file:
BIT2D	code-library/Data Structures/BIT 2D with Range Update and Range Query.cpp	/^  BIT2D() {$/;"	f	struct:BIT2D	file:
BIT2D	code-library/Data Structures/BIT 2D with Range Update and Range Query.cpp	/^struct BIT2D {$/;"	s	file:
BIT2D	code/Data Structures/BIT 2D with Range Update and Range Query.cpp	/^  BIT2D() {$/;"	f	struct:BIT2D	file:
BIT2D	code/Data Structures/BIT 2D with Range Update and Range Query.cpp	/^struct BIT2D {$/;"	s	file:
Basis	code-library/Math/Basis Vector Reduced Row Echelon Form.cpp	/^  Basis() {$/;"	f	struct:Basis	file:
Basis	code-library/Math/Basis Vector Reduced Row Echelon Form.cpp	/^struct Basis {$/;"	s	file:
Basis	code-library/Math/Basis Vector ft Weighted Linearly Independent Vectors.cpp	/^  Basis() {$/;"	f	struct:Basis	file:
Basis	code-library/Math/Basis Vector ft Weighted Linearly Independent Vectors.cpp	/^struct Basis {$/;"	s	file:
Basis	code-library/Math/Basis Vector.cpp	/^struct Basis {$/;"	s	file:
Basis	code/Math/Basis Vector Reduced Row Echelon Form.cpp	/^  Basis() {$/;"	f	struct:Basis	file:
Basis	code/Math/Basis Vector Reduced Row Echelon Form.cpp	/^struct Basis {$/;"	s	file:
Basis	code/Math/Basis Vector ft Weighted Linearly Independent Vectors.cpp	/^  Basis() {$/;"	f	struct:Basis	file:
Basis	code/Math/Basis Vector ft Weighted Linearly Independent Vectors.cpp	/^struct Basis {$/;"	s	file:
Basis	code/Math/Basis Vector.cpp	/^struct Basis {$/;"	s	file:
BerlekampMassey	code-library/Math/BerleKamp Massey.cpp	/^vector<mint> BerlekampMassey(vector<mint> S) {$/;"	f	typeref:typename:vector<mint>
BerlekampMassey	code-library/Math/Determinant of Sparse Matrix.cpp	/^vector<mint> BerlekampMassey(vector<mint> S) {$/;"	f	typeref:typename:vector<mint>
BerlekampMassey	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^vector<mint> BerlekampMassey(vector<mint> S) {$/;"	f	typeref:typename:vector<mint>
BerlekampMassey	code-library/Math/Reeds Sloane Algorithm.cpp	/^  static vec BerlekampMassey(const vec &s, ll mod) {$/;"	f	struct:LinearRecurrence	typeref:typename:vec	file:
BerlekampMassey	code/Math/BerleKamp Massey.cpp	/^vector<mint> BerlekampMassey(vector<mint> S) {$/;"	f	typeref:typename:vector<mint>
BerlekampMassey	code/Math/Determinant of Sparse Matrix.cpp	/^vector<mint> BerlekampMassey(vector<mint> S) {$/;"	f	typeref:typename:vector<mint>
BerlekampMassey	code/Math/Generating Function of a Linear Recurrence.cpp	/^vector<mint> BerlekampMassey(vector<mint> S) {$/;"	f	typeref:typename:vector<mint>
BerlekampMassey	code/Math/Reeds Sloane Algorithm.cpp	/^  static vec BerlekampMassey(const vec &s, ll mod) {$/;"	f	struct:LinearRecurrence	typeref:typename:vec	file:
Bernoulli	code-library/Math/Faulhaber Formula Fastest.cpp	/^poly Bernoulli(int n) {$/;"	f	typeref:typename:poly
Bernoulli	code/Math/Faulhaber Formula Fastest.cpp	/^poly Bernoulli(int n) {$/;"	f	typeref:typename:poly
BigInt	code-library/Miscellaneous/BigInt.cpp	/^  BigInt() : sgn(1) {}$/;"	f	struct:BigInt	file:
BigInt	code-library/Miscellaneous/BigInt.cpp	/^  BigInt(BigInt&& other) : BigInt() {$/;"	f	struct:BigInt	file:
BigInt	code-library/Miscellaneous/BigInt.cpp	/^  BigInt(const BigInt& other) {$/;"	f	struct:BigInt	file:
BigInt	code-library/Miscellaneous/BigInt.cpp	/^  BigInt(const string& s) {$/;"	f	struct:BigInt	file:
BigInt	code-library/Miscellaneous/BigInt.cpp	/^  BigInt(ll v) {$/;"	f	struct:BigInt	file:
BigInt	code-library/Miscellaneous/BigInt.cpp	/^struct BigInt {$/;"	s	file:
BigInt	code/Miscellaneous/BigInt.cpp	/^  BigInt() : sgn(1) {}$/;"	f	struct:BigInt	file:
BigInt	code/Miscellaneous/BigInt.cpp	/^  BigInt(BigInt&& other) : BigInt() {$/;"	f	struct:BigInt	file:
BigInt	code/Miscellaneous/BigInt.cpp	/^  BigInt(const BigInt& other) {$/;"	f	struct:BigInt	file:
BigInt	code/Miscellaneous/BigInt.cpp	/^  BigInt(const string& s) {$/;"	f	struct:BigInt	file:
BigInt	code/Miscellaneous/BigInt.cpp	/^  BigInt(ll v) {$/;"	f	struct:BigInt	file:
BigInt	code/Miscellaneous/BigInt.cpp	/^struct BigInt {$/;"	s	file:
Bitset	code-library/Miscellaneous/Bitset Custom.cpp	/^    Bitset() { memset(a, 0, sizeof a); }$/;"	f	struct:Bitset	file:
Bitset	code-library/Miscellaneous/Bitset Custom.cpp	/^struct Bitset$/;"	s	file:
Bitset	code-library/Strings/Bit LCS.cpp	/^struct Bitset {$/;"	s	file:
Bitset	code/Miscellaneous/Bitset Custom.cpp	/^    Bitset() { memset(a, 0, sizeof a); }$/;"	f	struct:Bitset	file:
Bitset	code/Miscellaneous/Bitset Custom.cpp	/^struct Bitset$/;"	s	file:
Bitset	code/Strings/Bit LCS.cpp	/^struct Bitset {$/;"	s	file:
Block	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^  Block() {}$/;"	f	struct:Block	file:
Block	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^  Block(int s, int to_assign, bool to_rev = false) {$/;"	f	struct:Block	file:
Block	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^  Block(vector<int> &a, int to_assign = -1, bool to_rev = false) {$/;"	f	struct:Block	file:
Block	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^struct Block {$/;"	s	file:
Block	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^  Block() {}$/;"	f	struct:Block	file:
Block	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^  Block(int s, int to_assign, bool to_rev = false) {$/;"	f	struct:Block	file:
Block	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^  Block(vector<int> &a, int to_assign = -1, bool to_rev = false) {$/;"	f	struct:Block	file:
Block	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^struct Block {$/;"	s	file:
Blossom	code-library/Game Theory/Matching Game On A Graph.cpp	/^  Blossom() {}$/;"	f	struct:Blossom	file:
Blossom	code-library/Game Theory/Matching Game On A Graph.cpp	/^  Blossom(int _n) {$/;"	f	struct:Blossom	file:
Blossom	code-library/Game Theory/Matching Game On A Graph.cpp	/^struct Blossom {$/;"	s	file:
Blossom	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  Blossom() {}$/;"	f	struct:Blossom	file:
Blossom	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  Blossom(int _n) {$/;"	f	struct:Blossom	file:
Blossom	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^struct Blossom {$/;"	s	file:
Blossom	code-library/Graph Theory/Blossom Algorithm.cpp	/^  Blossom() {}$/;"	f	struct:Blossom	file:
Blossom	code-library/Graph Theory/Blossom Algorithm.cpp	/^  Blossom(int _n) {$/;"	f	struct:Blossom	file:
Blossom	code-library/Graph Theory/Blossom Algorithm.cpp	/^struct Blossom {$/;"	s	file:
Blossom	code/Game Theory/Matching Game On A Graph.cpp	/^  Blossom() {}$/;"	f	struct:Blossom	file:
Blossom	code/Game Theory/Matching Game On A Graph.cpp	/^  Blossom(int _n) {$/;"	f	struct:Blossom	file:
Blossom	code/Game Theory/Matching Game On A Graph.cpp	/^struct Blossom {$/;"	s	file:
Blossom	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  Blossom() {}$/;"	f	struct:Blossom	file:
Blossom	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  Blossom(int _n) {$/;"	f	struct:Blossom	file:
Blossom	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^struct Blossom {$/;"	s	file:
Blossom	code/Graph Theory/Blossom Algorithm.cpp	/^  Blossom() {}$/;"	f	struct:Blossom	file:
Blossom	code/Graph Theory/Blossom Algorithm.cpp	/^  Blossom(int _n) {$/;"	f	struct:Blossom	file:
Blossom	code/Graph Theory/Blossom Algorithm.cpp	/^struct Blossom {$/;"	s	file:
BronKerbosch	code-library/Graph Theory/Maximum Clique.cpp	/^void BronKerbosch(int n, long long R, long long P, long long X) {$/;"	f	typeref:typename:void
BronKerbosch	code/Graph Theory/Maximum Clique.cpp	/^void BronKerbosch(int n, long long R, long long P, long long X) {$/;"	f	typeref:typename:void
C	code-library/Data Structures/MOs Online.cpp	/^const int N = 1e5 + 1, B = 4500, C = N \/ B + 1;$/;"	v	typeref:typename:const int
C	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^int C(int i) {$/;"	f	typeref:typename:int
C	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^} C;$/;"	v	typeref:struct:ChromaticPolynomial
C	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^mint dp[N][N], C[N], G[N];$/;"	v	typeref:typename:mint[]
C	code-library/Graph Theory/Edge Coloring Simple Graph.cpp	/^int C[N][N], col[N][N];$/;"	v	namespace:Vizing	typeref:typename:int[][]
C	code-library/Number Theory/K Divisors.cpp	/^const int C = 1010; \/\/ 4th root of max n$/;"	v	typeref:typename:const int
C	code/Data Structures/MOs Online.cpp	/^const int N = 1e5 + 1, B = 4500, C = N \/ B + 1;$/;"	v	typeref:typename:const int
C	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^int C(int i) {$/;"	f	typeref:typename:int
C	code/Graph Theory/Chromatic Polynoimial.cpp	/^} C;$/;"	v	typeref:struct:ChromaticPolynomial
C	code/Graph Theory/Counting Labeled Graphs.cpp	/^mint dp[N][N], C[N], G[N];$/;"	v	typeref:typename:mint[]
C	code/Graph Theory/Edge Coloring Simple Graph.cpp	/^int C[N][N], col[N][N];$/;"	v	namespace:Vizing	typeref:typename:int[][]
C	code/Number Theory/K Divisors.cpp	/^const int C = 1010; \/\/ 4th root of max n$/;"	v	typeref:typename:const int
CC	code-library/Miscellaneous/Parallel Binary Search.cpp	/^#define CC(/;"	d	file:
CC	code/Miscellaneous/Parallel Binary Search.cpp	/^#define CC(/;"	d	file:
CH3D	code-library/Geometry/Geometry 3D.cpp	/^struct CH3D {$/;"	s	file:
CH3D	code/Geometry/Geometry 3D.cpp	/^struct CH3D {$/;"	s	file:
CHT	code-library/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^struct CHT {$/;"	s	file:
CHT	code-library/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^struct CHT : public multiset<line> {$/;"	s	file:
CHT	code/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^struct CHT {$/;"	s	file:
CHT	code/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^struct CHT : public multiset<line> {$/;"	s	file:
CRT	code-library/Number Theory/CRT.cpp	/^pair<T, T> CRT(T a1, T m1, T a2, T m2) {$/;"	f	typeref:typename:pair<T,T>
CRT	code-library/Number Theory/Intersection of Arithmetic Progressions.cpp	/^pair<T, T> CRT(T a1, T m1, T a2, T m2) {$/;"	f	typeref:typename:pair<T,T>
CRT	code-library/Number Theory/Smallest Nonnegative Integer x s.t. l <= ax % p <= r.cpp	/^pair<T, T> CRT(T x, T a, T y, T b) {$/;"	f	typeref:typename:pair<T,T>
CRT	code-library/Number Theory/nCr Modulo Any Mod.cpp	/^pair<ll, ll> CRT(ll a1, ll m1, ll a2, ll m2) {$/;"	f	typeref:typename:pair<ll,ll>
CRT	code/Number Theory/CRT.cpp	/^pair<T, T> CRT(T a1, T m1, T a2, T m2) {$/;"	f	typeref:typename:pair<T,T>
CRT	code/Number Theory/Intersection of Arithmetic Progressions.cpp	/^pair<T, T> CRT(T a1, T m1, T a2, T m2) {$/;"	f	typeref:typename:pair<T,T>
CRT	code/Number Theory/Smallest Nonnegative Integer x s.t. l <= ax % p <= r.cpp	/^pair<T, T> CRT(T x, T a, T y, T b) {$/;"	f	typeref:typename:pair<T,T>
CRT	code/Number Theory/nCr Modulo Any Mod.cpp	/^pair<ll, ll> CRT(ll a1, ll m1, ll a2, ll m2) {$/;"	f	typeref:typename:pair<ll,ll>
CU	code-library/Geometry/Geometry 2D.cpp	/^} CU; $/;"	v	typeref:struct:CircleUnion
CU	code/Geometry/Geometry 2D.cpp	/^} CU; $/;"	v	typeref:struct:CircleUnion
C_Cpp.errorSquiggles	.vscode/settings.json	/^    "C_Cpp.errorSquiggles": "Enabled"$/;"	s
ChromaticPolynomial	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^struct ChromaticPolynomial {$/;"	s	file:
ChromaticPolynomial	code/Graph Theory/Chromatic Polynoimial.cpp	/^struct ChromaticPolynomial {$/;"	s	file:
CircleUnion	code-library/Geometry/Geometry 2D.cpp	/^    CircleUnion() {$/;"	f	struct:CircleUnion	file:
CircleUnion	code-library/Geometry/Geometry 2D.cpp	/^struct CircleUnion {$/;"	s	file:
CircleUnion	code/Geometry/Geometry 2D.cpp	/^    CircleUnion() {$/;"	f	struct:CircleUnion	file:
CircleUnion	code/Geometry/Geometry 2D.cpp	/^struct CircleUnion {$/;"	s	file:
Combi	code-library/Math/Polynomial Sum.cpp	/^  Combi(int _n): n(_n), facts(_n), finvs(_n), invs(_n){$/;"	f	struct:Combi	file:
Combi	code-library/Math/Polynomial Sum.cpp	/^struct Combi{$/;"	s	file:
Combi	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  Combi(int _n): n(_n), facts(_n), finvs(_n), invs(_n){$/;"	f	struct:Combi	file:
Combi	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^struct Combi{$/;"	s	file:
Combi	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  Combi(int _n): n(_n), facts(_n), finvs(_n), invs(_n){$/;"	f	struct:Combi	file:
Combi	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^struct Combi{$/;"	s	file:
Combi	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  Combi(int _n): n(_n), facts(_n), finvs(_n), invs(_n){$/;"	f	struct:Combi	file:
Combi	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^struct Combi{$/;"	s	file:
Combi	code/Math/Polynomial Sum.cpp	/^  Combi(int _n): n(_n), facts(_n), finvs(_n), invs(_n){$/;"	f	struct:Combi	file:
Combi	code/Math/Polynomial Sum.cpp	/^struct Combi{$/;"	s	file:
Combi	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  Combi(int _n): n(_n), facts(_n), finvs(_n), invs(_n){$/;"	f	struct:Combi	file:
Combi	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^struct Combi{$/;"	s	file:
Combi	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  Combi(int _n): n(_n), facts(_n), finvs(_n), invs(_n){$/;"	f	struct:Combi	file:
Combi	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^struct Combi{$/;"	s	file:
Combi	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  Combi(int _n): n(_n), facts(_n), finvs(_n), invs(_n){$/;"	f	struct:Combi	file:
Combi	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^struct Combi{$/;"	s	file:
CompetitiveCompanionHandler	.compilingScripts/download_prob.py	/^    class CompetitiveCompanionHandler(http.server.BaseHTTPRequestHandler):$/;"	c	function:listen_once	file:
CompileAndRunWithFlags	.config/nvim/init.vim	/^command! -nargs=0 CompileAndRunWithFlags call TermWrapper(printf('g++ -H -std=c++17 -O2 -Wall -W/;"	c
CompileAndRunWithFlags	dotfiles/init.vim	/^command! -nargs=0 CompileAndRunWithFlags call TermWrapper(printf('g++ -H -std=c++17 -O2 -Wall -W/;"	c
CompileAndRunWithFlags	dotfiles/macinit.vim	/^command! -nargs=0 CompileAndRunWithFlags call TermWrapper(printf('g++ -std=c++17 -O2 -Wall -Wext/;"	c
Components	code-library/Graph Theory/Three Edge Connectivity.cpp	/^  Components() {}$/;"	f	struct:Components	file:
Components	code-library/Graph Theory/Three Edge Connectivity.cpp	/^  Components(int sz) : nxt(sz) {$/;"	f	struct:Components	file:
Components	code-library/Graph Theory/Three Edge Connectivity.cpp	/^struct Components {$/;"	s	file:
Components	code/Graph Theory/Three Edge Connectivity.cpp	/^  Components() {}$/;"	f	struct:Components	file:
Components	code/Graph Theory/Three Edge Connectivity.cpp	/^  Components(int sz) : nxt(sz) {$/;"	f	struct:Components	file:
Components	code/Graph Theory/Three Edge Connectivity.cpp	/^struct Components {$/;"	s	file:
Cplx	code-library/Miscellaneous/BigInt.cpp	/^typedef cplx<ld> Cplx;$/;"	t	typeref:typename:cplx<ld>	file:
Cplx	code/Miscellaneous/BigInt.cpp	/^typedef cplx<ld> Cplx;$/;"	t	typeref:typename:cplx<ld>	file:
D	code-library/Data Structures/DSU with Rollbacks.cpp	/^  DSU D;$/;"	m	struct:DSUQueue	typeref:typename:DSU	file:
D	code-library/Data Structures/Queue Undo Trick.cpp	/^  DSU D;$/;"	m	struct:DSUQueue	typeref:typename:DSU	file:
D	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^const double D = 1e6; \/\/ each point is divided by D for better precision$/;"	v	typeref:typename:const double
D	code-library/Number Theory/Min_25 Sieve.cpp	/^const int N = 2e5 + 9, D = 3; \/\/ N >= 2 * sqrt(n)$/;"	v	typeref:typename:const int
D	code/Data Structures/DSU with Rollbacks.cpp	/^  DSU D;$/;"	m	struct:DSUQueue	typeref:typename:DSU	file:
D	code/Data Structures/Queue Undo Trick.cpp	/^  DSU D;$/;"	m	struct:DSUQueue	typeref:typename:DSU	file:
D	code/Geometry/Half Plane Intersection Dynamic.cpp	/^const double D = 1e6; \/\/ each point is divided by D for better precision$/;"	v	typeref:typename:const double
D	code/Number Theory/Min_25 Sieve.cpp	/^const int N = 2e5 + 9, D = 3; \/\/ N >= 2 * sqrt(n)$/;"	v	typeref:typename:const int
DCEL	code-library/Geometry/Point Location.cpp	/^struct DCEL {$/;"	s	file:
DCEL	code/Geometry/Point Location.cpp	/^struct DCEL {$/;"	s	file:
DD	code-library/Miscellaneous/Parallel Binary Search.cpp	/^#define DD(/;"	d	file:
DD	code/Miscellaneous/Parallel Binary Search.cpp	/^#define DD(/;"	d	file:
DEL	code-library/Geometry/Point Location.cpp	/^enum EventType { DEL = 2, ADD = 3, GET = 1, VERT = 0 };$/;"	e	enum:EventType	file:
DEL	code/Geometry/Point Location.cpp	/^enum EventType { DEL = 2, ADD = 3, GET = 1, VERT = 0 };$/;"	e	enum:EventType	file:
DIG	code-library/Miscellaneous/BigInt.cpp	/^const int DIG = 9, FDIG = 4;$/;"	v	typeref:typename:const int
DIG	code/Miscellaneous/BigInt.cpp	/^const int DIG = 9, FDIG = 4;$/;"	v	typeref:typename:const int
DMST	code-library/Graph Theory/Directed MST.cpp	/^vector<int> DMST(int n, int root, const vector<edge> &edges) {$/;"	f	typeref:typename:vector<int>
DMST	code/Graph Theory/Directed MST.cpp	/^vector<int> DMST(int n, int root, const vector<edge> &edges) {$/;"	f	typeref:typename:vector<int>
DST	code-library/Data Structures/Disjoint Sparse Table.cpp	/^  DST(vector<int> & a) {$/;"	f	struct:DST	file:
DST	code-library/Data Structures/Disjoint Sparse Table.cpp	/^struct DST {$/;"	s	file:
DST	code/Data Structures/Disjoint Sparse Table.cpp	/^  DST(vector<int> & a) {$/;"	f	struct:DST	file:
DST	code/Data Structures/Disjoint Sparse Table.cpp	/^struct DST {$/;"	s	file:
DSU	code-library/Data Structures/DSU Partially Persistent.cpp	/^  DSU(int n) : par(n + 1, {{-1, 0}}) {}$/;"	f	struct:DSU	file:
DSU	code-library/Data Structures/DSU Partially Persistent.cpp	/^struct DSU {$/;"	s	file:
DSU	code-library/Data Structures/DSU with Rollbacks.cpp	/^  DSU() {}$/;"	f	struct:DSU	file:
DSU	code-library/Data Structures/DSU with Rollbacks.cpp	/^  DSU(int n) {$/;"	f	struct:DSU	file:
DSU	code-library/Data Structures/DSU with Rollbacks.cpp	/^struct DSU {$/;"	s	file:
DSU	code-library/Data Structures/DSU.cpp	/^  DSU(int n) : par(n + 1), rnk(n + 1, 0), sz(n + 1, 1), c(n) {$/;"	f	struct:DSU	file:
DSU	code-library/Data Structures/DSU.cpp	/^struct DSU {$/;"	s	file:
DSU	code-library/Data Structures/Queue Undo Trick.cpp	/^  DSU() {}$/;"	f	struct:DSU	file:
DSU	code-library/Data Structures/Queue Undo Trick.cpp	/^  DSU(int n) {$/;"	f	struct:DSU	file:
DSU	code-library/Data Structures/Queue Undo Trick.cpp	/^struct DSU {$/;"	s	file:
DSU	code-library/Graph Theory/Directed MST.cpp	/^  DSU (int n) : par(n, -1) {}$/;"	f	struct:DSU	file:
DSU	code-library/Graph Theory/Directed MST.cpp	/^struct DSU {$/;"	s	file:
DSU	code-library/Graph Theory/Manhattan MST.cpp	/^struct DSU {$/;"	s	file:
DSU	code/Data Structures/DSU Partially Persistent.cpp	/^  DSU(int n) : par(n + 1, {{-1, 0}}) {}$/;"	f	struct:DSU	file:
DSU	code/Data Structures/DSU Partially Persistent.cpp	/^struct DSU {$/;"	s	file:
DSU	code/Data Structures/DSU with Rollbacks.cpp	/^  DSU() {}$/;"	f	struct:DSU	file:
DSU	code/Data Structures/DSU with Rollbacks.cpp	/^  DSU(int n) {$/;"	f	struct:DSU	file:
DSU	code/Data Structures/DSU with Rollbacks.cpp	/^struct DSU {$/;"	s	file:
DSU	code/Data Structures/DSU.cpp	/^  DSU(int n) : par(n + 1), rnk(n + 1, 0), sz(n + 1, 1), c(n) {$/;"	f	struct:DSU	file:
DSU	code/Data Structures/DSU.cpp	/^struct DSU {$/;"	s	file:
DSU	code/Data Structures/Queue Undo Trick.cpp	/^  DSU() {}$/;"	f	struct:DSU	file:
DSU	code/Data Structures/Queue Undo Trick.cpp	/^  DSU(int n) {$/;"	f	struct:DSU	file:
DSU	code/Data Structures/Queue Undo Trick.cpp	/^struct DSU {$/;"	s	file:
DSU	code/Graph Theory/Directed MST.cpp	/^  DSU (int n) : par(n, -1) {}$/;"	f	struct:DSU	file:
DSU	code/Graph Theory/Directed MST.cpp	/^struct DSU {$/;"	s	file:
DSU	code/Graph Theory/Manhattan MST.cpp	/^struct DSU {$/;"	s	file:
DSU	contests/USACO/dec_silver_2021/B/brute.cpp	/^	DSU(int N) { e = vector<int>(N, -1); }$/;"	f	struct:DSU	file:
DSU	contests/USACO/dec_silver_2021/B/brute.cpp	/^struct DSU {$/;"	s	file:
DSU	practice/usacoguide/gold/dsu/closing/main.cpp	/^	DSU(int N) { e = vector<int>(N, -1); }$/;"	f	struct:DSU	file:
DSU	practice/usacoguide/gold/dsu/closing/main.cpp	/^struct DSU {$/;"	s	file:
DSU	practice/usacoguide/gold/dsu/moocast/main.cpp	/^	DSU(int N) { e = vector<int>(N, -1); }$/;"	f	struct:DSU	file:
DSU	practice/usacoguide/gold/dsu/moocast/main.cpp	/^struct DSU {$/;"	s	file:
DSU	practice/usacoguide/gold/dsu/mootube/main.cpp	/^	DSU(int N) { e = vector<int>(N, -1); }$/;"	f	struct:DSU	file:
DSU	practice/usacoguide/gold/dsu/mootube/main.cpp	/^struct DSU {$/;"	s	file:
DSU	practice/usacoguide/gold/dsu/tractor/main.cpp	/^	DSU(int W) { e = vector<int>(W, -1); }$/;"	f	struct:DSU	file:
DSU	practice/usacoguide/gold/dsu/tractor/main.cpp	/^struct DSU {$/;"	s	file:
DSU	practice/usacoguide/gold/dsu/tractor/mountain.cpp	/^	DSU(int N) { e = vector<int>(N, -1); }$/;"	f	struct:DSU	file:
DSU	practice/usacoguide/gold/dsu/tractor/mountain.cpp	/^struct DSU {$/;"	s	file:
DSU	practice/usacoguide/gold/dsu/wormhole/main.cpp	/^	DSU(int N) { e = vector<int>(N, -1); }$/;"	f	struct:DSU	file:
DSU	practice/usacoguide/gold/dsu/wormhole/main.cpp	/^struct DSU {$/;"	s	file:
DSU	practice/usacoguide/silver/idk/lirs/main.cpp	/^	DSU(int N) { e = vector<int>(N, -1); }$/;"	f	struct:DSU	file:
DSU	practice/usacoguide/silver/idk/lirs/main.cpp	/^struct DSU {$/;"	s	file:
DSUQueue	code-library/Data Structures/DSU with Rollbacks.cpp	/^  DSUQueue(int n) {$/;"	f	struct:DSUQueue	file:
DSUQueue	code-library/Data Structures/DSU with Rollbacks.cpp	/^struct DSUQueue {$/;"	s	file:
DSUQueue	code-library/Data Structures/Queue Undo Trick.cpp	/^  DSUQueue(int n) {$/;"	f	struct:DSUQueue	file:
DSUQueue	code-library/Data Structures/Queue Undo Trick.cpp	/^struct DSUQueue {$/;"	s	file:
DSUQueue	code/Data Structures/DSU with Rollbacks.cpp	/^  DSUQueue(int n) {$/;"	f	struct:DSUQueue	file:
DSUQueue	code/Data Structures/DSU with Rollbacks.cpp	/^struct DSUQueue {$/;"	s	file:
DSUQueue	code/Data Structures/Queue Undo Trick.cpp	/^  DSUQueue(int n) {$/;"	f	struct:DSUQueue	file:
DSUQueue	code/Data Structures/Queue Undo Trick.cpp	/^struct DSUQueue {$/;"	s	file:
DT	code-library/Data Structures/Binarizing a Tree.cpp	/^int st[N * 2], en[N * 2], DT;$/;"	v	typeref:typename:int
DT	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^int st[N * 2], en[N * 2], DT;$/;"	v	typeref:typename:int
DT	code/Data Structures/Binarizing a Tree.cpp	/^int st[N * 2], en[N * 2], DT;$/;"	v	typeref:typename:int
DT	code/Data Structures/Centroid Decomposition Persistent.cpp	/^int st[N * 2], en[N * 2], DT;$/;"	v	typeref:typename:int
Determinant	code-library/Math/Determinant of Sparse Matrix.cpp	/^mint Determinant(int n, vector<Elem> M) {$/;"	f	typeref:typename:mint
Determinant	code/Math/Determinant of Sparse Matrix.cpp	/^mint Determinant(int n, vector<Elem> M) {$/;"	f	typeref:typename:mint
Dinic	code-library/Graph Theory/Dinics Algorithm.cpp	/^  Dinic() {}$/;"	f	struct:Dinic	file:
Dinic	code-library/Graph Theory/Dinics Algorithm.cpp	/^  Dinic(int _n) {$/;"	f	struct:Dinic	file:
Dinic	code-library/Graph Theory/Dinics Algorithm.cpp	/^struct Dinic {$/;"	s	file:
Dinic	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  Dinic(FlowGraph &edges, int s, int t) :$/;"	f	struct:Dinic	file:
Dinic	code-library/Graph Theory/Gomory Hu Tree.cpp	/^struct Dinic {$/;"	s	file:
Dinic	code-library/Graph Theory/L R Flow with Dinic.cpp	/^  Dinic() {}$/;"	f	struct:Dinic	file:
Dinic	code-library/Graph Theory/L R Flow with Dinic.cpp	/^  Dinic(int _n) {$/;"	f	struct:Dinic	file:
Dinic	code-library/Graph Theory/L R Flow with Dinic.cpp	/^struct Dinic {$/;"	s	file:
Dinic	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  Dinic() {}$/;"	f	struct:Dinic	file:
Dinic	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  Dinic(int _n) {$/;"	f	struct:Dinic	file:
Dinic	code-library/Graph Theory/Maximum Closure Problem.cpp	/^struct Dinic {$/;"	s	file:
Dinic	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^  Dinic() {}$/;"	f	struct:Dinic	file:
Dinic	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^  Dinic(int _n) {$/;"	f	struct:Dinic	file:
Dinic	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^struct Dinic {$/;"	s	file:
Dinic	code-library/Graph Theory/Unique Min Cut.cpp	/^  Dinic() {}$/;"	f	struct:Dinic	file:
Dinic	code-library/Graph Theory/Unique Min Cut.cpp	/^  Dinic(int _n) {$/;"	f	struct:Dinic	file:
Dinic	code-library/Graph Theory/Unique Min Cut.cpp	/^struct Dinic {$/;"	s	file:
Dinic	code/Graph Theory/Dinics Algorithm.cpp	/^  Dinic() {}$/;"	f	struct:Dinic	file:
Dinic	code/Graph Theory/Dinics Algorithm.cpp	/^  Dinic(int _n) {$/;"	f	struct:Dinic	file:
Dinic	code/Graph Theory/Dinics Algorithm.cpp	/^struct Dinic {$/;"	s	file:
Dinic	code/Graph Theory/Gomory Hu Tree.cpp	/^  Dinic(FlowGraph &edges, int s, int t) :$/;"	f	struct:Dinic	file:
Dinic	code/Graph Theory/Gomory Hu Tree.cpp	/^struct Dinic {$/;"	s	file:
Dinic	code/Graph Theory/L R Flow with Dinic.cpp	/^  Dinic() {}$/;"	f	struct:Dinic	file:
Dinic	code/Graph Theory/L R Flow with Dinic.cpp	/^  Dinic(int _n) {$/;"	f	struct:Dinic	file:
Dinic	code/Graph Theory/L R Flow with Dinic.cpp	/^struct Dinic {$/;"	s	file:
Dinic	code/Graph Theory/Maximum Closure Problem.cpp	/^  Dinic() {}$/;"	f	struct:Dinic	file:
Dinic	code/Graph Theory/Maximum Closure Problem.cpp	/^  Dinic(int _n) {$/;"	f	struct:Dinic	file:
Dinic	code/Graph Theory/Maximum Closure Problem.cpp	/^struct Dinic {$/;"	s	file:
Dinic	code/Graph Theory/Maximum Density Subgraph.cpp	/^  Dinic() {}$/;"	f	struct:Dinic	file:
Dinic	code/Graph Theory/Maximum Density Subgraph.cpp	/^  Dinic(int _n) {$/;"	f	struct:Dinic	file:
Dinic	code/Graph Theory/Maximum Density Subgraph.cpp	/^struct Dinic {$/;"	s	file:
Dinic	code/Graph Theory/Unique Min Cut.cpp	/^  Dinic() {}$/;"	f	struct:Dinic	file:
Dinic	code/Graph Theory/Unique Min Cut.cpp	/^  Dinic(int _n) {$/;"	f	struct:Dinic	file:
Dinic	code/Graph Theory/Unique Min Cut.cpp	/^struct Dinic {$/;"	s	file:
Dirichlet	code-library/Number Theory/Dirichlet Convolution.cpp	/^namespace Dirichlet {$/;"	n	file:
Dirichlet	code/Number Theory/Dirichlet Convolution.cpp	/^namespace Dirichlet {$/;"	n	file:
E	code-library/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  Euler<N * 2, 0> E; \/\/ at least 2 * n$/;"	m	struct:EdgeColoring	typeref:typename:Euler<N * 2,0>	file:
E	code-library/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^} E[N * 4];$/;"	v	typeref:struct:EDGE[]
E	code/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  Euler<N * 2, 0> E; \/\/ at least 2 * n$/;"	m	struct:EdgeColoring	typeref:typename:Euler<N * 2,0>	file:
E	code/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^} E[N * 4];$/;"	v	typeref:struct:EDGE[]
EDGE	code-library/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^struct EDGE {$/;"	s	file:
EDGE	code/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^struct EDGE {$/;"	s	file:
EPS	code-library/Math/Simplex Algorithm.cpp	/^#define EPS /;"	d	file:
EPS	code/Math/Simplex Algorithm.cpp	/^#define EPS /;"	d	file:
EQUAL	code-library/Math/Simplex Algorithm.cpp	/^#define EQUAL /;"	d	file:
EQUAL	code/Math/Simplex Algorithm.cpp	/^#define EQUAL /;"	d	file:
Edge	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^    Edge(int _to, cost_t _c, flow_t _f, int _rev): c(_c), f(_f), to(_to), rev(_rev) {}$/;"	f	struct:mcSFlow::Edge	file:
Edge	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  struct Edge {$/;"	s	struct:mcSFlow	file:
Edge	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^    Edge(int _to, cost_t _c, flow_t _f, int _rev): c(_c), f(_f), to(_to), rev(_rev) {}$/;"	f	struct:mcSFlow::Edge	file:
Edge	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  struct Edge {$/;"	s	struct:mcSFlow	file:
EdgeColoring	code-library/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^struct EdgeColoring {$/;"	s	file:
EdgeColoring	code-library/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^namespace EdgeColoring {$/;"	n	file:
EdgeColoring	code/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^struct EdgeColoring {$/;"	s	file:
EdgeColoring	code/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^namespace EdgeColoring {$/;"	n	file:
Elem	code-library/Math/Determinant of Sparse Matrix.cpp	/^struct Elem { int x, y; mint v; };$/;"	s	file:
Elem	code/Math/Determinant of Sparse Matrix.cpp	/^struct Elem { int x, y; mint v; };$/;"	s	file:
Enlarge	code-library/Graph Theory/Hungarian Algorithm.cpp	/^  void Enlarge() {$/;"	f	struct:Hungarian	typeref:typename:void	file:
Enlarge	code/Graph Theory/Hungarian Algorithm.cpp	/^  void Enlarge() {$/;"	f	struct:Hungarian	typeref:typename:void	file:
Eppstein	code-library/Data Structures/Persistent Meldable Heap.cpp	/^vector<ll> Eppstein(int n, int src, int dest, int k) { \/\/ 0 indexed, directed graph$/;"	f	typeref:typename:vector<ll>
Eppstein	code-library/Graph Theory/Eppsteins Algorithm.cpp	/^vector<ll> Eppstein(int n, int src, int dest, int k) { \/\/ 0 indexed, directed graph$/;"	f	typeref:typename:vector<ll>
Eppstein	code/Data Structures/Persistent Meldable Heap.cpp	/^vector<ll> Eppstein(int n, int src, int dest, int k) { \/\/ 0 indexed, directed graph$/;"	f	typeref:typename:vector<ll>
Eppstein	code/Graph Theory/Eppsteins Algorithm.cpp	/^vector<ll> Eppstein(int n, int src, int dest, int k) { \/\/ 0 indexed, directed graph$/;"	f	typeref:typename:vector<ll>
Euler	code-library/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  Euler() {$/;"	f	struct:Euler	file:
Euler	code-library/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^template<int N, bool directed> struct Euler {$/;"	s	file:
Euler	code/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  Euler() {$/;"	f	struct:Euler	file:
Euler	code/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^template<int N, bool directed> struct Euler {$/;"	s	file:
Event	code-library/Geometry/Point Location.cpp	/^struct Event {$/;"	s	file:
Event	code/Geometry/Point Location.cpp	/^struct Event {$/;"	s	file:
EventType	code-library/Geometry/Point Location.cpp	/^enum EventType { DEL = 2, ADD = 3, GET = 1, VERT = 0 };$/;"	g	file:
EventType	code/Geometry/Point Location.cpp	/^enum EventType { DEL = 2, ADD = 3, GET = 1, VERT = 0 };$/;"	g	file:
F	code-library/Geometry/Delaunay Triangulation.cpp	/^    PT F() { return r() -> p; }$/;"	f	struct:Quad	typeref:typename:PT	file:
F	code-library/Geometry/Geometry 3D.cpp	/^    vector<face> F; \/\/ convex surface triangles$/;"	m	struct:CH3D	typeref:typename:vector<face>	file:
F	code-library/Geometry/Voronoi Diagram.cpp	/^    P F() { return r() -> p; }$/;"	f	struct:Quad	typeref:typename:P	file:
F	code-library/Graph Theory/Gomory Hu Tree.cpp	/^using F = long long;$/;"	t	typeref:typename:long long	file:
F	code-library/Graph Theory/L R Flow with Dinic.cpp	/^  Dinic F;$/;"	m	struct:LR_Flow	typeref:typename:Dinic	file:
F	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  MCMF F;$/;"	m	struct:LR_Flow	typeref:typename:MCMF	file:
F	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^} F;$/;"	v	typeref:struct:Dinic
F	code-library/Graph Theory/Unique Min Cut.cpp	/^} F;$/;"	v	typeref:struct:Dinic
F	code/Geometry/Delaunay Triangulation.cpp	/^    PT F() { return r() -> p; }$/;"	f	struct:Quad	typeref:typename:PT	file:
F	code/Geometry/Geometry 3D.cpp	/^    vector<face> F; \/\/ convex surface triangles$/;"	m	struct:CH3D	typeref:typename:vector<face>	file:
F	code/Geometry/Voronoi Diagram.cpp	/^    P F() { return r() -> p; }$/;"	f	struct:Quad	typeref:typename:P	file:
F	code/Graph Theory/Gomory Hu Tree.cpp	/^using F = long long;$/;"	t	typeref:typename:long long	file:
F	code/Graph Theory/L R Flow with Dinic.cpp	/^  Dinic F;$/;"	m	struct:LR_Flow	typeref:typename:Dinic	file:
F	code/Graph Theory/L R Flow with MCMF.cpp	/^  MCMF F;$/;"	m	struct:LR_Flow	typeref:typename:MCMF	file:
F	code/Graph Theory/Maximum Density Subgraph.cpp	/^} F;$/;"	v	typeref:struct:Dinic
F	code/Graph Theory/Unique Min Cut.cpp	/^} F;$/;"	v	typeref:struct:Dinic
F	contests/Codeforces/737/C.cpp	/^#define F /;"	d	file:
FBASE	code-library/Miscellaneous/BigInt.cpp	/^const int BASE = 1e9, FBASE = 1e4;$/;"	v	typeref:typename:const int
FBASE	code/Miscellaneous/BigInt.cpp	/^const int BASE = 1e9, FBASE = 1e4;$/;"	v	typeref:typename:const int
FDIG	code-library/Miscellaneous/BigInt.cpp	/^const int DIG = 9, FDIG = 4;$/;"	v	typeref:typename:const int
FDIG	code/Miscellaneous/BigInt.cpp	/^const int DIG = 9, FDIG = 4;$/;"	v	typeref:typename:const int
FFA	code-library/Math/Finite Field Arithmetic Binary.cpp	/^namespace FFA {$/;"	n	file:
FFA	code/Math/Finite Field Arithmetic Binary.cpp	/^namespace FFA {$/;"	n	file:
FFT	code-library/Miscellaneous/BigInt.cpp	/^  static vector<Cplx> FFT(vector<Cplx> v, int dir = 1) {$/;"	f	struct:BigInt	typeref:typename:vector<Cplx>	file:
FFT	code/Miscellaneous/BigInt.cpp	/^  static vector<Cplx> FFT(vector<Cplx> v, int dir = 1) {$/;"	f	struct:BigInt	typeref:typename:vector<Cplx>	file:
FR	code-library/Number Theory/Fermats Theorem on Sum of Two Squares.cpp	/^#define FR /;"	d	file:
FR	code/Number Theory/Fermats Theorem on Sum of Two Squares.cpp	/^#define FR /;"	d	file:
FWHT	code-library/Math/FWHT in Any Base.cpp	/^namespace FWHT {$/;"	n	file:
FWHT	code-library/Math/FWHT in Ternary Base.cpp	/^struct FWHT {$/;"	s	file:
FWHT	code-library/Math/FWHT.cpp	/^struct FWHT{$/;"	s	file:
FWHT	code/Math/FWHT in Any Base.cpp	/^namespace FWHT {$/;"	n	file:
FWHT	code/Math/FWHT in Ternary Base.cpp	/^struct FWHT {$/;"	s	file:
FWHT	code/Math/FWHT.cpp	/^struct FWHT{$/;"	s	file:
FermatRepresent	code-library/Number Theory/Fermats Theorem on Sum of Two Squares.cpp	/^namespace FermatRepresent {$/;"	n	file:
FermatRepresent	code/Number Theory/Fermats Theorem on Sum of Two Squares.cpp	/^namespace FermatRepresent {$/;"	n	file:
Find	code-library/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^int Find(int x) {$/;"	f	typeref:typename:int
Find	code-library/Graph Theory/Inverse Graph.cpp	/^int Find(int x) {$/;"	f	typeref:typename:int
Find	code/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^int Find(int x) {$/;"	f	typeref:typename:int
Find	code/Graph Theory/Inverse Graph.cpp	/^int Find(int x) {$/;"	f	typeref:typename:int
FlowGraph	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  FlowGraph(size_t n) : vector<vector<S>>(n) {}$/;"	f	struct:FlowGraph	file:
FlowGraph	code-library/Graph Theory/Gomory Hu Tree.cpp	/^struct FlowGraph : vector<vector<S>> {$/;"	s	file:
FlowGraph	code/Graph Theory/Gomory Hu Tree.cpp	/^  FlowGraph(size_t n) : vector<vector<S>>(n) {}$/;"	f	struct:FlowGraph	file:
FlowGraph	code/Graph Theory/Gomory Hu Tree.cpp	/^struct FlowGraph : vector<vector<S>> {$/;"	s	file:
Freivalds	code-library/Math/Freivalds Algorithm.cpp	/^int Freivalds(Mat a, Mat b, Mat c) {$/;"	f	typeref:typename:int
Freivalds	code/Math/Freivalds Algorithm.cpp	/^int Freivalds(Mat a, Mat b, Mat c) {$/;"	f	typeref:typename:int
G	code-library/Data Structures/Binarizing a Tree.cpp	/^vector<pair<int, int>> g[N * 2], G[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
G	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^vector<pair<int, int>> g[N * 2], G[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
G	code-library/Graph Theory/3 CYCLE and 4 CYCLE.cpp	/^vector<int> g[N], G[N];$/;"	v	typeref:typename:vector<int>[]
G	code-library/Graph Theory/Chinese Postman Problem.cpp	/^  long long G[N][N], dis[N];$/;"	m	struct:RandomizedMatching	typeref:typename:long long[][]	file:
G	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^mint dp[N][N], C[N], G[N];$/;"	v	typeref:typename:mint[]
G	code-library/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^vector<int> G[N];$/;"	v	typeref:typename:vector<int>[]
G	code-library/Graph Theory/Kuhns Algorithm.cpp	/^vector<int> g[N], r[N], G[N], vec; \/\/G is the condensed graph$/;"	v	typeref:typename:vector<int>[]
G	code-library/Graph Theory/LCA in O(1).cpp	/^  vector<vector<int>> G;$/;"	m	struct:LCA	typeref:typename:vector<vector<int>>	file:
G	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  vector<vector<int>> g, r, G;\/\/G is the condensed graph$/;"	m	struct:MaximumClosure	typeref:typename:vector<vector<int>>	file:
G	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  vector<vector<Edge> > G;$/;"	m	struct:mcSFlow	typeref:typename:vector<vector<Edge>>	file:
G	code-library/Graph Theory/Randomized Matching Weighted.cpp	/^	long long G[N][N], dis[N];$/;"	m	struct:RandomizedMatching	typeref:typename:long long[][]	file:
G	code-library/Graph Theory/SCC.cpp	/^vector<int> g[N], r[N], G[N], vec; \/\/G is the condensed graph$/;"	v	typeref:typename:vector<int>[]
G	code-library/Graph Theory/Stoer Wagner Algorithm.cpp	/^  long long G[N][N], dis[N];$/;"	m	struct:StoerWagner	typeref:typename:long long[][]	file:
G	code/Data Structures/Binarizing a Tree.cpp	/^vector<pair<int, int>> g[N * 2], G[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
G	code/Data Structures/Centroid Decomposition Persistent.cpp	/^vector<pair<int, int>> g[N * 2], G[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
G	code/Graph Theory/3 CYCLE and 4 CYCLE.cpp	/^vector<int> g[N], G[N];$/;"	v	typeref:typename:vector<int>[]
G	code/Graph Theory/Chinese Postman Problem.cpp	/^  long long G[N][N], dis[N];$/;"	m	struct:RandomizedMatching	typeref:typename:long long[][]	file:
G	code/Graph Theory/Counting Labeled Graphs.cpp	/^mint dp[N][N], C[N], G[N];$/;"	v	typeref:typename:mint[]
G	code/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^vector<int> G[N];$/;"	v	typeref:typename:vector<int>[]
G	code/Graph Theory/Kuhns Algorithm.cpp	/^vector<int> g[N], r[N], G[N], vec; \/\/G is the condensed graph$/;"	v	typeref:typename:vector<int>[]
G	code/Graph Theory/LCA in O(1).cpp	/^  vector<vector<int>> G;$/;"	m	struct:LCA	typeref:typename:vector<vector<int>>	file:
G	code/Graph Theory/Maximum Closure Problem.cpp	/^  vector<vector<int>> g, r, G;\/\/G is the condensed graph$/;"	m	struct:MaximumClosure	typeref:typename:vector<vector<int>>	file:
G	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  vector<vector<Edge> > G;$/;"	m	struct:mcSFlow	typeref:typename:vector<vector<Edge>>	file:
G	code/Graph Theory/Randomized Matching Weighted.cpp	/^	long long G[N][N], dis[N];$/;"	m	struct:RandomizedMatching	typeref:typename:long long[][]	file:
G	code/Graph Theory/SCC.cpp	/^vector<int> g[N], r[N], G[N], vec; \/\/G is the condensed graph$/;"	v	typeref:typename:vector<int>[]
G	code/Graph Theory/Stoer Wagner Algorithm.cpp	/^  long long G[N][N], dis[N];$/;"	m	struct:StoerWagner	typeref:typename:long long[][]	file:
GET	code-library/Geometry/Point Location.cpp	/^enum EventType { DEL = 2, ADD = 3, GET = 1, VERT = 0 };$/;"	e	enum:EventType	file:
GET	code/Geometry/Point Location.cpp	/^enum EventType { DEL = 2, ADD = 3, GET = 1, VERT = 0 };$/;"	e	enum:EventType	file:
GREATEQ	code-library/Math/Simplex Algorithm.cpp	/^#define GREATEQ /;"	d	file:
GREATEQ	code/Math/Simplex Algorithm.cpp	/^#define GREATEQ /;"	d	file:
Gauss	code-library/Math/Determinant under Composite Modulo.cpp	/^int Gauss(vector<vector<int>> a, const int mod) {$/;"	f	typeref:typename:int
Gauss	code-library/Math/Determinant under Prime Modulo.cpp	/^int Gauss(vector<vector<int>> a) {$/;"	f	typeref:typename:int
Gauss	code-library/Math/Determinant.cpp	/^int Gauss(vector<vector<double>> a) {$/;"	f	typeref:typename:int
Gauss	code-library/Math/Gaussian Elimination Modular.cpp	/^int Gauss(vector<vector<int>> a, vector<int> &ans){$/;"	f	typeref:typename:int
Gauss	code-library/Math/Gaussian Elimination Modulo 2.cpp	/^int Gauss(int n, int m, vector<bitset<N>> a, bitset<N> &ans) {$/;"	f	typeref:typename:int
Gauss	code-library/Math/Gaussian Elimination.cpp	/^int Gauss(vector<vector<double>> a, vector<double> &ans) {$/;"	f	typeref:typename:int
Gauss	code-library/Math/Inverse of A Matrix.cpp	/^bool Gauss(vector<vector<int>> a, vector<vector<int>> &ans, const int mod) {$/;"	f	typeref:typename:bool
Gauss	code/Math/Determinant under Composite Modulo.cpp	/^int Gauss(vector<vector<int>> a, const int mod) {$/;"	f	typeref:typename:int
Gauss	code/Math/Determinant under Prime Modulo.cpp	/^int Gauss(vector<vector<int>> a) {$/;"	f	typeref:typename:int
Gauss	code/Math/Determinant.cpp	/^int Gauss(vector<vector<double>> a) {$/;"	f	typeref:typename:int
Gauss	code/Math/Gaussian Elimination Modular.cpp	/^int Gauss(vector<vector<int>> a, vector<int> &ans){$/;"	f	typeref:typename:int
Gauss	code/Math/Gaussian Elimination Modulo 2.cpp	/^int Gauss(int n, int m, vector<bitset<N>> a, bitset<N> &ans) {$/;"	f	typeref:typename:int
Gauss	code/Math/Gaussian Elimination.cpp	/^int Gauss(vector<vector<double>> a, vector<double> &ans) {$/;"	f	typeref:typename:int
Gauss	code/Math/Inverse of A Matrix.cpp	/^bool Gauss(vector<vector<int>> a, vector<vector<int>> &ans, const int mod) {$/;"	f	typeref:typename:bool
GomoryHuTree	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  GomoryHuTree(int n, const vector<edge> &ed) : V(n), p(V), w(V), c(V) {$/;"	f	struct:GomoryHuTree	file:
GomoryHuTree	code-library/Graph Theory/Gomory Hu Tree.cpp	/^struct GomoryHuTree {$/;"	s	file:
GomoryHuTree	code/Graph Theory/Gomory Hu Tree.cpp	/^  GomoryHuTree(int n, const vector<edge> &ed) : V(n), p(V), w(V), c(V) {$/;"	f	struct:GomoryHuTree	file:
GomoryHuTree	code/Graph Theory/Gomory Hu Tree.cpp	/^struct GomoryHuTree {$/;"	s	file:
Group	code-library/Miscellaneous/Schreier–Sims algorithm.cpp	/^  Group(vector<vector<int>> &gen, int _n){$/;"	f	struct:Group	file:
Group	code-library/Miscellaneous/Schreier–Sims algorithm.cpp	/^struct Group {$/;"	s	file:
Group	code/Miscellaneous/Schreier–Sims algorithm.cpp	/^  Group(vector<vector<int>> &gen, int _n){$/;"	f	struct:Group	file:
Group	code/Miscellaneous/Schreier–Sims algorithm.cpp	/^struct Group {$/;"	s	file:
H	code-library/Geometry/Delaunay Triangulation.cpp	/^	#define H(/;"	d	file:
H	code-library/Geometry/Voronoi Diagram.cpp	/^	#define H(/;"	d	file:
H	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^}H;$/;"	v	typeref:struct:Hafnian
H	code/Geometry/Delaunay Triangulation.cpp	/^	#define H(/;"	d	file:
H	code/Geometry/Voronoi Diagram.cpp	/^	#define H(/;"	d	file:
H	code/Graph Theory/Hafnian of a Matrix.cpp	/^}H;$/;"	v	typeref:struct:Hafnian
HASH	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^struct HASH {$/;"	s	file:
HASH	code/Data Structures/Dynamic Connectivity Problem.cpp	/^struct HASH {$/;"	s	file:
HP	code-library/Geometry/Geometry 2D.cpp	/^    HP() {}$/;"	f	struct:HP	file:
HP	code-library/Geometry/Geometry 2D.cpp	/^    HP(PT a, PT b) : a(a), b(b) {}$/;"	f	struct:HP	file:
HP	code-library/Geometry/Geometry 2D.cpp	/^    HP(const HP& rhs) : a(rhs.a), b(rhs.b) {}$/;"	f	struct:HP	file:
HP	code-library/Geometry/Geometry 2D.cpp	/^struct HP {$/;"	s	file:
HP	code-library/Geometry/Half Plane Intersection.cpp	/^    HP() {}$/;"	f	struct:HP	file:
HP	code-library/Geometry/Half Plane Intersection.cpp	/^    HP(PT a, PT b) : a(a), b(b) {}$/;"	f	struct:HP	file:
HP	code-library/Geometry/Half Plane Intersection.cpp	/^    HP(const HP& rhs) : a(rhs.a), b(rhs.b) {}$/;"	f	struct:HP	file:
HP	code-library/Geometry/Half Plane Intersection.cpp	/^struct HP {$/;"	s	file:
HP	code/Geometry/Geometry 2D.cpp	/^    HP() {}$/;"	f	struct:HP	file:
HP	code/Geometry/Geometry 2D.cpp	/^    HP(PT a, PT b) : a(a), b(b) {}$/;"	f	struct:HP	file:
HP	code/Geometry/Geometry 2D.cpp	/^    HP(const HP& rhs) : a(rhs.a), b(rhs.b) {}$/;"	f	struct:HP	file:
HP	code/Geometry/Geometry 2D.cpp	/^struct HP {$/;"	s	file:
HP	code/Geometry/Half Plane Intersection.cpp	/^    HP() {}$/;"	f	struct:HP	file:
HP	code/Geometry/Half Plane Intersection.cpp	/^    HP(PT a, PT b) : a(a), b(b) {}$/;"	f	struct:HP	file:
HP	code/Geometry/Half Plane Intersection.cpp	/^    HP(const HP& rhs) : a(rhs.a), b(rhs.b) {}$/;"	f	struct:HP	file:
HP	code/Geometry/Half Plane Intersection.cpp	/^struct HP {$/;"	s	file:
Hafnian	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^struct Hafnian {$/;"	s	file:
Hafnian	code-library/Math/Hafnian of a Matrix.cpp	/^namespace Hafnian {$/;"	n	file:
Hafnian	code/Graph Theory/Hafnian of a Matrix.cpp	/^struct Hafnian {$/;"	s	file:
Hafnian	code/Math/Hafnian of a Matrix.cpp	/^namespace Hafnian {$/;"	n	file:
HalfPlaneSet	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    HalfPlaneSet() {$/;"	f	struct:HalfPlaneSet	file:
HalfPlaneSet	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^struct HalfPlaneSet : multimap<Angle, PT> { \/\/(dir, PT)$/;"	s	file:
HalfPlaneSet	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    HalfPlaneSet() {$/;"	f	struct:HalfPlaneSet	file:
HalfPlaneSet	code/Geometry/Half Plane Intersection Dynamic.cpp	/^struct HalfPlaneSet : multimap<Angle, PT> { \/\/(dir, PT)$/;"	s	file:
Hashing	code-library/Strings/String Hashing 2D.cpp	/^  Hashing() {}$/;"	f	struct:Hashing	file:
Hashing	code-library/Strings/String Hashing 2D.cpp	/^  Hashing(vector<string>& s) {$/;"	f	struct:Hashing	file:
Hashing	code-library/Strings/String Hashing 2D.cpp	/^struct Hashing {$/;"	s	file:
Hashing	code-library/Strings/String Hashing.cpp	/^  Hashing() {}$/;"	f	struct:Hashing	file:
Hashing	code-library/Strings/String Hashing.cpp	/^  Hashing(string _s) {$/;"	f	struct:Hashing	file:
Hashing	code-library/Strings/String Hashing.cpp	/^struct Hashing {$/;"	s	file:
Hashing	code/Strings/String Hashing 2D.cpp	/^  Hashing() {}$/;"	f	struct:Hashing	file:
Hashing	code/Strings/String Hashing 2D.cpp	/^  Hashing(vector<string>& s) {$/;"	f	struct:Hashing	file:
Hashing	code/Strings/String Hashing 2D.cpp	/^struct Hashing {$/;"	s	file:
Hashing	code/Strings/String Hashing.cpp	/^  Hashing() {}$/;"	f	struct:Hashing	file:
Hashing	code/Strings/String Hashing.cpp	/^  Hashing(string _s) {$/;"	f	struct:Hashing	file:
Hashing	code/Strings/String Hashing.cpp	/^struct Hashing {$/;"	s	file:
Hessenberg	code-library/Math/Characteristic Polynomial Faster.cpp	/^vector<vector<mint>> Hessenberg(vector<vector<mint>> a) {$/;"	f	typeref:typename:vector<vector<mint>>
Hessenberg	code/Math/Characteristic Polynomial Faster.cpp	/^vector<vector<mint>> Hessenberg(vector<vector<mint>> a) {$/;"	f	typeref:typename:vector<vector<mint>>
HopcroftKarp	code-library/Graph Theory/HopCroft Karp Algorithm.cpp	/^  HopcroftKarp(int _n, int _m) {$/;"	f	struct:HopcroftKarp	file:
HopcroftKarp	code-library/Graph Theory/HopCroft Karp Algorithm.cpp	/^struct HopcroftKarp {$/;"	s	file:
HopcroftKarp	code/Graph Theory/HopCroft Karp Algorithm.cpp	/^  HopcroftKarp(int _n, int _m) {$/;"	f	struct:HopcroftKarp	file:
HopcroftKarp	code/Graph Theory/HopCroft Karp Algorithm.cpp	/^struct HopcroftKarp {$/;"	s	file:
Hungarian	code-library/Graph Theory/Hungarian Algorithm.cpp	/^  Hungarian() {}$/;"	f	struct:Hungarian	file:
Hungarian	code-library/Graph Theory/Hungarian Algorithm.cpp	/^  Hungarian(int n1, int n2): n(max(n1, n2)) {$/;"	f	struct:Hungarian	file:
Hungarian	code-library/Graph Theory/Hungarian Algorithm.cpp	/^struct Hungarian {$/;"	s	file:
Hungarian	code/Graph Theory/Hungarian Algorithm.cpp	/^  Hungarian() {}$/;"	f	struct:Hungarian	file:
Hungarian	code/Graph Theory/Hungarian Algorithm.cpp	/^  Hungarian(int n1, int n2): n(max(n1, n2)) {$/;"	f	struct:Hungarian	file:
Hungarian	code/Graph Theory/Hungarian Algorithm.cpp	/^struct Hungarian {$/;"	s	file:
I	code-library/Data Structures/MOs Online.cpp	/^int a[N], I[N];$/;"	v	typeref:typename:int[]
I	code/Data Structures/MOs Online.cpp	/^int a[N], I[N];$/;"	v	typeref:typename:int[]
INF	code-library/Data Structures/KD Tree.cpp	/^const long long INF = 2000000000000000007;$/;"	v	typeref:typename:const long long
INF	code-library/Data Structures/Persistent Meldable Heap.cpp	/^const ll INF = 1e18;$/;"	v	typeref:typename:const ll
INF	code-library/Graph Theory/Bellman Ford.cpp	/^const int INF = 2e9;$/;"	v	typeref:typename:const int
INF	code-library/Graph Theory/Eppsteins Algorithm.cpp	/^const ll INF = 1e18;$/;"	v	typeref:typename:const ll
INF	code-library/Graph Theory/Johnson's Algorithm.cpp	/^const long long INF = 1e18;$/;"	v	typeref:typename:const long long
INF	code-library/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^const ll INF = 1e18 + 5;$/;"	v	typeref:typename:const ll
INF	code/Data Structures/KD Tree.cpp	/^const long long INF = 2000000000000000007;$/;"	v	typeref:typename:const long long
INF	code/Data Structures/Persistent Meldable Heap.cpp	/^const ll INF = 1e18;$/;"	v	typeref:typename:const ll
INF	code/Graph Theory/Bellman Ford.cpp	/^const int INF = 2e9;$/;"	v	typeref:typename:const int
INF	code/Graph Theory/Eppsteins Algorithm.cpp	/^const ll INF = 1e18;$/;"	v	typeref:typename:const ll
INF	code/Graph Theory/Johnson's Algorithm.cpp	/^const long long INF = 1e18;$/;"	v	typeref:typename:const long long
INF	code/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^const ll INF = 1e18 + 5;$/;"	v	typeref:typename:const ll
INF	practice/usacoguide/gold/introDP/711C.cpp	/^const ll INF = ll(1e18);$/;"	v	typeref:typename:const ll
INFCOST	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  static constexpr cost_t INFCOST = numeric_limits<cost_t>::max() \/ 2;$/;"	m	struct:mcSFlow	typeref:typename:cost_t	file:
INFCOST	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  static constexpr cost_t INFCOST = numeric_limits<cost_t>::max() \/ 2;$/;"	m	struct:mcSFlow	typeref:typename:cost_t	file:
INFEASIBLE	code-library/Math/Simplex Algorithm.cpp	/^#define INFEASIBLE /;"	d	file:
INFEASIBLE	code/Math/Simplex Algorithm.cpp	/^#define INFEASIBLE /;"	d	file:
IO	code-library/Miscellaneous/Parallel Binary Search.cpp	/^namespace IO {$/;"	n	file:
IO	code/Miscellaneous/Parallel Binary Search.cpp	/^namespace IO {$/;"	n	file:
Int	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^    Int() {};$/;"	f	struct:ST::Int	file:
Int	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^    Int(mint _a, mint _d) {a = _a, d = _d;}$/;"	f	struct:ST::Int	file:
Int	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  struct Int { \/\/ arithmetic progression a, a + d, a + 2 * d, ...$/;"	s	struct:ST	file:
Int	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^    Int() {};$/;"	f	struct:ST::Int	file:
Int	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^    Int(mint _a, mint _d) {a = _a, d = _d;}$/;"	f	struct:ST::Int	file:
Int	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  struct Int { \/\/ arithmetic progression a, a + d, a + 2 * d, ...$/;"	s	struct:ST	file:
IsomorphicSuffixArray	code-library/Strings/Suffix Array Isomorphic.cpp	/^  IsomorphicSuffixArray() {}$/;"	f	struct:IsomorphicSuffixArray	file:
IsomorphicSuffixArray	code-library/Strings/Suffix Array Isomorphic.cpp	/^  IsomorphicSuffixArray(string _s) {$/;"	f	struct:IsomorphicSuffixArray	file:
IsomorphicSuffixArray	code-library/Strings/Suffix Array Isomorphic.cpp	/^struct IsomorphicSuffixArray {$/;"	s	file:
IsomorphicSuffixArray	code/Strings/Suffix Array Isomorphic.cpp	/^  IsomorphicSuffixArray() {}$/;"	f	struct:IsomorphicSuffixArray	file:
IsomorphicSuffixArray	code/Strings/Suffix Array Isomorphic.cpp	/^  IsomorphicSuffixArray(string _s) {$/;"	f	struct:IsomorphicSuffixArray	file:
IsomorphicSuffixArray	code/Strings/Suffix Array Isomorphic.cpp	/^struct IsomorphicSuffixArray {$/;"	s	file:
Italiano	code-library/Graph Theory/DAG Reachability Dynamic.cpp	/^  Italiano(int n) : n(n), par(n, vector<int>(n, -1)), child(n, vector<vector<int>>(n)) { }$/;"	f	struct:Italiano	file:
Italiano	code-library/Graph Theory/DAG Reachability Dynamic.cpp	/^struct Italiano {$/;"	s	file:
Italiano	code/Graph Theory/DAG Reachability Dynamic.cpp	/^  Italiano(int n) : n(n), par(n, vector<int>(n, -1)), child(n, vector<vector<int>>(n)) { }$/;"	f	struct:Italiano	file:
Italiano	code/Graph Theory/DAG Reachability Dynamic.cpp	/^struct Italiano {$/;"	s	file:
K	code-library/Data Structures/Persistent Trie.cpp	/^const int K = 15;$/;"	v	typeref:typename:const int
K	code/Data Structures/Persistent Trie.cpp	/^const int K = 15;$/;"	v	typeref:typename:const int
K	contests/Codeforces/1622/C/sol.cpp	/^int N, K;$/;"	v	typeref:typename:int
K	contests/Codeforces/1622/C_new/sol.cpp	/^int N, K, sum = 0; $/;"	v	typeref:typename:int
K	practice/cf/random/1700/4.cpp	/^int N, K, X = 0;$/;"	v	typeref:typename:int
K	practice/usacoguide/gold/bfs/milkpails.cpp	/^int X, Y, K, M; $/;"	v	typeref:typename:int
K	practice/usacoguide/gold/divisibility/powerproducts.cpp	/^int N, K;$/;"	v	typeref:typename:int
Kruskal	code-library/Graph Theory/Manhattan MST.cpp	/^long long Kruskal() {$/;"	f	typeref:typename:long long
Kruskal	code/Graph Theory/Manhattan MST.cpp	/^long long Kruskal() {$/;"	f	typeref:typename:long long
Kuhn	code-library/Graph Theory/Kuhns Algorithm.cpp	/^  Kuhn(int _n, int _m) {$/;"	f	struct:Kuhn	file:
Kuhn	code-library/Graph Theory/Kuhns Algorithm.cpp	/^struct Kuhn {$/;"	s	file:
Kuhn	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  Kuhn() {}$/;"	f	struct:Kuhn	file:
Kuhn	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  Kuhn(int _n, int _m) {$/;"	f	struct:Kuhn	file:
Kuhn	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^struct Kuhn {$/;"	s	file:
Kuhn	code/Graph Theory/Kuhns Algorithm.cpp	/^  Kuhn(int _n, int _m) {$/;"	f	struct:Kuhn	file:
Kuhn	code/Graph Theory/Kuhns Algorithm.cpp	/^struct Kuhn {$/;"	s	file:
Kuhn	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  Kuhn() {}$/;"	f	struct:Kuhn	file:
Kuhn	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  Kuhn(int _n, int _m) {$/;"	f	struct:Kuhn	file:
Kuhn	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^struct Kuhn {$/;"	s	file:
L	code-library/Data Structures/Persistent Array.cpp	/^  vector<int> L, R;$/;"	m	struct:PersistentQueue	typeref:typename:vector<int>	file:
L	code-library/Data Structures/Persistent Queue.cpp	/^  vector<int> L, R;$/;"	m	struct:PersistentQueue	typeref:typename:vector<int>	file:
L	code-library/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  int L, R;$/;"	m	struct:LiChaoTree	typeref:typename:int	file:
L	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  int L, R;$/;"	m	struct:PersistentLiChaoTree	typeref:typename:int	file:
L	code-library/Geometry/Onion Decomposition.cpp	/^        int L, R;$/;"	m	struct:LeftHull::node	typeref:typename:int	file:
L	code-library/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^const int L = 62;$/;"	v	typeref:typename:const int
L	code-library/Number Theory/K Divisors.cpp	/^const int L = 41; \/\/ 2^L >= max n$/;"	v	typeref:typename:const int
L	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^const int N = 755, L = 1e7 + 9;$/;"	v	typeref:typename:const int
L	code/Data Structures/Persistent Array.cpp	/^  vector<int> L, R;$/;"	m	struct:PersistentQueue	typeref:typename:vector<int>	file:
L	code/Data Structures/Persistent Queue.cpp	/^  vector<int> L, R;$/;"	m	struct:PersistentQueue	typeref:typename:vector<int>	file:
L	code/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  int L, R;$/;"	m	struct:LiChaoTree	typeref:typename:int	file:
L	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  int L, R;$/;"	m	struct:PersistentLiChaoTree	typeref:typename:int	file:
L	code/Geometry/Onion Decomposition.cpp	/^        int L, R;$/;"	m	struct:LeftHull::node	typeref:typename:int	file:
L	code/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^const int L = 62;$/;"	v	typeref:typename:const int
L	code/Number Theory/K Divisors.cpp	/^const int L = 41; \/\/ 2^L >= max n$/;"	v	typeref:typename:const int
L	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^const int N = 755, L = 1e7 + 9;$/;"	v	typeref:typename:const int
LCA	code-library/Graph Theory/LCA in O(1).cpp	/^  LCA() {} $/;"	f	struct:LCA	file:
LCA	code-library/Graph Theory/LCA in O(1).cpp	/^  LCA(int n) : enter(n, -1), exxit(n, -1), depth(n), G(n), linear(2 * n) {}$/;"	f	struct:LCA	file:
LCA	code-library/Graph Theory/LCA in O(1).cpp	/^struct LCA { \/\/ 0-based$/;"	s	file:
LCA	code/Graph Theory/LCA in O(1).cpp	/^  LCA() {} $/;"	f	struct:LCA	file:
LCA	code/Graph Theory/LCA in O(1).cpp	/^  LCA(int n) : enter(n, -1), exxit(n, -1), depth(n), G(n), linear(2 * n) {}$/;"	f	struct:LCA	file:
LCA	code/Graph Theory/LCA in O(1).cpp	/^struct LCA { \/\/ 0-based$/;"	s	file:
LCT	code-library/Data Structures/Link Cut Tree.cpp	/^  LCT() {}$/;"	f	struct:LCT	file:
LCT	code-library/Data Structures/Link Cut Tree.cpp	/^  LCT(int n) : t(n + 1) {}$/;"	f	struct:LCT	file:
LCT	code-library/Data Structures/Link Cut Tree.cpp	/^struct LCT {$/;"	s	file:
LCT	code/Data Structures/Link Cut Tree.cpp	/^  LCT() {}$/;"	f	struct:LCT	file:
LCT	code/Data Structures/Link Cut Tree.cpp	/^  LCT(int n) : t(n + 1) {}$/;"	f	struct:LCT	file:
LCT	code/Data Structures/Link Cut Tree.cpp	/^struct LCT {$/;"	s	file:
LDE	code-library/Number Theory/Linear Diophantine Equation with Nonnegative Solutions.cpp	/^  LDE() {}$/;"	f	struct:LDE	file:
LDE	code-library/Number Theory/Linear Diophantine Equation with Nonnegative Solutions.cpp	/^  LDE(vector<int> a) { \/\/ O(min(a[i]) * n * log(min(a[i])))$/;"	f	struct:LDE	file:
LDE	code-library/Number Theory/Linear Diophantine Equation with Nonnegative Solutions.cpp	/^struct LDE { \/\/ sum(a[i] * x[i]) = k, x[i] >= 0$/;"	s	file:
LDE	code/Number Theory/Linear Diophantine Equation with Nonnegative Solutions.cpp	/^  LDE() {}$/;"	f	struct:LDE	file:
LDE	code/Number Theory/Linear Diophantine Equation with Nonnegative Solutions.cpp	/^  LDE(vector<int> a) { \/\/ O(min(a[i]) * n * log(min(a[i])))$/;"	f	struct:LDE	file:
LDE	code/Number Theory/Linear Diophantine Equation with Nonnegative Solutions.cpp	/^struct LDE { \/\/ sum(a[i] * x[i]) = k, x[i] >= 0$/;"	s	file:
LESSEQ	code-library/Math/Simplex Algorithm.cpp	/^#define LESSEQ /;"	d	file:
LESSEQ	code/Math/Simplex Algorithm.cpp	/^#define LESSEQ /;"	d	file:
LG	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^const int LG = 17;$/;"	v	typeref:typename:const int
LG	code-library/Data Structures/HLD.cpp	/^const int N = 1e5 + 9, LG = 18, inf = 1e9 + 9;$/;"	v	typeref:typename:const int
LG	code-library/Data Structures/LCA.cpp	/^const int N = 3e5 + 9, LG = 18;$/;"	v	typeref:typename:const int
LG	code-library/Data Structures/Permutation Tree.cpp	/^const int N = 1e5 + 9, inf = 1e9 + 7, LG = 19;$/;"	v	typeref:typename:const int
LG	code-library/Data Structures/Reachability Tree.cpp	/^const int N = 1e5 + 9, LG = 18;$/;"	v	typeref:typename:const int
LG	code-library/Data Structures/Sparse Table 2D.cpp	/^const int N = 505, LG = 10;$/;"	v	typeref:typename:const int
LG	code-library/Graph Theory/LCA.cpp	/^const int N = 3e5 + 9, LG = 18;$/;"	v	typeref:typename:const int
LG	code-library/Strings/Suffix Array Isomorphic.cpp	/^  static const int LG = 18;$/;"	m	struct:IsomorphicSuffixArray	typeref:typename:const int	file:
LG	code-library/Strings/Suffix Array Isomorphic.cpp	/^  static const int LG = 18;$/;"	m	struct:SuffixArray	typeref:typename:const int	file:
LG	code-library/Strings/Suffix Array.cpp	/^  static const int LG = 18;$/;"	m	struct:SuffixArray	typeref:typename:const int	file:
LG	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^const int LG = 17;$/;"	v	typeref:typename:const int
LG	code/Data Structures/HLD.cpp	/^const int N = 1e5 + 9, LG = 18, inf = 1e9 + 9;$/;"	v	typeref:typename:const int
LG	code/Data Structures/LCA.cpp	/^const int N = 3e5 + 9, LG = 18;$/;"	v	typeref:typename:const int
LG	code/Data Structures/Permutation Tree.cpp	/^const int N = 1e5 + 9, inf = 1e9 + 7, LG = 19;$/;"	v	typeref:typename:const int
LG	code/Data Structures/Reachability Tree.cpp	/^const int N = 1e5 + 9, LG = 18;$/;"	v	typeref:typename:const int
LG	code/Data Structures/Sparse Table 2D.cpp	/^const int N = 505, LG = 10;$/;"	v	typeref:typename:const int
LG	code/Graph Theory/LCA.cpp	/^const int N = 3e5 + 9, LG = 18;$/;"	v	typeref:typename:const int
LG	code/Strings/Suffix Array Isomorphic.cpp	/^  static const int LG = 18;$/;"	m	struct:IsomorphicSuffixArray	typeref:typename:const int	file:
LG	code/Strings/Suffix Array Isomorphic.cpp	/^  static const int LG = 18;$/;"	m	struct:SuffixArray	typeref:typename:const int	file:
LG	code/Strings/Suffix Array.cpp	/^  static const int LG = 18;$/;"	m	struct:SuffixArray	typeref:typename:const int	file:
LL	code-library/Miscellaneous/Parallel Binary Search.cpp	/^#define LL(/;"	d	file:
LL	code/Miscellaneous/Parallel Binary Search.cpp	/^#define LL(/;"	d	file:
LR_Flow	code-library/Graph Theory/L R Flow with Dinic.cpp	/^  LR_Flow() {}$/;"	f	struct:LR_Flow	file:
LR_Flow	code-library/Graph Theory/L R Flow with Dinic.cpp	/^  LR_Flow(int _n) {$/;"	f	struct:LR_Flow	file:
LR_Flow	code-library/Graph Theory/L R Flow with Dinic.cpp	/^struct LR_Flow {$/;"	s	file:
LR_Flow	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  LR_Flow() {}$/;"	f	struct:LR_Flow	file:
LR_Flow	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  LR_Flow(int _n) {$/;"	f	struct:LR_Flow	file:
LR_Flow	code-library/Graph Theory/L R Flow with MCMF.cpp	/^struct LR_Flow {$/;"	s	file:
LR_Flow	code/Graph Theory/L R Flow with Dinic.cpp	/^  LR_Flow() {}$/;"	f	struct:LR_Flow	file:
LR_Flow	code/Graph Theory/L R Flow with Dinic.cpp	/^  LR_Flow(int _n) {$/;"	f	struct:LR_Flow	file:
LR_Flow	code/Graph Theory/L R Flow with Dinic.cpp	/^struct LR_Flow {$/;"	s	file:
LR_Flow	code/Graph Theory/L R Flow with MCMF.cpp	/^  LR_Flow() {}$/;"	f	struct:LR_Flow	file:
LR_Flow	code/Graph Theory/L R Flow with MCMF.cpp	/^  LR_Flow(int _n) {$/;"	f	struct:LR_Flow	file:
LR_Flow	code/Graph Theory/L R Flow with MCMF.cpp	/^struct LR_Flow {$/;"	s	file:
LTE	code-library/Data Structures/Wavelet Tree.cpp	/^  int LTE(int l, int r, int k) {$/;"	f	struct:wavelet_tree	typeref:typename:int	file:
LTE	code-library/Strings/Number of Palindromes in Range.cpp	/^  int LTE(int l, int r, int k) {$/;"	f	struct:wavelet_tree	typeref:typename:int	file:
LTE	code/Data Structures/Wavelet Tree.cpp	/^  int LTE(int l, int r, int k) {$/;"	f	struct:wavelet_tree	typeref:typename:int	file:
LTE	code/Strings/Number of Palindromes in Range.cpp	/^  int LTE(int l, int r, int k) {$/;"	f	struct:wavelet_tree	typeref:typename:int	file:
Lagrange	code-library/Math/Characteristic Polynomial Faster.cpp	/^vector<mint> Lagrange(vector<mint> &x, vector<mint> &y) {$/;"	f	typeref:typename:vector<mint>
Lagrange	code-library/Math/Lagrange Interpolation Brute.cpp	/^vector<mint> Lagrange(vector<mint> &x, vector<mint> &y) {$/;"	f	typeref:typename:vector<mint>
Lagrange	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^vector<mint> Lagrange(vector<mint> &p) {$/;"	f	typeref:typename:vector<mint>
Lagrange	code-library/Math/Lagrange Interpolation.cpp	/^mint Lagrange(const vector<mint> &p, mint x, mint a = 0, mint d = 1) {$/;"	f	typeref:typename:mint
Lagrange	code-library/Math/Polynomial Sum.cpp	/^mint Lagrange(const vector<mint> &p, mint x, mint a = 0, mint d = 1) {$/;"	f	typeref:typename:mint
Lagrange	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^vector<mint> Lagrange(vector<mint> &x, vector<mint> &y) {$/;"	f	typeref:typename:vector<mint>
Lagrange	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^vector<mint> Lagrange(vector<mint> &x, vector<mint> &y) {$/;"	f	typeref:typename:vector<mint>
Lagrange	code/Math/Characteristic Polynomial Faster.cpp	/^vector<mint> Lagrange(vector<mint> &x, vector<mint> &y) {$/;"	f	typeref:typename:vector<mint>
Lagrange	code/Math/Lagrange Interpolation Brute.cpp	/^vector<mint> Lagrange(vector<mint> &x, vector<mint> &y) {$/;"	f	typeref:typename:vector<mint>
Lagrange	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^vector<mint> Lagrange(vector<mint> &p) {$/;"	f	typeref:typename:vector<mint>
Lagrange	code/Math/Lagrange Interpolation.cpp	/^mint Lagrange(const vector<mint> &p, mint x, mint a = 0, mint d = 1) {$/;"	f	typeref:typename:mint
Lagrange	code/Math/Polynomial Sum.cpp	/^mint Lagrange(const vector<mint> &p, mint x, mint a = 0, mint d = 1) {$/;"	f	typeref:typename:mint
Lagrange	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^vector<mint> Lagrange(vector<mint> &x, vector<mint> &y) {$/;"	f	typeref:typename:vector<mint>
Lagrange	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^vector<mint> Lagrange(vector<mint> &x, vector<mint> &y) {$/;"	f	typeref:typename:vector<mint>
LeftHull	code-library/Geometry/Onion Decomposition.cpp	/^    LeftHull(const vector<PT>& ps): ps(ps), nodes(ps.size() * 2), root(0) {$/;"	f	struct:LeftHull	file:
LeftHull	code-library/Geometry/Onion Decomposition.cpp	/^struct LeftHull {$/;"	s	file:
LeftHull	code/Geometry/Onion Decomposition.cpp	/^    LeftHull(const vector<PT>& ps): ps(ps), nodes(ps.size() * 2), root(0) {$/;"	f	struct:LeftHull	file:
LeftHull	code/Geometry/Onion Decomposition.cpp	/^struct LeftHull {$/;"	s	file:
Legendre	code-library/Number Theory/K Divisors.cpp	/^  long long Legendre(long long n) {$/;"	f	namespace:pcf	typeref:typename:long long
Legendre	code-library/Number Theory/Prime Counting Function.cpp	/^  long long Legendre(long long n) {$/;"	f	namespace:pcf	typeref:typename:long long
Legendre	code/Number Theory/K Divisors.cpp	/^  long long Legendre(long long n) {$/;"	f	namespace:pcf	typeref:typename:long long
Legendre	code/Number Theory/Prime Counting Function.cpp	/^  long long Legendre(long long n) {$/;"	f	namespace:pcf	typeref:typename:long long
Lehmer	code-library/Number Theory/K Divisors.cpp	/^  long long Lehmer(long long n) {$/;"	f	namespace:pcf	typeref:typename:long long
Lehmer	code-library/Number Theory/Prime Counting Function.cpp	/^  long long Lehmer(long long n) {$/;"	f	namespace:pcf	typeref:typename:long long
Lehmer	code/Number Theory/K Divisors.cpp	/^  long long Lehmer(long long n) {$/;"	f	namespace:pcf	typeref:typename:long long
Lehmer	code/Number Theory/Prime Counting Function.cpp	/^  long long Lehmer(long long n) {$/;"	f	namespace:pcf	typeref:typename:long long
LiChaoNode	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  LiChaoNode() {$/;"	f	struct:LiChaoNode	file:
LiChaoNode	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  LiChaoNode(Line line) : line(line), l(0), r(0) {}$/;"	f	struct:LiChaoNode	file:
LiChaoNode	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^struct LiChaoNode {$/;"	s	file:
LiChaoNode	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  LiChaoNode() {$/;"	f	struct:LiChaoNode	file:
LiChaoNode	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  LiChaoNode(Line line) : line(line), l(0), r(0) {}$/;"	f	struct:LiChaoNode	file:
LiChaoNode	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^struct LiChaoNode {$/;"	s	file:
LiChaoTree	code-library/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  LiChaoTree() : L(numeric_limits<int>::min() \/ 2), R(numeric_limits<int>::max() \/ 2), root(nu/;"	f	struct:LiChaoTree	file:
LiChaoTree	code-library/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  LiChaoTree(int L, int R) : L(L), R(R) {$/;"	f	struct:LiChaoTree	file:
LiChaoTree	code-library/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^struct LiChaoTree {$/;"	s	file:
LiChaoTree	code/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  LiChaoTree() : L(numeric_limits<int>::min() \/ 2), R(numeric_limits<int>::max() \/ 2), root(nu/;"	f	struct:LiChaoTree	file:
LiChaoTree	code/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  LiChaoTree(int L, int R) : L(L), R(R) {$/;"	f	struct:LiChaoTree	file:
LiChaoTree	code/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^struct LiChaoTree {$/;"	s	file:
Line	code-library/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^struct Line {$/;"	s	file:
Line	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^struct Line {$/;"	s	file:
Line	code/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^struct Line {$/;"	s	file:
Line	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^struct Line {$/;"	s	file:
LinearRecurrence	code-library/Math/BerleKamp Massey.cpp	/^mint LinearRecurrence(vector<mint> &S, vector<mint> &tr, long long k) {$/;"	f	typeref:typename:mint
LinearRecurrence	code-library/Math/Linear Recurrence Fastest.cpp	/^int LinearRecurrence(vector<int>& S, vector<int> &C, long long n) {$/;"	f	typeref:typename:int
LinearRecurrence	code-library/Math/Linear Recurrence.cpp	/^mint LinearRecurrence(vector<mint> &S, vector<mint> &tr, long long k) {$/;"	f	typeref:typename:mint
LinearRecurrence	code-library/Math/Reeds Sloane Algorithm.cpp	/^  LinearRecurrence(const vec &s, const vec &c, ll mod):$/;"	f	struct:LinearRecurrence	file:
LinearRecurrence	code-library/Math/Reeds Sloane Algorithm.cpp	/^  LinearRecurrence(const vec &s, ll mod, bool is_prime = true): mod(mod) {$/;"	f	struct:LinearRecurrence	file:
LinearRecurrence	code-library/Math/Reeds Sloane Algorithm.cpp	/^struct LinearRecurrence {$/;"	s	file:
LinearRecurrence	code/Math/BerleKamp Massey.cpp	/^mint LinearRecurrence(vector<mint> &S, vector<mint> &tr, long long k) {$/;"	f	typeref:typename:mint
LinearRecurrence	code/Math/Linear Recurrence Fastest.cpp	/^int LinearRecurrence(vector<int>& S, vector<int> &C, long long n) {$/;"	f	typeref:typename:int
LinearRecurrence	code/Math/Linear Recurrence.cpp	/^mint LinearRecurrence(vector<mint> &S, vector<mint> &tr, long long k) {$/;"	f	typeref:typename:mint
LinearRecurrence	code/Math/Reeds Sloane Algorithm.cpp	/^  LinearRecurrence(const vec &s, const vec &c, ll mod):$/;"	f	struct:LinearRecurrence	file:
LinearRecurrence	code/Math/Reeds Sloane Algorithm.cpp	/^  LinearRecurrence(const vec &s, ll mod, bool is_prime = true): mod(mod) {$/;"	f	struct:LinearRecurrence	file:
LinearRecurrence	code/Math/Reeds Sloane Algorithm.cpp	/^struct LinearRecurrence {$/;"	s	file:
Lx	code-library/Graph Theory/L R Flow with Dinic.cpp	/^int Lx[N], Rx[N], Ly[N], Ry[N], degx[N], degy[N];$/;"	v	typeref:typename:int[]
Lx	code/Graph Theory/L R Flow with Dinic.cpp	/^int Lx[N], Rx[N], Ly[N], Ry[N], degx[N], degy[N];$/;"	v	typeref:typename:int[]
Ly	code-library/Graph Theory/L R Flow with Dinic.cpp	/^int Lx[N], Rx[N], Ly[N], Ry[N], degx[N], degy[N];$/;"	v	typeref:typename:int[]
Ly	code/Graph Theory/L R Flow with Dinic.cpp	/^int Lx[N], Rx[N], Ly[N], Ry[N], degx[N], degy[N];$/;"	v	typeref:typename:int[]
M	code-library/Data Structures/BIT 2D with Range Update and Range Query.cpp	/^  long long M[N][N][2], A[N][N][2];$/;"	m	struct:BIT2D	typeref:typename:long long[][][2]	file:
M	code-library/Data Structures/BIT with Range Update and Range Query.cpp	/^  long long M[N], A[N];$/;"	m	struct:BIT	typeref:typename:long long[]	file:
M	code-library/Data Structures/Binarizing a Tree.cpp	/^const int N = 2e5 + 9, M = N * 2 + N * 19 * 2;$/;"	v	typeref:typename:const int
M	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^const int N = 2e5 + 9, M = N * 2 + N * 19 * 2;$/;"	v	typeref:typename:const int
M	code-library/Game Theory/Matching Game On A Graph.cpp	/^} M;$/;"	v	typeref:struct:Blossom
M	code-library/Graph Theory/Blossom Algorithm.cpp	/^} M;$/;"	v	typeref:struct:Blossom
M	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^const double M = 1e9;$/;"	v	typeref:typename:const double
M	code-library/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^const int M = 200010;$/;"	v	typeref:typename:const int
M	code-library/Graph Theory/Number of Different Cliques.cpp	/^const int M = 42;$/;"	v	typeref:typename:const int
M	code-library/Math/FWHT in Ternary Base.cpp	/^  const int M = 177147; \/\/3^BIT, it must be a power of 3$/;"	m	struct:FWHT	typeref:typename:const int	file:
M	code-library/Math/FWHT.cpp	/^#define M /;"	d	file:
M	code-library/Number Theory/K Divisors.cpp	/^const int M = 2020; \/\/ maximum number of divisors$/;"	v	typeref:typename:const int
M	code-library/Number Theory/Smallest Nonnegative Integer x s.t. l <= ax % p <= r.cpp	/^const long long M = 1LL * mod * (mod + 2);$/;"	v	typeref:typename:const long long
M	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^} M;$/;"	v	typeref:struct:Kuhn
M	code-library/Strings/Bit LCS.cpp	/^int M;$/;"	v	typeref:typename:int
M	code/Data Structures/BIT 2D with Range Update and Range Query.cpp	/^  long long M[N][N][2], A[N][N][2];$/;"	m	struct:BIT2D	typeref:typename:long long[][][2]	file:
M	code/Data Structures/BIT with Range Update and Range Query.cpp	/^  long long M[N], A[N];$/;"	m	struct:BIT	typeref:typename:long long[]	file:
M	code/Data Structures/Binarizing a Tree.cpp	/^const int N = 2e5 + 9, M = N * 2 + N * 19 * 2;$/;"	v	typeref:typename:const int
M	code/Data Structures/Centroid Decomposition Persistent.cpp	/^const int N = 2e5 + 9, M = N * 2 + N * 19 * 2;$/;"	v	typeref:typename:const int
M	code/Game Theory/Matching Game On A Graph.cpp	/^} M;$/;"	v	typeref:struct:Blossom
M	code/Graph Theory/Blossom Algorithm.cpp	/^} M;$/;"	v	typeref:struct:Blossom
M	code/Graph Theory/Maximum Density Subgraph.cpp	/^const double M = 1e9;$/;"	v	typeref:typename:const double
M	code/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^const int M = 200010;$/;"	v	typeref:typename:const int
M	code/Graph Theory/Number of Different Cliques.cpp	/^const int M = 42;$/;"	v	typeref:typename:const int
M	code/Math/FWHT in Ternary Base.cpp	/^  const int M = 177147; \/\/3^BIT, it must be a power of 3$/;"	m	struct:FWHT	typeref:typename:const int	file:
M	code/Math/FWHT.cpp	/^#define M /;"	d	file:
M	code/Number Theory/K Divisors.cpp	/^const int M = 2020; \/\/ maximum number of divisors$/;"	v	typeref:typename:const int
M	code/Number Theory/Smallest Nonnegative Integer x s.t. l <= ax % p <= r.cpp	/^const long long M = 1LL * mod * (mod + 2);$/;"	v	typeref:typename:const long long
M	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^} M;$/;"	v	typeref:struct:Kuhn
M	code/Strings/Bit LCS.cpp	/^int M;$/;"	v	typeref:typename:int
M	contests/Codeforces/737/C.cpp	/^const int M = (int)1000000007;$/;"	v	typeref:typename:const int
M	contests/LIT2021/C.cpp	/^int N, M;$/;"	v	typeref:typename:int
M	practice/cpbook/ch1/1.6/game/easier/10189/main.cpp	/^int N, M;$/;"	v	typeref:typename:int
M	practice/cpbook/ch1/1.6/reallife/medium/01091/ac.cpp	/^map<string, int> M;$/;"	v	typeref:typename:map<string,int>
M	practice/usacoguide/gold/bfs/milkpails.cpp	/^int X, Y, K, M; $/;"	v	typeref:typename:int
M	practice/usacoguide/gold/bfs/monsters.cpp	/^int N, M;$/;"	v	typeref:typename:int
MAXC	code-library/Math/Simplex Algorithm.cpp	/^#define MAXC /;"	d	file:
MAXC	code/Math/Simplex Algorithm.cpp	/^#define MAXC /;"	d	file:
MAXIMIZE	code-library/Math/Simplex Algorithm.cpp	/^#define MAXIMIZE /;"	d	file:
MAXIMIZE	code/Math/Simplex Algorithm.cpp	/^#define MAXIMIZE /;"	d	file:
MAXN	code-library/Data Structures/Wavelet Tree.cpp	/^const int MAXN = (int)3e5 + 9;$/;"	v	typeref:typename:const int
MAXN	code-library/Graph Theory/Dynamic MST.cpp	/^const int MAXN = 1e5 + 9;$/;"	v	typeref:typename:const int
MAXN	code-library/Math/Polynomial Factorization.cpp	/^const int MAXN = 1.1e5;$/;"	v	typeref:typename:const int
MAXN	code-library/Number Theory/K Divisors.cpp	/^  #define MAXN /;"	d	file:
MAXN	code-library/Number Theory/Prime Counting Function.cpp	/^  #define MAXN /;"	d	file:
MAXN	code-library/Strings/Number of Palindromes in Range.cpp	/^const int MAXN = (int)5100;$/;"	v	typeref:typename:const int
MAXN	code/Data Structures/Wavelet Tree.cpp	/^const int MAXN = (int)3e5 + 9;$/;"	v	typeref:typename:const int
MAXN	code/Graph Theory/Dynamic MST.cpp	/^const int MAXN = 1e5 + 9;$/;"	v	typeref:typename:const int
MAXN	code/Math/Polynomial Factorization.cpp	/^const int MAXN = 1.1e5;$/;"	v	typeref:typename:const int
MAXN	code/Number Theory/K Divisors.cpp	/^  #define MAXN /;"	d	file:
MAXN	code/Number Theory/Prime Counting Function.cpp	/^  #define MAXN /;"	d	file:
MAXN	code/Strings/Number of Palindromes in Range.cpp	/^const int MAXN = (int)5100;$/;"	v	typeref:typename:const int
MAXV	code-library/Data Structures/Wavelet Tree.cpp	/^const int MAXV = (int)1e9 + 9; \/\/maximum value of any element in array$/;"	v	typeref:typename:const int
MAXV	code-library/Math/Simplex Algorithm.cpp	/^#define MAXV /;"	d	file:
MAXV	code-library/Strings/Number of Palindromes in Range.cpp	/^const int MAXV = (int)5100;\/\/ maximum value of any element in array$/;"	v	typeref:typename:const int
MAXV	code/Data Structures/Wavelet Tree.cpp	/^const int MAXV = (int)1e9 + 9; \/\/maximum value of any element in array$/;"	v	typeref:typename:const int
MAXV	code/Math/Simplex Algorithm.cpp	/^#define MAXV /;"	d	file:
MAXV	code/Strings/Number of Palindromes in Range.cpp	/^const int MAXV = (int)5100;\/\/ maximum value of any element in array$/;"	v	typeref:typename:const int
MAX_PRIMES	code-library/Number Theory/K Divisors.cpp	/^  #define MAX_PRIMES /;"	d	file:
MAX_PRIMES	code-library/Number Theory/Prime Counting Function.cpp	/^  #define MAX_PRIMES /;"	d	file:
MAX_PRIMES	code/Number Theory/K Divisors.cpp	/^  #define MAX_PRIMES /;"	d	file:
MAX_PRIMES	code/Number Theory/Prime Counting Function.cpp	/^  #define MAX_PRIMES /;"	d	file:
MCMF	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  MCMF() {}$/;"	f	struct:MCMF	file:
MCMF	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  MCMF(int _n) { \/\/ 0-based indexing$/;"	f	struct:MCMF	file:
MCMF	code-library/Graph Theory/L R Flow with MCMF.cpp	/^struct MCMF {$/;"	s	file:
MCMF	code-library/Graph Theory/Min Cost Max Flow.cpp	/^  MCMF() {}$/;"	f	struct:MCMF	file:
MCMF	code-library/Graph Theory/Min Cost Max Flow.cpp	/^  MCMF(int _n) { \/\/ 0-based indexing$/;"	f	struct:MCMF	file:
MCMF	code-library/Graph Theory/Min Cost Max Flow.cpp	/^struct MCMF {$/;"	s	file:
MCMF	code/Graph Theory/L R Flow with MCMF.cpp	/^  MCMF() {}$/;"	f	struct:MCMF	file:
MCMF	code/Graph Theory/L R Flow with MCMF.cpp	/^  MCMF(int _n) { \/\/ 0-based indexing$/;"	f	struct:MCMF	file:
MCMF	code/Graph Theory/L R Flow with MCMF.cpp	/^struct MCMF {$/;"	s	file:
MCMF	code/Graph Theory/Min Cost Max Flow.cpp	/^  MCMF() {}$/;"	f	struct:MCMF	file:
MCMF	code/Graph Theory/Min Cost Max Flow.cpp	/^  MCMF(int _n) { \/\/ 0-based indexing$/;"	f	struct:MCMF	file:
MCMF	code/Graph Theory/Min Cost Max Flow.cpp	/^struct MCMF {$/;"	s	file:
MEX	code-library/Data Structures/MOs Online.cpp	/^  MEX() {$/;"	f	struct:MEX	file:
MEX	code-library/Data Structures/MOs Online.cpp	/^struct MEX {$/;"	s	file:
MEX	code/Data Structures/MOs Online.cpp	/^  MEX() {$/;"	f	struct:MEX	file:
MEX	code/Data Structures/MOs Online.cpp	/^struct MEX {$/;"	s	file:
MINIMIZE	code-library/Math/Simplex Algorithm.cpp	/^#define MINIMIZE /;"	d	file:
MINIMIZE	code/Math/Simplex Algorithm.cpp	/^#define MINIMIZE /;"	d	file:
MOD	code-library/Math/Polynomial Factorization.cpp	/^const int MOD = 998244353;$/;"	v	typeref:typename:const int
MOD	code-library/Miscellaneous/BigInt.cpp	/^const int MOD = 1e9 + 7;$/;"	v	typeref:typename:const int
MOD	code-library/Number Theory/Power Tower.cpp	/^inline ll MOD(ll x, ll m) {$/;"	f	typeref:typename:ll
MOD	code/Math/Polynomial Factorization.cpp	/^const int MOD = 998244353;$/;"	v	typeref:typename:const int
MOD	code/Miscellaneous/BigInt.cpp	/^const int MOD = 1e9 + 7;$/;"	v	typeref:typename:const int
MOD	code/Number Theory/Power Tower.cpp	/^inline ll MOD(ll x, ll m) {$/;"	f	typeref:typename:ll
MOD	contests/AtCoder/ABC211/C.cpp	/^const int MOD = 1e9 + 7;$/;"	v	typeref:typename:const int
MOD	contests/AtCoder/ABC211/D.cpp	/^const int mxN = 2e5 + 5, MOD = 1e9 + 7;$/;"	v	typeref:typename:const int
MOD	contests/LIT2021/D.cpp	/^const int MOD = 1e9 + 7;$/;"	v	typeref:typename:const int
MOD	practice/cf/DP/1091D.cpp	/^const int MOD = 998244353;$/;"	v	typeref:typename:const int
MOD	practice/cf/random/1700/6.cpp	/^int MOD = 5;$/;"	v	typeref:typename:int
MOD	practice/cf/random/i_hate_math_problems/1422C.cpp	/^const int MOD = 1e9 + 7;$/;"	v	typeref:typename:const int
MOD	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^const int MOD = 1e9 + 7;$/;"	v	typeref:typename:const int
MOD	practice/december2021/DP/counting_towers/sol.cpp	/^const int MOD = 1e9 + 7;$/;"	v	typeref:typename:const int
MOD	practice/usacoguide/gold/introDP/711C.cpp	/^const int MOD = 1e9 + 7;$/;"	v	typeref:typename:const int
MOD	practice/usacoguide/gold/introDP/arraydescription.cpp	/^const int MOD = 1e9 + 7;$/;"	v	typeref:typename:const int
MOD	practice/usacoguide/gold/introDP/gridpaths.cpp	/^const int mxN = 1005, MOD = 1e9 + 7;$/;"	v	typeref:typename:const int
MOD	practice/usacoguide/gold/modular/exponentiation.cpp	/^#define MOD /;"	d	file:
MOD	practice/usacoguide/gold/modular/santasbot.cpp	/^#define MOD /;"	d	file:
MOD	practice/usacoguide/gold/modular/test.cpp	/^#define MOD /;"	d	file:
MOD1	code-library/Strings/String Hashing.cpp	/^const int MOD1 = 127657753, MOD2 = 987654319;$/;"	v	typeref:typename:const int
MOD1	code/Strings/String Hashing.cpp	/^const int MOD1 = 127657753, MOD2 = 987654319;$/;"	v	typeref:typename:const int
MOD2	code-library/Strings/String Hashing.cpp	/^const int MOD1 = 127657753, MOD2 = 987654319;$/;"	v	typeref:typename:const int
MOD2	code/Strings/String Hashing.cpp	/^const int MOD1 = 127657753, MOD2 = 987654319;$/;"	v	typeref:typename:const int
MOD_value	code/modint.hpp	/^    static const int MOD_value = MOD;$/;"	m	struct:Mint	typeref:typename:const int
MOD_value	practice/december2021/DP/counting_towers/sol.cpp	/^    static const int MOD_value = MOD;$/;"	m	struct:Modular	typeref:typename:const int	file:
MST	code-library/Graph Theory/Steiner Tree Problem.cpp	/^long long MST() {$/;"	f	typeref:typename:long long
MST	code/Graph Theory/Steiner Tree Problem.cpp	/^long long MST() {$/;"	f	typeref:typename:long long
MXK	code-library/Math/FWHT in Any Base.cpp	/^  const int MXK = 10; \/\/(mod - 1) should be divisible by each base$/;"	v	namespace:FWHT	typeref:typename:const int
MXK	code/Math/FWHT in Any Base.cpp	/^  const int MXK = 10; \/\/(mod - 1) should be divisible by each base$/;"	v	namespace:FWHT	typeref:typename:const int
Manhattan	code-library/Graph Theory/Manhattan MST.cpp	/^void Manhattan() {$/;"	f	typeref:typename:void
Manhattan	code/Graph Theory/Manhattan MST.cpp	/^void Manhattan() {$/;"	f	typeref:typename:void
Mat	code-library/Math/Determinant of Sparse Matrix.cpp	/^  Mat() { }$/;"	f	struct:Mat	file:
Mat	code-library/Math/Determinant of Sparse Matrix.cpp	/^  Mat(int _n, int _m) {n = _n; m = _m; a.assign(n, vector<int>(m, 0)); }$/;"	f	struct:Mat	file:
Mat	code-library/Math/Determinant of Sparse Matrix.cpp	/^  Mat(vector< vector<int> > v) { n = v.size(); m = n ? v[0].size() : 0; a = v; }$/;"	f	struct:Mat	file:
Mat	code-library/Math/Determinant of Sparse Matrix.cpp	/^struct Mat {$/;"	s	file:
Mat	code-library/Math/Freivalds Algorithm.cpp	/^  Mat() { }$/;"	f	struct:Mat	file:
Mat	code-library/Math/Freivalds Algorithm.cpp	/^  Mat(int _n, int _m) {n = _n; m = _m; a.assign(n, vector<int>(m, 0)); }$/;"	f	struct:Mat	file:
Mat	code-library/Math/Freivalds Algorithm.cpp	/^  Mat(vector< vector<int> > v) { n = v.size(); m = n ? v[0].size() : 0; a = v; }$/;"	f	struct:Mat	file:
Mat	code-library/Math/Freivalds Algorithm.cpp	/^struct Mat {$/;"	s	file:
Mat	code-library/Math/Matrix Exponentiation.cpp	/^  Mat() { }$/;"	f	struct:Mat	file:
Mat	code-library/Math/Matrix Exponentiation.cpp	/^  Mat(int _n, int _m) {n = _n; m = _m; a.assign(n, vector<int>(m, 0)); }$/;"	f	struct:Mat	file:
Mat	code-library/Math/Matrix Exponentiation.cpp	/^  Mat(vector< vector<int> > v) { n = v.size(); m = n ? v[0].size() : 0; a = v; }$/;"	f	struct:Mat	file:
Mat	code-library/Math/Matrix Exponentiation.cpp	/^struct Mat {$/;"	s	file:
Mat	code/Math/Determinant of Sparse Matrix.cpp	/^  Mat() { }$/;"	f	struct:Mat	file:
Mat	code/Math/Determinant of Sparse Matrix.cpp	/^  Mat(int _n, int _m) {n = _n; m = _m; a.assign(n, vector<int>(m, 0)); }$/;"	f	struct:Mat	file:
Mat	code/Math/Determinant of Sparse Matrix.cpp	/^  Mat(vector< vector<int> > v) { n = v.size(); m = n ? v[0].size() : 0; a = v; }$/;"	f	struct:Mat	file:
Mat	code/Math/Determinant of Sparse Matrix.cpp	/^struct Mat {$/;"	s	file:
Mat	code/Math/Freivalds Algorithm.cpp	/^  Mat() { }$/;"	f	struct:Mat	file:
Mat	code/Math/Freivalds Algorithm.cpp	/^  Mat(int _n, int _m) {n = _n; m = _m; a.assign(n, vector<int>(m, 0)); }$/;"	f	struct:Mat	file:
Mat	code/Math/Freivalds Algorithm.cpp	/^  Mat(vector< vector<int> > v) { n = v.size(); m = n ? v[0].size() : 0; a = v; }$/;"	f	struct:Mat	file:
Mat	code/Math/Freivalds Algorithm.cpp	/^struct Mat {$/;"	s	file:
Mat	code/Math/Matrix Exponentiation.cpp	/^  Mat() { }$/;"	f	struct:Mat	file:
Mat	code/Math/Matrix Exponentiation.cpp	/^  Mat(int _n, int _m) {n = _n; m = _m; a.assign(n, vector<int>(m, 0)); }$/;"	f	struct:Mat	file:
Mat	code/Math/Matrix Exponentiation.cpp	/^  Mat(vector< vector<int> > v) { n = v.size(); m = n ? v[0].size() : 0; a = v; }$/;"	f	struct:Mat	file:
Mat	code/Math/Matrix Exponentiation.cpp	/^struct Mat {$/;"	s	file:
Matrix	code-library/Math/FWHT in Any Base.cpp	/^    Matrix(int n, int m) : n(n), m(m) { }$/;"	f	struct:FWHT::Matrix	file:
Matrix	code-library/Math/FWHT in Any Base.cpp	/^  struct Matrix {$/;"	s	namespace:FWHT	file:
Matrix	code/Math/FWHT in Any Base.cpp	/^    Matrix(int n, int m) : n(n), m(m) { }$/;"	f	struct:FWHT::Matrix	file:
Matrix	code/Math/FWHT in Any Base.cpp	/^  struct Matrix {$/;"	s	namespace:FWHT	file:
MatrixRecurrence	code-library/Math/Determinant of Sparse Matrix.cpp	/^vector<mint> MatrixRecurrence(int n, vector<Elem> M) {$/;"	f	typeref:typename:vector<mint>
MatrixRecurrence	code/Math/Determinant of Sparse Matrix.cpp	/^vector<mint> MatrixRecurrence(int n, vector<Elem> M) {$/;"	f	typeref:typename:vector<mint>
MaximumClosure	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  MaximumClosure() {}$/;"	f	struct:MaximumClosure	file:
MaximumClosure	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  MaximumClosure(int _n) {$/;"	f	struct:MaximumClosure	file:
MaximumClosure	code-library/Graph Theory/Maximum Closure Problem.cpp	/^struct MaximumClosure { \/\/answer could be an empty set and could be disconnected$/;"	s	file:
MaximumClosure	code/Graph Theory/Maximum Closure Problem.cpp	/^  MaximumClosure() {}$/;"	f	struct:MaximumClosure	file:
MaximumClosure	code/Graph Theory/Maximum Closure Problem.cpp	/^  MaximumClosure(int _n) {$/;"	f	struct:MaximumClosure	file:
MaximumClosure	code/Graph Theory/Maximum Closure Problem.cpp	/^struct MaximumClosure { \/\/answer could be an empty set and could be disconnected$/;"	s	file:
Mint	code-library/Number Theory/Prime Factorization Fastest.cpp	/^  Mint() : n(0) { }$/;"	f	struct:Mint	file:
Mint	code-library/Number Theory/Prime Factorization Fastest.cpp	/^  Mint(const uint64_t &x) : n(init(x)) { }$/;"	f	struct:Mint	file:
Mint	code-library/Number Theory/Prime Factorization Fastest.cpp	/^struct Mint {$/;"	s	file:
Mint	code/Number Theory/Prime Factorization Fastest.cpp	/^  Mint() : n(0) { }$/;"	f	struct:Mint	file:
Mint	code/Number Theory/Prime Factorization Fastest.cpp	/^  Mint(const uint64_t &x) : n(init(x)) { }$/;"	f	struct:Mint	file:
Mint	code/Number Theory/Prime Factorization Fastest.cpp	/^struct Mint {$/;"	s	file:
Mint	code/modint.hpp	/^    Mint(long long a, long long b) : value(0){ *this += a; *this \/= b;}$/;"	f	struct:Mint
Mint	code/modint.hpp	/^    Mint(long long v = 0) { value = v % MOD; if (value < 0) value += MOD;}$/;"	f	struct:Mint
Mint	code/modint.hpp	/^struct Mint {$/;"	s
Mod	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  Mod() {}$/;"	f	class:ntt::Mod	file:
Mod	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  Mod(word_t n) : x(init(n)) {};$/;"	f	class:ntt::Mod	file:
Mod	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^class Mod {$/;"	c	namespace:ntt	file:
Mod	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  Mod() {}$/;"	f	class:ntt::Mod	file:
Mod	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  Mod(word_t n) : x(init(n)) {};$/;"	f	class:ntt::Mod	file:
Mod	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^class Mod {$/;"	c	namespace:ntt	file:
Modular	practice/december2021/DP/counting_towers/sol.cpp	/^    Modular(long long a, long long b) : value(0){ *this += a; *this \/= b;}$/;"	f	struct:Modular	file:
Modular	practice/december2021/DP/counting_towers/sol.cpp	/^    Modular(long long v = 0) { value = v % MOD; if (value < 0) value += MOD;}$/;"	f	struct:Modular	file:
Modular	practice/december2021/DP/counting_towers/sol.cpp	/^struct Modular {$/;"	s	file:
N	code-library/Data Structures/Augmented DSU.cpp	/^const int N = 10000;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/BIT 2D with Range Update and Range Query.cpp	/^const int N = 1010;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/BIT with Range Update and Range Query.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/BIT.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/BST using STL.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Binarizing a Tree.cpp	/^const int N = 2e5 + 9, M = N * 2 + N * 19 * 2;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Cartesian Tree.cpp	/^const int N = 1e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^const int N = 2e5 + 9, M = N * 2 + N * 19 * 2;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Centroid Decomposition.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/DSU Partially Persistent.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/DSU on Tree.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/DSU with Rollbacks.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/DSU.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Disjoint Sparse Table.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Dynamic Diameter Online.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^const int N = 1e5 + 9, mod = 1e9 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/HLD.cpp	/^const int N = 1e5 + 9, LG = 18, inf = 1e9 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Implicit Treap.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/KD Tree.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/LCA.cpp	/^const int N = 3e5 + 9, LG = 18;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Link Cut Tree.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/MOs Algorithm.cpp	/^const int N = 1e6 + 9, B = 440;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/MOs Online.cpp	/^const int N = 1e5 + 1, B = 4500, C = N \/ B + 1;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/MOs on tree.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/MOs with DSU.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/MOs with Update.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Monotonous Queue.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Permutation Tree.cpp	/^const int N = 1e5 + 9, inf = 1e9 + 7, LG = 19;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Persistent Trie.cpp	/^const int N = 1e5 + 100;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Persistent UnionFind.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Queue Undo Trick.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Reachability Tree.cpp	/^const int N = 1e5 + 9, LG = 18;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Segment Tree Beats.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Segment Tree Lazy.cpp	/^const int N = 5e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Segment Tree Merging.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Segment Tree NonRecursive.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^const int N = 1e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Segment Tree Persistent.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^const int N = 1010, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Segment Tree.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Sparse Table 2D.cpp	/^const int N = 505, LG = 10;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Sparse Table.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^const int N = 1e5 + 9, B = 330;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Static to Dynamic Trick.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Treap persistent.cpp	/^const int N = 5e4 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Treap.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Data Structures/Trie.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Dynamic Programming Optimizations/1D1D DP.cpp	/^const int N = 1e4 + 9;$/;"	v	typeref:typename:const int
N	code-library/Dynamic Programming Optimizations/Connected Component DP.cpp	/^const int N = 105, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Dynamic Programming Optimizations/DP Over Divisors.cpp	/^const int N = 3e3 + 9;$/;"	v	typeref:typename:const int
N	code-library/Dynamic Programming Optimizations/Digit DP.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Dynamic Programming Optimizations/Divide and Conquer Optimization.cpp	/^const int N = 4010;$/;"	v	typeref:typename:const int
N	code-library/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Dynamic Programming Optimizations/Dynamic Submask Count.cpp	/^const int N = (1 << 16) + 9;$/;"	v	typeref:typename:const int
N	code-library/Dynamic Programming Optimizations/Knuth Optimization.cpp	/^const int N = 1010;$/;"	v	typeref:typename:const int
N	code-library/Dynamic Programming Optimizations/Number of Subsequences Having Product at least K.cpp	/^const int N = 1010, mod = 1e9 + 7, SQ = sqrt(mod) + 1;$/;"	v	typeref:typename:const int
N	code-library/Dynamic Programming Optimizations/Persistent CHT.cpp	/^  const static int N = 1e6 + 6;$/;"	m	struct:PersistentCHT	typeref:typename:const int	file:
N	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Dynamic Programming Optimizations/SOS convolutions.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code-library/Dynamic Programming Optimizations/Subset Sum in SQRT.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Dynamic Programming Optimizations/Subset Union of Bitsets.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Dynamic Programming Optimizations/XOR Equation.cpp	/^const int N = 55, mod = 1000000003;$/;"	v	typeref:typename:const int
N	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^const int N = 303, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Game Theory/Blue Red Hackenbush.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Game Theory/Green Hackenbush.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Game Theory/Matching Game On A Graph.cpp	/^const int N = 2e3 + 9;$/;"	v	typeref:typename:const int
N	code-library/Geometry/All Pair Segment Intersection.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Geometry/Closest Pair of Points.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Geometry/Convec Hull Dynamic.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Geometry/Delaunay Triangulation.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Geometry/Geometry 2D.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Geometry/Maximum Area of Triangle, Given are Lengths.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Geometry/Onion Decomposition.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Geometry/Point Location.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Geometry/Voronoi Diagram.cpp	/^const int N = 3e4 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/2 SAT.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/3 CYCLE and 4 CYCLE.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/3 SAT.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Articulation Points.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Bellman Ford.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Block Cut Tree.cpp	/^const int N = 4e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^const int N = 405;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Blossom Algorithm.cpp	/^const int N = 2e3 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Boruvka's Algorithm.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Chinese Postman Problem.cpp	/^const int N = 105;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Chordal Graph.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^const int N = 210;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Cycle Detection.cpp	/^const int N = 5e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/DAG Reachability Dynamic.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Dijkstra on Segment Tree.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Dijkstra.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Dinics Algorithm.cpp	/^const int N = 5010;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Directed MST.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Dominator Tree.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^const int N = 5002;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Edge Coloring Simple Graph.cpp	/^const int N = 2e3 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Euler Path Directed.cpp	/^const int N = 4e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Euler Path Undirected.cpp	/^const int N = 420;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Floyd Warshall.cpp	/^const int N = 105;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^const int N = 200005;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Gomory Hu Tree.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/HopCroft Karp Algorithm.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Hungarian Algorithm.cpp	/^const int N = 509;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Inverse Graph.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Johnson's Algorithm.cpp	/^const int N = 1010;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Kirchoffs Theorem.cpp	/^const int N = 205, mod = 1000210433;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Krushkal's MST.cpp	/^const int N = 3e5 + 9, mod = 1e9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Kuhns Algorithm.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/L R Flow with Dinic.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/L R Flow with MCMF.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/LCA.cpp	/^const int N = 3e5 + 9, LG = 18;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Manhattan MST.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Maximum Clique.cpp	/^const int N = 42;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Maximum Closure Problem.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^const int N = 1010;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Maximum Independant Set.cpp	/^const int N = 42;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  int N, S, T;$/;"	m	struct:mcSFlow	typeref:typename:int	file:
N	code-library/Graph Theory/Min Cost Max Flow.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Min Cut in a Planar Graph.cpp	/^const int N = 3e6 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^const int N = 505;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Minimum Mean Weight Cycle.cpp	/^const int N = 26 * 27;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Minimum Weight Cycle For Each Edge.cpp	/^const int N = 205, inf = 1e9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Minimum Weight Cycle For Each Vertex.cpp	/^const int N = 305, inf = 1e9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Number of Arborescence.cpp	/^const int N = 1e3 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Number of DAG.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Online Articulation Bridges.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Path Intersection.cpp	/^const int N = 1e4 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Path Union.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Prim's MST.cpp	/^const int N = 2020;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Prufer Code.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Randomized Matching Unweighted.cpp	/^const int N = 510;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Randomized Matching Weighted.cpp	/^const int N = 405;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/SCC.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/SPFA.cpp	/^const int N = 5050;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/ST Numbering.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Stable Marriage Problem.cpp	/^const int N = 1010;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Steiner Tree Problem.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Stoer Wagner Algorithm.cpp	/^const int N = 155;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/System Of Difference Constraints.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Three Edge Connectivity.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Tree Isomorphism.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 97;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Tree Orientation.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Tuttes Theorem.cpp	/^const int N = 105;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Unique Min Cut.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Graph Theory/Virtual Tree.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Math/All Possible Perfect Matching XOR Values.cpp	/^const int N = 1030;$/;"	v	typeref:typename:const int
N	code-library/Math/Basis Vector Reduced Row Echelon Form.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Math/Basis Vector.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Math/BerleKamp Massey.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Math/Characteristic Polynomial Faster.cpp	/^const int N = 505, mod = 998244353;$/;"	v	typeref:typename:const int
N	code-library/Math/Determinant of Sparse Matrix.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code-library/Math/Determinant under Composite Modulo.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Math/Determinant under Prime Modulo.cpp	/^const int N = 105, mod = 998244353;$/;"	v	typeref:typename:const int
N	code-library/Math/Determinant.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Math/FFT.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Math/FWHT in Any Base.cpp	/^const int N = 1e5 + 9, mod = 330301441;$/;"	v	typeref:typename:const int
N	code-library/Math/FWHT in Ternary Base.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Math/FWHT.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Math/Faulhaber Formula Fastest.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Math/Finite Field Arithmetic Binary.cpp	/^const int N = 44;$/;"	v	typeref:typename:const int
N	code-library/Math/Freivalds Algorithm.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Math/Gaussian Elimination Modular.cpp	/^const int N = 105, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Math/Gaussian Elimination Modulo 2.cpp	/^const int N = 2010;$/;"	v	typeref:typename:const int
N	code-library/Math/Gaussian Elimination.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^const int N = 3e3 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code-library/Math/Hafnian of a Matrix.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code-library/Math/Inverse of A Matrix modulo 2.cpp	/^const int N = 2005;$/;"	v	typeref:typename:const int
N	code-library/Math/Inverse of A Matrix.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Math/Lagrange Interpolation Brute.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^const int N = 1e6 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Math/Lagrange Interpolation.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Math/Lagrange Multiplier.cpp	/^const int N = 1010;$/;"	v	typeref:typename:const int
N	code-library/Math/Linear Recurrence Fastest.cpp	/^const int N = 3e5 + 9, mod = 104857601;$/;"	v	typeref:typename:const int
N	code-library/Math/Linear Recurrence With Polynomial Coefficients.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Math/Linear Recurrence.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Math/NTT Online.cpp	/^const int N = 1e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Math/NTT With Any Prime MOD.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code-library/Math/NTT.cpp	/^const int N = 1 << 18;$/;"	v	typeref:typename:const int
N	code-library/Math/Permanent of a Matrix.cpp	/^const int N = 20;$/;"	v	typeref:typename:const int
N	code-library/Math/Polynomial Sum.cpp	/^const int N = 1e7 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code-library/Math/Polynomial with Binomial Coefficients.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code-library/Math/Polynomial.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code-library/Math/Simplex Algorithm.cpp	/^const int N=510;$/;"	v	typeref:typename:const int
N	code-library/Math/Subset Sum Problem.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code-library/Math/The Slime Trick.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code-library/Math/Thomas Algorithm.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code-library/Math/Vandermonde Matrix.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Miscellaneous/Bitset Custom.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Miscellaneous/K-th Root of a Permutation.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Miscellaneous/MEX of all Subarrays.cpp	/^const int N = 1e5 + 9, inf = 1e9;$/;"	v	typeref:typename:const int
N	code-library/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^const int N = 6010;$/;"	v	typeref:typename:const int
N	code-library/Miscellaneous/Parallel Binary Search.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Miscellaneous/Subset Union of Bitsets.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Miscellaneous/XOR Equation Arbitrary Range.cpp	/^const int N = 55, mod = 1000000003;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/Bell Number.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/Combinatorics Basics.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/Dirichlet Convolution.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^const int N = 25, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/LCM of Fibonacci Numbers.cpp	/^const int N = 3e5 + 9, mod= 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/Linear Sieve for Multiplicative Functions.cpp	/^const int N = 1e7 + 9;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/Lucas Theorem.cpp	/^const int N = 1e6 + 3, mod = 1e6 + 3;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/Maximum Coprime Product.cpp	/^const int N = 1e5;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/Min_25 Sieve.cpp	/^const int N = 2e5 + 9, D = 3; \/\/ N >= 2 * sqrt(n)$/;"	v	typeref:typename:const int
N	code-library/Number Theory/Mobius Function.cpp	/^const int N = 5e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^const int N = 1e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/Phi Function.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/Power Tower.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^const int N = 1e5 + 9, B = 330, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/Prime Counting Function.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/Prime Number System.cpp	/^const int N = 1e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/Sieve.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/Smallest Nonnegative Integer x s.t. l <= ax % p <= r.cpp	/^const int N = 1e9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/Smallest Number Having Exactly K Divisors.cpp	/^const int N = 1e6 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^const int N = 1 << 18;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^const int N = 1 << 18;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^const int N = 1 << 18;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/Sum of Arithmetic Progression Modular and Divided.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^const int N = 25, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^const int N = 2e5 + 9, mod = 924844033;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^const int N = 1 << 16;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/Tonelli Shanks Algorithm.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Number Theory/nCr Modulo Any Mod.cpp	/^const int N = 1e6 + 9;$/;"	v	typeref:typename:const int
N	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^const int N = 755, L = 1e7 + 9;$/;"	v	typeref:typename:const int
N	code-library/Strings/Aho Corasick Dynamic.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Strings/Aho Corasick.cpp	/^  int N, P;$/;"	m	struct:AC	typeref:typename:int	file:
N	code-library/Strings/Aho Corasick.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Strings/All Substring Longest Common Subsequence.cpp	/^const int N = 2002;$/;"	v	typeref:typename:const int
N	code-library/Strings/Bit LCS.cpp	/^const int N = 5e4 + 9, SIGMA = 26;$/;"	v	typeref:typename:const int
N	code-library/Strings/Cyclic LCS.cpp	/^const int N = 2010;$/;"	v	typeref:typename:const int
N	code-library/Strings/De Bruijn Sequence.cpp	/^const int N = 3e5 + 9; \/\/ >= k^n$/;"	v	typeref:typename:const int
N	code-library/Strings/KMP.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Strings/Number of Palindromes in Range.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Strings/Palindromic Tree Persistent.cpp	/^const int N = 1e6 + 9;$/;"	v	typeref:typename:const int
N	code-library/Strings/Palindromic Tree.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Strings/Prefix Automaton.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Strings/String Hashing 2D.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Strings/String Hashing.cpp	/^const int N = 1e6 + 9;$/;"	v	typeref:typename:const int
N	code-library/Strings/String Matching With FFT.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Strings/String Matching using Bitsets.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Strings/Suffix Array Isomorphic.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Strings/Suffix Array.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code-library/Strings/Suffix Automaton.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/Augmented DSU.cpp	/^const int N = 10000;$/;"	v	typeref:typename:const int
N	code/Data Structures/BIT 2D with Range Update and Range Query.cpp	/^const int N = 1010;$/;"	v	typeref:typename:const int
N	code/Data Structures/BIT with Range Update and Range Query.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/BIT.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/BST using STL.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/Binarizing a Tree.cpp	/^const int N = 2e5 + 9, M = N * 2 + N * 19 * 2;$/;"	v	typeref:typename:const int
N	code/Data Structures/Cartesian Tree.cpp	/^const int N = 1e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Data Structures/Centroid Decomposition Persistent.cpp	/^const int N = 2e5 + 9, M = N * 2 + N * 19 * 2;$/;"	v	typeref:typename:const int
N	code/Data Structures/Centroid Decomposition.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/DSU Partially Persistent.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/DSU on Tree.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/DSU with Rollbacks.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/DSU.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/Disjoint Sparse Table.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/Dynamic Connectivity Problem.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/Dynamic Diameter Online.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^const int N = 1e5 + 9, mod = 1e9 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/HLD.cpp	/^const int N = 1e5 + 9, LG = 18, inf = 1e9 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/Implicit Treap.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/KD Tree.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/LCA.cpp	/^const int N = 3e5 + 9, LG = 18;$/;"	v	typeref:typename:const int
N	code/Data Structures/Link Cut Tree.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/MOs Algorithm.cpp	/^const int N = 1e6 + 9, B = 440;$/;"	v	typeref:typename:const int
N	code/Data Structures/MOs Online.cpp	/^const int N = 1e5 + 1, B = 4500, C = N \/ B + 1;$/;"	v	typeref:typename:const int
N	code/Data Structures/MOs on tree.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/MOs with DSU.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/MOs with Update.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/Monotonous Queue.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/Permutation Tree.cpp	/^const int N = 1e5 + 9, inf = 1e9 + 7, LG = 19;$/;"	v	typeref:typename:const int
N	code/Data Structures/Persistent Trie.cpp	/^const int N = 1e5 + 100;$/;"	v	typeref:typename:const int
N	code/Data Structures/Persistent UnionFind.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/Queue Undo Trick.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/Reachability Tree.cpp	/^const int N = 1e5 + 9, LG = 18;$/;"	v	typeref:typename:const int
N	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/Segment Tree Beats.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/Segment Tree Lazy.cpp	/^const int N = 5e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/Segment Tree Merging.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/Segment Tree NonRecursive.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^const int N = 1e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code/Data Structures/Segment Tree Persistent.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^const int N = 1010, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Data Structures/Segment Tree.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/Sparse Table 2D.cpp	/^const int N = 505, LG = 10;$/;"	v	typeref:typename:const int
N	code/Data Structures/Sparse Table.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^const int N = 1e5 + 9, B = 330;$/;"	v	typeref:typename:const int
N	code/Data Structures/Static to Dynamic Trick.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/Treap persistent.cpp	/^const int N = 5e4 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/Treap.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code/Data Structures/Trie.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Dynamic Programming Optimizations/1D1D DP.cpp	/^const int N = 1e4 + 9;$/;"	v	typeref:typename:const int
N	code/Dynamic Programming Optimizations/Connected Component DP.cpp	/^const int N = 105, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Dynamic Programming Optimizations/DP Over Divisors.cpp	/^const int N = 3e3 + 9;$/;"	v	typeref:typename:const int
N	code/Dynamic Programming Optimizations/Digit DP.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Dynamic Programming Optimizations/Divide and Conquer Optimization.cpp	/^const int N = 4010;$/;"	v	typeref:typename:const int
N	code/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Dynamic Programming Optimizations/Dynamic Submask Count.cpp	/^const int N = (1 << 16) + 9;$/;"	v	typeref:typename:const int
N	code/Dynamic Programming Optimizations/Knuth Optimization.cpp	/^const int N = 1010;$/;"	v	typeref:typename:const int
N	code/Dynamic Programming Optimizations/Number of Subsequences Having Product at least K.cpp	/^const int N = 1010, mod = 1e9 + 7, SQ = sqrt(mod) + 1;$/;"	v	typeref:typename:const int
N	code/Dynamic Programming Optimizations/Persistent CHT.cpp	/^  const static int N = 1e6 + 6;$/;"	m	struct:PersistentCHT	typeref:typename:const int	file:
N	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Dynamic Programming Optimizations/SOS convolutions.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code/Dynamic Programming Optimizations/Subset Sum in SQRT.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Dynamic Programming Optimizations/Subset Union of Bitsets.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code/Dynamic Programming Optimizations/XOR Equation.cpp	/^const int N = 55, mod = 1000000003;$/;"	v	typeref:typename:const int
N	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^const int N = 303, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Game Theory/Blue Red Hackenbush.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Game Theory/Green Hackenbush.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Game Theory/Matching Game On A Graph.cpp	/^const int N = 2e3 + 9;$/;"	v	typeref:typename:const int
N	code/Geometry/All Pair Segment Intersection.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Geometry/Closest Pair of Points.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Geometry/Convec Hull Dynamic.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Geometry/Delaunay Triangulation.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Geometry/Geometry 2D.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Geometry/Maximum Area of Triangle, Given are Lengths.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Geometry/Onion Decomposition.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Geometry/Point Location.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Geometry/Voronoi Diagram.cpp	/^const int N = 3e4 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/2 SAT.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/3 CYCLE and 4 CYCLE.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/3 SAT.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Articulation Points.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Bellman Ford.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Block Cut Tree.cpp	/^const int N = 4e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^const int N = 405;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Blossom Algorithm.cpp	/^const int N = 2e3 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Boruvka's Algorithm.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Chinese Postman Problem.cpp	/^const int N = 105;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Chordal Graph.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Chromatic Polynoimial.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Counting Labeled Graphs.cpp	/^const int N = 210;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Cycle Detection.cpp	/^const int N = 5e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/DAG Reachability Dynamic.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Dijkstra on Segment Tree.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Dijkstra.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Dinics Algorithm.cpp	/^const int N = 5010;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Directed MST.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Dominator Tree.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^const int N = 5002;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Edge Coloring Simple Graph.cpp	/^const int N = 2e3 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Euler Path Directed.cpp	/^const int N = 4e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Euler Path Undirected.cpp	/^const int N = 420;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Floyd Warshall.cpp	/^const int N = 105;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^const int N = 200005;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Gomory Hu Tree.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Hafnian of a Matrix.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code/Graph Theory/HopCroft Karp Algorithm.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Hungarian Algorithm.cpp	/^const int N = 509;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Inverse Graph.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Johnson's Algorithm.cpp	/^const int N = 1010;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Kirchoffs Theorem.cpp	/^const int N = 205, mod = 1000210433;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Krushkal's MST.cpp	/^const int N = 3e5 + 9, mod = 1e9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Kuhns Algorithm.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/L R Flow with Dinic.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/L R Flow with MCMF.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/LCA.cpp	/^const int N = 3e5 + 9, LG = 18;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Manhattan MST.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Maximum Clique.cpp	/^const int N = 42;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Maximum Closure Problem.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Maximum Density Subgraph.cpp	/^const int N = 1010;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Maximum Independant Set.cpp	/^const int N = 42;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  int N, S, T;$/;"	m	struct:mcSFlow	typeref:typename:int	file:
N	code/Graph Theory/Min Cost Max Flow.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Min Cut in a Planar Graph.cpp	/^const int N = 3e6 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^const int N = 505;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Minimum Mean Weight Cycle.cpp	/^const int N = 26 * 27;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Minimum Weight Cycle For Each Edge.cpp	/^const int N = 205, inf = 1e9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Minimum Weight Cycle For Each Vertex.cpp	/^const int N = 305, inf = 1e9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Number of Arborescence.cpp	/^const int N = 1e3 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Number of DAG.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Online Articulation Bridges.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Path Intersection.cpp	/^const int N = 1e4 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Path Union.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Prim's MST.cpp	/^const int N = 2020;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Prufer Code.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Randomized Matching Unweighted.cpp	/^const int N = 510;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Randomized Matching Weighted.cpp	/^const int N = 405;$/;"	v	typeref:typename:const int
N	code/Graph Theory/SCC.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/SPFA.cpp	/^const int N = 5050;$/;"	v	typeref:typename:const int
N	code/Graph Theory/ST Numbering.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Stable Marriage Problem.cpp	/^const int N = 1010;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Steiner Tree Problem.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Stoer Wagner Algorithm.cpp	/^const int N = 155;$/;"	v	typeref:typename:const int
N	code/Graph Theory/System Of Difference Constraints.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Three Edge Connectivity.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Tree Isomorphism.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 97;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Tree Orientation.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Tuttes Theorem.cpp	/^const int N = 105;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Unique Min Cut.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Graph Theory/Virtual Tree.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Math/All Possible Perfect Matching XOR Values.cpp	/^const int N = 1030;$/;"	v	typeref:typename:const int
N	code/Math/Basis Vector Reduced Row Echelon Form.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Math/Basis Vector.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Math/BerleKamp Massey.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Math/Characteristic Polynomial Faster.cpp	/^const int N = 505, mod = 998244353;$/;"	v	typeref:typename:const int
N	code/Math/Determinant of Sparse Matrix.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code/Math/Determinant under Composite Modulo.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Math/Determinant under Prime Modulo.cpp	/^const int N = 105, mod = 998244353;$/;"	v	typeref:typename:const int
N	code/Math/Determinant.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Math/FFT.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Math/FWHT in Any Base.cpp	/^const int N = 1e5 + 9, mod = 330301441;$/;"	v	typeref:typename:const int
N	code/Math/FWHT in Ternary Base.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Math/FWHT.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Math/Faulhaber Formula Fastest.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Math/Finite Field Arithmetic Binary.cpp	/^const int N = 44;$/;"	v	typeref:typename:const int
N	code/Math/Freivalds Algorithm.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Math/Gaussian Elimination Modular.cpp	/^const int N = 105, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Math/Gaussian Elimination Modulo 2.cpp	/^const int N = 2010;$/;"	v	typeref:typename:const int
N	code/Math/Gaussian Elimination.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Math/Generating Function of a Linear Recurrence.cpp	/^const int N = 3e3 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code/Math/Hafnian of a Matrix.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code/Math/Inverse of A Matrix modulo 2.cpp	/^const int N = 2005;$/;"	v	typeref:typename:const int
N	code/Math/Inverse of A Matrix.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Math/Lagrange Interpolation Brute.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^const int N = 1e6 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Math/Lagrange Interpolation.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Math/Lagrange Multiplier.cpp	/^const int N = 1010;$/;"	v	typeref:typename:const int
N	code/Math/Linear Recurrence Fastest.cpp	/^const int N = 3e5 + 9, mod = 104857601;$/;"	v	typeref:typename:const int
N	code/Math/Linear Recurrence With Polynomial Coefficients.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Math/Linear Recurrence.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Math/NTT Online.cpp	/^const int N = 1e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Math/NTT With Any Prime MOD.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code/Math/NTT.cpp	/^const int N = 1 << 18;$/;"	v	typeref:typename:const int
N	code/Math/Permanent of a Matrix.cpp	/^const int N = 20;$/;"	v	typeref:typename:const int
N	code/Math/Polynomial Sum.cpp	/^const int N = 1e7 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code/Math/Polynomial with Binomial Coefficients.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code/Math/Polynomial.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code/Math/Simplex Algorithm.cpp	/^const int N=510;$/;"	v	typeref:typename:const int
N	code/Math/Subset Sum Problem.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code/Math/The Slime Trick.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code/Math/Thomas Algorithm.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code/Math/Vandermonde Matrix.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Miscellaneous/Bitset Custom.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code/Miscellaneous/K-th Root of a Permutation.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Miscellaneous/MEX of all Subarrays.cpp	/^const int N = 1e5 + 9, inf = 1e9;$/;"	v	typeref:typename:const int
N	code/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^const int N = 6010;$/;"	v	typeref:typename:const int
N	code/Miscellaneous/Parallel Binary Search.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Miscellaneous/Subset Union of Bitsets.cpp	/^const int N = 2e5 + 9;$/;"	v	typeref:typename:const int
N	code/Miscellaneous/XOR Equation Arbitrary Range.cpp	/^const int N = 55, mod = 1000000003;$/;"	v	typeref:typename:const int
N	code/Number Theory/Bell Number.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Number Theory/Combinatorics Basics.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Number Theory/Dirichlet Convolution.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
N	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^const int N = 25, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Number Theory/LCM of Fibonacci Numbers.cpp	/^const int N = 3e5 + 9, mod= 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Number Theory/Linear Sieve for Multiplicative Functions.cpp	/^const int N = 1e7 + 9;$/;"	v	typeref:typename:const int
N	code/Number Theory/Lucas Theorem.cpp	/^const int N = 1e6 + 3, mod = 1e6 + 3;$/;"	v	typeref:typename:const int
N	code/Number Theory/Maximum Coprime Product.cpp	/^const int N = 1e5;$/;"	v	typeref:typename:const int
N	code/Number Theory/Min_25 Sieve.cpp	/^const int N = 2e5 + 9, D = 3; \/\/ N >= 2 * sqrt(n)$/;"	v	typeref:typename:const int
N	code/Number Theory/Mobius Function.cpp	/^const int N = 5e5 + 9;$/;"	v	typeref:typename:const int
N	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^const int N = 1e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Number Theory/Phi Function.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Number Theory/Power Tower.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^const int N = 1e5 + 9, B = 330, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Number Theory/Prime Counting Function.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Number Theory/Prime Number System.cpp	/^const int N = 1e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Number Theory/Sieve.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Number Theory/Smallest Nonnegative Integer x s.t. l <= ax % p <= r.cpp	/^const int N = 1e9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Number Theory/Smallest Number Having Exactly K Divisors.cpp	/^const int N = 1e6 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^const int N = 1 << 18;$/;"	v	typeref:typename:const int
N	code/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^const int N = 1 << 18;$/;"	v	typeref:typename:const int
N	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^const int N = 1 << 18;$/;"	v	typeref:typename:const int
N	code/Number Theory/Sum of Arithmetic Progression Modular and Divided.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^const int N = 25, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
N	code/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^const int N = 2e5 + 9, mod = 924844033;$/;"	v	typeref:typename:const int
N	code/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^const int N = 1 << 16;$/;"	v	typeref:typename:const int
N	code/Number Theory/Tonelli Shanks Algorithm.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Number Theory/nCr Modulo Any Mod.cpp	/^const int N = 1e6 + 9;$/;"	v	typeref:typename:const int
N	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^const int N = 755, L = 1e7 + 9;$/;"	v	typeref:typename:const int
N	code/Strings/Aho Corasick Dynamic.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Strings/Aho Corasick.cpp	/^  int N, P;$/;"	m	struct:AC	typeref:typename:int	file:
N	code/Strings/Aho Corasick.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Strings/All Substring Longest Common Subsequence.cpp	/^const int N = 2002;$/;"	v	typeref:typename:const int
N	code/Strings/Bit LCS.cpp	/^const int N = 5e4 + 9, SIGMA = 26;$/;"	v	typeref:typename:const int
N	code/Strings/Cyclic LCS.cpp	/^const int N = 2010;$/;"	v	typeref:typename:const int
N	code/Strings/De Bruijn Sequence.cpp	/^const int N = 3e5 + 9; \/\/ >= k^n$/;"	v	typeref:typename:const int
N	code/Strings/KMP.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Strings/Number of Palindromes in Range.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Strings/Palindromic Tree Persistent.cpp	/^const int N = 1e6 + 9;$/;"	v	typeref:typename:const int
N	code/Strings/Palindromic Tree.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Strings/Prefix Automaton.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Strings/String Hashing 2D.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Strings/String Hashing.cpp	/^const int N = 1e6 + 9;$/;"	v	typeref:typename:const int
N	code/Strings/String Matching With FFT.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Strings/String Matching using Bitsets.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Strings/Suffix Array Isomorphic.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Strings/Suffix Array.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^const int N = 1e5 + 9;$/;"	v	typeref:typename:const int
N	code/Strings/Suffix Automaton.cpp	/^const int N = 3e5 + 9;$/;"	v	typeref:typename:const int
N	contests/Codeforces/1609/B.cpp	/^int N, Q;$/;"	v	typeref:typename:int
N	contests/Codeforces/1622/C/sol.cpp	/^int N, K;$/;"	v	typeref:typename:int
N	contests/Codeforces/1622/C_new/sol.cpp	/^int N, K, sum = 0; $/;"	v	typeref:typename:int
N	contests/Codeforces/1623/new_C/sol.cpp	/^int N;$/;"	v	typeref:typename:int
N	contests/Codeforces/737/C.cpp	/^const int N = (int)998244353 ;$/;"	v	typeref:typename:const int
N	contests/LIT2021/C.cpp	/^int N, M;$/;"	v	typeref:typename:int
N	practice/cf/DP/knap2.cpp	/^const int N = 505;$/;"	v	typeref:typename:const int
N	practice/cf/random/1700/4.cpp	/^int N, K, X = 0;$/;"	v	typeref:typename:int
N	practice/cf/random/pink/main.cpp	/^int N;$/;"	v	typeref:typename:int
N	practice/club/prob3/solution_prob3.cpp	/^int N;$/;"	v	typeref:typename:int
N	practice/cpbook/ch1/1.6/game/easier/10189/main.cpp	/^int N, M;$/;"	v	typeref:typename:int
N	practice/cpbook/ch3/DP/10684.cpp	/^int N;$/;"	v	typeref:typename:int
N	practice/december2021/DP/removal_game/sol.cpp	/^int N;$/;"	v	typeref:typename:int
N	practice/usacoguide/gold/SP/flightdiscount.cpp	/^int N;$/;"	v	typeref:typename:int
N	practice/usacoguide/gold/SP/pump.cpp	/^int N;$/;"	v	typeref:typename:int
N	practice/usacoguide/gold/SP/visitfj.cpp	/^int N, TT;$/;"	v	typeref:typename:int
N	practice/usacoguide/gold/SP/visitfj/main.cpp	/^int N, TT;$/;"	v	typeref:typename:int
N	practice/usacoguide/gold/bfs/cownav.cpp	/^int N;$/;"	v	typeref:typename:int
N	practice/usacoguide/gold/bfs/mecho/main.cpp	/^int N, S; $/;"	v	typeref:typename:int
N	practice/usacoguide/gold/bfs/mechonew/main.cpp	/^int N, S; $/;"	v	typeref:typename:int
N	practice/usacoguide/gold/bfs/monsters.cpp	/^int N, M;$/;"	v	typeref:typename:int
N	practice/usacoguide/gold/divisibility/powerproducts.cpp	/^int N, K;$/;"	v	typeref:typename:int
N	practice/usacoguide/gold/dsu/tractor/main.cpp	/^int N;$/;"	v	typeref:typename:int
N	practice/usacoguide/gold/introDP/711C.cpp	/^const int N = 101;$/;"	v	typeref:typename:const int
N	practice/usacoguide/silver/binsearch/sabotage.cpp	/^int N, sum = 0;$/;"	v	typeref:typename:int
N	practice/usacoguide/silver/idk/maze/main.cpp	/^int N;$/;"	v	typeref:typename:int
NAME_PATTERN	.compilingScripts/download_prob.py	/^NAME_PATTERN = re.compile(r'^[A-Z][0-9]*\\b')$/;"	v
NTT64	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^#define NTT64$/;"	d	file:
NTT64	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^#define NTT64$/;"	d	file:
OR	code-library/Math/FWHT.cpp	/^#define OR /;"	d	file:
OR	code/Math/FWHT.cpp	/^#define OR /;"	d	file:
P	code-library/Data Structures/Permutation Tree.cpp	/^int P[N * 2][LG];$/;"	v	typeref:typename:int[][]
P	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^mint s[N], P = 37;$/;"	v	typeref:typename:mint
P	code-library/Geometry/Geometry 3D.cpp	/^    vector<p3> P;$/;"	m	struct:CH3D	typeref:typename:vector<p3>	file:
P	code-library/Geometry/Voronoi Diagram.cpp	/^    P() { x = 0, y = 0; }$/;"	f	struct:P	file:
P	code-library/Geometry/Voronoi Diagram.cpp	/^    P(const P &p) : x(p.x), y(p.y)    {}$/;"	f	struct:P	file:
P	code-library/Geometry/Voronoi Diagram.cpp	/^    P(long long x, long long y) : x(x), y(y) {}$/;"	f	struct:P	file:
P	code-library/Geometry/Voronoi Diagram.cpp	/^struct P {$/;"	s	file:
P	code-library/Graph Theory/Tree Isomorphism.cpp	/^const mint P = 998244353, Q = 1e9 + 33, R = 99999989;$/;"	v	typeref:typename:const mint
P	code-library/Math/Determinant of Cyclic Matrix.cpp	/^constexpr int P = 1000000007;$/;"	v	typeref:typename:int
P	code-library/Math/Determinant of Permutant Matrix.cpp	/^constexpr int P = 1000000007;$/;"	v	typeref:typename:int
P	code-library/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^  const int P = 1e6 + 9;$/;"	v	namespace:PollardRho	typeref:typename:const int
P	code-library/Number Theory/Pisano Period.cpp	/^  const int P = 1e6 + 9;$/;"	v	namespace:PollardRho	typeref:typename:const int
P	code-library/Number Theory/Pollard Rho.cpp	/^  const int P = 1e6 + 9;$/;"	v	namespace:PollardRho	typeref:typename:const int
P	code-library/Number Theory/Sieve upto 1e9.cpp	/^    P(int p) : p(p) {}$/;"	f	struct:sieve::P	file:
P	code-library/Number Theory/Sieve upto 1e9.cpp	/^  struct P { $/;"	s	function:sieve	file:
P	code-library/Strings/Aho Corasick.cpp	/^  int N, P;$/;"	m	struct:AC	typeref:typename:int	file:
P	code/Data Structures/Permutation Tree.cpp	/^int P[N * 2][LG];$/;"	v	typeref:typename:int[][]
P	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^mint s[N], P = 37;$/;"	v	typeref:typename:mint
P	code/Geometry/Geometry 3D.cpp	/^    vector<p3> P;$/;"	m	struct:CH3D	typeref:typename:vector<p3>	file:
P	code/Geometry/Voronoi Diagram.cpp	/^    P() { x = 0, y = 0; }$/;"	f	struct:P	file:
P	code/Geometry/Voronoi Diagram.cpp	/^    P(const P &p) : x(p.x), y(p.y)    {}$/;"	f	struct:P	file:
P	code/Geometry/Voronoi Diagram.cpp	/^    P(long long x, long long y) : x(x), y(y) {}$/;"	f	struct:P	file:
P	code/Geometry/Voronoi Diagram.cpp	/^struct P {$/;"	s	file:
P	code/Graph Theory/Tree Isomorphism.cpp	/^const mint P = 998244353, Q = 1e9 + 33, R = 99999989;$/;"	v	typeref:typename:const mint
P	code/Math/Determinant of Cyclic Matrix.cpp	/^constexpr int P = 1000000007;$/;"	v	typeref:typename:int
P	code/Math/Determinant of Permutant Matrix.cpp	/^constexpr int P = 1000000007;$/;"	v	typeref:typename:int
P	code/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^  const int P = 1e6 + 9;$/;"	v	namespace:PollardRho	typeref:typename:const int
P	code/Number Theory/Pisano Period.cpp	/^  const int P = 1e6 + 9;$/;"	v	namespace:PollardRho	typeref:typename:const int
P	code/Number Theory/Pollard Rho.cpp	/^  const int P = 1e6 + 9;$/;"	v	namespace:PollardRho	typeref:typename:const int
P	code/Number Theory/Sieve upto 1e9.cpp	/^    P(int p) : p(p) {}$/;"	f	struct:sieve::P	file:
P	code/Number Theory/Sieve upto 1e9.cpp	/^  struct P { $/;"	s	function:sieve	file:
P	code/Strings/Aho Corasick.cpp	/^  int N, P;$/;"	m	struct:AC	typeref:typename:int	file:
P	contests/LIT2021/C.cpp	/^struct P {$/;"	s	file:
P1	code-library/Math/FWHT.cpp	/^  int P1[M], P2[M];$/;"	m	struct:FWHT	typeref:typename:int[]	file:
P1	code/Math/FWHT.cpp	/^  int P1[M], P2[M];$/;"	m	struct:FWHT	typeref:typename:int[]	file:
P2	code-library/Math/FWHT.cpp	/^  int P1[M], P2[M];$/;"	m	struct:FWHT	typeref:typename:int[]	file:
P2	code/Math/FWHT.cpp	/^  int P1[M], P2[M];$/;"	m	struct:FWHT	typeref:typename:int[]	file:
PEO	code-library/Graph Theory/Chordal Graph.cpp	/^vector<int> PEO(int n) { \/\/ O(n + m)$/;"	f	typeref:typename:vector<int>
PEO	code/Graph Theory/Chordal Graph.cpp	/^vector<int> PEO(int n) { \/\/ O(n + m)$/;"	f	typeref:typename:vector<int>
PHI_K	code-library/Number Theory/K Divisors.cpp	/^  #define PHI_K /;"	d	file:
PHI_K	code-library/Number Theory/Prime Counting Function.cpp	/^  #define PHI_K /;"	d	file:
PHI_K	code/Number Theory/K Divisors.cpp	/^  #define PHI_K /;"	d	file:
PHI_K	code/Number Theory/Prime Counting Function.cpp	/^  #define PHI_K /;"	d	file:
PHI_N	code-library/Number Theory/K Divisors.cpp	/^  #define PHI_N /;"	d	file:
PHI_N	code-library/Number Theory/Prime Counting Function.cpp	/^  #define PHI_N /;"	d	file:
PHI_N	code/Number Theory/K Divisors.cpp	/^  #define PHI_N /;"	d	file:
PHI_N	code/Number Theory/Prime Counting Function.cpp	/^  #define PHI_N /;"	d	file:
PI	code-library/Data Structures/Centroid Decomposition.cpp	/^const double PI = acos(-1);$/;"	v	typeref:typename:const double
PI	code-library/Geometry/All Pair Segment Intersection.cpp	/^const double PI = acos(-1.0);$/;"	v	typeref:typename:const double
PI	code-library/Geometry/Geometry 2D.cpp	/^const double PI = acos((double)-1.0);$/;"	v	typeref:typename:const double
PI	code-library/Geometry/Geometry 3D.cpp	/^const double PI = acos((double)-1.0);$/;"	v	typeref:typename:const double
PI	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^const double PI = acos(-1.0);$/;"	v	typeref:typename:const double
PI	code-library/Geometry/Half Plane Intersection.cpp	/^const double PI = acos((double)-1.0);$/;"	v	typeref:typename:const double
PI	code-library/Geometry/Voronoi Diagram.cpp	/^const double PI = acos(-1.0);$/;"	v	typeref:typename:const double
PI	code-library/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^const double PI = acos(-1);$/;"	v	typeref:typename:const double
PI	code-library/Math/FFT.cpp	/^const double PI = acos(-1);$/;"	v	typeref:typename:const double
PI	code-library/Math/Faulhaber Formula Fastest.cpp	/^const double PI = acosl(- 1.0);$/;"	v	typeref:typename:const double
PI	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^const double PI = acosl(- 1.0);$/;"	v	typeref:typename:const double
PI	code-library/Math/Linear Recurrence Fastest.cpp	/^const double PI = acosl(- 1.0);$/;"	v	typeref:typename:const double
PI	code-library/Math/NTT Online.cpp	/^const double PI = acosl(- 1.0);$/;"	v	typeref:typename:const double
PI	code-library/Math/NTT With Any Prime MOD.cpp	/^const double PI = acosl(- 1.0);$/;"	v	typeref:typename:const double
PI	code-library/Math/Polynomial with Binomial Coefficients.cpp	/^const double PI = acosl(- 1.0);$/;"	v	typeref:typename:const double
PI	code-library/Math/Polynomial.cpp	/^const double PI = acosl(- 1.0);$/;"	v	typeref:typename:const double
PI	code-library/Math/Simplex Algorithm.cpp	/^const ld PI=acos(-1.0);$/;"	v	typeref:typename:const ld
PI	code-library/Math/Subset Sum Problem.cpp	/^const double PI = acosl(- 1.0);$/;"	v	typeref:typename:const double
PI	code-library/Miscellaneous/BigInt.cpp	/^const ld PI = acos(-1.L);$/;"	v	typeref:typename:const ld
PI	code-library/Number Theory/Bell Number.cpp	/^const double PI = acosl(- 1.0);$/;"	v	typeref:typename:const double
PI	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^const double PI = acosl(- 1.0);$/;"	v	typeref:typename:const double
PI	code-library/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^const double PI = acosl(- 1.0);$/;"	v	typeref:typename:const double
PI	code-library/Strings/String Matching With FFT.cpp	/^const double PI = acos(-1);$/;"	v	typeref:typename:const double
PI	code/Data Structures/Centroid Decomposition.cpp	/^const double PI = acos(-1);$/;"	v	typeref:typename:const double
PI	code/Geometry/All Pair Segment Intersection.cpp	/^const double PI = acos(-1.0);$/;"	v	typeref:typename:const double
PI	code/Geometry/Geometry 2D.cpp	/^const double PI = acos((double)-1.0);$/;"	v	typeref:typename:const double
PI	code/Geometry/Geometry 3D.cpp	/^const double PI = acos((double)-1.0);$/;"	v	typeref:typename:const double
PI	code/Geometry/Half Plane Intersection Dynamic.cpp	/^const double PI = acos(-1.0);$/;"	v	typeref:typename:const double
PI	code/Geometry/Half Plane Intersection.cpp	/^const double PI = acos((double)-1.0);$/;"	v	typeref:typename:const double
PI	code/Geometry/Voronoi Diagram.cpp	/^const double PI = acos(-1.0);$/;"	v	typeref:typename:const double
PI	code/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^const double PI = acos(-1);$/;"	v	typeref:typename:const double
PI	code/Math/FFT.cpp	/^const double PI = acos(-1);$/;"	v	typeref:typename:const double
PI	code/Math/Faulhaber Formula Fastest.cpp	/^const double PI = acosl(- 1.0);$/;"	v	typeref:typename:const double
PI	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^const double PI = acosl(- 1.0);$/;"	v	typeref:typename:const double
PI	code/Math/Linear Recurrence Fastest.cpp	/^const double PI = acosl(- 1.0);$/;"	v	typeref:typename:const double
PI	code/Math/NTT Online.cpp	/^const double PI = acosl(- 1.0);$/;"	v	typeref:typename:const double
PI	code/Math/NTT With Any Prime MOD.cpp	/^const double PI = acosl(- 1.0);$/;"	v	typeref:typename:const double
PI	code/Math/Polynomial with Binomial Coefficients.cpp	/^const double PI = acosl(- 1.0);$/;"	v	typeref:typename:const double
PI	code/Math/Polynomial.cpp	/^const double PI = acosl(- 1.0);$/;"	v	typeref:typename:const double
PI	code/Math/Simplex Algorithm.cpp	/^const ld PI=acos(-1.0);$/;"	v	typeref:typename:const ld
PI	code/Math/Subset Sum Problem.cpp	/^const double PI = acosl(- 1.0);$/;"	v	typeref:typename:const double
PI	code/Miscellaneous/BigInt.cpp	/^const ld PI = acos(-1.L);$/;"	v	typeref:typename:const ld
PI	code/Number Theory/Bell Number.cpp	/^const double PI = acosl(- 1.0);$/;"	v	typeref:typename:const double
PI	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^const double PI = acosl(- 1.0);$/;"	v	typeref:typename:const double
PI	code/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^const double PI = acosl(- 1.0);$/;"	v	typeref:typename:const double
PI	code/Strings/String Matching With FFT.cpp	/^const double PI = acos(-1);$/;"	v	typeref:typename:const double
POW	code-library/Math/FWHT in Any Base.cpp	/^int POW(long long n, long long k) {$/;"	f	typeref:typename:int
POW	code-library/Math/FWHT.cpp	/^int POW(long long n, long long k) {$/;"	f	typeref:typename:int
POW	code-library/Math/NTT.cpp	/^int POW(int x, int y, int ans = 1) {$/;"	f	typeref:typename:int
POW	code-library/Math/Polynomial with Binomial Coefficients.cpp	/^int POW(long long n, long long k) {$/;"	f	typeref:typename:int
POW	code-library/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^int POW(int x, int y, int ans = 1) {$/;"	f	typeref:typename:int
POW	code-library/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^int POW(int x, int y, int ans = 1) {$/;"	f	typeref:typename:int
POW	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^int POW(int x, int y, int ans = 1) {$/;"	f	typeref:typename:int
POW	code-library/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^int POW(int x, int y, int ans = 1) {$/;"	f	typeref:typename:int
POW	code/Math/FWHT in Any Base.cpp	/^int POW(long long n, long long k) {$/;"	f	typeref:typename:int
POW	code/Math/FWHT.cpp	/^int POW(long long n, long long k) {$/;"	f	typeref:typename:int
POW	code/Math/NTT.cpp	/^int POW(int x, int y, int ans = 1) {$/;"	f	typeref:typename:int
POW	code/Math/Polynomial with Binomial Coefficients.cpp	/^int POW(long long n, long long k) {$/;"	f	typeref:typename:int
POW	code/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^int POW(int x, int y, int ans = 1) {$/;"	f	typeref:typename:int
POW	code/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^int POW(int x, int y, int ans = 1) {$/;"	f	typeref:typename:int
POW	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^int POW(int x, int y, int ans = 1) {$/;"	f	typeref:typename:int
POW	code/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^int POW(int x, int y, int ans = 1) {$/;"	f	typeref:typename:int
PQ	code-library/Data Structures/Venice Technique.cpp	/^template<typename T> struct PQ {$/;"	s	file:
PQ	code-library/Graph Theory/Directed MST.cpp	/^template<typename T> struct PQ {$/;"	s	file:
PQ	code/Data Structures/Venice Technique.cpp	/^template<typename T> struct PQ {$/;"	s	file:
PQ	code/Graph Theory/Directed MST.cpp	/^template<typename T> struct PQ {$/;"	s	file:
PST	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^struct PST$/;"	s	file:
PST	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^struct PST {$/;"	s	file:
PST	code-library/Data Structures/Segment Tree Persistent.cpp	/^struct PST {$/;"	s	file:
PST	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^struct PST$/;"	s	file:
PST	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^struct PST {$/;"	s	file:
PST	code/Data Structures/Segment Tree Persistent.cpp	/^struct PST {$/;"	s	file:
PT	code-library/Dynamic Programming Optimizations/Persistent CHT.cpp	/^  PT(int x = 0, int y = 0): x(x), y(y) {}$/;"	f	struct:PT	file:
PT	code-library/Dynamic Programming Optimizations/Persistent CHT.cpp	/^struct PT {$/;"	s	file:
PT	code-library/Geometry/All Pair Segment Intersection.cpp	/^    PT() {$/;"	f	struct:PT	file:
PT	code-library/Geometry/All Pair Segment Intersection.cpp	/^    PT(const PT &p) : x(p.x), y(p.y)    {}$/;"	f	struct:PT	file:
PT	code-library/Geometry/All Pair Segment Intersection.cpp	/^    PT(double x, double y) : x(x), y(y) {}$/;"	f	struct:PT	file:
PT	code-library/Geometry/All Pair Segment Intersection.cpp	/^struct PT {$/;"	s	file:
PT	code-library/Geometry/Convec Hull Dynamic.cpp	/^    PT() : x(0), y(0) {}$/;"	f	struct:PT	file:
PT	code-library/Geometry/Convec Hull Dynamic.cpp	/^    PT(const PT& rhs) : x(rhs.x), y(rhs.y) {}$/;"	f	struct:PT	file:
PT	code-library/Geometry/Convec Hull Dynamic.cpp	/^    PT(const iter& p) : x(p->first), y(p->second) {}$/;"	f	struct:PT	file:
PT	code-library/Geometry/Convec Hull Dynamic.cpp	/^    PT(int x, int y) : x(x), y(y) {}$/;"	f	struct:PT	file:
PT	code-library/Geometry/Convec Hull Dynamic.cpp	/^struct PT {$/;"	s	file:
PT	code-library/Geometry/Delaunay Triangulation.cpp	/^    PT() { x = 0, y = 0; }$/;"	f	struct:PT	file:
PT	code-library/Geometry/Delaunay Triangulation.cpp	/^    PT(const PT &p) : x(p.x), y(p.y)    {}$/;"	f	struct:PT	file:
PT	code-library/Geometry/Delaunay Triangulation.cpp	/^    PT(long long x, long long y) : x(x), y(y) {}$/;"	f	struct:PT	file:
PT	code-library/Geometry/Delaunay Triangulation.cpp	/^struct PT {$/;"	s	file:
PT	code-library/Geometry/Geometry 2D.cpp	/^    PT() { x = 0, y = 0; }$/;"	f	struct:PT	file:
PT	code-library/Geometry/Geometry 2D.cpp	/^    PT(const PT &p) : x(p.x), y(p.y)    {}$/;"	f	struct:PT	file:
PT	code-library/Geometry/Geometry 2D.cpp	/^    PT(double x, double y) : x(x), y(y) {}$/;"	f	struct:PT	file:
PT	code-library/Geometry/Geometry 2D.cpp	/^struct PT {$/;"	s	file:
PT	code-library/Geometry/Geometry 3D.cpp	/^    PT() { x = 0, y = 0; }$/;"	f	struct:PT	file:
PT	code-library/Geometry/Geometry 3D.cpp	/^    PT(const PT &p) : x(p.x), y(p.y)    {}$/;"	f	struct:PT	file:
PT	code-library/Geometry/Geometry 3D.cpp	/^    PT(double x, double y) : x(x), y(y) {}$/;"	f	struct:PT	file:
PT	code-library/Geometry/Geometry 3D.cpp	/^struct PT {$/;"	s	file:
PT	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    PT() { x = 0, y = 0; }$/;"	f	struct:PT	file:
PT	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    PT(const PT &p) : x(p.x), y(p.y)    {}$/;"	f	struct:PT	file:
PT	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    PT(double x, double y) : x(x), y(y) {}$/;"	f	struct:PT	file:
PT	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^struct PT {$/;"	s	file:
PT	code-library/Geometry/Half Plane Intersection.cpp	/^    PT() { x = 0, y = 0; }$/;"	f	struct:PT	file:
PT	code-library/Geometry/Half Plane Intersection.cpp	/^    PT(const PT &p) : x(p.x), y(p.y)    {}$/;"	f	struct:PT	file:
PT	code-library/Geometry/Half Plane Intersection.cpp	/^    PT(double x, double y) : x(x), y(y) {}$/;"	f	struct:PT	file:
PT	code-library/Geometry/Half Plane Intersection.cpp	/^struct PT {$/;"	s	file:
PT	code-library/Geometry/Onion Decomposition.cpp	/^struct PT {$/;"	s	file:
PT	code-library/Geometry/Point Location.cpp	/^    PT() {}$/;"	f	struct:PT	file:
PT	code-library/Geometry/Point Location.cpp	/^    PT(ll _x, ll _y) : x(_x), y(_y) {}$/;"	f	struct:PT	file:
PT	code-library/Geometry/Point Location.cpp	/^struct PT {$/;"	s	file:
PT	code-library/Geometry/Voronoi Diagram.cpp	/^    PT() { x = 0, y = 0; }$/;"	f	struct:PT	file:
PT	code-library/Geometry/Voronoi Diagram.cpp	/^    PT(const PT &p) : x(p.x), y(p.y)    {}$/;"	f	struct:PT	file:
PT	code-library/Geometry/Voronoi Diagram.cpp	/^    PT(double x, double y) : x(x), y(y) {}$/;"	f	struct:PT	file:
PT	code-library/Geometry/Voronoi Diagram.cpp	/^struct PT {$/;"	s	file:
PT	code-library/Graph Theory/Manhattan MST.cpp	/^struct PT {$/;"	s	file:
PT	code/Dynamic Programming Optimizations/Persistent CHT.cpp	/^  PT(int x = 0, int y = 0): x(x), y(y) {}$/;"	f	struct:PT	file:
PT	code/Dynamic Programming Optimizations/Persistent CHT.cpp	/^struct PT {$/;"	s	file:
PT	code/Geometry/All Pair Segment Intersection.cpp	/^    PT() {$/;"	f	struct:PT	file:
PT	code/Geometry/All Pair Segment Intersection.cpp	/^    PT(const PT &p) : x(p.x), y(p.y)    {}$/;"	f	struct:PT	file:
PT	code/Geometry/All Pair Segment Intersection.cpp	/^    PT(double x, double y) : x(x), y(y) {}$/;"	f	struct:PT	file:
PT	code/Geometry/All Pair Segment Intersection.cpp	/^struct PT {$/;"	s	file:
PT	code/Geometry/Convec Hull Dynamic.cpp	/^    PT() : x(0), y(0) {}$/;"	f	struct:PT	file:
PT	code/Geometry/Convec Hull Dynamic.cpp	/^    PT(const PT& rhs) : x(rhs.x), y(rhs.y) {}$/;"	f	struct:PT	file:
PT	code/Geometry/Convec Hull Dynamic.cpp	/^    PT(const iter& p) : x(p->first), y(p->second) {}$/;"	f	struct:PT	file:
PT	code/Geometry/Convec Hull Dynamic.cpp	/^    PT(int x, int y) : x(x), y(y) {}$/;"	f	struct:PT	file:
PT	code/Geometry/Convec Hull Dynamic.cpp	/^struct PT {$/;"	s	file:
PT	code/Geometry/Delaunay Triangulation.cpp	/^    PT() { x = 0, y = 0; }$/;"	f	struct:PT	file:
PT	code/Geometry/Delaunay Triangulation.cpp	/^    PT(const PT &p) : x(p.x), y(p.y)    {}$/;"	f	struct:PT	file:
PT	code/Geometry/Delaunay Triangulation.cpp	/^    PT(long long x, long long y) : x(x), y(y) {}$/;"	f	struct:PT	file:
PT	code/Geometry/Delaunay Triangulation.cpp	/^struct PT {$/;"	s	file:
PT	code/Geometry/Geometry 2D.cpp	/^    PT() { x = 0, y = 0; }$/;"	f	struct:PT	file:
PT	code/Geometry/Geometry 2D.cpp	/^    PT(const PT &p) : x(p.x), y(p.y)    {}$/;"	f	struct:PT	file:
PT	code/Geometry/Geometry 2D.cpp	/^    PT(double x, double y) : x(x), y(y) {}$/;"	f	struct:PT	file:
PT	code/Geometry/Geometry 2D.cpp	/^struct PT {$/;"	s	file:
PT	code/Geometry/Geometry 3D.cpp	/^    PT() { x = 0, y = 0; }$/;"	f	struct:PT	file:
PT	code/Geometry/Geometry 3D.cpp	/^    PT(const PT &p) : x(p.x), y(p.y)    {}$/;"	f	struct:PT	file:
PT	code/Geometry/Geometry 3D.cpp	/^    PT(double x, double y) : x(x), y(y) {}$/;"	f	struct:PT	file:
PT	code/Geometry/Geometry 3D.cpp	/^struct PT {$/;"	s	file:
PT	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    PT() { x = 0, y = 0; }$/;"	f	struct:PT	file:
PT	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    PT(const PT &p) : x(p.x), y(p.y)    {}$/;"	f	struct:PT	file:
PT	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    PT(double x, double y) : x(x), y(y) {}$/;"	f	struct:PT	file:
PT	code/Geometry/Half Plane Intersection Dynamic.cpp	/^struct PT {$/;"	s	file:
PT	code/Geometry/Half Plane Intersection.cpp	/^    PT() { x = 0, y = 0; }$/;"	f	struct:PT	file:
PT	code/Geometry/Half Plane Intersection.cpp	/^    PT(const PT &p) : x(p.x), y(p.y)    {}$/;"	f	struct:PT	file:
PT	code/Geometry/Half Plane Intersection.cpp	/^    PT(double x, double y) : x(x), y(y) {}$/;"	f	struct:PT	file:
PT	code/Geometry/Half Plane Intersection.cpp	/^struct PT {$/;"	s	file:
PT	code/Geometry/Onion Decomposition.cpp	/^struct PT {$/;"	s	file:
PT	code/Geometry/Point Location.cpp	/^    PT() {}$/;"	f	struct:PT	file:
PT	code/Geometry/Point Location.cpp	/^    PT(ll _x, ll _y) : x(_x), y(_y) {}$/;"	f	struct:PT	file:
PT	code/Geometry/Point Location.cpp	/^struct PT {$/;"	s	file:
PT	code/Geometry/Voronoi Diagram.cpp	/^    PT() { x = 0, y = 0; }$/;"	f	struct:PT	file:
PT	code/Geometry/Voronoi Diagram.cpp	/^    PT(const PT &p) : x(p.x), y(p.y)    {}$/;"	f	struct:PT	file:
PT	code/Geometry/Voronoi Diagram.cpp	/^    PT(double x, double y) : x(x), y(y) {}$/;"	f	struct:PT	file:
PT	code/Geometry/Voronoi Diagram.cpp	/^struct PT {$/;"	s	file:
PT	code/Graph Theory/Manhattan MST.cpp	/^struct PT {$/;"	s	file:
PWX	code-library/Strings/String Hashing 2D.cpp	/^  vector<int> PWX, PWY;$/;"	m	struct:Hashing	typeref:typename:vector<int>	file:
PWX	code/Strings/String Hashing 2D.cpp	/^  vector<int> PWX, PWY;$/;"	m	struct:Hashing	typeref:typename:vector<int>	file:
PWY	code-library/Strings/String Hashing 2D.cpp	/^  vector<int> PWX, PWY;$/;"	m	struct:Hashing	typeref:typename:vector<int>	file:
PWY	code/Strings/String Hashing 2D.cpp	/^  vector<int> PWX, PWY;$/;"	m	struct:Hashing	typeref:typename:vector<int>	file:
PX	code-library/Strings/String Hashing 2D.cpp	/^  static const int PX = 3731,  PY = 2999, mod = 998244353;$/;"	m	struct:Hashing	typeref:typename:const int	file:
PX	code/Strings/String Hashing 2D.cpp	/^  static const int PX = 3731,  PY = 2999, mod = 998244353;$/;"	m	struct:Hashing	typeref:typename:const int	file:
PY	code-library/Strings/String Hashing 2D.cpp	/^  static const int PX = 3731,  PY = 2999, mod = 998244353;$/;"	m	struct:Hashing	typeref:typename:const int	file:
PY	code/Strings/String Hashing 2D.cpp	/^  static const int PX = 3731,  PY = 2999, mod = 998244353;$/;"	m	struct:Hashing	typeref:typename:const int	file:
Pair	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  using Pair = pair< vector<int>, vector<int> >;$/;"	t	function:binomial_sum_mod_p	typeref:typename:pair<vector<int>,vector<int>>	file:
Pair	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  using Pair = pair< vector<int>, vector<int> >;$/;"	t	function:binomial_sum_mod_p	typeref:typename:pair<vector<int>,vector<int>>	file:
PalindromicTree	code-library/Strings/Palindromic Tree Persistent.cpp	/^  PalindromicTree() {$/;"	f	struct:PalindromicTree	file:
PalindromicTree	code-library/Strings/Palindromic Tree Persistent.cpp	/^struct PalindromicTree {$/;"	s	file:
PalindromicTree	code-library/Strings/Palindromic Tree.cpp	/^  PalindromicTree() {}$/;"	f	struct:PalindromicTree	file:
PalindromicTree	code-library/Strings/Palindromic Tree.cpp	/^  PalindromicTree(string _s) {$/;"	f	struct:PalindromicTree	file:
PalindromicTree	code-library/Strings/Palindromic Tree.cpp	/^struct PalindromicTree {$/;"	s	file:
PalindromicTree	code/Strings/Palindromic Tree Persistent.cpp	/^  PalindromicTree() {$/;"	f	struct:PalindromicTree	file:
PalindromicTree	code/Strings/Palindromic Tree Persistent.cpp	/^struct PalindromicTree {$/;"	s	file:
PalindromicTree	code/Strings/Palindromic Tree.cpp	/^  PalindromicTree() {}$/;"	f	struct:PalindromicTree	file:
PalindromicTree	code/Strings/Palindromic Tree.cpp	/^  PalindromicTree(string _s) {$/;"	f	struct:PalindromicTree	file:
PalindromicTree	code/Strings/Palindromic Tree.cpp	/^struct PalindromicTree {$/;"	s	file:
PersistentArray	code-library/Data Structures/Persistent Array.cpp	/^struct PersistentArray { \/\/ 0-indexed$/;"	s	file:
PersistentArray	code-library/Data Structures/Persistent Queue.cpp	/^struct PersistentArray { \/\/ 0-indexed$/;"	s	file:
PersistentArray	code-library/Data Structures/Persistent UnionFind.cpp	/^struct PersistentArray { \/\/ 0-indexed$/;"	s	file:
PersistentArray	code/Data Structures/Persistent Array.cpp	/^struct PersistentArray { \/\/ 0-indexed$/;"	s	file:
PersistentArray	code/Data Structures/Persistent Queue.cpp	/^struct PersistentArray { \/\/ 0-indexed$/;"	s	file:
PersistentArray	code/Data Structures/Persistent UnionFind.cpp	/^struct PersistentArray { \/\/ 0-indexed$/;"	s	file:
PersistentCHT	code-library/Dynamic Programming Optimizations/Persistent CHT.cpp	/^struct PersistentCHT { \/\/minimizes dot product$/;"	s	file:
PersistentCHT	code/Dynamic Programming Optimizations/Persistent CHT.cpp	/^struct PersistentCHT { \/\/minimizes dot product$/;"	s	file:
PersistentDSU	code-library/Data Structures/Persistent UnionFind.cpp	/^  PersistentDSU() {}$/;"	f	struct:PersistentDSU	file:
PersistentDSU	code-library/Data Structures/Persistent UnionFind.cpp	/^  PersistentDSU(int n, int q) { \/\/ q -> maximum instances of DSU$/;"	f	struct:PersistentDSU	file:
PersistentDSU	code-library/Data Structures/Persistent UnionFind.cpp	/^struct PersistentDSU {$/;"	s	file:
PersistentDSU	code/Data Structures/Persistent UnionFind.cpp	/^  PersistentDSU() {}$/;"	f	struct:PersistentDSU	file:
PersistentDSU	code/Data Structures/Persistent UnionFind.cpp	/^  PersistentDSU(int n, int q) { \/\/ q -> maximum instances of DSU$/;"	f	struct:PersistentDSU	file:
PersistentDSU	code/Data Structures/Persistent UnionFind.cpp	/^struct PersistentDSU {$/;"	s	file:
PersistentLiChaoTree	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  PersistentLiChaoTree() {$/;"	f	struct:PersistentLiChaoTree	file:
PersistentLiChaoTree	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  PersistentLiChaoTree(int L, int R) : L(L), R(R) {$/;"	f	struct:PersistentLiChaoTree	file:
PersistentLiChaoTree	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^struct PersistentLiChaoTree {$/;"	s	file:
PersistentLiChaoTree	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  PersistentLiChaoTree() {$/;"	f	struct:PersistentLiChaoTree	file:
PersistentLiChaoTree	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  PersistentLiChaoTree(int L, int R) : L(L), R(R) {$/;"	f	struct:PersistentLiChaoTree	file:
PersistentLiChaoTree	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^struct PersistentLiChaoTree {$/;"	s	file:
PersistentQueue	code-library/Data Structures/Persistent Array.cpp	/^  PersistentQueue() {}$/;"	f	struct:PersistentQueue	file:
PersistentQueue	code-library/Data Structures/Persistent Array.cpp	/^  PersistentQueue(int q) { \/\/ max size of a queue$/;"	f	struct:PersistentQueue	file:
PersistentQueue	code-library/Data Structures/Persistent Array.cpp	/^struct PersistentQueue {$/;"	s	file:
PersistentQueue	code-library/Data Structures/Persistent Queue.cpp	/^  PersistentQueue() {}$/;"	f	struct:PersistentQueue	file:
PersistentQueue	code-library/Data Structures/Persistent Queue.cpp	/^  PersistentQueue(int q) { \/\/ max size of a queue$/;"	f	struct:PersistentQueue	file:
PersistentQueue	code-library/Data Structures/Persistent Queue.cpp	/^struct PersistentQueue {$/;"	s	file:
PersistentQueue	code/Data Structures/Persistent Array.cpp	/^  PersistentQueue() {}$/;"	f	struct:PersistentQueue	file:
PersistentQueue	code/Data Structures/Persistent Array.cpp	/^  PersistentQueue(int q) { \/\/ max size of a queue$/;"	f	struct:PersistentQueue	file:
PersistentQueue	code/Data Structures/Persistent Array.cpp	/^struct PersistentQueue {$/;"	s	file:
PersistentQueue	code/Data Structures/Persistent Queue.cpp	/^  PersistentQueue() {}$/;"	f	struct:PersistentQueue	file:
PersistentQueue	code/Data Structures/Persistent Queue.cpp	/^  PersistentQueue(int q) { \/\/ max size of a queue$/;"	f	struct:PersistentQueue	file:
PersistentQueue	code/Data Structures/Persistent Queue.cpp	/^struct PersistentQueue {$/;"	s	file:
PersistentTreap	code-library/Data Structures/Treap persistent.cpp	/^namespace PersistentTreap {$/;"	n	file:
PersistentTreap	code/Data Structures/Treap persistent.cpp	/^namespace PersistentTreap {$/;"	n	file:
Point	practice/usacoguide/gold/bfs/cownav.cpp	/^struct Point {$/;"	s	file:
PollardRho	code-library/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^namespace PollardRho {$/;"	n	file:
PollardRho	code-library/Number Theory/Pisano Period.cpp	/^namespace PollardRho {$/;"	n	file:
PollardRho	code-library/Number Theory/Pollard Rho.cpp	/^namespace PollardRho {$/;"	n	file:
PollardRho	code/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^namespace PollardRho {$/;"	n	file:
PollardRho	code/Number Theory/Pisano Period.cpp	/^namespace PollardRho {$/;"	n	file:
PollardRho	code/Number Theory/Pollard Rho.cpp	/^namespace PollardRho {$/;"	n	file:
Poly	code-library/Math/Determinant of Cyclic Matrix.cpp	/^using Poly = vector<int>;$/;"	t	typeref:typename:vector<int>	file:
Poly	code-library/Math/Determinant of Permutant Matrix.cpp	/^using Poly = vector<int>;$/;"	t	typeref:typename:vector<int>	file:
Poly	code/Math/Determinant of Cyclic Matrix.cpp	/^using Poly = vector<int>;$/;"	t	typeref:typename:vector<int>	file:
Poly	code/Math/Determinant of Permutant Matrix.cpp	/^using Poly = vector<int>;$/;"	t	typeref:typename:vector<int>	file:
Prims	code-library/Graph Theory/Prim's MST.cpp	/^long long Prims(int n, vector< pair<int, int> > &edges) {$/;"	f	typeref:typename:long long
Prims	code/Graph Theory/Prim's MST.cpp	/^long long Prims(int n, vector< pair<int, int> > &edges) {$/;"	f	typeref:typename:long long
Q	code-library/Data Structures/MOs Algorithm.cpp	/^} Q[N];$/;"	v	typeref:struct:query[]
Q	code-library/Data Structures/MOs on tree.cpp	/^} Q[N];$/;"	v	typeref:struct:query[]
Q	code-library/Data Structures/MOs with Update.cpp	/^} Q[N];$/;"	v	typeref:struct:query[]
Q	code-library/Data Structures/Reachability Tree.cpp	/^queue<pair<int, int>> Q;$/;"	v	typeref:typename:queue<pair<int,int>>
Q	code-library/Data Structures/Venice Technique.cpp	/^  priority_queue<T, vector<T>, greater<T>> Q;$/;"	m	struct:PQ	typeref:typename:priority_queue<T,vector<T>,greater<T>>	file:
Q	code-library/Game Theory/Matching Game On A Graph.cpp	/^  queue<int> Q;$/;"	m	struct:Blossom	typeref:typename:queue<int>	file:
Q	code-library/Geometry/Delaunay Triangulation.cpp	/^typedef struct Quad* Q;$/;"	t	typeref:struct:Quad *	file:
Q	code-library/Geometry/Voronoi Diagram.cpp	/^typedef struct Quad* Q;$/;"	t	typeref:struct:Quad *	file:
Q	code-library/Graph Theory/Blossom Algorithm.cpp	/^  queue<int> Q;$/;"	m	struct:Blossom	typeref:typename:queue<int>	file:
Q	code-library/Graph Theory/Directed MST.cpp	/^  priority_queue<T, vector<T>, greater<T>> Q;$/;"	m	struct:PQ	typeref:typename:priority_queue<T,vector<T>,greater<T>>	file:
Q	code-library/Graph Theory/Tree Isomorphism.cpp	/^const mint P = 998244353, Q = 1e9 + 33, R = 99999989;$/;"	v	typeref:typename:const mint
Q	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^} Q[N];$/;"	v	typeref:struct:query[]
Q	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^vector<pair<int, int>> Q[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
Q	code/Data Structures/MOs Algorithm.cpp	/^} Q[N];$/;"	v	typeref:struct:query[]
Q	code/Data Structures/MOs on tree.cpp	/^} Q[N];$/;"	v	typeref:struct:query[]
Q	code/Data Structures/MOs with Update.cpp	/^} Q[N];$/;"	v	typeref:struct:query[]
Q	code/Data Structures/Reachability Tree.cpp	/^queue<pair<int, int>> Q;$/;"	v	typeref:typename:queue<pair<int,int>>
Q	code/Data Structures/Venice Technique.cpp	/^  priority_queue<T, vector<T>, greater<T>> Q;$/;"	m	struct:PQ	typeref:typename:priority_queue<T,vector<T>,greater<T>>	file:
Q	code/Game Theory/Matching Game On A Graph.cpp	/^  queue<int> Q;$/;"	m	struct:Blossom	typeref:typename:queue<int>	file:
Q	code/Geometry/Delaunay Triangulation.cpp	/^typedef struct Quad* Q;$/;"	t	typeref:struct:Quad *	file:
Q	code/Geometry/Voronoi Diagram.cpp	/^typedef struct Quad* Q;$/;"	t	typeref:struct:Quad *	file:
Q	code/Graph Theory/Blossom Algorithm.cpp	/^  queue<int> Q;$/;"	m	struct:Blossom	typeref:typename:queue<int>	file:
Q	code/Graph Theory/Directed MST.cpp	/^  priority_queue<T, vector<T>, greater<T>> Q;$/;"	m	struct:PQ	typeref:typename:priority_queue<T,vector<T>,greater<T>>	file:
Q	code/Graph Theory/Tree Isomorphism.cpp	/^const mint P = 998244353, Q = 1e9 + 33, R = 99999989;$/;"	v	typeref:typename:const mint
Q	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^} Q[N];$/;"	v	typeref:struct:query[]
Q	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^vector<pair<int, int>> Q[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
Q	contests/Codeforces/1609/B.cpp	/^int N, Q;$/;"	v	typeref:typename:int
Quad	code-library/Geometry/Delaunay Triangulation.cpp	/^struct Quad {$/;"	s	file:
Quad	code-library/Geometry/Voronoi Diagram.cpp	/^struct Quad {$/;"	s	file:
Quad	code/Geometry/Delaunay Triangulation.cpp	/^struct Quad {$/;"	s	file:
Quad	code/Geometry/Voronoi Diagram.cpp	/^struct Quad {$/;"	s	file:
Query	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^ll Query(int cur, int x, int l, int r) {$/;"	f	typeref:typename:ll
Query	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^ll Query(int cur, int x, int l, int r) {$/;"	f	typeref:typename:ll
R	code-library/Data Structures/Persistent Array.cpp	/^  vector<int> L, R;$/;"	m	struct:PersistentQueue	typeref:typename:vector<int>	file:
R	code-library/Data Structures/Persistent Queue.cpp	/^  vector<int> L, R;$/;"	m	struct:PersistentQueue	typeref:typename:vector<int>	file:
R	code-library/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  int L, R;$/;"	m	struct:LiChaoTree	typeref:typename:int	file:
R	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  int L, R;$/;"	m	struct:PersistentLiChaoTree	typeref:typename:int	file:
R	code-library/Geometry/Onion Decomposition.cpp	/^        int L, R;$/;"	m	struct:LeftHull::node	typeref:typename:int	file:
R	code-library/Graph Theory/Tree Isomorphism.cpp	/^const mint P = 998244353, Q = 1e9 + 33, R = 99999989;$/;"	v	typeref:typename:const mint
R	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^using R = int;$/;"	t	typeref:typename:int	file:
R	code/Data Structures/Persistent Array.cpp	/^  vector<int> L, R;$/;"	m	struct:PersistentQueue	typeref:typename:vector<int>	file:
R	code/Data Structures/Persistent Queue.cpp	/^  vector<int> L, R;$/;"	m	struct:PersistentQueue	typeref:typename:vector<int>	file:
R	code/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  int L, R;$/;"	m	struct:LiChaoTree	typeref:typename:int	file:
R	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  int L, R;$/;"	m	struct:PersistentLiChaoTree	typeref:typename:int	file:
R	code/Geometry/Onion Decomposition.cpp	/^        int L, R;$/;"	m	struct:LeftHull::node	typeref:typename:int	file:
R	code/Graph Theory/Tree Isomorphism.cpp	/^const mint P = 998244353, Q = 1e9 + 33, R = 99999989;$/;"	v	typeref:typename:const mint
R	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^using R = int;$/;"	t	typeref:typename:int	file:
R64	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^using R64 = i64;$/;"	t	typeref:typename:i64	file:
R64	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^using R64 = i64;$/;"	t	typeref:typename:i64	file:
RMQ	code-library/Graph Theory/LCA in O(1).cpp	/^struct RMQ { \/\/ 0-based$/;"	s	file:
RMQ	code/Graph Theory/LCA in O(1).cpp	/^struct RMQ { \/\/ 0-based$/;"	s	file:
RT	code-library/Data Structures/Reachability Tree.cpp	/^struct RT {$/;"	s	file:
RT	code/Data Structures/Reachability Tree.cpp	/^struct RT {$/;"	s	file:
RandomizedMatching	code-library/Graph Theory/Chinese Postman Problem.cpp	/^  RandomizedMatching() {}$/;"	f	struct:RandomizedMatching	file:
RandomizedMatching	code-library/Graph Theory/Chinese Postman Problem.cpp	/^  RandomizedMatching(int _n) {$/;"	f	struct:RandomizedMatching	file:
RandomizedMatching	code-library/Graph Theory/Chinese Postman Problem.cpp	/^struct RandomizedMatching {$/;"	s	file:
RandomizedMatching	code-library/Graph Theory/Randomized Matching Unweighted.cpp	/^  RandomizedMatching() {}$/;"	f	struct:RandomizedMatching	file:
RandomizedMatching	code-library/Graph Theory/Randomized Matching Unweighted.cpp	/^  RandomizedMatching(int _n) {$/;"	f	struct:RandomizedMatching	file:
RandomizedMatching	code-library/Graph Theory/Randomized Matching Unweighted.cpp	/^struct RandomizedMatching {$/;"	s	file:
RandomizedMatching	code-library/Graph Theory/Randomized Matching Weighted.cpp	/^	RandomizedMatching() {}$/;"	f	struct:RandomizedMatching	file:
RandomizedMatching	code-library/Graph Theory/Randomized Matching Weighted.cpp	/^	RandomizedMatching(int _n) {$/;"	f	struct:RandomizedMatching	file:
RandomizedMatching	code-library/Graph Theory/Randomized Matching Weighted.cpp	/^struct RandomizedMatching {$/;"	s	file:
RandomizedMatching	code/Graph Theory/Chinese Postman Problem.cpp	/^  RandomizedMatching() {}$/;"	f	struct:RandomizedMatching	file:
RandomizedMatching	code/Graph Theory/Chinese Postman Problem.cpp	/^  RandomizedMatching(int _n) {$/;"	f	struct:RandomizedMatching	file:
RandomizedMatching	code/Graph Theory/Chinese Postman Problem.cpp	/^struct RandomizedMatching {$/;"	s	file:
RandomizedMatching	code/Graph Theory/Randomized Matching Unweighted.cpp	/^  RandomizedMatching() {}$/;"	f	struct:RandomizedMatching	file:
RandomizedMatching	code/Graph Theory/Randomized Matching Unweighted.cpp	/^  RandomizedMatching(int _n) {$/;"	f	struct:RandomizedMatching	file:
RandomizedMatching	code/Graph Theory/Randomized Matching Unweighted.cpp	/^struct RandomizedMatching {$/;"	s	file:
RandomizedMatching	code/Graph Theory/Randomized Matching Weighted.cpp	/^	RandomizedMatching() {}$/;"	f	struct:RandomizedMatching	file:
RandomizedMatching	code/Graph Theory/Randomized Matching Weighted.cpp	/^	RandomizedMatching(int _n) {$/;"	f	struct:RandomizedMatching	file:
RandomizedMatching	code/Graph Theory/Randomized Matching Weighted.cpp	/^struct RandomizedMatching {$/;"	s	file:
ReedsSloane	code-library/Math/Reeds Sloane Algorithm.cpp	/^  static vec ReedsSloane(const vec &s, ll mod) {$/;"	f	struct:LinearRecurrence	typeref:typename:vec	file:
ReedsSloane	code/Math/Reeds Sloane Algorithm.cpp	/^  static vec ReedsSloane(const vec &s, ll mod) {$/;"	f	struct:LinearRecurrence	typeref:typename:vec	file:
Run	.config/nvim/init.vim	/^command! -nargs=0 Run call TermWrapper(printf('~\/.\/a.out'))$/;"	c
Run	dotfiles/init.vim	/^command! -nargs=0 Run call TermWrapper(printf('~\/.\/a.out'))$/;"	c
Run	dotfiles/macinit.vim	/^command! -nargs=0 Run call TermWrapper(printf('~\/.\/a.out'))$/;"	c
Rx	code-library/Graph Theory/L R Flow with Dinic.cpp	/^int Lx[N], Rx[N], Ly[N], Ry[N], degx[N], degy[N];$/;"	v	typeref:typename:int[]
Rx	code/Graph Theory/L R Flow with Dinic.cpp	/^int Lx[N], Rx[N], Ly[N], Ry[N], degx[N], degy[N];$/;"	v	typeref:typename:int[]
Ry	code-library/Graph Theory/L R Flow with Dinic.cpp	/^int Lx[N], Rx[N], Ly[N], Ry[N], degx[N], degy[N];$/;"	v	typeref:typename:int[]
Ry	code/Graph Theory/L R Flow with Dinic.cpp	/^int Lx[N], Rx[N], Ly[N], Ry[N], degx[N], degy[N];$/;"	v	typeref:typename:int[]
S	.config/nvim/init.vim	/^nmap        S   <Plug>(vsnip-cut-text)$/;"	m
S	.config/nvim/init.vim	/^xmap        S   <Plug>(vsnip-cut-text)$/;"	m
S	code-library/Data Structures/DSU with Rollbacks.cpp	/^  vector<update> S;$/;"	m	struct:DSUQueue	typeref:typename:vector<update>	file:
S	code-library/Data Structures/Queue Undo Trick.cpp	/^  vector<update> S;$/;"	m	struct:DSUQueue	typeref:typename:vector<update>	file:
S	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  int n, n_x, match[N * 2], slack[N * 2], st[N * 2], pa[N * 2], flower_from[N * 2][N * 2], S[N */;"	m	struct:Blossom	typeref:typename:int[]	file:
S	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  S(int v, int ri, F c, W cost = 0) :$/;"	f	struct:S	file:
S	code-library/Graph Theory/Gomory Hu Tree.cpp	/^struct S {$/;"	s	file:
S	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  int N, S, T;$/;"	m	struct:mcSFlow	typeref:typename:int	file:
S	code-library/Strings/Suffix Array Isomorphic.cpp	/^  SuffixArray S;$/;"	m	struct:IsomorphicSuffixArray	typeref:typename:SuffixArray	file:
S	code/Data Structures/DSU with Rollbacks.cpp	/^  vector<update> S;$/;"	m	struct:DSUQueue	typeref:typename:vector<update>	file:
S	code/Data Structures/Queue Undo Trick.cpp	/^  vector<update> S;$/;"	m	struct:DSUQueue	typeref:typename:vector<update>	file:
S	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  int n, n_x, match[N * 2], slack[N * 2], st[N * 2], pa[N * 2], flower_from[N * 2][N * 2], S[N */;"	m	struct:Blossom	typeref:typename:int[]	file:
S	code/Graph Theory/Gomory Hu Tree.cpp	/^  S(int v, int ri, F c, W cost = 0) :$/;"	f	struct:S	file:
S	code/Graph Theory/Gomory Hu Tree.cpp	/^struct S {$/;"	s	file:
S	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  int N, S, T;$/;"	m	struct:mcSFlow	typeref:typename:int	file:
S	code/Strings/Suffix Array Isomorphic.cpp	/^  SuffixArray S;$/;"	m	struct:IsomorphicSuffixArray	typeref:typename:SuffixArray	file:
S	contests/Codeforces/1609/B.cpp	/^string S;$/;"	v	typeref:typename:string
S	contests/Codeforces/737/C.cpp	/^#define S /;"	d	file:
S	dotfiles/init.vim	/^nmap        S   <Plug>(vsnip-cut-text)$/;"	m
S	dotfiles/init.vim	/^xmap        S   <Plug>(vsnip-cut-text)$/;"	m
S	practice/cpbook/ch1/1.6/chess/10284/main.cpp	/^string S;$/;"	v	typeref:typename:string
S	practice/usacoguide/gold/bfs/mecho/main.cpp	/^int N, S; $/;"	v	typeref:typename:int
S	practice/usacoguide/gold/bfs/mechonew/main.cpp	/^int N, S; $/;"	v	typeref:typename:int
SAT_GOD	code-library/Graph Theory/3 SAT.cpp	/^  SAT_GOD(int n) : n(n), g(2*n), occ(2*n) { }$/;"	f	struct:SAT_GOD	file:
SAT_GOD	code-library/Graph Theory/3 SAT.cpp	/^struct SAT_GOD {$/;"	s	file:
SAT_GOD	code/Graph Theory/3 SAT.cpp	/^  SAT_GOD(int n) : n(n), g(2*n), occ(2*n) { }$/;"	f	struct:SAT_GOD	file:
SAT_GOD	code/Graph Theory/3 SAT.cpp	/^struct SAT_GOD {$/;"	s	file:
SA_IS	code-library/Strings/Suffix Array.cpp	/^vector<int> SA_IS(const vector<int> &vec, int val_range) {$/;"	f	typeref:typename:vector<int>
SA_IS	code/Strings/Suffix Array.cpp	/^vector<int> SA_IS(const vector<int> &vec, int val_range) {$/;"	f	typeref:typename:vector<int>
SGTBeats	code-library/Data Structures/Segment Tree Beats.cpp	/^  SGTBeats(int n) {$/;"	f	struct:SGTBeats	file:
SGTBeats	code-library/Data Structures/Segment Tree Beats.cpp	/^  SGTBeats(int n, ll *a) : n(n) {$/;"	f	struct:SGTBeats	file:
SGTBeats	code-library/Data Structures/Segment Tree Beats.cpp	/^struct SGTBeats {$/;"	s	file:
SGTBeats	code/Data Structures/Segment Tree Beats.cpp	/^  SGTBeats(int n) {$/;"	f	struct:SGTBeats	file:
SGTBeats	code/Data Structures/Segment Tree Beats.cpp	/^  SGTBeats(int n, ll *a) : n(n) {$/;"	f	struct:SGTBeats	file:
SGTBeats	code/Data Structures/Segment Tree Beats.cpp	/^struct SGTBeats {$/;"	s	file:
SIGMA	code-library/Strings/Bit LCS.cpp	/^const int N = 5e4 + 9, SIGMA = 26;$/;"	v	typeref:typename:const int
SIGMA	code/Strings/Bit LCS.cpp	/^const int N = 5e4 + 9, SIGMA = 26;$/;"	v	typeref:typename:const int
SIZE	practice/cf/random/1700/testing.cpp	/^template <typename T, size_t N> int SIZE(const T (&t)[N]){ return N; } template<typename T> int /;"	f	typeref:typename:int
SM	code-library/Graph Theory/Stable Marriage Problem.cpp	/^void SM(int n) {$/;"	f	typeref:typename:void
SM	code/Graph Theory/Stable Marriage Problem.cpp	/^void SM(int n) {$/;"	f	typeref:typename:void
SOS	code-library/Dynamic Programming Optimizations/SOS convolutions.cpp	/^namespace SOS {$/;"	n	file:
SOS	code/Dynamic Programming Optimizations/SOS convolutions.cpp	/^namespace SOS {$/;"	n	file:
SQ	code-library/Dynamic Programming Optimizations/Number of Subsequences Having Product at least K.cpp	/^const int N = 1010, mod = 1e9 + 7, SQ = sqrt(mod) + 1;$/;"	v	typeref:typename:const int
SQ	code-library/Geometry/All Pair Segment Intersection.cpp	/^double SQ(double x) {$/;"	f	typeref:typename:double
SQ	code-library/Geometry/Geometry 2D.cpp	/^    inline double SQ(const double x) {return x * x;}$/;"	f	struct:CircleUnion	typeref:typename:double	file:
SQ	code-library/Geometry/Geometry 2D.cpp	/^double SQ(double x) { return x * x; }$/;"	f	typeref:typename:double
SQ	code-library/Geometry/Geometry 3D.cpp	/^double SQ(double x) { return x * x; }$/;"	f	typeref:typename:double
SQ	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^double SQ(double x) { return x * x; }$/;"	f	typeref:typename:double
SQ	code-library/Geometry/Half Plane Intersection.cpp	/^double SQ(double x) { return x * x; }$/;"	f	typeref:typename:double
SQ	code-library/Geometry/Voronoi Diagram.cpp	/^double SQ(double x) { return x * x; }$/;"	f	typeref:typename:double
SQ	code/Dynamic Programming Optimizations/Number of Subsequences Having Product at least K.cpp	/^const int N = 1010, mod = 1e9 + 7, SQ = sqrt(mod) + 1;$/;"	v	typeref:typename:const int
SQ	code/Geometry/All Pair Segment Intersection.cpp	/^double SQ(double x) {$/;"	f	typeref:typename:double
SQ	code/Geometry/Geometry 2D.cpp	/^    inline double SQ(const double x) {return x * x;}$/;"	f	struct:CircleUnion	typeref:typename:double	file:
SQ	code/Geometry/Geometry 2D.cpp	/^double SQ(double x) { return x * x; }$/;"	f	typeref:typename:double
SQ	code/Geometry/Geometry 3D.cpp	/^double SQ(double x) { return x * x; }$/;"	f	typeref:typename:double
SQ	code/Geometry/Half Plane Intersection Dynamic.cpp	/^double SQ(double x) { return x * x; }$/;"	f	typeref:typename:double
SQ	code/Geometry/Half Plane Intersection.cpp	/^double SQ(double x) { return x * x; }$/;"	f	typeref:typename:double
SQ	code/Geometry/Voronoi Diagram.cpp	/^double SQ(double x) { return x * x; }$/;"	f	typeref:typename:double
SQRT	code-library/Number Theory/Tonelli Shanks Algorithm.cpp	/^int SQRT(int a, int p) {$/;"	f	typeref:typename:int
SQRT	code/Number Theory/Tonelli Shanks Algorithm.cpp	/^int SQRT(int a, int p) {$/;"	f	typeref:typename:int
ST	code-library/Data Structures/Dynamic Diameter Online.cpp	/^    ST() {$/;"	f	struct:ST	file:
ST	code-library/Data Structures/Dynamic Diameter Online.cpp	/^struct ST$/;"	s	file:
ST	code-library/Data Structures/HLD.cpp	/^  ST() {$/;"	f	struct:ST	file:
ST	code-library/Data Structures/HLD.cpp	/^struct ST {$/;"	s	file:
ST	code-library/Data Structures/Permutation Tree.cpp	/^  ST() {}$/;"	f	struct:ST	file:
ST	code-library/Data Structures/Permutation Tree.cpp	/^struct ST {$/;"	s	file:
ST	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  ST() {$/;"	f	struct:ST	file:
ST	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  ST(int st, int en) {$/;"	f	struct:ST	file:
ST	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^struct ST {$/;"	s	file:
ST	code-library/Data Structures/Segment Tree Lazy.cpp	/^  ST() {$/;"	f	struct:ST	file:
ST	code-library/Data Structures/Segment Tree Lazy.cpp	/^struct ST {$/;"	s	file:
ST	code-library/Data Structures/Segment Tree NonRecursive.cpp	/^  ST() {$/;"	f	struct:ST	file:
ST	code-library/Data Structures/Segment Tree NonRecursive.cpp	/^struct ST {$/;"	s	file:
ST	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  ST() {$/;"	f	struct:ST	file:
ST	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^struct ST {$/;"	s	file:
ST	code-library/Data Structures/Segment Tree.cpp	/^  ST() {$/;"	f	struct:ST	file:
ST	code-library/Data Structures/Segment Tree.cpp	/^struct ST {$/;"	s	file:
ST	code-library/Miscellaneous/MEX of all Subarrays.cpp	/^  ST() {}$/;"	f	struct:ST	file:
ST	code-library/Miscellaneous/MEX of all Subarrays.cpp	/^struct ST {$/;"	s	file:
ST	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  ST() {$/;"	f	struct:ST	file:
ST	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^struct ST {$/;"	s	file:
ST	code/Data Structures/Dynamic Diameter Online.cpp	/^    ST() {$/;"	f	struct:ST	file:
ST	code/Data Structures/Dynamic Diameter Online.cpp	/^struct ST$/;"	s	file:
ST	code/Data Structures/HLD.cpp	/^  ST() {$/;"	f	struct:ST	file:
ST	code/Data Structures/HLD.cpp	/^struct ST {$/;"	s	file:
ST	code/Data Structures/Permutation Tree.cpp	/^  ST() {}$/;"	f	struct:ST	file:
ST	code/Data Structures/Permutation Tree.cpp	/^struct ST {$/;"	s	file:
ST	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  ST() {$/;"	f	struct:ST	file:
ST	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  ST(int st, int en) {$/;"	f	struct:ST	file:
ST	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^struct ST {$/;"	s	file:
ST	code/Data Structures/Segment Tree Lazy.cpp	/^  ST() {$/;"	f	struct:ST	file:
ST	code/Data Structures/Segment Tree Lazy.cpp	/^struct ST {$/;"	s	file:
ST	code/Data Structures/Segment Tree NonRecursive.cpp	/^  ST() {$/;"	f	struct:ST	file:
ST	code/Data Structures/Segment Tree NonRecursive.cpp	/^struct ST {$/;"	s	file:
ST	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  ST() {$/;"	f	struct:ST	file:
ST	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^struct ST {$/;"	s	file:
ST	code/Data Structures/Segment Tree.cpp	/^  ST() {$/;"	f	struct:ST	file:
ST	code/Data Structures/Segment Tree.cpp	/^struct ST {$/;"	s	file:
ST	code/Miscellaneous/MEX of all Subarrays.cpp	/^  ST() {}$/;"	f	struct:ST	file:
ST	code/Miscellaneous/MEX of all Subarrays.cpp	/^struct ST {$/;"	s	file:
ST	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  ST() {$/;"	f	struct:ST	file:
ST	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^struct ST {$/;"	s	file:
STM	code-library/Data Structures/Segment Tree Merging.cpp	/^  STM() {$/;"	f	struct:STM	file:
STM	code-library/Data Structures/Segment Tree Merging.cpp	/^struct STM {$/;"	s	file:
STM	code/Data Structures/Segment Tree Merging.cpp	/^  STM() {$/;"	f	struct:STM	file:
STM	code/Data Structures/Segment Tree Merging.cpp	/^struct STM {$/;"	s	file:
Set	code-library/Geometry/Geometry 3D.cpp	/^struct Set : vector<p3> {$/;"	s	file:
Set	code/Geometry/Geometry 3D.cpp	/^struct Set : vector<p3> {$/;"	s	file:
SqrtTree	code-library/Data Structures/SQRT Tree.cpp	/^  SqrtTree(const vector<SqrtTreeItem>& a)$/;"	f	struct:SqrtTree	file:
SqrtTree	code-library/Data Structures/SQRT Tree.cpp	/^struct SqrtTree {$/;"	s	file:
SqrtTree	code/Data Structures/SQRT Tree.cpp	/^  SqrtTree(const vector<SqrtTreeItem>& a)$/;"	f	struct:SqrtTree	file:
SqrtTree	code/Data Structures/SQRT Tree.cpp	/^struct SqrtTree {$/;"	s	file:
SqrtTreeItem	code-library/Data Structures/SQRT Tree.cpp	/^#define SqrtTreeItem /;"	d	file:
SqrtTreeItem	code/Data Structures/SQRT Tree.cpp	/^#define SqrtTreeItem /;"	d	file:
StoerWagner	code-library/Graph Theory/Stoer Wagner Algorithm.cpp	/^  StoerWagner() {}$/;"	f	struct:StoerWagner	file:
StoerWagner	code-library/Graph Theory/Stoer Wagner Algorithm.cpp	/^  StoerWagner(int _n) {$/;"	f	struct:StoerWagner	file:
StoerWagner	code-library/Graph Theory/Stoer Wagner Algorithm.cpp	/^struct StoerWagner {$/;"	s	file:
StoerWagner	code/Graph Theory/Stoer Wagner Algorithm.cpp	/^  StoerWagner() {}$/;"	f	struct:StoerWagner	file:
StoerWagner	code/Graph Theory/Stoer Wagner Algorithm.cpp	/^  StoerWagner(int _n) {$/;"	f	struct:StoerWagner	file:
StoerWagner	code/Graph Theory/Stoer Wagner Algorithm.cpp	/^struct StoerWagner {$/;"	s	file:
SuffixArray	code-library/Strings/Suffix Array Isomorphic.cpp	/^  SuffixArray() {}$/;"	f	struct:SuffixArray	file:
SuffixArray	code-library/Strings/Suffix Array Isomorphic.cpp	/^  SuffixArray(vector<int> _s) {$/;"	f	struct:SuffixArray	file:
SuffixArray	code-library/Strings/Suffix Array Isomorphic.cpp	/^struct SuffixArray {$/;"	s	file:
SuffixArray	code-library/Strings/Suffix Array.cpp	/^  SuffixArray() {}$/;"	f	struct:SuffixArray	file:
SuffixArray	code-library/Strings/Suffix Array.cpp	/^  SuffixArray(string _s) {$/;"	f	struct:SuffixArray	file:
SuffixArray	code-library/Strings/Suffix Array.cpp	/^struct SuffixArray {$/;"	s	file:
SuffixArray	code/Strings/Suffix Array Isomorphic.cpp	/^  SuffixArray() {}$/;"	f	struct:SuffixArray	file:
SuffixArray	code/Strings/Suffix Array Isomorphic.cpp	/^  SuffixArray(vector<int> _s) {$/;"	f	struct:SuffixArray	file:
SuffixArray	code/Strings/Suffix Array Isomorphic.cpp	/^struct SuffixArray {$/;"	s	file:
SuffixArray	code/Strings/Suffix Array.cpp	/^  SuffixArray() {}$/;"	f	struct:SuffixArray	file:
SuffixArray	code/Strings/Suffix Array.cpp	/^  SuffixArray(string _s) {$/;"	f	struct:SuffixArray	file:
SuffixArray	code/Strings/Suffix Array.cpp	/^struct SuffixArray {$/;"	s	file:
SuffixAutomaton	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  SuffixAutomaton() {}$/;"	f	struct:SuffixAutomaton	file:
SuffixAutomaton	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  SuffixAutomaton(int n) {$/;"	f	struct:SuffixAutomaton	file:
SuffixAutomaton	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^struct SuffixAutomaton {$/;"	s	file:
SuffixAutomaton	code-library/Strings/Suffix Automaton.cpp	/^    SuffixAutomaton() {}$/;"	f	struct:SuffixAutomaton	file:
SuffixAutomaton	code-library/Strings/Suffix Automaton.cpp	/^    SuffixAutomaton(int n) {$/;"	f	struct:SuffixAutomaton	file:
SuffixAutomaton	code-library/Strings/Suffix Automaton.cpp	/^struct SuffixAutomaton {$/;"	s	file:
SuffixAutomaton	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  SuffixAutomaton() {}$/;"	f	struct:SuffixAutomaton	file:
SuffixAutomaton	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  SuffixAutomaton(int n) {$/;"	f	struct:SuffixAutomaton	file:
SuffixAutomaton	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^struct SuffixAutomaton {$/;"	s	file:
SuffixAutomaton	code/Strings/Suffix Automaton.cpp	/^    SuffixAutomaton() {}$/;"	f	struct:SuffixAutomaton	file:
SuffixAutomaton	code/Strings/Suffix Automaton.cpp	/^    SuffixAutomaton(int n) {$/;"	f	struct:SuffixAutomaton	file:
SuffixAutomaton	code/Strings/Suffix Automaton.cpp	/^struct SuffixAutomaton {$/;"	s	file:
T	code-library/Data Structures/Binarizing a Tree.cpp	/^int T;$/;"	v	typeref:typename:int
T	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^int T;$/;"	v	typeref:typename:int
T	code-library/Data Structures/Dynamic Diameter Online.cpp	/^int T, st[N * 2], en[N * 2], pos[N];$/;"	v	typeref:typename:int
T	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    int T = 0;$/;"	m	struct:PST	typeref:typename:int	file:
T	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int T, head[N], st[N], en[N];$/;"	v	typeref:typename:int
T	code-library/Data Structures/HLD.cpp	/^int T, head[N], st[N], en[N];$/;"	v	typeref:typename:int
T	code-library/Data Structures/MOs on tree.cpp	/^int st[N], en[N], T, par[N][20], dep[N], id[N * 2];$/;"	v	typeref:typename:int
T	code-library/Data Structures/Reachability Tree.cpp	/^  int T, st[2 * N], en[2 * N];$/;"	m	struct:RT	typeref:typename:int	file:
T	code-library/Data Structures/Segment Tree Merging.cpp	/^  int T;$/;"	m	struct:STM	typeref:typename:int	file:
T	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^  int T = 0;$/;"	m	struct:PST	typeref:typename:int	file:
T	code-library/Data Structures/Segment Tree Persistent.cpp	/^  int T = 0;$/;"	m	struct:PST	typeref:typename:int	file:
T	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^int n, T;$/;"	v	typeref:typename:int
T	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^int T;$/;"	v	typeref:typename:int
T	code-library/Game Theory/Green Hackenbush.cpp	/^int n, T, low[N], dis[N];$/;"	v	typeref:typename:int
T	code-library/Graph Theory/Articulation Points.cpp	/^int T, low[N], dis[N], art[N];$/;"	v	typeref:typename:int
T	code-library/Graph Theory/Block Cut Tree.cpp	/^int T, low[N], dis[N], art[N], sz;$/;"	v	typeref:typename:int
T	code-library/Graph Theory/Dominator Tree.cpp	/^int id[N], rev[N], T;$/;"	v	typeref:typename:int
T	code-library/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^typedef array<int, 2> T;$/;"	t	typeref:typename:array<int,2>	file:
T	code-library/Graph Theory/Euler Path Directed.cpp	/^int T = 0;$/;"	v	typeref:typename:int
T	code-library/Graph Theory/L R Flow with MCMF.cpp	/^using T = long long;$/;"	t	typeref:typename:long long	file:
T	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  int N, S, T;$/;"	m	struct:mcSFlow	typeref:typename:int	file:
T	code-library/Graph Theory/Min Cost Max Flow.cpp	/^using T = long long;$/;"	t	typeref:typename:long long	file:
T	code-library/Graph Theory/Randomized Matching Unweighted.cpp	/^  int n, match[N], vis[N], T = 0;$/;"	m	struct:RandomizedMatching	typeref:typename:int	file:
T	code-library/Graph Theory/ST Numbering.cpp	/^int low[N], dis[N], T = 0, par[N], sign[N];$/;"	v	typeref:typename:int
T	code-library/Graph Theory/Virtual Tree.cpp	/^int par[N][20], dep[N], sz[N], st[N], en[N], T;$/;"	v	typeref:typename:int
T	code-library/Number Theory/CRT.cpp	/^using T = __int128;$/;"	t	typeref:typename:__int128	file:
T	code-library/Number Theory/Dirichlet Convolution.cpp	/^  const int T = 1e7 + 9;$/;"	v	namespace:Dirichlet	typeref:typename:const int
T	code-library/Number Theory/Intersection of Arithmetic Progressions.cpp	/^using T = __int128;$/;"	t	typeref:typename:__int128	file:
T	code-library/Number Theory/Linear Diophantine Equation Three Variables with Nonnegative Solutions.cpp	/^using T = __int128;$/;"	t	typeref:typename:__int128	file:
T	code-library/Number Theory/Min_25 Sieve.cpp	/^using T = mint;$/;"	t	typeref:typename:mint	file:
T	code-library/Number Theory/Smallest Nonnegative Integer x s.t. l <= ax % p <= r.cpp	/^using T = __int128;$/;"	t	typeref:typename:__int128	file:
T	code/Data Structures/Binarizing a Tree.cpp	/^int T;$/;"	v	typeref:typename:int
T	code/Data Structures/Centroid Decomposition Persistent.cpp	/^int T;$/;"	v	typeref:typename:int
T	code/Data Structures/Dynamic Diameter Online.cpp	/^int T, st[N * 2], en[N * 2], pos[N];$/;"	v	typeref:typename:int
T	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    int T = 0;$/;"	m	struct:PST	typeref:typename:int	file:
T	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int T, head[N], st[N], en[N];$/;"	v	typeref:typename:int
T	code/Data Structures/HLD.cpp	/^int T, head[N], st[N], en[N];$/;"	v	typeref:typename:int
T	code/Data Structures/MOs on tree.cpp	/^int st[N], en[N], T, par[N][20], dep[N], id[N * 2];$/;"	v	typeref:typename:int
T	code/Data Structures/Reachability Tree.cpp	/^  int T, st[2 * N], en[2 * N];$/;"	m	struct:RT	typeref:typename:int	file:
T	code/Data Structures/Segment Tree Merging.cpp	/^  int T;$/;"	m	struct:STM	typeref:typename:int	file:
T	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^  int T = 0;$/;"	m	struct:PST	typeref:typename:int	file:
T	code/Data Structures/Segment Tree Persistent.cpp	/^  int T = 0;$/;"	m	struct:PST	typeref:typename:int	file:
T	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^int n, T;$/;"	v	typeref:typename:int
T	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^int T;$/;"	v	typeref:typename:int
T	code/Game Theory/Green Hackenbush.cpp	/^int n, T, low[N], dis[N];$/;"	v	typeref:typename:int
T	code/Graph Theory/Articulation Points.cpp	/^int T, low[N], dis[N], art[N];$/;"	v	typeref:typename:int
T	code/Graph Theory/Block Cut Tree.cpp	/^int T, low[N], dis[N], art[N], sz;$/;"	v	typeref:typename:int
T	code/Graph Theory/Dominator Tree.cpp	/^int id[N], rev[N], T;$/;"	v	typeref:typename:int
T	code/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^typedef array<int, 2> T;$/;"	t	typeref:typename:array<int,2>	file:
T	code/Graph Theory/Euler Path Directed.cpp	/^int T = 0;$/;"	v	typeref:typename:int
T	code/Graph Theory/L R Flow with MCMF.cpp	/^using T = long long;$/;"	t	typeref:typename:long long	file:
T	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  int N, S, T;$/;"	m	struct:mcSFlow	typeref:typename:int	file:
T	code/Graph Theory/Min Cost Max Flow.cpp	/^using T = long long;$/;"	t	typeref:typename:long long	file:
T	code/Graph Theory/Randomized Matching Unweighted.cpp	/^  int n, match[N], vis[N], T = 0;$/;"	m	struct:RandomizedMatching	typeref:typename:int	file:
T	code/Graph Theory/ST Numbering.cpp	/^int low[N], dis[N], T = 0, par[N], sign[N];$/;"	v	typeref:typename:int
T	code/Graph Theory/Virtual Tree.cpp	/^int par[N][20], dep[N], sz[N], st[N], en[N], T;$/;"	v	typeref:typename:int
T	code/Number Theory/CRT.cpp	/^using T = __int128;$/;"	t	typeref:typename:__int128	file:
T	code/Number Theory/Dirichlet Convolution.cpp	/^  const int T = 1e7 + 9;$/;"	v	namespace:Dirichlet	typeref:typename:const int
T	code/Number Theory/Intersection of Arithmetic Progressions.cpp	/^using T = __int128;$/;"	t	typeref:typename:__int128	file:
T	code/Number Theory/Linear Diophantine Equation Three Variables with Nonnegative Solutions.cpp	/^using T = __int128;$/;"	t	typeref:typename:__int128	file:
T	code/Number Theory/Min_25 Sieve.cpp	/^using T = mint;$/;"	t	typeref:typename:mint	file:
T	code/Number Theory/Smallest Nonnegative Integer x s.t. l <= ax % p <= r.cpp	/^using T = __int128;$/;"	t	typeref:typename:__int128	file:
T	practice/usacoguide/gold/SP/flightdiscount.cpp	/^	using T = pair<ll, pair<int, int>>; priority_queue<T, vector<T>, greater<T>> pq;$/;"	t	function:dijkstra	typeref:typename:pair<ll,pair<int,int>>	file:
T	practice/usacoguide/gold/SP/pump.cpp	/^	using T = pair<ll,int>; priority_queue<T,vector<T>,greater<T>> pq;$/;"	t	function:dijkstra	typeref:typename:pair<ll,int>	file:
T	practice/usacoguide/gold/SP/visitfj.cpp	/^    using T = pair<ll, pair<int, int>>; priority_queue<T, vector<T>, greater<T>> pq;$/;"	t	function:dijkstra	typeref:typename:pair<ll,pair<int,int>>	file:
T	practice/usacoguide/gold/SP/visitfj/main.cpp	/^    using T = pair<pair<ll, int>, pair<int, int>>; priority_queue<T, vector<T>, greater<T>> pq;$/;"	t	function:dijkstra	typeref:typename:pair<pair<ll,int>,pair<int,int>>	file:
TEC	code-library/Graph Theory/Three Edge Connectivity.cpp	/^vector<vector<int>> TEC(vector<vector<int>> g) {$/;"	f	typeref:typename:vector<vector<int>>
TEC	code/Graph Theory/Three Edge Connectivity.cpp	/^vector<vector<int>> TEC(vector<vector<int>> g) {$/;"	f	typeref:typename:vector<vector<int>>
TECC	code-library/Graph Theory/Articulation Bridges.cpp	/^  TECC(const vector<vector<int>> &g): g(g), n(g.size()), used(n), comp(n, -1), ord(n), low(n), k/;"	f	struct:TECC	file:
TECC	code-library/Graph Theory/Articulation Bridges.cpp	/^struct TECC { \/\/ 0 indexed$/;"	s	file:
TECC	code/Graph Theory/Articulation Bridges.cpp	/^  TECC(const vector<vector<int>> &g): g(g), n(g.size()), used(n), comp(n, -1), ord(n), low(n), k/;"	f	struct:TECC	file:
TECC	code/Graph Theory/Articulation Bridges.cpp	/^struct TECC { \/\/ 0 indexed$/;"	s	file:
TT	practice/usacoguide/gold/SP/visitfj.cpp	/^int N, TT;$/;"	v	typeref:typename:int
TT	practice/usacoguide/gold/SP/visitfj/main.cpp	/^int N, TT;$/;"	v	typeref:typename:int
TermWrapper	.config/nvim/init.vim	/^function! TermWrapper(command) abort$/;"	f
TermWrapper	dotfiles/init.vim	/^function! TermWrapper(command) abort$/;"	f
TermWrapper	dotfiles/macinit.vim	/^function! TermWrapper(command) abort$/;"	f
Thomas	code-library/Math/The Slime Trick.cpp	/^vector<mint> Thomas(vector<vector<mint>> a) {$/;"	f	typeref:typename:vector<mint>
Thomas	code-library/Math/Thomas Algorithm.cpp	/^vector<mint> Thomas(vector<vector<mint>> a) {$/;"	f	typeref:typename:vector<mint>
Thomas	code/Math/The Slime Trick.cpp	/^vector<mint> Thomas(vector<vector<mint>> a) {$/;"	f	typeref:typename:vector<mint>
Thomas	code/Math/Thomas Algorithm.cpp	/^vector<mint> Thomas(vector<vector<mint>> a) {$/;"	f	typeref:typename:vector<mint>
Topic List (For this Library, Must Check)	code-library/README.md	/^## Topic List (For this Library, Must Check)$/;"	s
Topic List (For this Library, Must Check)	code/README.md	/^## Topic List (For this Library, Must Check)$/;"	s
Tree	code-library/Graph Theory/Tree Isomorphism.cpp	/^  Tree() {}$/;"	f	struct:Tree	file:
Tree	code-library/Graph Theory/Tree Isomorphism.cpp	/^  Tree(int _n) : n(_n) {$/;"	f	struct:Tree	file:
Tree	code-library/Graph Theory/Tree Isomorphism.cpp	/^struct Tree {$/;"	s	file:
Tree	code/Graph Theory/Tree Isomorphism.cpp	/^  Tree() {}$/;"	f	struct:Tree	file:
Tree	code/Graph Theory/Tree Isomorphism.cpp	/^  Tree(int _n) : n(_n) {$/;"	f	struct:Tree	file:
Tree	code/Graph Theory/Tree Isomorphism.cpp	/^struct Tree {$/;"	s	file:
Trie	code-library/Data Structures/Trie.cpp	/^  Trie() {$/;"	f	struct:Trie	file:
Trie	code-library/Data Structures/Trie.cpp	/^struct Trie {$/;"	s	file:
Trie	code/Data Structures/Trie.cpp	/^  Trie() {$/;"	f	struct:Trie	file:
Trie	code/Data Structures/Trie.cpp	/^struct Trie {$/;"	s	file:
U	code-library/Data Structures/MOs with Update.cpp	/^} U[N];$/;"	v	typeref:struct:upd[]
U	code-library/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^int n, m, U[M], V[M], id[N], par[N];$/;"	v	typeref:typename:int[]
U	code/Data Structures/MOs with Update.cpp	/^} U[N];$/;"	v	typeref:struct:upd[]
U	code/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^int n, m, U[M], V[M], id[N], par[N];$/;"	v	typeref:typename:int[]
ULL	code-library/Miscellaneous/Parallel Binary Search.cpp	/^#define ULL(/;"	d	file:
ULL	code/Miscellaneous/Parallel Binary Search.cpp	/^#define ULL(/;"	d	file:
UNBOUNDED	code-library/Math/Simplex Algorithm.cpp	/^#define UNBOUNDED /;"	d	file:
UNBOUNDED	code/Math/Simplex Algorithm.cpp	/^#define UNBOUNDED /;"	d	file:
V	code-library/Data Structures/Segment Tree Persistent.cpp	/^int V[N], root[N], a[N];$/;"	v	typeref:typename:int[]
V	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^const int V = 18;$/;"	v	typeref:typename:const int
V	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  int V, s, t;$/;"	m	struct:Dinic	typeref:typename:int	file:
V	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  int V;$/;"	m	struct:GomoryHuTree	typeref:typename:int	file:
V	code-library/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^int n, m, U[M], V[M], id[N], par[N];$/;"	v	typeref:typename:int[]
V	code/Data Structures/Segment Tree Persistent.cpp	/^int V[N], root[N], a[N];$/;"	v	typeref:typename:int[]
V	code/Graph Theory/Chromatic Polynoimial.cpp	/^const int V = 18;$/;"	v	typeref:typename:const int
V	code/Graph Theory/Gomory Hu Tree.cpp	/^  int V, s, t;$/;"	m	struct:Dinic	typeref:typename:int	file:
V	code/Graph Theory/Gomory Hu Tree.cpp	/^  int V;$/;"	m	struct:GomoryHuTree	typeref:typename:int	file:
V	code/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^int n, m, U[M], V[M], id[N], par[N];$/;"	v	typeref:typename:int[]
VERT	code-library/Geometry/Point Location.cpp	/^enum EventType { DEL = 2, ADD = 3, GET = 1, VERT = 0 };$/;"	e	enum:EventType	file:
VERT	code/Geometry/Point Location.cpp	/^enum EventType { DEL = 2, ADD = 3, GET = 1, VERT = 0 };$/;"	e	enum:EventType	file:
Vizing	code-library/Graph Theory/Edge Coloring Simple Graph.cpp	/^namespace Vizing {$/;"	n	file:
Vizing	code/Graph Theory/Edge Coloring Simple Graph.cpp	/^namespace Vizing {$/;"	n	file:
W	.compilingScripts/init.vim	/^command! W call W()$/;"	c
W	.compilingScripts/init.vim	/^function! W()$/;"	f
W	.config/nvim/init.vim	/^command! W call W()$/;"	c
W	.config/nvim/init.vim	/^function! W()$/;"	f
W	code-library/Data Structures/Dynamic Diameter Online.cpp	/^long long W[N];$/;"	v	typeref:typename:long long[]
W	code-library/Graph Theory/Gomory Hu Tree.cpp	/^using W = long long; \/\/ types for flow and weight\/cost$/;"	t	typeref:typename:long long	file:
W	code-library/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^ll d[N][N], W[M];$/;"	v	typeref:typename:ll[]
W	code-library/Graph Theory/Minimum Weight Cycle For Each Edge.cpp	/^int g[N][N], ans[N * N], last[N], dp[N * N], id[N][N], W[N * N];$/;"	v	typeref:typename:int[]
W	code-library/Strings/Bit LCS.cpp	/^const int W = 62;$/;"	v	typeref:typename:const int
W	code/Data Structures/Dynamic Diameter Online.cpp	/^long long W[N];$/;"	v	typeref:typename:long long[]
W	code/Graph Theory/Gomory Hu Tree.cpp	/^using W = long long; \/\/ types for flow and weight\/cost$/;"	t	typeref:typename:long long	file:
W	code/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^ll d[N][N], W[M];$/;"	v	typeref:typename:ll[]
W	code/Graph Theory/Minimum Weight Cycle For Each Edge.cpp	/^int g[N][N], ans[N * N], last[N], dp[N * N], id[N][N], W[N * N];$/;"	v	typeref:typename:int[]
W	code/Strings/Bit LCS.cpp	/^const int W = 62;$/;"	v	typeref:typename:const int
W	dotfiles/init.vim	/^command! W call W()$/;"	c
W	dotfiles/init.vim	/^function! W()$/;"	f
W	dotfiles/macinit.vim	/^command! W call W()$/;"	c
W	dotfiles/macinit.vim	/^function! W()$/;"	f
Why am I sharing this library?	code-library/README.md	/^#### Why am I sharing this library?$/;"	t
Why am I sharing this library?	code/README.md	/^#### Why am I sharing this library?$/;"	t
X	code-library/Strings/Suffix Array Isomorphic.cpp	/^int buc[N], r[N], suf[N], X[N], Y[N], high[N];$/;"	v	typeref:typename:int[]
X	code/Strings/Suffix Array Isomorphic.cpp	/^int buc[N], r[N], suf[N], X[N], Y[N], high[N];$/;"	v	typeref:typename:int[]
X	practice/cf/random/1700/4.cpp	/^int N, K, X = 0;$/;"	v	typeref:typename:int
X	practice/usacoguide/gold/bfs/milkpails.cpp	/^int X, Y, K, M; $/;"	v	typeref:typename:int
XOR	code-library/Math/FWHT.cpp	/^#define XOR /;"	d	file:
XOR	code/Math/FWHT.cpp	/^#define XOR /;"	d	file:
Y	code-library/Strings/Suffix Array Isomorphic.cpp	/^int buc[N], r[N], suf[N], X[N], Y[N], high[N];$/;"	v	typeref:typename:int[]
Y	code/Strings/Suffix Array Isomorphic.cpp	/^int buc[N], r[N], suf[N], X[N], Y[N], high[N];$/;"	v	typeref:typename:int[]
Y	practice/usacoguide/gold/bfs/milkpails.cpp	/^int X, Y, K, M; $/;"	v	typeref:typename:int
Z	code-library/Dynamic Programming Optimizations/XOR Equation.cpp	/^int k, Z;$/;"	v	typeref:typename:int
Z	code-library/Miscellaneous/XOR Equation Arbitrary Range.cpp	/^int k, Z;$/;"	v	typeref:typename:int
Z	code/Dynamic Programming Optimizations/XOR Equation.cpp	/^int k, Z;$/;"	v	typeref:typename:int
Z	code/Miscellaneous/XOR Equation Arbitrary Range.cpp	/^int k, Z;$/;"	v	typeref:typename:int
["<S-Tab>"]	init.lua	/^    ["<S-Tab>"] = cmp.mapping(function(fallback)$/;"	f
["<Tab>"]	init.lua	/^	["<Tab>"] = cmp.mapping(function(fallback)$/;"	f
['[M']	init.lua	/^        ['[M'] = '@function.outer',$/;"	f
['[m']	init.lua	/^        ['[m'] = '@function.outer',$/;"	f
[']M']	init.lua	/^        [']M'] = '@function.outer',$/;"	f
[']m']	init.lua	/^        [']m'] = '@function.outer',$/;"	f
['af']	init.lua	/^        ['af'] = '@function.outer',$/;"	f
['if']	init.lua	/^        ['if'] = '@function.inner',$/;"	f
[e	.config/nvim/init.vim	/^nnoremap <silent> [e :Lspsaga diagnostic_jump_prev<CR>$/;"	m
[e	dotfiles/init.vim	/^nnoremap <silent> [e :Lspsaga diagnostic_jump_prev<CR>$/;"	m
[e	dotfiles/macinit.vim	/^nnoremap <silent> [e :Lspsaga diagnostic_jump_next<CR>$/;"	m
\\numpy	practice/club/november_olympiad_probs.tex	/^\\newcommand{\\numpy}{{\\tt numpy}}    % tt font for numpy$/;"	C
]e	.config/nvim/init.vim	/^nnoremap <silent> ]e :Lspsaga diagnostic_jump_next<CR>$/;"	m
]e	dotfiles/init.vim	/^nnoremap <silent> ]e :Lspsaga diagnostic_jump_next<CR>$/;"	m
]e	dotfiles/macinit.vim	/^nnoremap <silent> ]e :Lspsaga diagnostic_jump_prev<CR>$/;"	m
_Find_first	code-library/Miscellaneous/Bitset Custom.cpp	/^    int _Find_first() {$/;"	f	struct:Bitset	typeref:typename:int	file:
_Find_first	code/Miscellaneous/Bitset Custom.cpp	/^    int _Find_first() {$/;"	f	struct:Bitset	typeref:typename:int	file:
_Find_next	code-library/Miscellaneous/Bitset Custom.cpp	/^    int _Find_next(int k) {$/;"	f	struct:Bitset	typeref:typename:int	file:
_Find_next	code/Miscellaneous/Bitset Custom.cpp	/^    int _Find_next(int k) {$/;"	f	struct:Bitset	typeref:typename:int	file:
__add	code-library/Miscellaneous/BigInt.cpp	/^  void __add(const BigInt& v) {$/;"	f	struct:BigInt	typeref:typename:void	file:
__add	code/Miscellaneous/BigInt.cpp	/^  void __add(const BigInt& v) {$/;"	f	struct:BigInt	typeref:typename:void	file:
__anon0f7819400102	code-library/Geometry/Point Location.cpp	/^    const pair<pt_type, int>& r) {$/;"	f	function:sweepline	file:
__anon1271ab520102	code/Strings/Cyclic LCS.cpp	/^    auto eq = [&](int a, int b) {$/;"	f	function:yo	file:
__anon133b90730102	code-library/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^    sort(id + 1, id + n + 1, [&] (int i, int j) {return d[u][i] > d[u][j];});$/;"	f	function:main	file:
__anon16b6aba80102	code-library/Number Theory/Sieve upto 1e9.cpp	/^  auto approx_prime_count = [] (const int N) -> int {$/;"	f	function:sieve	typeref:typename:int	file:
__anon19349fa40102	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^        auto eval = [&](iter it) {$/;"	f	function:HalfPlaneSet::cut	file:
__anon19349fa40202	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^        auto intersect = [&](iter it)  {$/;"	f	function:HalfPlaneSet::cut	file:
__anon19e624350102	code/Data Structures/Wavelet Tree.cpp	/^    auto f = [mid](int x) {$/;"	f	function:wavelet_tree::init	file:
__anon19ee87490102	practice/december2021/1560E/sol.cpp	/^	sort(last.begin(), last.end(), [](const pair<char, int> &a, const pair<char, int> &b) { return /;"	f	function:solve	file:
__anon21e14c250102	code/Strings/De Bruijn Sequence.cpp	/^  function<void(int, int)> db = [&](int t, int p) {$/;"	f	function:de_bruijn	file:
__anon2d41255c0102	code-library/Math/Polynomial Factorization.cpp	/^    sort(inds.begin(), inds.end(), [&](int a, int b) -> bool {$/;"	f	function:main	typeref:typename:bool	file:
__anon31b62f6e0102	code-library/Dynamic Programming Optimizations/Hirschbergs Algorithm.cpp	/^        function<long long (int, int)> get_val = [&](int i, int j) {$/;"	f	function:main	file:
__anon31b62f6e0202	code-library/Dynamic Programming Optimizations/Hirschbergs Algorithm.cpp	/^        function<void (int, int, int, int)> Hirschberg = [&](int li, int lj, int ri, int rj) {$/;"	f	function:main	file:
__anon3b23e5c60102	code/Graph Theory/Gomory Hu Tree.cpp	/^  sort(t.begin(), t.end(), [](const edge & l, const edge & r) {$/;"	f	function:main	file:
__anon3e3a142a0102	code-library/Graph Theory/Three Edge Connectivity.cpp	/^  auto absorb = [&](int v, int w) -> void {$/;"	f	function:TEC	typeref:typename:void	file:
__anon3e3a142a0202	code-library/Graph Theory/Three Edge Connectivity.cpp	/^  function<void(int, int)> dfs = [&](int v, int p) -> void {$/;"	f	function:TEC	typeref:typename:void	file:
__anon433b61020102	code/Geometry/Half Plane Intersection Dynamic.cpp	/^        auto eval = [&](iter it) {$/;"	f	function:HalfPlaneSet::cut	file:
__anon433b61020202	code/Geometry/Half Plane Intersection Dynamic.cpp	/^        auto intersect = [&](iter it)  {$/;"	f	function:HalfPlaneSet::cut	file:
__anon43b35e8c0102	code-library/Graph Theory/Edge Coloring Simple Graph.cpp	/^  auto update = [&](int u) {$/;"	f	function:Vizing::solve	file:
__anon43b35e8c0202	code-library/Graph Theory/Edge Coloring Simple Graph.cpp	/^  auto color = [&](int u, int v, int c) {$/;"	f	function:Vizing::solve	file:
__anon43b35e8c0302	code-library/Graph Theory/Edge Coloring Simple Graph.cpp	/^  auto flip = [&](int u, int c1, int c2) {$/;"	f	function:Vizing::solve	file:
__anon45df0e7d0102	code-library/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^    y->succ = [ = ] { return next(y) == end() ? 0 : &*next(y); };$/;"	f	function:CHT::add	file:
__anon53cadfd70102	code-library/Data Structures/Wavelet Tree.cpp	/^    auto f = [mid](int x) {$/;"	f	function:wavelet_tree::init	file:
__anon5705b2930102	code/Graph Theory/Virtual Tree.cpp	/^  sort(v.begin(), v.end(), [](int x, int y) {$/;"	f	function:buildtree	file:
__anon5705b2930202	code/Graph Theory/Virtual Tree.cpp	/^  sort(v.begin(), v.end(), [](int x, int y) {$/;"	f	function:buildtree	file:
__anon583d7bbf0102	code-library/Geometry/Geometry 2D.cpp	/^    sort(v.begin(), v.end(), [](PT a,PT b) {$/;"	f	function:polar_sort	file:
__anon583d7bbf0202	code-library/Geometry/Geometry 2D.cpp	/^	auto tot_dist = [&](PT z) {$/;"	f	function:geometric_median	file:
__anon583d7bbf0302	code-library/Geometry/Geometry 2D.cpp	/^	auto findY = [&](double x) {$/;"	f	function:geometric_median	file:
__anon5abf6e2d0102	code-library/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^    sort(G[i].begin(), G[i].end(), [&](int e1, int e2) {$/;"	f	function:main	file:
__anon5cb8a05f0102	code-library/Dynamic Programming Optimizations/Subset Sum in SQRT.cpp	/^      sort(id[i].begin(), id[i].end(), [&](int u, int v) {$/;"	f	function:main	file:
__anon5ff5038d0102	practice/december2021/1619D/sol.cpp	/^	auto ok = [&](int alpha) -> bool {$/;"	f	function:solve	typeref:typename:bool	file:
__anon613e252a0102	code/Strings/Suffix Array Isomorphic.cpp	/^    [&](const int &i, const int &j) { \/\/ O(alpha)$/;"	f	function:IsomorphicSuffixArray::IsomorphicSuffixArray	file:
__anon63aeb5280102	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  sort(t.begin(), t.end(), [](const edge & l, const edge & r) {$/;"	f	function:main	file:
__anon651a8d740102	code/Math/Linear Recurrence With Polynomial Coefficients.cpp	/^  auto mul = [mod] (int a, int b) {$/;"	f	function:find_recurrence_relation	file:
__anon651a8d740202	code/Math/Linear Recurrence With Polynomial Coefficients.cpp	/^  auto fixed = [mod] (int a) {$/;"	f	function:find_recurrence_relation	file:
__anon651a8d740302	code/Math/Linear Recurrence With Polynomial Coefficients.cpp	/^  auto error = [] (int order, int deg) {$/;"	f	function:find_recurrence_relation	file:
__anon651a8d740402	code/Math/Linear Recurrence With Polynomial Coefficients.cpp	/^  auto verbose = [&] {$/;"	f	function:find_recurrence_relation	file:
__anon674e4d920102	code-library/Number Theory/Sum of The Number of Divisors in cbrt(n).cpp	/^  auto out = [n] (uint64 x, uint32 y) {$/;"	f	function:sum_sigma0	file:
__anon674e4d920202	code-library/Number Theory/Sum of The Number of Divisors in cbrt(n).cpp	/^  auto cut = [n] (uint64 x, uint32 dx, uint32 dy) {$/;"	f	function:sum_sigma0	file:
__anon6785d58c0102	code-library/Strings/Suffix Array Isomorphic.cpp	/^    [&](const int &i, const int &j) { \/\/ O(alpha)$/;"	f	function:IsomorphicSuffixArray::IsomorphicSuffixArray	file:
__anon6f6f14740102	code-library/Strings/Cyclic LCS.cpp	/^    auto eq = [&](int a, int b) {$/;"	f	function:yo	file:
__anon71cd1b700102	code/Number Theory/Sum of The Number of Divisors in cbrt(n).cpp	/^  auto out = [n] (uint64 x, uint32 y) {$/;"	f	function:sum_sigma0	file:
__anon71cd1b700202	code/Number Theory/Sum of The Number of Divisors in cbrt(n).cpp	/^  auto cut = [n] (uint64 x, uint32 dx, uint32 dy) {$/;"	f	function:sum_sigma0	file:
__anon77f479400102	code-library/Graph Theory/Eppsteins Algorithm.cpp	/^  auto comp = [](auto s, auto t) { return get<0>(s) > get<0>(t); };$/;"	f	function:Eppstein	file:
__anon8ace5ebd0102	code/Dynamic Programming Optimizations/Subset Sum in SQRT.cpp	/^      sort(id[i].begin(), id[i].end(), [&](int u, int v) {$/;"	f	function:main	file:
__anon8c0eb90c0102	code/Dynamic Programming Optimizations/Hirschbergs Algorithm.cpp	/^        function<long long (int, int)> get_val = [&](int i, int j) {$/;"	f	function:main	file:
__anon8c0eb90c0202	code/Dynamic Programming Optimizations/Hirschbergs Algorithm.cpp	/^        function<void (int, int, int, int)> Hirschberg = [&](int li, int lj, int ri, int rj) {$/;"	f	function:main	file:
__anon8c2a9f540102	code-library/Data Structures/Persistent Meldable Heap.cpp	/^  auto comp = [](auto s, auto t) { return get<0>(s) > get<0>(t); };$/;"	f	function:Eppstein	file:
__anon8cd840ca0102	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  auto mod_invs = [&] (vector<int>& f) {$/;"	f	function:binomial_sum_mod_p	file:
__anon8cd840ca0202	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  auto conv = [&] (vector<int>& f) -> poly {$/;"	f	function:binomial_sum_mod_p	typeref:typename:poly	file:
__anon8cd840ca0302	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  auto shift = [&] (const poly& cf, const poly& f, i64 dx) {$/;"	f	function:binomial_sum_mod_p	file:
__anon8cd840ca0402	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  function< Pair(int) > rec = [&] (int n) -> Pair {$/;"	f	function:binomial_sum_mod_p	typeref:typename:Pair	file:
__anon9783b4e80102	contests/USACO/dec_silver_2021/A/AAA.cpp	/^	sort(ranges.begin(), ranges.end(), [](const pair<pair<int, int>, int> &a, const pair<pair<int, /;"	f	function:solve	file:
__anona8b6bc9e0102	code/Graph Theory/Eppsteins Algorithm.cpp	/^  auto comp = [](auto s, auto t) { return get<0>(s) > get<0>(t); };$/;"	f	function:Eppstein	file:
__anonacb4cb990102	code/Strings/Number of Palindromes in Range.cpp	/^    auto f = [mid](int x) {$/;"	f	function:wavelet_tree::init	file:
__anonaebeb7470102	code-library/Strings/De Bruijn Sequence.cpp	/^  function<void(int, int)> db = [&](int t, int p) {$/;"	f	function:de_bruijn	file:
__anonaf660fc70102	practice/usacoguide/gold/dsu/mootube/main.cpp	/^    sort(edges.begin(), edges.end(), [](const pair<pair<int, int>, int> &a, const pair<pair<int,/;"	f	function:solve	file:
__anonaf660fc70202	practice/usacoguide/gold/dsu/mootube/main.cpp	/^    sort(queries.begin(), queries.end(), [](const pair<pair<int, int>, int> &a, const pair<pair</;"	f	function:solve	file:
__anonb0a9f9bb0102	code-library/Strings/Number of Palindromes in Range.cpp	/^    auto f = [mid](int x) {$/;"	f	function:wavelet_tree::init	file:
__anonb18a3d110102	code/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^    sort(id + 1, id + n + 1, [&] (int i, int j) {return d[u][i] > d[u][j];});$/;"	f	function:main	file:
__anonb63160b20102	code/Data Structures/Persistent Meldable Heap.cpp	/^  auto comp = [](auto s, auto t) { return get<0>(s) > get<0>(t); };$/;"	f	function:Eppstein	file:
__anonb6c4f57a0102	code/Math/Polynomial Factorization.cpp	/^    sort(inds.begin(), inds.end(), [&](int a, int b) -> bool {$/;"	f	function:main	typeref:typename:bool	file:
__anonb7afed1c0102	code/Geometry/Voronoi Diagram.cpp	/^    sort(v.begin(), v.end(), [](PT a,PT b) {$/;"	f	function:polar_sort	file:
__anonc1186c2a0102	code/Graph Theory/Edge Coloring Simple Graph.cpp	/^  auto update = [&](int u) {$/;"	f	function:Vizing::solve	file:
__anonc1186c2a0202	code/Graph Theory/Edge Coloring Simple Graph.cpp	/^  auto color = [&](int u, int v, int c) {$/;"	f	function:Vizing::solve	file:
__anonc1186c2a0302	code/Graph Theory/Edge Coloring Simple Graph.cpp	/^  auto flip = [&](int u, int c1, int c2) {$/;"	f	function:Vizing::solve	file:
__anonc30ad6880102	code/Graph Theory/Three Edge Connectivity.cpp	/^  auto absorb = [&](int v, int w) -> void {$/;"	f	function:TEC	typeref:typename:void	file:
__anonc30ad6880202	code/Graph Theory/Three Edge Connectivity.cpp	/^  function<void(int, int)> dfs = [&](int v, int p) -> void {$/;"	f	function:TEC	typeref:typename:void	file:
__anonc641421d0102	code/Geometry/Geometry 2D.cpp	/^    sort(v.begin(), v.end(), [](PT a,PT b) {$/;"	f	function:polar_sort	file:
__anonc641421d0202	code/Geometry/Geometry 2D.cpp	/^	auto tot_dist = [&](PT z) {$/;"	f	function:geometric_median	file:
__anonc641421d0302	code/Geometry/Geometry 2D.cpp	/^	auto findY = [&](double x) {$/;"	f	function:geometric_median	file:
__anonc67f371b0102	code/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^    y->succ = [ = ] { return next(y) == end() ? 0 : &*next(y); };$/;"	f	function:CHT::add	file:
__anonce9dd5d50102	code/Math/Reeds Sloane Algorithm.cpp	/^    function<ll(ll)> inverse = [&](ll a) {$/;"	f	function:LinearRecurrence::BerlekampMassey	file:
__anonce9dd5d50202	code/Math/Reeds Sloane Algorithm.cpp	/^    auto inverse = [] (ll a, ll m) {$/;"	f	function:LinearRecurrence::ReedsSloane	file:
__anonce9dd5d50302	code/Math/Reeds Sloane Algorithm.cpp	/^    auto L = [] (const vec &a, const vec &b) {$/;"	f	function:LinearRecurrence::ReedsSloane	file:
__anonce9dd5d50402	code/Math/Reeds Sloane Algorithm.cpp	/^    auto prime_power = [&] (const vec &s, ll mod, ll p, ll e) {$/;"	f	function:LinearRecurrence::ReedsSloane	file:
__anoncf61aade0102	code/Geometry/Point Location.cpp	/^    const pair<pt_type, int>& r) {$/;"	f	function:sweepline	file:
__anond56e9ac80102	practice/december2021/1572A/sol.cpp	/^	auto BFS = [&]() -> int {$/;"	f	function:solve	typeref:typename:int	file:
__anond81222d60102	code-library/Math/Linear Recurrence With Polynomial Coefficients.cpp	/^  auto mul = [mod] (int a, int b) {$/;"	f	function:find_recurrence_relation	file:
__anond81222d60202	code-library/Math/Linear Recurrence With Polynomial Coefficients.cpp	/^  auto fixed = [mod] (int a) {$/;"	f	function:find_recurrence_relation	file:
__anond81222d60302	code-library/Math/Linear Recurrence With Polynomial Coefficients.cpp	/^  auto error = [] (int order, int deg) {$/;"	f	function:find_recurrence_relation	file:
__anond81222d60402	code-library/Math/Linear Recurrence With Polynomial Coefficients.cpp	/^  auto verbose = [&] {$/;"	f	function:find_recurrence_relation	file:
__anondcd1f0060102	code/Number Theory/Sieve upto 1e9.cpp	/^  auto approx_prime_count = [] (const int N) -> int {$/;"	f	function:sieve	typeref:typename:int	file:
__anonf4fc81280102	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  auto mod_invs = [&] (vector<int>& f) {$/;"	f	function:binomial_sum_mod_p	file:
__anonf4fc81280202	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  auto conv = [&] (vector<int>& f) -> poly {$/;"	f	function:binomial_sum_mod_p	typeref:typename:poly	file:
__anonf4fc81280302	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  auto shift = [&] (const poly& cf, const poly& f, i64 dx) {$/;"	f	function:binomial_sum_mod_p	file:
__anonf4fc81280402	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  function< Pair(int) > rec = [&] (int n) -> Pair {$/;"	f	function:binomial_sum_mod_p	typeref:typename:Pair	file:
__anonf67141750102	code-library/Graph Theory/Virtual Tree.cpp	/^  sort(v.begin(), v.end(), [](int x, int y) {$/;"	f	function:buildtree	file:
__anonf67141750202	code-library/Graph Theory/Virtual Tree.cpp	/^  sort(v.begin(), v.end(), [](int x, int y) {$/;"	f	function:buildtree	file:
__anonf728a5370102	code-library/Math/Reeds Sloane Algorithm.cpp	/^    function<ll(ll)> inverse = [&](ll a) {$/;"	f	function:LinearRecurrence::BerlekampMassey	file:
__anonf728a5370202	code-library/Math/Reeds Sloane Algorithm.cpp	/^    auto inverse = [] (ll a, ll m) {$/;"	f	function:LinearRecurrence::ReedsSloane	file:
__anonf728a5370302	code-library/Math/Reeds Sloane Algorithm.cpp	/^    auto L = [] (const vec &a, const vec &b) {$/;"	f	function:LinearRecurrence::ReedsSloane	file:
__anonf728a5370402	code-library/Math/Reeds Sloane Algorithm.cpp	/^    auto prime_power = [&] (const vec &s, ll mod, ll p, ll e) {$/;"	f	function:LinearRecurrence::ReedsSloane	file:
__anonf90e1acb0102	code/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^    sort(G[i].begin(), G[i].end(), [&](int e1, int e2) {$/;"	f	function:main	file:
__anonfa9427be0102	code-library/Geometry/Voronoi Diagram.cpp	/^    sort(v.begin(), v.end(), [](PT a,PT b) {$/;"	f	function:polar_sort	file:
__cmp	code-library/Miscellaneous/BigInt.cpp	/^  friend int __cmp(const BigInt& x, const BigInt& y) {$/;"	f	typeref:typename:int	file:
__cmp	code/Miscellaneous/BigInt.cpp	/^  friend int __cmp(const BigInt& x, const BigInt& y) {$/;"	f	typeref:typename:int	file:
__id	code-library/Data Structures/Top Tree.cpp	/^  int __id;$/;"	m	struct:top_tree_node	typeref:typename:int	file:
__id	code/Data Structures/Top Tree.cpp	/^  int __id;$/;"	m	struct:top_tree_node	typeref:typename:int	file:
__sub	code-library/Miscellaneous/BigInt.cpp	/^  void __sub(const BigInt& v) {$/;"	f	struct:BigInt	typeref:typename:void	file:
__sub	code/Miscellaneous/BigInt.cpp	/^  void __sub(const BigInt& v) {$/;"	f	struct:BigInt	typeref:typename:void	file:
_add_val	code-library/Data Structures/Segment Tree Beats.cpp	/^  void _add_val(ll x, int a, int b, int k, int l, int r) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
_add_val	code/Data Structures/Segment Tree Beats.cpp	/^  void _add_val(ll x, int a, int b, int k, int l, int r) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
_query_max	code-library/Data Structures/Segment Tree Beats.cpp	/^  ll _query_max(int a, int b, int k, int l, int r) {$/;"	f	struct:SGTBeats	typeref:typename:ll	file:
_query_max	code/Data Structures/Segment Tree Beats.cpp	/^  ll _query_max(int a, int b, int k, int l, int r) {$/;"	f	struct:SGTBeats	typeref:typename:ll	file:
_query_min	code-library/Data Structures/Segment Tree Beats.cpp	/^  ll _query_min(int a, int b, int k, int l, int r) {$/;"	f	struct:SGTBeats	typeref:typename:ll	file:
_query_min	code/Data Structures/Segment Tree Beats.cpp	/^  ll _query_min(int a, int b, int k, int l, int r) {$/;"	f	struct:SGTBeats	typeref:typename:ll	file:
_query_sum	code-library/Data Structures/Segment Tree Beats.cpp	/^  ll _query_sum(int a, int b, int k, int l, int r) {$/;"	f	struct:SGTBeats	typeref:typename:ll	file:
_query_sum	code/Data Structures/Segment Tree Beats.cpp	/^  ll _query_sum(int a, int b, int k, int l, int r) {$/;"	f	struct:SGTBeats	typeref:typename:ll	file:
_rep	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^#define _rep(/;"	d	file:
_rep	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^#define _rep(/;"	d	file:
_update_max	code-library/Data Structures/Segment Tree Beats.cpp	/^  void _update_max(ll x, int a, int b, int k, int l, int r) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
_update_max	code/Data Structures/Segment Tree Beats.cpp	/^  void _update_max(ll x, int a, int b, int k, int l, int r) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
_update_min	code-library/Data Structures/Segment Tree Beats.cpp	/^  void _update_min(ll x, int a, int b, int k, int l, int r) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
_update_min	code/Data Structures/Segment Tree Beats.cpp	/^  void _update_min(ll x, int a, int b, int k, int l, int r) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
_update_val	code-library/Data Structures/Segment Tree Beats.cpp	/^  void _update_val(ll x, int a, int b, int k, int l, int r) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
_update_val	code/Data Structures/Segment Tree Beats.cpp	/^  void _update_val(ll x, int a, int b, int k, int l, int r) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
a	code-library/Data Structures/Binarizing a Tree.cpp	/^int a[N], root[N];$/;"	v	typeref:typename:int[]
a	code-library/Data Structures/Cartesian Tree.cpp	/^pair<int, int> a[N];$/;"	v	typeref:typename:pair<int,int>[]
a	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^int a[N], root[N];$/;"	v	typeref:typename:int[]
a	code-library/Data Structures/Centroid Decomposition.cpp	/^  double a, b;$/;"	m	struct:base	typeref:typename:double	file:
a	code-library/Data Structures/DSU Partially Persistent.cpp	/^int a[N];$/;"	v	typeref:typename:int[]
a	code-library/Data Structures/DSU with Rollbacks.cpp	/^int u[N], v[N], a[N];$/;"	v	typeref:typename:int[]
a	code-library/Data Structures/Dynamic Diameter Online.cpp	/^    long long a = 0, b = 0, c = 0, d = 0, e = 0;$/;"	m	struct:node	typeref:typename:long long	file:
a	code-library/Data Structures/MOs Algorithm.cpp	/^int cnt[N], a[N];$/;"	v	typeref:typename:int[]
a	code-library/Data Structures/MOs Online.cpp	/^int a[N], I[N];$/;"	v	typeref:typename:int[]
a	code-library/Data Structures/MOs on tree.cpp	/^int cnt[N], a[N], ans;$/;"	v	typeref:typename:int[]
a	code-library/Data Structures/MOs with DSU.cpp	/^edge a[N];$/;"	v	typeref:typename:edge[]
a	code-library/Data Structures/MOs with Update.cpp	/^int a[N];$/;"	v	typeref:typename:int[]
a	code-library/Data Structures/Monotonous Queue.cpp	/^  int a[N + 10], b[N + 10], l = 0, r = -1;$/;"	m	struct:monotonous_queue	typeref:typename:int[]	file:
a	code-library/Data Structures/Queue Undo Trick.cpp	/^int u[N], v[N], a[N];$/;"	v	typeref:typename:int[]
a	code-library/Data Structures/Segment Tree Beats.cpp	/^ll a[N];$/;"	v	typeref:typename:ll[]
a	code-library/Data Structures/Segment Tree Lazy.cpp	/^int a[N];$/;"	v	typeref:typename:int[]
a	code-library/Data Structures/Segment Tree Merging.cpp	/^int n, q, a[N];$/;"	v	typeref:typename:int[]
a	code-library/Data Structures/Segment Tree NonRecursive.cpp	/^int n, a[N];$/;"	v	typeref:typename:int[]
a	code-library/Data Structures/Segment Tree Persistent.cpp	/^int V[N], root[N], a[N];$/;"	v	typeref:typename:int[]
a	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^    mint a = 0, d = 0;$/;"	m	struct:ST::Int	typeref:typename:mint	file:
a	code-library/Data Structures/Segment Tree.cpp	/^int a[N];$/;"	v	typeref:typename:int[]
a	code-library/Data Structures/Sparse Table 2D.cpp	/^int a[N][N], lg2[N];$/;"	v	typeref:typename:int[][]
a	code-library/Data Structures/Sparse Table.cpp	/^int t[N][18], a[N];$/;"	v	typeref:typename:int[]
a	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^vector<int> a, blocks;$/;"	v	typeref:typename:vector<int>
a	code-library/Data Structures/Wavelet Tree.cpp	/^int a[MAXN];$/;"	v	typeref:typename:int[]
a	code-library/Dynamic Programming Optimizations/Connected Component DP.cpp	/^int n, k, a[N], dp[N][N][1005][3];$/;"	v	typeref:typename:int[]
a	code-library/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^ll a[N], b[N];$/;"	v	typeref:typename:ll[]
a	code-library/Dynamic Programming Optimizations/Divide and Conquer Optimization.cpp	/^int a[N][N], c[N][N], dp[810][N]; \/\/ dp[i][j]=minimum cost for dividing [1...j] into i parts$/;"	v	typeref:typename:int[][]
a	code-library/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^ll a[N], b[N];$/;"	v	typeref:typename:ll[]
a	code-library/Dynamic Programming Optimizations/Knuth Optimization.cpp	/^int a[N], mid[N][N];$/;"	v	typeref:typename:int[]
a	code-library/Dynamic Programming Optimizations/Number of Subsequences Having Product at least K.cpp	/^int a[N], k;$/;"	v	typeref:typename:int[]
a	code-library/Game Theory/Blue Red Hackenbush.cpp	/^} a[N];$/;"	v	typeref:struct:surreal[]
a	code-library/Geometry/All Pair Segment Intersection.cpp	/^PT a[N], d[N];$/;"	v	typeref:typename:PT[]
a	code-library/Geometry/Geometry 2D.cpp	/^    PT a, b; \/\/ goes through points a and b$/;"	m	struct:line	typeref:typename:PT	file:
a	code-library/Geometry/Geometry 2D.cpp	/^    PT a, b;$/;"	m	struct:HP	typeref:typename:PT	file:
a	code-library/Geometry/Geometry 3D.cpp	/^        int a, b, c; \/\/ the number of three points on one face of the convex hull$/;"	m	struct:CH3D::face	typeref:typename:int	file:
a	code-library/Geometry/Half Plane Intersection.cpp	/^    PT a, b;$/;"	m	struct:HP	typeref:typename:PT	file:
a	code-library/Graph Theory/Bellman Ford.cpp	/^  int a, b, cost;$/;"	m	struct:st	typeref:typename:int	file:
a	code-library/Graph Theory/Boruvka's Algorithm.cpp	/^int a[N];$/;"	v	typeref:typename:int[]
a	code-library/Graph Theory/Chordal Graph.cpp	/^int a[N], b[N];$/;"	v	typeref:typename:int[]
a	code-library/Graph Theory/Min Cut in a Planar Graph.cpp	/^int n, s, t, a[N];$/;"	v	typeref:typename:int[]
a	code-library/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^  double a, b;$/;"	m	struct:base	typeref:typename:double	file:
a	code-library/Graph Theory/Path Union.cpp	/^int a[N];$/;"	v	typeref:typename:int[]
a	code-library/Graph Theory/System Of Difference Constraints.cpp	/^int a[N], ans[N];$/;"	v	typeref:typename:int[]
a	code-library/Math/All Possible Perfect Matching XOR Values.cpp	/^int a[N][N], p[N], n, vis[N];$/;"	v	typeref:typename:int[][]
a	code-library/Math/Basis Vector Reduced Row Echelon Form.cpp	/^  int a[B];$/;"	m	struct:Basis	typeref:typename:int[]	file:
a	code-library/Math/Basis Vector Reduced Row Echelon Form.cpp	/^int a[N], p[N];$/;"	v	typeref:typename:int[]
a	code-library/Math/Basis Vector ft Weighted Linearly Independent Vectors.cpp	/^  T a[B];$/;"	m	struct:Basis	typeref:typename:T[]	file:
a	code-library/Math/Basis Vector.cpp	/^  vector<int> a;$/;"	m	struct:Basis	typeref:typename:vector<int>	file:
a	code-library/Math/Determinant of Sparse Matrix.cpp	/^  vector< vector<int> > a;$/;"	m	struct:Mat	typeref:typename:vector<vector<int>>	file:
a	code-library/Math/FFT.cpp	/^  double a, b;$/;"	m	struct:base	typeref:typename:double	file:
a	code-library/Math/FWHT in Any Base.cpp	/^    int a[MXK][MXK], n, m;$/;"	m	struct:FWHT::Matrix	typeref:typename:int[][]	file:
a	code-library/Math/FWHT in Ternary Base.cpp	/^  mint a, b;$/;"	m	struct:cmplx	typeref:typename:mint	file:
a	code-library/Math/Faulhaber Formula Fastest.cpp	/^  vector<mint> a;$/;"	m	struct:poly	typeref:typename:vector<mint>	file:
a	code-library/Math/Faulhaber Formula Fastest.cpp	/^int a[N];$/;"	v	typeref:typename:int[]
a	code-library/Math/Finite Field Arithmetic Binary.cpp	/^int a[N][N];$/;"	v	typeref:typename:int[][]
a	code-library/Math/Freivalds Algorithm.cpp	/^  vector< vector<int> > a;$/;"	m	struct:Mat	typeref:typename:vector<vector<int>>	file:
a	code-library/Math/Inverse of A Matrix modulo 2.cpp	/^int a[500500], b[500500];$/;"	v	typeref:typename:int[500500]
a	code-library/Math/Matrix Exponentiation.cpp	/^  vector<vector<int>> a;$/;"	m	struct:Mat	typeref:typename:vector<vector<int>>	file:
a	code-library/Math/NTT Online.cpp	/^int ans[N], a[N], dp[N];$/;"	v	typeref:typename:int[]
a	code-library/Math/Permanent of a Matrix.cpp	/^int n, a[N][N];$/;"	v	typeref:typename:int[][]
a	code-library/Math/Polynomial.cpp	/^  vector<mint> a;$/;"	m	struct:poly	typeref:typename:vector<mint>	file:
a	code-library/Math/Simplex Algorithm.cpp	/^ll n,k,a[N],dis[N][N];$/;"	v	typeref:typename:ll[]
a	code-library/Math/Subset Sum Problem.cpp	/^  vector<mint> a;$/;"	m	struct:poly	typeref:typename:vector<mint>	file:
a	code-library/Math/The Slime Trick.cpp	/^int a[N];$/;"	v	typeref:typename:int[]
a	code-library/Math/Thomas Algorithm.cpp	/^int a[N];$/;"	v	typeref:typename:int[]
a	code-library/Miscellaneous/BigInt.cpp	/^  vector<int> a;$/;"	m	struct:BigInt	typeref:typename:vector<int>	file:
a	code-library/Miscellaneous/Bitset Custom.cpp	/^    unsigned long long a[sz];$/;"	m	struct:Bitset	typeref:typename:unsigned long long[]	file:
a	code-library/Miscellaneous/Bitset Custom.cpp	/^int a[N], ans[N];$/;"	v	typeref:typename:int[]
a	code-library/Miscellaneous/MEX of all Subarrays.cpp	/^int a[N], f[N];$/;"	v	typeref:typename:int[]
a	code-library/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^ll a[N];$/;"	v	typeref:typename:ll[]
a	code-library/Miscellaneous/Parallel Binary Search.cpp	/^vector<int> a[N];$/;"	v	typeref:typename:vector<int>[]
a	code-library/Number Theory/Bell Number.cpp	/^    vector<mint> a;$/;"	m	struct:poly	typeref:typename:vector<mint>	file:
a	code-library/Number Theory/Linear Diophantine With N Unknowns and Two Equations.cpp	/^ll a, b, coeff; \/\/ possible points that can be generated are of the form (a * m, b * m + k * c/;"	v	typeref:typename:ll
a	code-library/Number Theory/Min_25 Sieve.cpp	/^ll a[N];$/;"	v	typeref:typename:ll[]
a	code-library/Number Theory/Mobius Function.cpp	/^int a[N];$/;"	v	typeref:typename:int[]
a	code-library/Number Theory/Phi Field.cpp	/^  mint a, b;$/;"	m	struct:field	typeref:typename:mint	file:
a	code-library/Number Theory/Power Tower.cpp	/^int a[N];$/;"	v	typeref:typename:int[]
a	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    vector<mint> a;$/;"	m	struct:poly	typeref:typename:vector<mint>	file:
a	code-library/Strings/Number of Palindromes in Range.cpp	/^int a[N], b[N], c[N], d[N];$/;"	v	typeref:typename:int[]
a	code-library/Strings/String Matching With FFT.cpp	/^  double a, b;$/;"	m	struct:base	typeref:typename:double	file:
a	code-library/Strings/Suffix Array Isomorphic.cpp	/^  vector<int> sa, rank, lcp, a;$/;"	m	struct:IsomorphicSuffixArray	typeref:typename:vector<int>	file:
a	code/Data Structures/Binarizing a Tree.cpp	/^int a[N], root[N];$/;"	v	typeref:typename:int[]
a	code/Data Structures/Cartesian Tree.cpp	/^pair<int, int> a[N];$/;"	v	typeref:typename:pair<int,int>[]
a	code/Data Structures/Centroid Decomposition Persistent.cpp	/^int a[N], root[N];$/;"	v	typeref:typename:int[]
a	code/Data Structures/Centroid Decomposition.cpp	/^  double a, b;$/;"	m	struct:base	typeref:typename:double	file:
a	code/Data Structures/DSU Partially Persistent.cpp	/^int a[N];$/;"	v	typeref:typename:int[]
a	code/Data Structures/DSU with Rollbacks.cpp	/^int u[N], v[N], a[N];$/;"	v	typeref:typename:int[]
a	code/Data Structures/Dynamic Diameter Online.cpp	/^    long long a = 0, b = 0, c = 0, d = 0, e = 0;$/;"	m	struct:node	typeref:typename:long long	file:
a	code/Data Structures/MOs Algorithm.cpp	/^int cnt[N], a[N];$/;"	v	typeref:typename:int[]
a	code/Data Structures/MOs Online.cpp	/^int a[N], I[N];$/;"	v	typeref:typename:int[]
a	code/Data Structures/MOs on tree.cpp	/^int cnt[N], a[N], ans;$/;"	v	typeref:typename:int[]
a	code/Data Structures/MOs with DSU.cpp	/^edge a[N];$/;"	v	typeref:typename:edge[]
a	code/Data Structures/MOs with Update.cpp	/^int a[N];$/;"	v	typeref:typename:int[]
a	code/Data Structures/Monotonous Queue.cpp	/^  int a[N + 10], b[N + 10], l = 0, r = -1;$/;"	m	struct:monotonous_queue	typeref:typename:int[]	file:
a	code/Data Structures/Queue Undo Trick.cpp	/^int u[N], v[N], a[N];$/;"	v	typeref:typename:int[]
a	code/Data Structures/Segment Tree Beats.cpp	/^ll a[N];$/;"	v	typeref:typename:ll[]
a	code/Data Structures/Segment Tree Lazy.cpp	/^int a[N];$/;"	v	typeref:typename:int[]
a	code/Data Structures/Segment Tree Merging.cpp	/^int n, q, a[N];$/;"	v	typeref:typename:int[]
a	code/Data Structures/Segment Tree NonRecursive.cpp	/^int n, a[N];$/;"	v	typeref:typename:int[]
a	code/Data Structures/Segment Tree Persistent.cpp	/^int V[N], root[N], a[N];$/;"	v	typeref:typename:int[]
a	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^    mint a = 0, d = 0;$/;"	m	struct:ST::Int	typeref:typename:mint	file:
a	code/Data Structures/Segment Tree.cpp	/^int a[N];$/;"	v	typeref:typename:int[]
a	code/Data Structures/Sparse Table 2D.cpp	/^int a[N][N], lg2[N];$/;"	v	typeref:typename:int[][]
a	code/Data Structures/Sparse Table.cpp	/^int t[N][18], a[N];$/;"	v	typeref:typename:int[]
a	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^vector<int> a, blocks;$/;"	v	typeref:typename:vector<int>
a	code/Data Structures/Wavelet Tree.cpp	/^int a[MAXN];$/;"	v	typeref:typename:int[]
a	code/Dynamic Programming Optimizations/Connected Component DP.cpp	/^int n, k, a[N], dp[N][N][1005][3];$/;"	v	typeref:typename:int[]
a	code/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^ll a[N], b[N];$/;"	v	typeref:typename:ll[]
a	code/Dynamic Programming Optimizations/Divide and Conquer Optimization.cpp	/^int a[N][N], c[N][N], dp[810][N]; \/\/ dp[i][j]=minimum cost for dividing [1...j] into i parts$/;"	v	typeref:typename:int[][]
a	code/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^ll a[N], b[N];$/;"	v	typeref:typename:ll[]
a	code/Dynamic Programming Optimizations/Knuth Optimization.cpp	/^int a[N], mid[N][N];$/;"	v	typeref:typename:int[]
a	code/Dynamic Programming Optimizations/Number of Subsequences Having Product at least K.cpp	/^int a[N], k;$/;"	v	typeref:typename:int[]
a	code/Game Theory/Blue Red Hackenbush.cpp	/^} a[N];$/;"	v	typeref:struct:surreal[]
a	code/Geometry/All Pair Segment Intersection.cpp	/^PT a[N], d[N];$/;"	v	typeref:typename:PT[]
a	code/Geometry/Geometry 2D.cpp	/^    PT a, b; \/\/ goes through points a and b$/;"	m	struct:line	typeref:typename:PT	file:
a	code/Geometry/Geometry 2D.cpp	/^    PT a, b;$/;"	m	struct:HP	typeref:typename:PT	file:
a	code/Geometry/Geometry 3D.cpp	/^        int a, b, c; \/\/ the number of three points on one face of the convex hull$/;"	m	struct:CH3D::face	typeref:typename:int	file:
a	code/Geometry/Half Plane Intersection.cpp	/^    PT a, b;$/;"	m	struct:HP	typeref:typename:PT	file:
a	code/Graph Theory/Bellman Ford.cpp	/^  int a, b, cost;$/;"	m	struct:st	typeref:typename:int	file:
a	code/Graph Theory/Boruvka's Algorithm.cpp	/^int a[N];$/;"	v	typeref:typename:int[]
a	code/Graph Theory/Chordal Graph.cpp	/^int a[N], b[N];$/;"	v	typeref:typename:int[]
a	code/Graph Theory/Min Cut in a Planar Graph.cpp	/^int n, s, t, a[N];$/;"	v	typeref:typename:int[]
a	code/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^  double a, b;$/;"	m	struct:base	typeref:typename:double	file:
a	code/Graph Theory/Path Union.cpp	/^int a[N];$/;"	v	typeref:typename:int[]
a	code/Graph Theory/System Of Difference Constraints.cpp	/^int a[N], ans[N];$/;"	v	typeref:typename:int[]
a	code/Math/All Possible Perfect Matching XOR Values.cpp	/^int a[N][N], p[N], n, vis[N];$/;"	v	typeref:typename:int[][]
a	code/Math/Basis Vector Reduced Row Echelon Form.cpp	/^  int a[B];$/;"	m	struct:Basis	typeref:typename:int[]	file:
a	code/Math/Basis Vector Reduced Row Echelon Form.cpp	/^int a[N], p[N];$/;"	v	typeref:typename:int[]
a	code/Math/Basis Vector ft Weighted Linearly Independent Vectors.cpp	/^  T a[B];$/;"	m	struct:Basis	typeref:typename:T[]	file:
a	code/Math/Basis Vector.cpp	/^  vector<int> a;$/;"	m	struct:Basis	typeref:typename:vector<int>	file:
a	code/Math/Determinant of Sparse Matrix.cpp	/^  vector< vector<int> > a;$/;"	m	struct:Mat	typeref:typename:vector<vector<int>>	file:
a	code/Math/FFT.cpp	/^  double a, b;$/;"	m	struct:base	typeref:typename:double	file:
a	code/Math/FWHT in Any Base.cpp	/^    int a[MXK][MXK], n, m;$/;"	m	struct:FWHT::Matrix	typeref:typename:int[][]	file:
a	code/Math/FWHT in Ternary Base.cpp	/^  mint a, b;$/;"	m	struct:cmplx	typeref:typename:mint	file:
a	code/Math/Faulhaber Formula Fastest.cpp	/^  vector<mint> a;$/;"	m	struct:poly	typeref:typename:vector<mint>	file:
a	code/Math/Faulhaber Formula Fastest.cpp	/^int a[N];$/;"	v	typeref:typename:int[]
a	code/Math/Finite Field Arithmetic Binary.cpp	/^int a[N][N];$/;"	v	typeref:typename:int[][]
a	code/Math/Freivalds Algorithm.cpp	/^  vector< vector<int> > a;$/;"	m	struct:Mat	typeref:typename:vector<vector<int>>	file:
a	code/Math/Inverse of A Matrix modulo 2.cpp	/^int a[500500], b[500500];$/;"	v	typeref:typename:int[500500]
a	code/Math/Matrix Exponentiation.cpp	/^  vector<vector<int>> a;$/;"	m	struct:Mat	typeref:typename:vector<vector<int>>	file:
a	code/Math/NTT Online.cpp	/^int ans[N], a[N], dp[N];$/;"	v	typeref:typename:int[]
a	code/Math/Permanent of a Matrix.cpp	/^int n, a[N][N];$/;"	v	typeref:typename:int[][]
a	code/Math/Polynomial.cpp	/^  vector<mint> a;$/;"	m	struct:poly	typeref:typename:vector<mint>	file:
a	code/Math/Simplex Algorithm.cpp	/^ll n,k,a[N],dis[N][N];$/;"	v	typeref:typename:ll[]
a	code/Math/Subset Sum Problem.cpp	/^  vector<mint> a;$/;"	m	struct:poly	typeref:typename:vector<mint>	file:
a	code/Math/The Slime Trick.cpp	/^int a[N];$/;"	v	typeref:typename:int[]
a	code/Math/Thomas Algorithm.cpp	/^int a[N];$/;"	v	typeref:typename:int[]
a	code/Miscellaneous/BigInt.cpp	/^  vector<int> a;$/;"	m	struct:BigInt	typeref:typename:vector<int>	file:
a	code/Miscellaneous/Bitset Custom.cpp	/^    unsigned long long a[sz];$/;"	m	struct:Bitset	typeref:typename:unsigned long long[]	file:
a	code/Miscellaneous/Bitset Custom.cpp	/^int a[N], ans[N];$/;"	v	typeref:typename:int[]
a	code/Miscellaneous/MEX of all Subarrays.cpp	/^int a[N], f[N];$/;"	v	typeref:typename:int[]
a	code/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^ll a[N];$/;"	v	typeref:typename:ll[]
a	code/Miscellaneous/Parallel Binary Search.cpp	/^vector<int> a[N];$/;"	v	typeref:typename:vector<int>[]
a	code/Number Theory/Bell Number.cpp	/^    vector<mint> a;$/;"	m	struct:poly	typeref:typename:vector<mint>	file:
a	code/Number Theory/Linear Diophantine With N Unknowns and Two Equations.cpp	/^ll a, b, coeff; \/\/ possible points that can be generated are of the form (a * m, b * m + k * c/;"	v	typeref:typename:ll
a	code/Number Theory/Min_25 Sieve.cpp	/^ll a[N];$/;"	v	typeref:typename:ll[]
a	code/Number Theory/Mobius Function.cpp	/^int a[N];$/;"	v	typeref:typename:int[]
a	code/Number Theory/Phi Field.cpp	/^  mint a, b;$/;"	m	struct:field	typeref:typename:mint	file:
a	code/Number Theory/Power Tower.cpp	/^int a[N];$/;"	v	typeref:typename:int[]
a	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    vector<mint> a;$/;"	m	struct:poly	typeref:typename:vector<mint>	file:
a	code/Strings/Number of Palindromes in Range.cpp	/^int a[N], b[N], c[N], d[N];$/;"	v	typeref:typename:int[]
a	code/Strings/String Matching With FFT.cpp	/^  double a, b;$/;"	m	struct:base	typeref:typename:double	file:
a	code/Strings/Suffix Array Isomorphic.cpp	/^  vector<int> sa, rank, lcp, a;$/;"	m	struct:IsomorphicSuffixArray	typeref:typename:vector<int>	file:
a	practice/cpbook/ch1/1.6/reallife/medium/01091/ac.cpp	/^int n, a[maxn], b[maxn];$/;"	v	typeref:typename:int[]
abs	code-library/Geometry/Geometry 3D.cpp	/^    double abs() { return sqrt(x * x + y * y + z * z); }$/;"	f	struct:p3	typeref:typename:double	file:
abs	code-library/Geometry/Geometry 3D.cpp	/^double abs(p3 v) { return sqrt(sq(v)); }$/;"	f	typeref:typename:double
abs	code-library/Miscellaneous/BigInt.cpp	/^  BigInt abs() const {$/;"	f	struct:BigInt	typeref:typename:BigInt	file:
abs	code/Geometry/Geometry 3D.cpp	/^    double abs() { return sqrt(x * x + y * y + z * z); }$/;"	f	struct:p3	typeref:typename:double	file:
abs	code/Geometry/Geometry 3D.cpp	/^double abs(p3 v) { return sqrt(sq(v)); }$/;"	f	typeref:typename:double
abs	code/Miscellaneous/BigInt.cpp	/^  BigInt abs() const {$/;"	f	struct:BigInt	typeref:typename:BigInt	file:
ac	code-library/Data Structures/Static to Dynamic Trick.cpp	/^  aho_corasick_static ac[20];$/;"	m	struct:aho_corasick	typeref:typename:aho_corasick_static[20]	file:
ac	code-library/Strings/Aho Corasick Dynamic.cpp	/^  aho_corasick_static ac[20];$/;"	m	struct:aho_corasick	typeref:typename:aho_corasick_static[20]	file:
ac	code/Data Structures/Static to Dynamic Trick.cpp	/^  aho_corasick_static ac[20];$/;"	m	struct:aho_corasick	typeref:typename:aho_corasick_static[20]	file:
ac	code/Strings/Aho Corasick Dynamic.cpp	/^  aho_corasick_static ac[20];$/;"	m	struct:aho_corasick	typeref:typename:aho_corasick_static[20]	file:
access	code-library/Data Structures/Link Cut Tree.cpp	/^  int access(int _u) {$/;"	f	struct:LCT	typeref:typename:int	file:
access	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  void access(int x, int v) {$/;"	f	namespace:lct	typeref:typename:void
access	code/Data Structures/Link Cut Tree.cpp	/^  int access(int _u) {$/;"	f	struct:LCT	typeref:typename:int	file:
access	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  void access(int x, int v) {$/;"	f	namespace:lct	typeref:typename:void
ad	code-library/Game Theory/Matching Game On A Graph.cpp	/^  bool ad[N];$/;"	m	struct:Blossom	typeref:typename:bool[]	file:
ad	code-library/Graph Theory/Blossom Algorithm.cpp	/^  bool ad[N];$/;"	m	struct:Blossom	typeref:typename:bool[]	file:
ad	code/Game Theory/Matching Game On A Graph.cpp	/^  bool ad[N];$/;"	m	struct:Blossom	typeref:typename:bool[]	file:
ad	code/Graph Theory/Blossom Algorithm.cpp	/^  bool ad[N];$/;"	m	struct:Blossom	typeref:typename:bool[]	file:
add	code-library/Data Structures/DSU on Tree.cpp	/^void add(int u, int p, int x) {$/;"	f	typeref:typename:void
add	code-library/Data Structures/MOs Online.cpp	/^  void add(int x) {$/;"	f	struct:MEX	typeref:typename:void	file:
add	code-library/Data Structures/MOs on tree.cpp	/^inline void add(int u) {$/;"	f	typeref:typename:void
add	code-library/Data Structures/MOs with DSU.cpp	/^void add(int idx) {$/;"	f	typeref:typename:void
add	code-library/Data Structures/MOs with Update.cpp	/^inline void add(int x) {$/;"	f	typeref:typename:void
add	code-library/Data Structures/Venice Technique.cpp	/^  void add(long long x) { sum += x; }$/;"	f	struct:PQ	typeref:typename:void	file:
add	code-library/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^  void add(ll _m, ll _b) {$/;"	f	struct:CHT	typeref:typename:void	file:
add	code-library/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^  void add(ll m, ll b) {$/;"	f	struct:CHT	typeref:typename:void	file:
add	code-library/Game Theory/Blue Red Hackenbush.cpp	/^  void add(int x) {$/;"	f	struct:surreal	typeref:typename:void	file:
add	code-library/Geometry/Convec Hull Dynamic.cpp	/^inline void add(set<pair<int, int>>& hull, const PT& p, long long& scross) { \/\/no collinear PT/;"	f	typeref:typename:void
add	code-library/Geometry/Convec Hull Dynamic.cpp	/^inline void add(set<pair<int, int>>& hull, iter it, long long& scross) {$/;"	f	typeref:typename:void
add	code-library/Geometry/Geometry 2D.cpp	/^    void add(double xx, double yy, double rr) {$/;"	f	struct:CircleUnion	typeref:typename:void	file:
add	code-library/Graph Theory/2 SAT.cpp	/^  void add(int a,bool af,int b,bool bf) {$/;"	f	struct:twosat	typeref:typename:void	file:
add	code-library/Graph Theory/3 SAT.cpp	/^  void add(int u, int af, int v = 1e9, int bf = 0, int w = 1e9, int cf = 0) {$/;"	f	struct:SAT_GOD	typeref:typename:void	file:
add	code-library/Graph Theory/Boruvka's Algorithm.cpp	/^void add(int x, int id) {$/;"	f	typeref:typename:void
add	code-library/Graph Theory/Dijkstra on Segment Tree.cpp	/^int add;$/;"	v	typeref:typename:int
add	code-library/Graph Theory/Directed MST.cpp	/^  void add(long long x) { sum += x; }$/;"	f	struct:PQ	typeref:typename:void	file:
add	code-library/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  void add(int x) {$/;"	f	struct:Euler	typeref:typename:void	file:
add	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^    void add(vector<mint>& ans, const vector<mint>& a, const vector<mint>& b) {$/;"	f	struct:Hafnian	typeref:typename:void	file:
add	code-library/Graph Theory/Kirchoffs Theorem.cpp	/^inline void add(int u, int v) {$/;"	f	typeref:typename:void
add	code-library/Graph Theory/Manhattan MST.cpp	/^void add(int u, int v, int w) {$/;"	f	typeref:typename:void
add	code-library/Graph Theory/System Of Difference Constraints.cpp	/^void add(int u, int v, int w, int ty) {$/;"	f	typeref:typename:void
add	code-library/Math/Finite Field Arithmetic Binary.cpp	/^  inline int add(int a, int b) { return a ^ b; }$/;"	f	namespace:FFA	typeref:typename:int
add	code-library/Math/Hafnian of a Matrix.cpp	/^  void add(vector<mint>& ans, const vector<mint>& a, const vector<mint>& b) {$/;"	f	namespace:Hafnian	typeref:typename:void
add	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^vector<mint> add(vector<mint> a, vector<mint> b) {$/;"	f	typeref:typename:vector<mint>
add	code-library/Number Theory/Linear Diophantine With N Unknowns and Two Equations.cpp	/^void add(ll c, ll d) {$/;"	f	typeref:typename:void
add	code-library/Number Theory/Mobius Function.cpp	/^void add(int x, int k) {$/;"	f	typeref:typename:void
add	code/Data Structures/DSU on Tree.cpp	/^void add(int u, int p, int x) {$/;"	f	typeref:typename:void
add	code/Data Structures/MOs Online.cpp	/^  void add(int x) {$/;"	f	struct:MEX	typeref:typename:void	file:
add	code/Data Structures/MOs on tree.cpp	/^inline void add(int u) {$/;"	f	typeref:typename:void
add	code/Data Structures/MOs with DSU.cpp	/^void add(int idx) {$/;"	f	typeref:typename:void
add	code/Data Structures/MOs with Update.cpp	/^inline void add(int x) {$/;"	f	typeref:typename:void
add	code/Data Structures/Venice Technique.cpp	/^  void add(long long x) { sum += x; }$/;"	f	struct:PQ	typeref:typename:void	file:
add	code/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^  void add(ll _m, ll _b) {$/;"	f	struct:CHT	typeref:typename:void	file:
add	code/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^  void add(ll m, ll b) {$/;"	f	struct:CHT	typeref:typename:void	file:
add	code/Game Theory/Blue Red Hackenbush.cpp	/^  void add(int x) {$/;"	f	struct:surreal	typeref:typename:void	file:
add	code/Geometry/Convec Hull Dynamic.cpp	/^inline void add(set<pair<int, int>>& hull, const PT& p, long long& scross) { \/\/no collinear PT/;"	f	typeref:typename:void
add	code/Geometry/Convec Hull Dynamic.cpp	/^inline void add(set<pair<int, int>>& hull, iter it, long long& scross) {$/;"	f	typeref:typename:void
add	code/Geometry/Geometry 2D.cpp	/^    void add(double xx, double yy, double rr) {$/;"	f	struct:CircleUnion	typeref:typename:void	file:
add	code/Graph Theory/2 SAT.cpp	/^  void add(int a,bool af,int b,bool bf) {$/;"	f	struct:twosat	typeref:typename:void	file:
add	code/Graph Theory/3 SAT.cpp	/^  void add(int u, int af, int v = 1e9, int bf = 0, int w = 1e9, int cf = 0) {$/;"	f	struct:SAT_GOD	typeref:typename:void	file:
add	code/Graph Theory/Boruvka's Algorithm.cpp	/^void add(int x, int id) {$/;"	f	typeref:typename:void
add	code/Graph Theory/Dijkstra on Segment Tree.cpp	/^int add;$/;"	v	typeref:typename:int
add	code/Graph Theory/Directed MST.cpp	/^  void add(long long x) { sum += x; }$/;"	f	struct:PQ	typeref:typename:void	file:
add	code/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  void add(int x) {$/;"	f	struct:Euler	typeref:typename:void	file:
add	code/Graph Theory/Hafnian of a Matrix.cpp	/^    void add(vector<mint>& ans, const vector<mint>& a, const vector<mint>& b) {$/;"	f	struct:Hafnian	typeref:typename:void	file:
add	code/Graph Theory/Kirchoffs Theorem.cpp	/^inline void add(int u, int v) {$/;"	f	typeref:typename:void
add	code/Graph Theory/Manhattan MST.cpp	/^void add(int u, int v, int w) {$/;"	f	typeref:typename:void
add	code/Graph Theory/System Of Difference Constraints.cpp	/^void add(int u, int v, int w, int ty) {$/;"	f	typeref:typename:void
add	code/Math/Finite Field Arithmetic Binary.cpp	/^  inline int add(int a, int b) { return a ^ b; }$/;"	f	namespace:FFA	typeref:typename:int
add	code/Math/Hafnian of a Matrix.cpp	/^  void add(vector<mint>& ans, const vector<mint>& a, const vector<mint>& b) {$/;"	f	namespace:Hafnian	typeref:typename:void
add	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^vector<mint> add(vector<mint> a, vector<mint> b) {$/;"	f	typeref:typename:vector<mint>
add	code/Number Theory/Linear Diophantine With N Unknowns and Two Equations.cpp	/^void add(ll c, ll d) {$/;"	f	typeref:typename:void
add	code/Number Theory/Mobius Function.cpp	/^void add(int x, int k) {$/;"	f	typeref:typename:void
add2	code-library/Graph Theory/Kirchoffs Theorem.cpp	/^inline void add2(int u, int v) {$/;"	f	typeref:typename:void
add2	code/Graph Theory/Kirchoffs Theorem.cpp	/^inline void add2(int u, int v) {$/;"	f	typeref:typename:void
addOR	code-library/Graph Theory/2 SAT.cpp	/^  void addOR(int a, bool af, int b, bool bf) {$/;"	f	struct:twosat	typeref:typename:void	file:
addOR	code/Graph Theory/2 SAT.cpp	/^  void addOR(int a, bool af, int b, bool bf) {$/;"	f	struct:twosat	typeref:typename:void	file:
addXOR	code-library/Graph Theory/2 SAT.cpp	/^  void addXOR(int a, bool af, int b, bool bf) {$/;"	f	struct:twosat	typeref:typename:void	file:
addXOR	code/Graph Theory/2 SAT.cpp	/^  void addXOR(int a, bool af, int b, bool bf) {$/;"	f	struct:twosat	typeref:typename:void	file:
add_arc	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  void add_arc(int u, int v, F c, W cost = 0) {$/;"	f	struct:FlowGraph	typeref:typename:void	file:
add_arc	code/Graph Theory/Gomory Hu Tree.cpp	/^  void add_arc(int u, int v, F c, W cost = 0) {$/;"	f	struct:FlowGraph	typeref:typename:void	file:
add_blossom	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  inline void add_blossom(int u, int lca, int v) {$/;"	f	struct:Blossom	typeref:typename:void	file:
add_blossom	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  inline void add_blossom(int u, int lca, int v) {$/;"	f	struct:Blossom	typeref:typename:void	file:
add_clause	code-library/Graph Theory/3 SAT.cpp	/^  void add_clause(const vector<int> &c) {$/;"	f	struct:SAT_GOD	typeref:typename:void	file:
add_clause	code/Graph Theory/3 SAT.cpp	/^  void add_clause(const vector<int> &c) {$/;"	f	struct:SAT_GOD	typeref:typename:void	file:
add_constraint	code-library/Math/Simplex Algorithm.cpp	/^  inline void add_constraint(long double C[], long double lim, int cmp){$/;"	f	namespace:lp	typeref:typename:void
add_constraint	code/Math/Simplex Algorithm.cpp	/^  inline void add_constraint(long double C[], long double lim, int cmp){$/;"	f	namespace:lp	typeref:typename:void
add_edge	code-library/Data Structures/Binarizing a Tree.cpp	/^inline void add_edge(int u, int v, int w) {$/;"	f	typeref:typename:void
add_edge	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^inline void add_edge(int u, int v, int w) {$/;"	f	typeref:typename:void
add_edge	code-library/Data Structures/Permutation Tree.cpp	/^void add_edge(int u, int v) { \/\/u is parent of v$/;"	f	typeref:typename:void
add_edge	code-library/Game Theory/Matching Game On A Graph.cpp	/^  void add_edge(int u, int v) {$/;"	f	struct:Blossom	typeref:typename:void	file:
add_edge	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  void add_edge(int u, int v, long long w) {$/;"	f	struct:Blossom	typeref:typename:void	file:
add_edge	code-library/Graph Theory/Blossom Algorithm.cpp	/^  void add_edge(int u, int v) {$/;"	f	struct:Blossom	typeref:typename:void	file:
add_edge	code-library/Graph Theory/Chinese Postman Problem.cpp	/^  void add_edge(int u, int v, long long w) {$/;"	f	struct:RandomizedMatching	typeref:typename:void	file:
add_edge	code-library/Graph Theory/DAG Reachability Dynamic.cpp	/^  bool add_edge(int s, int t) {$/;"	f	struct:Italiano	typeref:typename:bool	file:
add_edge	code-library/Graph Theory/Dijkstra on Segment Tree.cpp	/^inline void add_edge(int u, int v, int w) {$/;"	f	typeref:typename:void
add_edge	code-library/Graph Theory/Dinics Algorithm.cpp	/^  void add_edge(int u, int v, long long w, int id = -1) {$/;"	f	struct:Dinic	typeref:typename:void	file:
add_edge	code-library/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  void add_edge(int a, int b) {$/;"	f	struct:Euler	typeref:typename:void	file:
add_edge	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  void add_edge(int u, int v, F c, W cost = 0) {$/;"	f	struct:FlowGraph	typeref:typename:void	file:
add_edge	code-library/Graph Theory/HopCroft Karp Algorithm.cpp	/^  void add_edge(int u, int v) {$/;"	f	struct:HopcroftKarp	typeref:typename:void	file:
add_edge	code-library/Graph Theory/Hungarian Algorithm.cpp	/^  void add_edge(int u, int v, long long cost) {$/;"	f	struct:Hungarian	typeref:typename:void	file:
add_edge	code-library/Graph Theory/Kuhns Algorithm.cpp	/^  void add_edge(int a, int b) {$/;"	f	struct:Kuhn	typeref:typename:void	file:
add_edge	code-library/Graph Theory/L R Flow with Dinic.cpp	/^  void add_edge(int u, int v, int l, int r, int id = -1) {$/;"	f	struct:LR_Flow	typeref:typename:void	file:
add_edge	code-library/Graph Theory/L R Flow with Dinic.cpp	/^  void add_edge(int u, int v, long long w, int id = -1) {$/;"	f	struct:Dinic	typeref:typename:void	file:
add_edge	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  void add_edge(int u, int v, T cap, T cost, int id = -1, bool directed = true) {$/;"	f	struct:MCMF	typeref:typename:void	file:
add_edge	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  void add_edge(int u, int v, T l, T r, T cost = 0, int id = -1) {$/;"	f	struct:LR_Flow	typeref:typename:void	file:
add_edge	code-library/Graph Theory/LCA in O(1).cpp	/^  void add_edge(int a, int b) {$/;"	f	struct:LCA	typeref:typename:void	file:
add_edge	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  void add_edge(int u, int v) {$/;"	f	struct:MaximumClosure	typeref:typename:void	file:
add_edge	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  void add_edge(int u, int v, long long w, int id = -1) {$/;"	f	struct:Dinic	typeref:typename:void	file:
add_edge	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^  void add_edge(int u, int v, double w, int id = -1) {$/;"	f	struct:Dinic	typeref:typename:void	file:
add_edge	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  void add_edge(int a, int b, cost_t cost, flow_t cap) {$/;"	f	struct:mcSFlow	typeref:typename:void	file:
add_edge	code-library/Graph Theory/Min Cost Max Flow.cpp	/^  void add_edge(int u, int v, T cap, T cost, int id = -1, bool directed = true) {$/;"	f	struct:MCMF	typeref:typename:void	file:
add_edge	code-library/Graph Theory/Min Cut in a Planar Graph.cpp	/^inline void add_edge(int u, int v) {$/;"	f	typeref:typename:void
add_edge	code-library/Graph Theory/Minimum Mean Weight Cycle.cpp	/^void add_edge(char a, char b, char c, char d, int w) {$/;"	f	typeref:typename:void
add_edge	code-library/Graph Theory/Online Articulation Bridges.cpp	/^void add_edge (int a, int b) {$/;"	f	typeref:typename:void
add_edge	code-library/Graph Theory/Randomized Matching Unweighted.cpp	/^  void add_edge(int u, int v) {$/;"	f	struct:RandomizedMatching	typeref:typename:void	file:
add_edge	code-library/Graph Theory/Randomized Matching Weighted.cpp	/^	void add_edge(int u, int v, long long w) {$/;"	f	struct:RandomizedMatching	typeref:typename:void	file:
add_edge	code-library/Graph Theory/Stoer Wagner Algorithm.cpp	/^  void add_edge(int u, int v, long long w) { \/\/undirected edge, multiple edges are merged into/;"	f	struct:StoerWagner	typeref:typename:void	file:
add_edge	code-library/Graph Theory/Tree Isomorphism.cpp	/^  void add_edge(int u, int v) {$/;"	f	struct:Tree	typeref:typename:void	file:
add_edge	code-library/Graph Theory/Unique Min Cut.cpp	/^  void add_edge(int u, int v, long long w, int id = -1) {$/;"	f	struct:Dinic	typeref:typename:void	file:
add_edge	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  void add_edge(int a, int b) {$/;"	f	struct:Kuhn	typeref:typename:void	file:
add_edge	code/Data Structures/Binarizing a Tree.cpp	/^inline void add_edge(int u, int v, int w) {$/;"	f	typeref:typename:void
add_edge	code/Data Structures/Centroid Decomposition Persistent.cpp	/^inline void add_edge(int u, int v, int w) {$/;"	f	typeref:typename:void
add_edge	code/Data Structures/Permutation Tree.cpp	/^void add_edge(int u, int v) { \/\/u is parent of v$/;"	f	typeref:typename:void
add_edge	code/Game Theory/Matching Game On A Graph.cpp	/^  void add_edge(int u, int v) {$/;"	f	struct:Blossom	typeref:typename:void	file:
add_edge	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  void add_edge(int u, int v, long long w) {$/;"	f	struct:Blossom	typeref:typename:void	file:
add_edge	code/Graph Theory/Blossom Algorithm.cpp	/^  void add_edge(int u, int v) {$/;"	f	struct:Blossom	typeref:typename:void	file:
add_edge	code/Graph Theory/Chinese Postman Problem.cpp	/^  void add_edge(int u, int v, long long w) {$/;"	f	struct:RandomizedMatching	typeref:typename:void	file:
add_edge	code/Graph Theory/DAG Reachability Dynamic.cpp	/^  bool add_edge(int s, int t) {$/;"	f	struct:Italiano	typeref:typename:bool	file:
add_edge	code/Graph Theory/Dijkstra on Segment Tree.cpp	/^inline void add_edge(int u, int v, int w) {$/;"	f	typeref:typename:void
add_edge	code/Graph Theory/Dinics Algorithm.cpp	/^  void add_edge(int u, int v, long long w, int id = -1) {$/;"	f	struct:Dinic	typeref:typename:void	file:
add_edge	code/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  void add_edge(int a, int b) {$/;"	f	struct:Euler	typeref:typename:void	file:
add_edge	code/Graph Theory/Gomory Hu Tree.cpp	/^  void add_edge(int u, int v, F c, W cost = 0) {$/;"	f	struct:FlowGraph	typeref:typename:void	file:
add_edge	code/Graph Theory/HopCroft Karp Algorithm.cpp	/^  void add_edge(int u, int v) {$/;"	f	struct:HopcroftKarp	typeref:typename:void	file:
add_edge	code/Graph Theory/Hungarian Algorithm.cpp	/^  void add_edge(int u, int v, long long cost) {$/;"	f	struct:Hungarian	typeref:typename:void	file:
add_edge	code/Graph Theory/Kuhns Algorithm.cpp	/^  void add_edge(int a, int b) {$/;"	f	struct:Kuhn	typeref:typename:void	file:
add_edge	code/Graph Theory/L R Flow with Dinic.cpp	/^  void add_edge(int u, int v, int l, int r, int id = -1) {$/;"	f	struct:LR_Flow	typeref:typename:void	file:
add_edge	code/Graph Theory/L R Flow with Dinic.cpp	/^  void add_edge(int u, int v, long long w, int id = -1) {$/;"	f	struct:Dinic	typeref:typename:void	file:
add_edge	code/Graph Theory/L R Flow with MCMF.cpp	/^  void add_edge(int u, int v, T cap, T cost, int id = -1, bool directed = true) {$/;"	f	struct:MCMF	typeref:typename:void	file:
add_edge	code/Graph Theory/L R Flow with MCMF.cpp	/^  void add_edge(int u, int v, T l, T r, T cost = 0, int id = -1) {$/;"	f	struct:LR_Flow	typeref:typename:void	file:
add_edge	code/Graph Theory/LCA in O(1).cpp	/^  void add_edge(int a, int b) {$/;"	f	struct:LCA	typeref:typename:void	file:
add_edge	code/Graph Theory/Maximum Closure Problem.cpp	/^  void add_edge(int u, int v) {$/;"	f	struct:MaximumClosure	typeref:typename:void	file:
add_edge	code/Graph Theory/Maximum Closure Problem.cpp	/^  void add_edge(int u, int v, long long w, int id = -1) {$/;"	f	struct:Dinic	typeref:typename:void	file:
add_edge	code/Graph Theory/Maximum Density Subgraph.cpp	/^  void add_edge(int u, int v, double w, int id = -1) {$/;"	f	struct:Dinic	typeref:typename:void	file:
add_edge	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  void add_edge(int a, int b, cost_t cost, flow_t cap) {$/;"	f	struct:mcSFlow	typeref:typename:void	file:
add_edge	code/Graph Theory/Min Cost Max Flow.cpp	/^  void add_edge(int u, int v, T cap, T cost, int id = -1, bool directed = true) {$/;"	f	struct:MCMF	typeref:typename:void	file:
add_edge	code/Graph Theory/Min Cut in a Planar Graph.cpp	/^inline void add_edge(int u, int v) {$/;"	f	typeref:typename:void
add_edge	code/Graph Theory/Minimum Mean Weight Cycle.cpp	/^void add_edge(char a, char b, char c, char d, int w) {$/;"	f	typeref:typename:void
add_edge	code/Graph Theory/Online Articulation Bridges.cpp	/^void add_edge (int a, int b) {$/;"	f	typeref:typename:void
add_edge	code/Graph Theory/Randomized Matching Unweighted.cpp	/^  void add_edge(int u, int v) {$/;"	f	struct:RandomizedMatching	typeref:typename:void	file:
add_edge	code/Graph Theory/Randomized Matching Weighted.cpp	/^	void add_edge(int u, int v, long long w) {$/;"	f	struct:RandomizedMatching	typeref:typename:void	file:
add_edge	code/Graph Theory/Stoer Wagner Algorithm.cpp	/^  void add_edge(int u, int v, long long w) { \/\/undirected edge, multiple edges are merged into/;"	f	struct:StoerWagner	typeref:typename:void	file:
add_edge	code/Graph Theory/Tree Isomorphism.cpp	/^  void add_edge(int u, int v) {$/;"	f	struct:Tree	typeref:typename:void	file:
add_edge	code/Graph Theory/Unique Min Cut.cpp	/^  void add_edge(int u, int v, long long w, int id = -1) {$/;"	f	struct:Dinic	typeref:typename:void	file:
add_edge	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  void add_edge(int a, int b) {$/;"	f	struct:Kuhn	typeref:typename:void	file:
add_flow	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  void add_flow(Edge& e, flow_t f) {$/;"	f	struct:mcSFlow	typeref:typename:void	file:
add_flow	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  void add_flow(Edge& e, flow_t f) {$/;"	f	struct:mcSFlow	typeref:typename:void	file:
add_left	code-library/Data Structures/MOs Algorithm.cpp	/^inline void add_left(int i) {$/;"	f	typeref:typename:void
add_left	code/Data Structures/MOs Algorithm.cpp	/^inline void add_left(int i) {$/;"	f	typeref:typename:void
add_line	code-library/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  void add_line(Line line) {$/;"	f	struct:LiChaoTree	typeref:typename:void	file:
add_line	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  void add_line(Line line) {$/;"	f	struct:PersistentLiChaoTree	typeref:typename:void	file:
add_line	code/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  void add_line(Line line) {$/;"	f	struct:LiChaoTree	typeref:typename:void	file:
add_line	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  void add_line(Line line) {$/;"	f	struct:PersistentLiChaoTree	typeref:typename:void	file:
add_mod	code-library/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^  inline ll add_mod(ll x, ll y, ll m) {$/;"	f	namespace:PollardRho	typeref:typename:ll
add_mod	code-library/Number Theory/Pisano Period.cpp	/^  inline ll add_mod(ll x, ll y, ll m) {$/;"	f	namespace:PollardRho	typeref:typename:ll
add_mod	code-library/Number Theory/Pollard Rho.cpp	/^  inline ll add_mod(ll x, ll y, ll m) {$/;"	f	namespace:PollardRho	typeref:typename:ll
add_mod	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static R add_mod(R a, R b) { return int(a += b - mod) < 0 ? a + mod : a; }$/;"	f	class:poly	typeref:typename:R	file:
add_mod	code/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^  inline ll add_mod(ll x, ll y, ll m) {$/;"	f	namespace:PollardRho	typeref:typename:ll
add_mod	code/Number Theory/Pisano Period.cpp	/^  inline ll add_mod(ll x, ll y, ll m) {$/;"	f	namespace:PollardRho	typeref:typename:ll
add_mod	code/Number Theory/Pollard Rho.cpp	/^  inline ll add_mod(ll x, ll y, ll m) {$/;"	f	namespace:PollardRho	typeref:typename:ll
add_mod	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static R add_mod(R a, R b) { return int(a += b - mod) < 0 ? a + mod : a; }$/;"	f	class:poly	typeref:typename:R	file:
add_pattern	code-library/Strings/Aho Corasick.cpp	/^  int add_pattern (const string T) {$/;"	f	struct:AC	typeref:typename:int	file:
add_pattern	code/Strings/Aho Corasick.cpp	/^  int add_pattern (const string T) {$/;"	f	struct:AC	typeref:typename:int	file:
add_right	code-library/Data Structures/MOs Algorithm.cpp	/^inline void add_right(int i) {$/;"	f	typeref:typename:void
add_right	code/Data Structures/MOs Algorithm.cpp	/^inline void add_right(int i) {$/;"	f	typeref:typename:void
add_segment	code-library/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  void add_segment(Line line, int l, int r) {$/;"	f	struct:LiChaoTree	typeref:typename:void	file:
add_segment	code-library/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  void add_segment(Line nw, int l, int r, int L, int R) {$/;"	f	struct:node	typeref:typename:void	file:
add_segment	code/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  void add_segment(Line line, int l, int r) {$/;"	f	struct:LiChaoTree	typeref:typename:void	file:
add_segment	code/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  void add_segment(Line nw, int l, int r, int L, int R) {$/;"	f	struct:node	typeref:typename:void	file:
add_val	code-library/Data Structures/Segment Tree Beats.cpp	/^  void add_val(int a, int b, ll x) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
add_val	code/Data Structures/Segment Tree Beats.cpp	/^  void add_val(int a, int b, ll x) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
add_word	code-library/Data Structures/Static to Dynamic Trick.cpp	/^  void add_word(string s) {$/;"	f	struct:aho_corasick	typeref:typename:void	file:
add_word	code-library/Data Structures/Static to Dynamic Trick.cpp	/^  void add_word(string s) {$/;"	f	struct:aho_corasick_static	typeref:typename:void	file:
add_word	code-library/Strings/Aho Corasick Dynamic.cpp	/^  void add_word(string s) {$/;"	f	struct:aho_corasick	typeref:typename:void	file:
add_word	code-library/Strings/Aho Corasick Dynamic.cpp	/^  void add_word(string s) {$/;"	f	struct:aho_corasick_static	typeref:typename:void	file:
add_word	code/Data Structures/Static to Dynamic Trick.cpp	/^  void add_word(string s) {$/;"	f	struct:aho_corasick	typeref:typename:void	file:
add_word	code/Data Structures/Static to Dynamic Trick.cpp	/^  void add_word(string s) {$/;"	f	struct:aho_corasick_static	typeref:typename:void	file:
add_word	code/Strings/Aho Corasick Dynamic.cpp	/^  void add_word(string s) {$/;"	f	struct:aho_corasick	typeref:typename:void	file:
add_word	code/Strings/Aho Corasick Dynamic.cpp	/^  void add_word(string s) {$/;"	f	struct:aho_corasick_static	typeref:typename:void	file:
addall	code-library/Data Structures/Segment Tree Beats.cpp	/^  void addall(int k, ll x) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
addall	code/Data Structures/Segment Tree Beats.cpp	/^  void addall(int k, ll x) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
adj	code-library/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  vector<pair<int, int>> adj[N];$/;"	m	struct:Euler	typeref:typename:vector<pair<int,int>>[]	file:
adj	code-library/Graph Theory/Maximum Independant Set.cpp	/^vector<int> adj[N];$/;"	v	typeref:typename:vector<int>[]
adj	code/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  vector<pair<int, int>> adj[N];$/;"	m	struct:Euler	typeref:typename:vector<pair<int,int>>[]	file:
adj	code/Graph Theory/Maximum Independant Set.cpp	/^vector<int> adj[N];$/;"	v	typeref:typename:vector<int>[]
adj	contests/AtCoder/231/D.cpp	/^vector<int> adj[mxN];$/;"	v	typeref:typename:vector<int>[]
adj	contests/AtCoder/ABC211/D.cpp	/^vector<int> adj[mxN];$/;"	v	typeref:typename:vector<int>[]
adj	practice/cf/random/1700/4.cpp	/^vector<vector<int>> adj;$/;"	v	typeref:typename:vector<vector<int>>
adj	practice/cf/random/1700/test1.cpp	/^vector<int> adj[mxN];$/;"	v	typeref:typename:vector<int>[]
adj	practice/usacoguide/gold/SP/flightdiscount.cpp	/^vector<pair<int, int>> adj[mxN];$/;"	v	typeref:typename:vector<pair<int,int>>[]
adj	practice/usacoguide/gold/bfs/graphgirth.cpp	/^vector<int> adj[mxN];$/;"	v	typeref:typename:vector<int>[]
adj	practice/usacoguide/gold/bfs/graphgirth2.cpp	/^vector<int> adj[2505];$/;"	v	typeref:typename:vector<int>[2505]
adj	practice/usacoguide/gold/bfs/piggyback.cpp	/^vector<int> adj[mxN];$/;"	v	typeref:typename:vector<int>[]
adj	practice/usacoguide/gold/dsu/closing/main.cpp	/^vector<int> adj[mxN];$/;"	v	typeref:typename:vector<int>[]
adj	practice/usacoguide/gold/dsu/wormhole/main.cpp	/^vector<array<int, 3>> adj;$/;"	v	typeref:typename:vector<array<int,3>>
adj	practice/usacoguide/gold/introDP/longestpath.cpp	/^vector<int> adj[mxN];$/;"	v	typeref:typename:vector<int>[]
adj	practice/usacoguide/gold/introDP/mooney.cpp	/^vector<int> adj[mxN], weight(mxN);$/;"	v	typeref:typename:vector<int>[]
adj	practice/usacoguide/gold/introDP/time.cpp	/^vector<int> adj[mxN], in_adj[mxN];$/;"	v	typeref:typename:vector<int>[]
adjacent	code-library/Data Structures/Permutation Tree.cpp	/^bool adjacent(int i, int j) {$/;"	f	typeref:typename:bool
adjacent	code/Data Structures/Permutation Tree.cpp	/^bool adjacent(int i, int j) {$/;"	f	typeref:typename:bool
advance	code-library/Strings/Aho Corasick.cpp	/^  int advance (int u, char c) {$/;"	f	struct:AC	typeref:typename:int	file:
advance	code/Strings/Aho Corasick.cpp	/^  int advance (int u, char c) {$/;"	f	struct:AC	typeref:typename:int	file:
advance_bottom	code-library/Data Structures/Queue Undo Trick.cpp	/^  void advance_bottom() {$/;"	f	struct:DSUQueue	typeref:typename:void	file:
advance_bottom	code/Data Structures/Queue Undo Trick.cpp	/^  void advance_bottom() {$/;"	f	struct:DSUQueue	typeref:typename:void	file:
aho	code-library/Data Structures/Static to Dynamic Trick.cpp	/^aho_corasick aho;$/;"	v	typeref:typename:aho_corasick
aho	code-library/Strings/Aho Corasick Dynamic.cpp	/^aho_corasick aho;$/;"	v	typeref:typename:aho_corasick
aho	code/Data Structures/Static to Dynamic Trick.cpp	/^aho_corasick aho;$/;"	v	typeref:typename:aho_corasick
aho	code/Strings/Aho Corasick Dynamic.cpp	/^aho_corasick aho;$/;"	v	typeref:typename:aho_corasick
aho_corasick	code-library/Data Structures/Static to Dynamic Trick.cpp	/^  aho_corasick() {$/;"	f	struct:aho_corasick	file:
aho_corasick	code-library/Data Structures/Static to Dynamic Trick.cpp	/^struct aho_corasick {$/;"	s	file:
aho_corasick	code-library/Strings/Aho Corasick Dynamic.cpp	/^  aho_corasick() {$/;"	f	struct:aho_corasick	file:
aho_corasick	code-library/Strings/Aho Corasick Dynamic.cpp	/^struct aho_corasick {$/;"	s	file:
aho_corasick	code/Data Structures/Static to Dynamic Trick.cpp	/^  aho_corasick() {$/;"	f	struct:aho_corasick	file:
aho_corasick	code/Data Structures/Static to Dynamic Trick.cpp	/^struct aho_corasick {$/;"	s	file:
aho_corasick	code/Strings/Aho Corasick Dynamic.cpp	/^  aho_corasick() {$/;"	f	struct:aho_corasick	file:
aho_corasick	code/Strings/Aho Corasick Dynamic.cpp	/^struct aho_corasick {$/;"	s	file:
aho_corasick_static	code-library/Data Structures/Static to Dynamic Trick.cpp	/^  aho_corasick_static() {$/;"	f	struct:aho_corasick_static	file:
aho_corasick_static	code-library/Data Structures/Static to Dynamic Trick.cpp	/^struct aho_corasick_static {$/;"	s	file:
aho_corasick_static	code-library/Strings/Aho Corasick Dynamic.cpp	/^  aho_corasick_static() {$/;"	f	struct:aho_corasick_static	file:
aho_corasick_static	code-library/Strings/Aho Corasick Dynamic.cpp	/^struct aho_corasick_static {$/;"	s	file:
aho_corasick_static	code/Data Structures/Static to Dynamic Trick.cpp	/^  aho_corasick_static() {$/;"	f	struct:aho_corasick_static	file:
aho_corasick_static	code/Data Structures/Static to Dynamic Trick.cpp	/^struct aho_corasick_static {$/;"	s	file:
aho_corasick_static	code/Strings/Aho Corasick Dynamic.cpp	/^  aho_corasick_static() {$/;"	f	struct:aho_corasick_static	file:
aho_corasick_static	code/Strings/Aho Corasick Dynamic.cpp	/^struct aho_corasick_static {$/;"	s	file:
alicia_end	contests/LIT2021/C.cpp	/^P alicia_start, kevin_start, alicia_end, kevin_end;$/;"	v	typeref:typename:P
alicia_start	contests/LIT2021/C.cpp	/^P alicia_start, kevin_start, alicia_end, kevin_end;$/;"	v	typeref:typename:P
alive	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^vector<pair<int, int>> alive[4 * N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
alive	code/Data Structures/Dynamic Connectivity Problem.cpp	/^vector<pair<int, int>> alive[4 * N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
all	code-library/Miscellaneous/Bitset Custom.cpp	/^const unsigned long long all = (1ull << 64) - 1;$/;"	v	typeref:typename:const unsigned long long
all	code/Miscellaneous/Bitset Custom.cpp	/^const unsigned long long all = (1ull << 64) - 1;$/;"	v	typeref:typename:const unsigned long long
all	contests/Codeforces/737/C.cpp	/^#define all(/;"	d	file:
allowed_move	practice/cpbook/ch1/1.6/chess/00225/main.cpp	/^bool allowed_move() {$/;"	f	typeref:typename:bool
amin	code-library/Dynamic Programming Optimizations/Hirschbergs Algorithm.cpp	/^void amin(T &a, T b) { if (a > b) a = b; }$/;"	f	typeref:typename:void
amin	code/Dynamic Programming Optimizations/Hirschbergs Algorithm.cpp	/^void amin(T &a, T b) { if (a > b) a = b; }$/;"	f	typeref:typename:void
amount	code-library/Miscellaneous/Parallel Binary Search.cpp	/^int amount[N], want[N], st[N], en[N], l[N], r[N], ans[N];$/;"	v	typeref:typename:int[]
amount	code/Miscellaneous/Parallel Binary Search.cpp	/^int amount[N], want[N], st[N], en[N], l[N], r[N], ans[N];$/;"	v	typeref:typename:int[]
amul	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static void amul(const R* f, int s1, const R* g, int s2, R* res) {$/;"	f	class:poly	typeref:typename:void	file:
amul	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static void amul(const R* f, int s1, const R* g, int s2, R* res) {$/;"	f	class:poly	typeref:typename:void	file:
analyze	practice/cpbook/ch1/1.6/reallife/medium/tenis/main.cpp	/^pair<bool, int> analyze(int score1, int score2, int set_num, string player1, string player2) {$/;"	f	typeref:typename:pair<bool,int>
angle	code-library/Geometry/Geometry 2D.cpp	/^    inline double angle(double A, double B, double C) {$/;"	f	struct:CircleUnion	typeref:typename:double	file:
angle	code/Geometry/Geometry 2D.cpp	/^    inline double angle(double A, double B, double C) {$/;"	f	struct:CircleUnion	typeref:typename:double	file:
angle_bisector	code-library/Geometry/Geometry 2D.cpp	/^PT angle_bisector(PT &a, PT &b, PT &c){$/;"	f	typeref:typename:PT
angle_bisector	code/Geometry/Geometry 2D.cpp	/^PT angle_bisector(PT &a, PT &b, PT &c){$/;"	f	typeref:typename:PT
angle_on_sphere	code-library/Geometry/Geometry 3D.cpp	/^double angle_on_sphere(p3 a, p3 b, p3 c) {$/;"	f	typeref:typename:double
angle_on_sphere	code/Geometry/Geometry 3D.cpp	/^double angle_on_sphere(p3 a, p3 b, p3 c) {$/;"	f	typeref:typename:double
ans	code-library/Data Structures/Cartesian Tree.cpp	/^ll inv[N], ans;$/;"	v	typeref:typename:ll
ans	code-library/Data Structures/Centroid Decomposition.cpp	/^long long ans[N]; \/\/ number of paths of length i = ans[i]$/;"	v	typeref:typename:long long[]
ans	code-library/Data Structures/DSU on Tree.cpp	/^int ans[N], col[N], sz[N], cnt[N];$/;"	v	typeref:typename:int[]
ans	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^int ans[N];$/;"	v	typeref:typename:int[]
ans	code-library/Data Structures/KD Tree.cpp	/^long long ans;$/;"	v	typeref:typename:long long
ans	code-library/Data Structures/MOs Algorithm.cpp	/^long long ans[N];$/;"	v	typeref:typename:long long[]
ans	code-library/Data Structures/MOs on tree.cpp	/^int cnt[N], a[N], ans;$/;"	v	typeref:typename:int
ans	code-library/Data Structures/MOs with Update.cpp	/^int cnt[N], f[N], ans[N], l, r, t;$/;"	v	typeref:typename:int[]
ans	code-library/Data Structures/Treap.cpp	/^  vector<int> ans;$/;"	m	struct:treap	typeref:typename:vector<int>	file:
ans	code-library/Data Structures/Treap.cpp	/^int ans[N];$/;"	v	typeref:typename:int[]
ans	code-library/Dynamic Programming Optimizations/DP Over Divisors.cpp	/^int cnt[N], ans[N];$/;"	v	typeref:typename:int[]
ans	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^ll ans[N], p[N], s[N];$/;"	v	typeref:typename:ll[]
ans	code-library/Dynamic Programming Optimizations/Subset Sum in SQRT.cpp	/^int ans[N], dep[N], sz[N];$/;"	v	typeref:typename:int[]
ans	code-library/Dynamic Programming Optimizations/Subset Union of Bitsets.cpp	/^int x[N], y[N], c[N], dp[1 << 20], msk[N], ans[N];$/;"	v	typeref:typename:int[]
ans	code-library/Geometry/Onion Decomposition.cpp	/^int layer[N], ans[N];$/;"	v	typeref:typename:int[]
ans	code-library/Geometry/Voronoi Diagram.cpp	/^double ans;$/;"	v	typeref:typename:double
ans	code-library/Graph Theory/Dijkstra on Segment Tree.cpp	/^long long ans[N];$/;"	v	typeref:typename:long long[]
ans	code-library/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  vector<int> ans;$/;"	m	struct:Euler	typeref:typename:vector<int>	file:
ans	code-library/Graph Theory/Euler Path Directed.cpp	/^vector<int> g[N], ans;$/;"	v	typeref:typename:vector<int>
ans	code-library/Graph Theory/Euler Path Undirected.cpp	/^vector<int> ans;$/;"	v	typeref:typename:vector<int>
ans	code-library/Graph Theory/Johnson's Algorithm.cpp	/^long long ans[N][N];$/;"	v	typeref:typename:long long[][]
ans	code-library/Graph Theory/Minimum Weight Cycle For Each Edge.cpp	/^int g[N][N], ans[N * N], last[N], dp[N * N], id[N][N], W[N * N];$/;"	v	typeref:typename:int[]
ans	code-library/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^long long ans[N]; \/\/ number of paths of length i = ans[i]$/;"	v	typeref:typename:long long[]
ans	code-library/Graph Theory/ST Numbering.cpp	/^int ans[N];$/;"	v	typeref:typename:int[]
ans	code-library/Graph Theory/Stable Marriage Problem.cpp	/^int m[N][N], w[N][N], id[N], marry[N], ans[N], pref[N][N];$/;"	v	typeref:typename:int[]
ans	code-library/Graph Theory/System Of Difference Constraints.cpp	/^int a[N], ans[N];$/;"	v	typeref:typename:int[]
ans	code-library/Graph Theory/Virtual Tree.cpp	/^int ans;$/;"	v	typeref:typename:int
ans	code-library/Math/FFT.cpp	/^long long ans[N];$/;"	v	typeref:typename:long long[]
ans	code-library/Math/NTT Online.cpp	/^int ans[N], a[N], dp[N];$/;"	v	typeref:typename:int[]
ans	code-library/Miscellaneous/Bitset Custom.cpp	/^int a[N], ans[N];$/;"	v	typeref:typename:int[]
ans	code-library/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^vector <int> ans;$/;"	v	typeref:typename:vector<int>
ans	code-library/Miscellaneous/Parallel Binary Search.cpp	/^int amount[N], want[N], st[N], en[N], l[N], r[N], ans[N];$/;"	v	typeref:typename:int[]
ans	code-library/Miscellaneous/Subset Union of Bitsets.cpp	/^int x[N], y[N], c[N], dp[1 << 20], msk[N], ans[N];$/;"	v	typeref:typename:int[]
ans	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^mint ans[N];$/;"	v	typeref:typename:mint[]
ans	code-library/Strings/De Bruijn Sequence.cpp	/^int ans[N], aux[N];$/;"	v	typeref:typename:int[]
ans	code-library/Strings/KMP.cpp	/^vector<int>ans;$/;"	v	typeref:typename:vector<int>
ans	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^long long ans[N];$/;"	v	typeref:typename:long long[]
ans	code/Data Structures/Cartesian Tree.cpp	/^ll inv[N], ans;$/;"	v	typeref:typename:ll
ans	code/Data Structures/Centroid Decomposition.cpp	/^long long ans[N]; \/\/ number of paths of length i = ans[i]$/;"	v	typeref:typename:long long[]
ans	code/Data Structures/DSU on Tree.cpp	/^int ans[N], col[N], sz[N], cnt[N];$/;"	v	typeref:typename:int[]
ans	code/Data Structures/Dynamic Connectivity Problem.cpp	/^int ans[N];$/;"	v	typeref:typename:int[]
ans	code/Data Structures/KD Tree.cpp	/^long long ans;$/;"	v	typeref:typename:long long
ans	code/Data Structures/MOs Algorithm.cpp	/^long long ans[N];$/;"	v	typeref:typename:long long[]
ans	code/Data Structures/MOs on tree.cpp	/^int cnt[N], a[N], ans;$/;"	v	typeref:typename:int
ans	code/Data Structures/MOs with Update.cpp	/^int cnt[N], f[N], ans[N], l, r, t;$/;"	v	typeref:typename:int[]
ans	code/Data Structures/Treap.cpp	/^  vector<int> ans;$/;"	m	struct:treap	typeref:typename:vector<int>	file:
ans	code/Data Structures/Treap.cpp	/^int ans[N];$/;"	v	typeref:typename:int[]
ans	code/Dynamic Programming Optimizations/DP Over Divisors.cpp	/^int cnt[N], ans[N];$/;"	v	typeref:typename:int[]
ans	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^ll ans[N], p[N], s[N];$/;"	v	typeref:typename:ll[]
ans	code/Dynamic Programming Optimizations/Subset Sum in SQRT.cpp	/^int ans[N], dep[N], sz[N];$/;"	v	typeref:typename:int[]
ans	code/Dynamic Programming Optimizations/Subset Union of Bitsets.cpp	/^int x[N], y[N], c[N], dp[1 << 20], msk[N], ans[N];$/;"	v	typeref:typename:int[]
ans	code/Geometry/Onion Decomposition.cpp	/^int layer[N], ans[N];$/;"	v	typeref:typename:int[]
ans	code/Geometry/Voronoi Diagram.cpp	/^double ans;$/;"	v	typeref:typename:double
ans	code/Graph Theory/Dijkstra on Segment Tree.cpp	/^long long ans[N];$/;"	v	typeref:typename:long long[]
ans	code/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  vector<int> ans;$/;"	m	struct:Euler	typeref:typename:vector<int>	file:
ans	code/Graph Theory/Euler Path Directed.cpp	/^vector<int> g[N], ans;$/;"	v	typeref:typename:vector<int>
ans	code/Graph Theory/Euler Path Undirected.cpp	/^vector<int> ans;$/;"	v	typeref:typename:vector<int>
ans	code/Graph Theory/Johnson's Algorithm.cpp	/^long long ans[N][N];$/;"	v	typeref:typename:long long[][]
ans	code/Graph Theory/Minimum Weight Cycle For Each Edge.cpp	/^int g[N][N], ans[N * N], last[N], dp[N * N], id[N][N], W[N * N];$/;"	v	typeref:typename:int[]
ans	code/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^long long ans[N]; \/\/ number of paths of length i = ans[i]$/;"	v	typeref:typename:long long[]
ans	code/Graph Theory/ST Numbering.cpp	/^int ans[N];$/;"	v	typeref:typename:int[]
ans	code/Graph Theory/Stable Marriage Problem.cpp	/^int m[N][N], w[N][N], id[N], marry[N], ans[N], pref[N][N];$/;"	v	typeref:typename:int[]
ans	code/Graph Theory/System Of Difference Constraints.cpp	/^int a[N], ans[N];$/;"	v	typeref:typename:int[]
ans	code/Graph Theory/Virtual Tree.cpp	/^int ans;$/;"	v	typeref:typename:int
ans	code/Math/FFT.cpp	/^long long ans[N];$/;"	v	typeref:typename:long long[]
ans	code/Math/NTT Online.cpp	/^int ans[N], a[N], dp[N];$/;"	v	typeref:typename:int[]
ans	code/Miscellaneous/Bitset Custom.cpp	/^int a[N], ans[N];$/;"	v	typeref:typename:int[]
ans	code/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^vector <int> ans;$/;"	v	typeref:typename:vector<int>
ans	code/Miscellaneous/Parallel Binary Search.cpp	/^int amount[N], want[N], st[N], en[N], l[N], r[N], ans[N];$/;"	v	typeref:typename:int[]
ans	code/Miscellaneous/Subset Union of Bitsets.cpp	/^int x[N], y[N], c[N], dp[1 << 20], msk[N], ans[N];$/;"	v	typeref:typename:int[]
ans	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^mint ans[N];$/;"	v	typeref:typename:mint[]
ans	code/Strings/De Bruijn Sequence.cpp	/^int ans[N], aux[N];$/;"	v	typeref:typename:int[]
ans	code/Strings/KMP.cpp	/^vector<int>ans;$/;"	v	typeref:typename:vector<int>
ans	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^long long ans[N];$/;"	v	typeref:typename:long long[]
ans	contests/AtCoder/231/D.cpp	/^vector<int> ans;$/;"	v	typeref:typename:vector<int>
ans	contests/Codeforces/1622/C/sol.cpp	/^int sum = 0, ans = 0;$/;"	v	typeref:typename:int
ans	contests/LIT2021/C.cpp	/^int ans = INT_MAX;$/;"	v	typeref:typename:int
ans	contests/USACO/dec_silver_2021/B/B.cpp	/^int ans = 0;$/;"	v	typeref:typename:int
ans	practice/cf/random/i_hate_math_problems/1336B.cpp	/^int ans = LLONG_MAX;$/;"	v	typeref:typename:int
ans	practice/cpbook/ch1/1.4/medium/11956.cpp	/^int ans[mxN];$/;"	v	typeref:typename:int[]
ans	practice/cpbook/ch1/1.6/chess/chess/main.cpp	/^vector<int> ans;$/;"	v	typeref:typename:vector<int>
ans	practice/usacoguide/gold/SP/visitfj.cpp	/^ll ans = LLONG_MAX;$/;"	v	typeref:typename:ll
ans	practice/usacoguide/gold/bfs/graphgirth2.cpp	/^int ans = 5000;$/;"	v	typeref:typename:int
ans	practice/usacoguide/gold/bfs/monsters.cpp	/^string ans(int x, int y) {$/;"	f	typeref:typename:string
ans	practice/usacoguide/silver/idk/maze/main.cpp	/^int ans = 0;$/;"	v	typeref:typename:int
answer	code-library/Data Structures/MOs with DSU.cpp	/^int answer[N];$/;"	v	typeref:typename:int[]
answer	code/Data Structures/MOs with DSU.cpp	/^int answer[N];$/;"	v	typeref:typename:int[]
answers	practice/usacoguide/silver/idk/maze/main.cpp	/^set<int> answers;$/;"	v	typeref:typename:set<int>
any_intersection	code-library/Geometry/All Pair Segment Intersection.cpp	/^pair<int, int> any_intersection(const vector<seg>& a) {$/;"	f	typeref:typename:pair<int,int>
any_intersection	code/Geometry/All Pair Segment Intersection.cpp	/^pair<int, int> any_intersection(const vector<seg>& a) {$/;"	f	typeref:typename:pair<int,int>
approximate	code-library/Number Theory/Rational Approximation.cpp	/^pair<ll, ll> approximate(ld x, ll n) {$/;"	f	typeref:typename:pair<ll,ll>
approximate	code/Number Theory/Rational Approximation.cpp	/^pair<ll, ll> approximate(ld x, ll n) {$/;"	f	typeref:typename:pair<ll,ll>
ar	code-library/Math/Simplex Algorithm.cpp	/^  long double val[MAXV], ar[MAXC][MAXV];$/;"	v	namespace:lp	typeref:typename:long double[][]
ar	code/Math/Simplex Algorithm.cpp	/^  long double val[MAXV], ar[MAXC][MAXV];$/;"	v	namespace:lp	typeref:typename:long double[][]
arc	code-library/Geometry/Geometry 2D.cpp	/^    double arc, pol;$/;"	m	struct:CircleUnion	typeref:typename:double	file:
arc	code/Geometry/Geometry 2D.cpp	/^    double arc, pol;$/;"	m	struct:CircleUnion	typeref:typename:double	file:
are_lines_same	code-library/Geometry/Geometry 2D.cpp	/^bool are_lines_same(PT a, PT b, PT c, PT d) {$/;"	f	typeref:typename:bool
are_lines_same	code/Geometry/Geometry 2D.cpp	/^bool are_lines_same(PT a, PT b, PT c, PT d) {$/;"	f	typeref:typename:bool
area	code-library/Geometry/Geometry 2D.cpp	/^    double area() { return PI * r * r; }$/;"	f	struct:circle	typeref:typename:double	file:
area	code-library/Geometry/Geometry 2D.cpp	/^double area(vector<PT> &p) {$/;"	f	typeref:typename:double
area	code-library/Geometry/Geometry 3D.cpp	/^    double area(p3 a, p3 b, p3 c) {$/;"	f	struct:CH3D	typeref:typename:double	file:
area	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    double area() { \/\/ answer \/ (D * D)$/;"	f	struct:HalfPlaneSet	typeref:typename:double	file:
area	code-library/Geometry/Half Plane Intersection.cpp	/^double area(vector<PT> &p) {$/;"	f	typeref:typename:double
area	code-library/Geometry/Maximum Area of Triangle, Given are Lengths.cpp	/^inline double area( double a, double b, double c ) {$/;"	f	typeref:typename:double
area	code/Geometry/Geometry 2D.cpp	/^    double area() { return PI * r * r; }$/;"	f	struct:circle	typeref:typename:double	file:
area	code/Geometry/Geometry 2D.cpp	/^double area(vector<PT> &p) {$/;"	f	typeref:typename:double
area	code/Geometry/Geometry 3D.cpp	/^    double area(p3 a, p3 b, p3 c) {$/;"	f	struct:CH3D	typeref:typename:double	file:
area	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    double area() { \/\/ answer \/ (D * D)$/;"	f	struct:HalfPlaneSet	typeref:typename:double	file:
area	code/Geometry/Half Plane Intersection.cpp	/^double area(vector<PT> &p) {$/;"	f	typeref:typename:double
area	code/Geometry/Maximum Area of Triangle, Given are Lengths.cpp	/^inline double area( double a, double b, double c ) {$/;"	f	typeref:typename:double
area_of_triangle	code-library/Geometry/Geometry 2D.cpp	/^double area_of_triangle(PT a, PT b, PT c) {$/;"	f	typeref:typename:double
area_of_triangle	code/Geometry/Geometry 2D.cpp	/^double area_of_triangle(PT a, PT b, PT c) {$/;"	f	typeref:typename:double
area_on_the_surface_of_the_sphere	code-library/Geometry/Geometry 3D.cpp	/^double area_on_the_surface_of_the_sphere(double r, vector<p3> p) {$/;"	f	typeref:typename:double
area_on_the_surface_of_the_sphere	code/Geometry/Geometry 3D.cpp	/^double area_on_the_surface_of_the_sphere(double r, vector<p3> p) {$/;"	f	typeref:typename:double
arg	code-library/Geometry/All Pair Segment Intersection.cpp	/^    double arg() {$/;"	f	struct:PT	typeref:typename:double	file:
arg	code-library/Geometry/Geometry 2D.cpp	/^    double arg() { return atan2(y, x); }$/;"	f	struct:PT	typeref:typename:double	file:
arg	code-library/Geometry/Geometry 3D.cpp	/^    double arg() { return atan2(y, x); }$/;"	f	struct:PT	typeref:typename:double	file:
arg	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    double arg() { return atan2(y, x); }$/;"	f	struct:PT	typeref:typename:double	file:
arg	code-library/Geometry/Half Plane Intersection.cpp	/^    double arg() { return atan2(y, x); }$/;"	f	struct:PT	typeref:typename:double	file:
arg	code-library/Geometry/Voronoi Diagram.cpp	/^    double arg() { return atan2(y, x); }$/;"	f	struct:PT	typeref:typename:double	file:
arg	code-library/Graph Theory/Hungarian Algorithm.cpp	/^  int l[N], r[N], arg[N], trace[N];$/;"	m	struct:Hungarian	typeref:typename:int[]	file:
arg	code/Geometry/All Pair Segment Intersection.cpp	/^    double arg() {$/;"	f	struct:PT	typeref:typename:double	file:
arg	code/Geometry/Geometry 2D.cpp	/^    double arg() { return atan2(y, x); }$/;"	f	struct:PT	typeref:typename:double	file:
arg	code/Geometry/Geometry 3D.cpp	/^    double arg() { return atan2(y, x); }$/;"	f	struct:PT	typeref:typename:double	file:
arg	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    double arg() { return atan2(y, x); }$/;"	f	struct:PT	typeref:typename:double	file:
arg	code/Geometry/Half Plane Intersection.cpp	/^    double arg() { return atan2(y, x); }$/;"	f	struct:PT	typeref:typename:double	file:
arg	code/Geometry/Voronoi Diagram.cpp	/^    double arg() { return atan2(y, x); }$/;"	f	struct:PT	typeref:typename:double	file:
arg	code/Graph Theory/Hungarian Algorithm.cpp	/^  int l[N], r[N], arg[N], trace[N];$/;"	m	struct:Hungarian	typeref:typename:int[]	file:
arr	code-library/Data Structures/KD Tree.cpp	/^point arr[N], pts[N];$/;"	v	typeref:typename:point[]
arr	code-library/Number Theory/Maximum Coprime Product.cpp	/^int arr[N + 1];$/;"	v	typeref:typename:int[]
arr	code/Data Structures/KD Tree.cpp	/^point arr[N], pts[N];$/;"	v	typeref:typename:point[]
arr	code/Number Theory/Maximum Coprime Product.cpp	/^int arr[N + 1];$/;"	v	typeref:typename:int[]
art	code-library/Graph Theory/Articulation Points.cpp	/^int T, low[N], dis[N], art[N];$/;"	v	typeref:typename:int[]
art	code-library/Graph Theory/Block Cut Tree.cpp	/^int T, low[N], dis[N], art[N], sz;$/;"	v	typeref:typename:int[]
art	code/Graph Theory/Articulation Points.cpp	/^int T, low[N], dis[N], art[N];$/;"	v	typeref:typename:int[]
art	code/Graph Theory/Block Cut Tree.cpp	/^int T, low[N], dis[N], art[N], sz;$/;"	v	typeref:typename:int[]
assign	code-library/Data Structures/Interval Set.cpp	/^  vector<pair<pair<int, int>, T> > assign(int l, int r, T val) {$/;"	f	struct:interval_set	typeref:typename:vector<pair<pair<int,int>,T>>	file:
assign	code/Data Structures/Interval Set.cpp	/^  vector<pair<pair<int, int>, T> > assign(int l, int r, T val) {$/;"	f	struct:interval_set	typeref:typename:vector<pair<pair<int,int>,T>>	file:
assigned	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^  int assigned = -1;$/;"	m	struct:Block	typeref:typename:int	file:
assigned	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^  int assigned = -1;$/;"	m	struct:Block	typeref:typename:int	file:
at	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^    mint at(mint n) {return (a + (n - 1) * d);}$/;"	f	struct:ST::Int	typeref:typename:mint	file:
at	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^    mint at(mint n) {return (a + (n - 1) * d);}$/;"	f	struct:ST::Int	typeref:typename:mint	file:
attack	practice/cpbook/ch1/1.6/chess/10284/main.cpp	/^bool attack[8][8];$/;"	v	typeref:typename:bool[8][8]
augment	code-library/Game Theory/Matching Game On A Graph.cpp	/^  void augment(int u, int v) {$/;"	f	struct:Blossom	typeref:typename:void	file:
augment	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  inline void augment(int u, int v) {$/;"	f	struct:Blossom	typeref:typename:void	file:
augment	code-library/Graph Theory/Blossom Algorithm.cpp	/^  void augment(int u, int v) {$/;"	f	struct:Blossom	typeref:typename:void	file:
augment	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  long long augment(int u, F c) { \/\/ we reuse the same iterators$/;"	f	struct:Dinic	typeref:typename:long long	file:
augment	code-library/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^bool augment() {$/;"	f	typeref:typename:bool
augment	code/Game Theory/Matching Game On A Graph.cpp	/^  void augment(int u, int v) {$/;"	f	struct:Blossom	typeref:typename:void	file:
augment	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  inline void augment(int u, int v) {$/;"	f	struct:Blossom	typeref:typename:void	file:
augment	code/Graph Theory/Blossom Algorithm.cpp	/^  void augment(int u, int v) {$/;"	f	struct:Blossom	typeref:typename:void	file:
augment	code/Graph Theory/Gomory Hu Tree.cpp	/^  long long augment(int u, F c) { \/\/ we reuse the same iterators$/;"	f	struct:Dinic	typeref:typename:long long	file:
augment	code/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^bool augment() {$/;"	f	typeref:typename:bool
aut	code-library/Strings/Prefix Automaton.cpp	/^int aut[N][26];$/;"	v	typeref:typename:int[][26]
aut	code/Strings/Prefix Automaton.cpp	/^int aut[N][26];$/;"	v	typeref:typename:int[][26]
aux	code-library/Game Theory/Matching Game On A Graph.cpp	/^  int vis[N], par[N], orig[N], match[N], aux[N], t;$/;"	m	struct:Blossom	typeref:typename:int[]	file:
aux	code-library/Graph Theory/Blossom Algorithm.cpp	/^  int vis[N], par[N], orig[N], match[N], aux[N], t;$/;"	m	struct:Blossom	typeref:typename:int[]	file:
aux	code-library/Strings/De Bruijn Sequence.cpp	/^int ans[N], aux[N];$/;"	v	typeref:typename:int[]
aux	code/Game Theory/Matching Game On A Graph.cpp	/^  int vis[N], par[N], orig[N], match[N], aux[N], t;$/;"	m	struct:Blossom	typeref:typename:int[]	file:
aux	code/Graph Theory/Blossom Algorithm.cpp	/^  int vis[N], par[N], orig[N], match[N], aux[N], t;$/;"	m	struct:Blossom	typeref:typename:int[]	file:
aux	code/Strings/De Bruijn Sequence.cpp	/^int ans[N], aux[N];$/;"	v	typeref:typename:int[]
axis	code-library/Data Structures/KD Tree.cpp	/^  int axis, value;$/;"	m	struct:kd_node	typeref:typename:int	file:
axis	code-library/Data Structures/KD Tree.cpp	/^  int axis;$/;"	m	struct:cmp_points	typeref:typename:int	file:
axis	code/Data Structures/KD Tree.cpp	/^  int axis, value;$/;"	m	struct:kd_node	typeref:typename:int	file:
axis	code/Data Structures/KD Tree.cpp	/^  int axis;$/;"	m	struct:cmp_points	typeref:typename:int	file:
b	code-library/Data Structures/Centroid Decomposition.cpp	/^  double a, b;$/;"	m	struct:base	typeref:typename:double	file:
b	code-library/Data Structures/Dynamic Diameter Online.cpp	/^    long long a = 0, b = 0, c = 0, d = 0, e = 0;$/;"	m	struct:node	typeref:typename:long long	file:
b	code-library/Data Structures/Monotonous Queue.cpp	/^  int a[N + 10], b[N + 10], l = 0, r = -1;$/;"	m	struct:monotonous_queue	typeref:typename:int[]	file:
b	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  int b, e;$/;"	m	struct:ST	typeref:typename:int	file:
b	code-library/Data Structures/Wavelet Tree.cpp	/^  int *b, *c, bsz, csz; \/\/ c holds the prefix sum of elements$/;"	m	struct:wavelet_tree	typeref:typename:int *	file:
b	code-library/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^  vector<ll> m, b;$/;"	m	struct:CHT	typeref:typename:vector<ll>	file:
b	code-library/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^ll a[N], b[N];$/;"	v	typeref:typename:ll[]
b	code-library/Dynamic Programming Optimizations/Digit DP.cpp	/^int pw[20][20], b[1 << 10][3000], cnt[1 << 10], dp[2][20][1 << 10][2520];$/;"	v	typeref:typename:int[][3000]
b	code-library/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^  ll m, b;$/;"	m	struct:line	typeref:typename:ll	file:
b	code-library/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^ll a[N], b[N];$/;"	v	typeref:typename:ll[]
b	code-library/Geometry/Geometry 2D.cpp	/^    PT a, b; \/\/ goes through points a and b$/;"	m	struct:line	typeref:typename:PT	file:
b	code-library/Geometry/Geometry 2D.cpp	/^    PT a, b;$/;"	m	struct:HP	typeref:typename:PT	file:
b	code-library/Geometry/Geometry 3D.cpp	/^        int a, b, c; \/\/ the number of three points on one face of the convex hull$/;"	m	struct:CH3D::face	typeref:typename:int	file:
b	code-library/Geometry/Half Plane Intersection.cpp	/^    PT a, b;$/;"	m	struct:HP	typeref:typename:PT	file:
b	code-library/Graph Theory/Bellman Ford.cpp	/^  int a, b, cost;$/;"	m	struct:st	typeref:typename:int	file:
b	code-library/Graph Theory/Chordal Graph.cpp	/^int a[N], b[N];$/;"	v	typeref:typename:int[]
b	code-library/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^  double a, b;$/;"	m	struct:base	typeref:typename:double	file:
b	code-library/Math/FFT.cpp	/^  double a, b;$/;"	m	struct:base	typeref:typename:double	file:
b	code-library/Math/FWHT in Ternary Base.cpp	/^  mint a, b;$/;"	m	struct:cmplx	typeref:typename:mint	file:
b	code-library/Math/Inverse of A Matrix modulo 2.cpp	/^int a[500500], b[500500];$/;"	v	typeref:typename:int[500500]
b	code-library/Math/Lagrange Multiplier.cpp	/^int b[N], c[N];$/;"	v	typeref:typename:int[]
b	code-library/Number Theory/Linear Diophantine With N Unknowns and Two Equations.cpp	/^ll a, b, coeff; \/\/ possible points that can be generated are of the form (a * m, b * m + k * c/;"	v	typeref:typename:ll
b	code-library/Number Theory/Maximum Coprime Product.cpp	/^bool b[N + 1];$/;"	v	typeref:typename:bool[]
b	code-library/Number Theory/Phi Field.cpp	/^  mint a, b;$/;"	m	struct:field	typeref:typename:mint	file:
b	code-library/Strings/Number of Palindromes in Range.cpp	/^  int *b, *c, bsz, csz; \/\/  c holds the prefix sum of elements$/;"	m	struct:wavelet_tree	typeref:typename:int *	file:
b	code-library/Strings/Number of Palindromes in Range.cpp	/^int a[N], b[N], c[N], d[N];$/;"	v	typeref:typename:int[]
b	code-library/Strings/String Matching With FFT.cpp	/^  double a, b;$/;"	m	struct:base	typeref:typename:double	file:
b	code/Data Structures/Centroid Decomposition.cpp	/^  double a, b;$/;"	m	struct:base	typeref:typename:double	file:
b	code/Data Structures/Dynamic Diameter Online.cpp	/^    long long a = 0, b = 0, c = 0, d = 0, e = 0;$/;"	m	struct:node	typeref:typename:long long	file:
b	code/Data Structures/Monotonous Queue.cpp	/^  int a[N + 10], b[N + 10], l = 0, r = -1;$/;"	m	struct:monotonous_queue	typeref:typename:int[]	file:
b	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  int b, e;$/;"	m	struct:ST	typeref:typename:int	file:
b	code/Data Structures/Wavelet Tree.cpp	/^  int *b, *c, bsz, csz; \/\/ c holds the prefix sum of elements$/;"	m	struct:wavelet_tree	typeref:typename:int *	file:
b	code/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^  vector<ll> m, b;$/;"	m	struct:CHT	typeref:typename:vector<ll>	file:
b	code/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^ll a[N], b[N];$/;"	v	typeref:typename:ll[]
b	code/Dynamic Programming Optimizations/Digit DP.cpp	/^int pw[20][20], b[1 << 10][3000], cnt[1 << 10], dp[2][20][1 << 10][2520];$/;"	v	typeref:typename:int[][3000]
b	code/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^  ll m, b;$/;"	m	struct:line	typeref:typename:ll	file:
b	code/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^ll a[N], b[N];$/;"	v	typeref:typename:ll[]
b	code/Geometry/Geometry 2D.cpp	/^    PT a, b; \/\/ goes through points a and b$/;"	m	struct:line	typeref:typename:PT	file:
b	code/Geometry/Geometry 2D.cpp	/^    PT a, b;$/;"	m	struct:HP	typeref:typename:PT	file:
b	code/Geometry/Geometry 3D.cpp	/^        int a, b, c; \/\/ the number of three points on one face of the convex hull$/;"	m	struct:CH3D::face	typeref:typename:int	file:
b	code/Geometry/Half Plane Intersection.cpp	/^    PT a, b;$/;"	m	struct:HP	typeref:typename:PT	file:
b	code/Graph Theory/Bellman Ford.cpp	/^  int a, b, cost;$/;"	m	struct:st	typeref:typename:int	file:
b	code/Graph Theory/Chordal Graph.cpp	/^int a[N], b[N];$/;"	v	typeref:typename:int[]
b	code/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^  double a, b;$/;"	m	struct:base	typeref:typename:double	file:
b	code/Math/FFT.cpp	/^  double a, b;$/;"	m	struct:base	typeref:typename:double	file:
b	code/Math/FWHT in Ternary Base.cpp	/^  mint a, b;$/;"	m	struct:cmplx	typeref:typename:mint	file:
b	code/Math/Inverse of A Matrix modulo 2.cpp	/^int a[500500], b[500500];$/;"	v	typeref:typename:int[500500]
b	code/Math/Lagrange Multiplier.cpp	/^int b[N], c[N];$/;"	v	typeref:typename:int[]
b	code/Number Theory/Linear Diophantine With N Unknowns and Two Equations.cpp	/^ll a, b, coeff; \/\/ possible points that can be generated are of the form (a * m, b * m + k * c/;"	v	typeref:typename:ll
b	code/Number Theory/Maximum Coprime Product.cpp	/^bool b[N + 1];$/;"	v	typeref:typename:bool[]
b	code/Number Theory/Phi Field.cpp	/^  mint a, b;$/;"	m	struct:field	typeref:typename:mint	file:
b	code/Strings/Number of Palindromes in Range.cpp	/^  int *b, *c, bsz, csz; \/\/  c holds the prefix sum of elements$/;"	m	struct:wavelet_tree	typeref:typename:int *	file:
b	code/Strings/Number of Palindromes in Range.cpp	/^int a[N], b[N], c[N], d[N];$/;"	v	typeref:typename:int[]
b	code/Strings/String Matching With FFT.cpp	/^  double a, b;$/;"	m	struct:base	typeref:typename:double	file:
b	practice/cpbook/ch1/1.6/reallife/medium/01091/ac.cpp	/^int n, a[maxn], b[maxn];$/;"	v	typeref:typename:int[]
backtrack	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^  void backtrack(int c) {$/;"	f	struct:persistent_dsu	typeref:typename:void	file:
backtrack	code-library/Number Theory/K Divisors.cpp	/^ll backtrack(ll n, int k, int last = 0) {$/;"	f	typeref:typename:ll
backtrack	code/Data Structures/Dynamic Connectivity Problem.cpp	/^  void backtrack(int c) {$/;"	f	struct:persistent_dsu	typeref:typename:void	file:
backtrack	code/Number Theory/K Divisors.cpp	/^ll backtrack(ll n, int k, int last = 0) {$/;"	f	typeref:typename:ll
bad	code-library/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^  bool bad(int l1, int l2, int l3) {$/;"	f	struct:CHT	typeref:typename:bool	file:
bad	code-library/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^  bool bad(iterator y) {$/;"	f	struct:CHT	typeref:typename:bool	file:
bad	code/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^  bool bad(int l1, int l2, int l3) {$/;"	f	struct:CHT	typeref:typename:bool	file:
bad	code/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^  bool bad(iterator y) {$/;"	f	struct:CHT	typeref:typename:bool	file:
base	code-library/Data Structures/Centroid Decomposition.cpp	/^  base(double a = 0, double b = 0) : a(a), b(b) {}$/;"	f	struct:base	file:
base	code-library/Data Structures/Centroid Decomposition.cpp	/^struct base {$/;"	s	file:
base	code-library/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^  base(double a = 0, double b = 0) : a(a), b(b) {}$/;"	f	struct:base	file:
base	code-library/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^struct base {$/;"	s	file:
base	code-library/Graph Theory/Tree Isomorphism.cpp	/^const int base = 10;$/;"	v	typeref:typename:const int
base	code-library/Math/FFT.cpp	/^  base(double a = 0, double b = 0) : a(a), b(b) {}$/;"	f	struct:base	file:
base	code-library/Math/FFT.cpp	/^struct base {$/;"	s	file:
base	code-library/Math/Faulhaber Formula Fastest.cpp	/^  base() { x = y = 0; }$/;"	f	struct:base	file:
base	code-library/Math/Faulhaber Formula Fastest.cpp	/^  base(double x, double y): x(x), y(y) { }$/;"	f	struct:base	file:
base	code-library/Math/Faulhaber Formula Fastest.cpp	/^struct base {$/;"	s	file:
base	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  base() { x = y = 0; }$/;"	f	struct:base	file:
base	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  base(double x, double y): x(x), y(y) { }$/;"	f	struct:base	file:
base	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^struct base {$/;"	s	file:
base	code-library/Math/Linear Recurrence Fastest.cpp	/^  base() { x = y = 0; }$/;"	f	struct:base	file:
base	code-library/Math/Linear Recurrence Fastest.cpp	/^  base(double x, double y): x(x), y(y) { }$/;"	f	struct:base	file:
base	code-library/Math/Linear Recurrence Fastest.cpp	/^struct base {$/;"	s	file:
base	code-library/Math/NTT Online.cpp	/^  base() { x = y = 0; }$/;"	f	struct:base	file:
base	code-library/Math/NTT Online.cpp	/^  base(double x, double y): x(x), y(y) { }$/;"	f	struct:base	file:
base	code-library/Math/NTT Online.cpp	/^struct base {$/;"	s	file:
base	code-library/Math/NTT With Any Prime MOD.cpp	/^  base() { x = y = 0; }$/;"	f	struct:base	file:
base	code-library/Math/NTT With Any Prime MOD.cpp	/^  base(double x, double y): x(x), y(y) { }$/;"	f	struct:base	file:
base	code-library/Math/NTT With Any Prime MOD.cpp	/^struct base {$/;"	s	file:
base	code-library/Math/Polynomial with Binomial Coefficients.cpp	/^  base() { x = y = 0; }$/;"	f	struct:base	file:
base	code-library/Math/Polynomial with Binomial Coefficients.cpp	/^  base(double x, double y): x(x), y(y) { }$/;"	f	struct:base	file:
base	code-library/Math/Polynomial with Binomial Coefficients.cpp	/^struct base {$/;"	s	file:
base	code-library/Math/Polynomial.cpp	/^  base() { x = y = 0; }$/;"	f	struct:base	file:
base	code-library/Math/Polynomial.cpp	/^  base(double x, double y): x(x), y(y) { }$/;"	f	struct:base	file:
base	code-library/Math/Polynomial.cpp	/^struct base {$/;"	s	file:
base	code-library/Math/Subset Sum Problem.cpp	/^  base() { x = y = 0; }$/;"	f	struct:base	file:
base	code-library/Math/Subset Sum Problem.cpp	/^  base(double x, double y): x(x), y(y) { }$/;"	f	struct:base	file:
base	code-library/Math/Subset Sum Problem.cpp	/^struct base {$/;"	s	file:
base	code-library/Number Theory/Bell Number.cpp	/^    base() { x = y = 0; }$/;"	f	struct:base	file:
base	code-library/Number Theory/Bell Number.cpp	/^    base(double x, double y): x(x), y(y) { }$/;"	f	struct:base	file:
base	code-library/Number Theory/Bell Number.cpp	/^struct base {$/;"	s	file:
base	code-library/Number Theory/Prime Number System.cpp	/^  base() {}$/;"	f	struct:base	file:
base	code-library/Number Theory/Prime Number System.cpp	/^  base(int n) {$/;"	f	struct:base	file:
base	code-library/Number Theory/Prime Number System.cpp	/^  base(map<int, int> z) {$/;"	f	struct:base	file:
base	code-library/Number Theory/Prime Number System.cpp	/^struct base { \/\/ doesn't support zero$/;"	s	file:
base	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    base() { x = y = 0; }$/;"	f	struct:base	file:
base	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    base(double x, double y): x(x), y(y) { }$/;"	f	struct:base	file:
base	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^struct base {$/;"	s	file:
base	code-library/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^    base() { x = y = 0; }$/;"	f	struct:base	file:
base	code-library/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^    base(double x, double y): x(x), y(y) { }$/;"	f	struct:base	file:
base	code-library/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^struct base {$/;"	s	file:
base	code-library/Strings/String Matching With FFT.cpp	/^  base(double a = 0, double b = 0) : a(a), b(b) {}$/;"	f	struct:base	file:
base	code-library/Strings/String Matching With FFT.cpp	/^struct base {$/;"	s	file:
base	code/Data Structures/Centroid Decomposition.cpp	/^  base(double a = 0, double b = 0) : a(a), b(b) {}$/;"	f	struct:base	file:
base	code/Data Structures/Centroid Decomposition.cpp	/^struct base {$/;"	s	file:
base	code/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^  base(double a = 0, double b = 0) : a(a), b(b) {}$/;"	f	struct:base	file:
base	code/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^struct base {$/;"	s	file:
base	code/Graph Theory/Tree Isomorphism.cpp	/^const int base = 10;$/;"	v	typeref:typename:const int
base	code/Math/FFT.cpp	/^  base(double a = 0, double b = 0) : a(a), b(b) {}$/;"	f	struct:base	file:
base	code/Math/FFT.cpp	/^struct base {$/;"	s	file:
base	code/Math/Faulhaber Formula Fastest.cpp	/^  base() { x = y = 0; }$/;"	f	struct:base	file:
base	code/Math/Faulhaber Formula Fastest.cpp	/^  base(double x, double y): x(x), y(y) { }$/;"	f	struct:base	file:
base	code/Math/Faulhaber Formula Fastest.cpp	/^struct base {$/;"	s	file:
base	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  base() { x = y = 0; }$/;"	f	struct:base	file:
base	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  base(double x, double y): x(x), y(y) { }$/;"	f	struct:base	file:
base	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^struct base {$/;"	s	file:
base	code/Math/Linear Recurrence Fastest.cpp	/^  base() { x = y = 0; }$/;"	f	struct:base	file:
base	code/Math/Linear Recurrence Fastest.cpp	/^  base(double x, double y): x(x), y(y) { }$/;"	f	struct:base	file:
base	code/Math/Linear Recurrence Fastest.cpp	/^struct base {$/;"	s	file:
base	code/Math/NTT Online.cpp	/^  base() { x = y = 0; }$/;"	f	struct:base	file:
base	code/Math/NTT Online.cpp	/^  base(double x, double y): x(x), y(y) { }$/;"	f	struct:base	file:
base	code/Math/NTT Online.cpp	/^struct base {$/;"	s	file:
base	code/Math/NTT With Any Prime MOD.cpp	/^  base() { x = y = 0; }$/;"	f	struct:base	file:
base	code/Math/NTT With Any Prime MOD.cpp	/^  base(double x, double y): x(x), y(y) { }$/;"	f	struct:base	file:
base	code/Math/NTT With Any Prime MOD.cpp	/^struct base {$/;"	s	file:
base	code/Math/Polynomial with Binomial Coefficients.cpp	/^  base() { x = y = 0; }$/;"	f	struct:base	file:
base	code/Math/Polynomial with Binomial Coefficients.cpp	/^  base(double x, double y): x(x), y(y) { }$/;"	f	struct:base	file:
base	code/Math/Polynomial with Binomial Coefficients.cpp	/^struct base {$/;"	s	file:
base	code/Math/Polynomial.cpp	/^  base() { x = y = 0; }$/;"	f	struct:base	file:
base	code/Math/Polynomial.cpp	/^  base(double x, double y): x(x), y(y) { }$/;"	f	struct:base	file:
base	code/Math/Polynomial.cpp	/^struct base {$/;"	s	file:
base	code/Math/Subset Sum Problem.cpp	/^  base() { x = y = 0; }$/;"	f	struct:base	file:
base	code/Math/Subset Sum Problem.cpp	/^  base(double x, double y): x(x), y(y) { }$/;"	f	struct:base	file:
base	code/Math/Subset Sum Problem.cpp	/^struct base {$/;"	s	file:
base	code/Number Theory/Bell Number.cpp	/^    base() { x = y = 0; }$/;"	f	struct:base	file:
base	code/Number Theory/Bell Number.cpp	/^    base(double x, double y): x(x), y(y) { }$/;"	f	struct:base	file:
base	code/Number Theory/Bell Number.cpp	/^struct base {$/;"	s	file:
base	code/Number Theory/Prime Number System.cpp	/^  base() {}$/;"	f	struct:base	file:
base	code/Number Theory/Prime Number System.cpp	/^  base(int n) {$/;"	f	struct:base	file:
base	code/Number Theory/Prime Number System.cpp	/^  base(map<int, int> z) {$/;"	f	struct:base	file:
base	code/Number Theory/Prime Number System.cpp	/^struct base { \/\/ doesn't support zero$/;"	s	file:
base	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    base() { x = y = 0; }$/;"	f	struct:base	file:
base	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    base(double x, double y): x(x), y(y) { }$/;"	f	struct:base	file:
base	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^struct base {$/;"	s	file:
base	code/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^    base() { x = y = 0; }$/;"	f	struct:base	file:
base	code/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^    base(double x, double y): x(x), y(y) { }$/;"	f	struct:base	file:
base	code/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^struct base {$/;"	s	file:
base	code/Strings/String Matching With FFT.cpp	/^  base(double a = 0, double b = 0) : a(a), b(b) {}$/;"	f	struct:base	file:
base	code/Strings/String Matching With FFT.cpp	/^struct base {$/;"	s	file:
basis	code-library/Math/Simplex Algorithm.cpp	/^  int m, n, solution_flag, minmax_flag, basis[MAXC], index[MAXV];$/;"	v	namespace:lp	typeref:typename:int[]
basis	code-library/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^vector <ll> basis, without[L];$/;"	v	typeref:typename:vector<ll>
basis	code/Math/Simplex Algorithm.cpp	/^  int m, n, solution_flag, minmax_flag, basis[MAXC], index[MAXV];$/;"	v	namespace:lp	typeref:typename:int[]
basis	code/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^vector <ll> basis, without[L];$/;"	v	typeref:typename:vector<ll>
batch	practice/cf/random/1700/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	o
batch	practice/cf/random/1700/1618E/problem.json	/^{"name": "E. Singers' Tour", "group": "Codeforces - Codeforces Round #760 (Div. 3)", "url": "htt/;"	o
batch	practice/cf/random/coloring/problem.json	/^{"name": "A. Dreamoon Likes Coloring", "group": "Codeforces - Codeforces Round #631 (Div. 1) - T/;"	o
batch	practice/cf/random/diane/problem.json	/^{"name": "D. Diane", "group": "Codeforces - Codeforces Round #735 (Div. 2)", "url": "https:\/\/c/;"	o
batch	practice/cf/random/pink/problem.json	/^{"name": "C. Pinkie Pie Eats Patty-cakes", "group": "Codeforces - Codeforces Round #662 (Div. 2)/;"	o
batch	practice/cf/stuff/dec 20 2021/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	o
batch	practice/usacoguide/gold/SP/dining/problem.json	/^{"name": "Problem 1. Fine Dining", "group": "USACO - USACO 2018 December Contest, Gold", "url": /;"	o
batch	practice/usacoguide/gold/SP/visitfj/problem.json	/^{"name": "Problem 1. Why Did the Cow Cross the Road", "group": "USACO - USACO 2017 February Cont/;"	o
batch	practice/usacoguide/gold/bfs/cownav/problem.json	/^{"name": "Problem 3. Cow Navigation", "group": "USACO - USACO 2017 January Contest, Gold", "url"/;"	o
batch	practice/usacoguide/gold/bfs/swap/problem.json	/^{"name": "Swap Game", "group": "CSES - CSES Problem Set", "url": "https:\/\/cses.fi\/problemset\//;"	o
batch	practice/usacoguide/gold/dsu/closing/problem.json	/^{"name": "Problem 2. Closing the Farm", "group": "USACO - USACO 2016 US Open Contest, Gold", "ur/;"	o
batch	practice/usacoguide/gold/dsu/moocast/problem.json	/^{"name": "Problem 1. Moocast", "group": "USACO - USACO 2016 December Contest, Gold", "url": "htt/;"	o
batch	practice/usacoguide/gold/dsu/mootube/problem.json	/^{"name": "Problem 1. MooTube", "group": "USACO - USACO 2018 January Contest, Gold", "url": "http/;"	o
batch	practice/usacoguide/gold/dsu/tractor/problem.json	/^{"name": "Problem 2. Tractor", "group": "USACO - USACO 2013 February Contest, Silver", "url": "h/;"	o
batch	practice/usacoguide/gold/dsu/wormhole/problem.json	/^{"name": "Problem 3. Wormhole Sort", "group": "USACO - USACO 2020 January Contest, Silver", "url/;"	o
batch	practice/usacoguide/silver/idk/lirs/problem.json	/^{"name": "Problem 3. Liars and Truth Tellers", "group": "USACO - USACO 2013 January Contest, Bro/;"	o
batch	practice/usacoguide/silver/idk/maze/problem.json	/^{"name": "Problem 1. Maze Tac Toe", "group": "USACO - USACO 2021 US Open, Silver", "url": "http:/;"	o
bcc	code-library/Graph Theory/Block Cut Tree.cpp	/^vector<int> g[N], bcc[N], st;$/;"	v	typeref:typename:vector<int>[]
bcc	code/Graph Theory/Block Cut Tree.cpp	/^vector<int> g[N], bcc[N], st;$/;"	v	typeref:typename:vector<int>[]
before	init.lua	/^      before = function (entry, vim_item)$/;"	f
beginNode	contests/USACO/dec_silver_2021/B/B.cpp	/^set<int> endNode, beginNode;$/;"	v	typeref:typename:set<int>
bel	code-library/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^int n, m, bel[N * 4];$/;"	v	typeref:typename:int[]
bel	code/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^int n, m, bel[N * 4];$/;"	v	typeref:typename:int[]
bell	code-library/Number Theory/Bell Number.cpp	/^vector<mint> bell(int n) { \/\/ e^(e^x - 1)$/;"	f	typeref:typename:vector<mint>
bell	code/Number Theory/Bell Number.cpp	/^vector<mint> bell(int n) { \/\/ e^(e^x - 1)$/;"	f	typeref:typename:vector<mint>
bellman_ford	code-library/Graph Theory/Johnson's Algorithm.cpp	/^bool bellman_ford(int n, int s, vector <struct edge> ed, vector <long long> &d){$/;"	f	typeref:typename:bool
bellman_ford	code/Graph Theory/Johnson's Algorithm.cpp	/^bool bellman_ford(int n, int s, vector <struct edge> ed, vector <long long> &d){$/;"	f	typeref:typename:bool
between	code-library/Data Structures/SQRT Tree.cpp	/^  vector< vector<SqrtTreeItem> > pref, suf, between;$/;"	m	struct:SqrtTree	typeref:typename:vector<vector<SqrtTreeItem>>	file:
between	code/Data Structures/SQRT Tree.cpp	/^  vector< vector<SqrtTreeItem> > pref, suf, between;$/;"	m	struct:SqrtTree	typeref:typename:vector<vector<SqrtTreeItem>>	file:
bfs	code-library/Game Theory/Matching Game On A Graph.cpp	/^  bool bfs(int u) {$/;"	f	struct:Blossom	typeref:typename:bool	file:
bfs	code-library/Graph Theory/Blossom Algorithm.cpp	/^  bool bfs(int u) {$/;"	f	struct:Blossom	typeref:typename:bool	file:
bfs	code-library/Graph Theory/Dinics Algorithm.cpp	/^  bool bfs() {$/;"	f	struct:Dinic	typeref:typename:bool	file:
bfs	code-library/Graph Theory/HopCroft Karp Algorithm.cpp	/^  bool bfs() {$/;"	f	struct:HopcroftKarp	typeref:typename:bool	file:
bfs	code-library/Graph Theory/L R Flow with Dinic.cpp	/^  bool bfs() {$/;"	f	struct:Dinic	typeref:typename:bool	file:
bfs	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  bool bfs() {$/;"	f	struct:Dinic	typeref:typename:bool	file:
bfs	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^  bool bfs() {$/;"	f	struct:Dinic	typeref:typename:bool	file:
bfs	code-library/Graph Theory/Tree Isomorphism.cpp	/^  vector<int> bfs(int s) {$/;"	f	struct:Tree	typeref:typename:vector<int>	file:
bfs	code-library/Graph Theory/Unique Min Cut.cpp	/^  bool bfs() {$/;"	f	struct:Dinic	typeref:typename:bool	file:
bfs	code/Game Theory/Matching Game On A Graph.cpp	/^  bool bfs(int u) {$/;"	f	struct:Blossom	typeref:typename:bool	file:
bfs	code/Graph Theory/Blossom Algorithm.cpp	/^  bool bfs(int u) {$/;"	f	struct:Blossom	typeref:typename:bool	file:
bfs	code/Graph Theory/Dinics Algorithm.cpp	/^  bool bfs() {$/;"	f	struct:Dinic	typeref:typename:bool	file:
bfs	code/Graph Theory/HopCroft Karp Algorithm.cpp	/^  bool bfs() {$/;"	f	struct:HopcroftKarp	typeref:typename:bool	file:
bfs	code/Graph Theory/L R Flow with Dinic.cpp	/^  bool bfs() {$/;"	f	struct:Dinic	typeref:typename:bool	file:
bfs	code/Graph Theory/Maximum Closure Problem.cpp	/^  bool bfs() {$/;"	f	struct:Dinic	typeref:typename:bool	file:
bfs	code/Graph Theory/Maximum Density Subgraph.cpp	/^  bool bfs() {$/;"	f	struct:Dinic	typeref:typename:bool	file:
bfs	code/Graph Theory/Tree Isomorphism.cpp	/^  vector<int> bfs(int s) {$/;"	f	struct:Tree	typeref:typename:vector<int>	file:
bfs	code/Graph Theory/Unique Min Cut.cpp	/^  bool bfs() {$/;"	f	struct:Dinic	typeref:typename:bool	file:
bfs	contests/AtCoder/ABC211/D.cpp	/^void bfs() {$/;"	f	typeref:typename:void
bfs	practice/usacoguide/gold/bfs/graphgirth2.cpp	/^void bfs(int x, int t){$/;"	f	typeref:typename:void
bfs	practice/usacoguide/gold/bfs/milkpails.cpp	/^int bfs() {$/;"	f	typeref:typename:int
bfs	practice/usacoguide/gold/bfs/monsters.cpp	/^void bfs() {$/;"	f	typeref:typename:void
bfs	practice/usacoguide/gold/bfs/piggyback.cpp	/^vector<int> bfs(int node) {$/;"	f	typeref:typename:vector<int>
big	code-library/Data Structures/DSU on Tree.cpp	/^bool big[N];$/;"	v	typeref:typename:bool[]
big	code-library/Dynamic Programming Optimizations/Dynamic Submask Count.cpp	/^int c[N], small[N], big[N];$/;"	v	typeref:typename:int[]
big	code/Data Structures/DSU on Tree.cpp	/^bool big[N];$/;"	v	typeref:typename:bool[]
big	code/Dynamic Programming Optimizations/Dynamic Submask Count.cpp	/^int c[N], small[N], big[N];$/;"	v	typeref:typename:int[]
bin_exp	practice/usacoguide/gold/modular/exponentiation2.cpp	/^int64_t bin_exp(int64_t a, int64_t b, int64_t MOD) {$/;"	f	typeref:typename:int64_t
bin_search	practice/cf/random/pink/main.cpp	/^int bin_search() {$/;"	f	typeref:typename:int
bin_search	practice/usacoguide/gold/bfs/mecho/main.cpp	/^int bin_search() {$/;"	f	typeref:typename:int
bin_search	practice/usacoguide/gold/bfs/mechonew/main.cpp	/^int bin_search() {$/;"	f	typeref:typename:int
bin_search	practice/usacoguide/gold/dsu/moocast/main.cpp	/^int bin_search() {$/;"	f	typeref:typename:int
bin_search	practice/usacoguide/gold/dsu/tractor/main.cpp	/^int bin_search() {$/;"	f	typeref:typename:int
bin_search	practice/usacoguide/gold/dsu/wormhole/main.cpp	/^int bin_search() {$/;"	f	typeref:typename:int
bin_search	practice/usacoguide/silver/binsearch/sabotage.cpp	/^double bin_search() {$/;"	f	typeref:typename:double
binarize	code-library/Data Structures/Binarizing a Tree.cpp	/^void binarize(int u, int p = 0) {$/;"	f	typeref:typename:void
binarize	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^void binarize(int u, int p = 0) {$/;"	f	typeref:typename:void
binarize	code/Data Structures/Binarizing a Tree.cpp	/^void binarize(int u, int p = 0) {$/;"	f	typeref:typename:void
binarize	code/Data Structures/Centroid Decomposition Persistent.cpp	/^void binarize(int u, int p = 0) {$/;"	f	typeref:typename:void
binomial_sum_mod_p	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^int binomial_sum_mod_p(int N, int K, int mod) {$/;"	f	typeref:typename:int
binomial_sum_mod_p	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^int binomial_sum_mod_p(int N, int K, int mod) {$/;"	f	typeref:typename:int
binpow	practice/usacoguide/gold/modular/santasbot.cpp	/^ll binpow(ll x, ll n, ll m) {$/;"	f	typeref:typename:ll
binpow	practice/usacoguide/gold/modular/test.cpp	/^ll binpow(ll x, ll n, ll m) {$/;"	f	typeref:typename:ll
bishop	practice/cpbook/ch1/1.6/chess/10284/main.cpp	/^void bishop(int row, int col, bool black) {$/;"	f	typeref:typename:void
bitflip	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^  void bitflip(vector<mint> &v) {$/;"	f	struct:ChromaticPolynomial	typeref:typename:void	file:
bitflip	code/Graph Theory/Chromatic Polynoimial.cpp	/^  void bitflip(vector<mint> &v) {$/;"	f	struct:ChromaticPolynomial	typeref:typename:void	file:
bl	code-library/Geometry/Onion Decomposition.cpp	/^        int bl, br;$/;"	m	struct:LeftHull::node	typeref:typename:int	file:
bl	code-library/Graph Theory/Online Articulation Bridges.cpp	/^int n, bridges, par[N], bl[N], comp[N], sz[N];$/;"	v	typeref:typename:int[]
bl	code/Geometry/Onion Decomposition.cpp	/^        int bl, br;$/;"	m	struct:LeftHull::node	typeref:typename:int	file:
bl	code/Graph Theory/Online Articulation Bridges.cpp	/^int n, bridges, par[N], bl[N], comp[N], sz[N];$/;"	v	typeref:typename:int[]
blocks	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^vector<int> a, blocks;$/;"	v	typeref:typename:vector<int>
blocks	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^vector<int> a, blocks;$/;"	v	typeref:typename:vector<int>
blossom	code-library/Game Theory/Matching Game On A Graph.cpp	/^  void blossom(int v, int w, int a) {$/;"	f	struct:Blossom	typeref:typename:void	file:
blossom	code-library/Graph Theory/Blossom Algorithm.cpp	/^  void blossom(int v, int w, int a) {$/;"	f	struct:Blossom	typeref:typename:void	file:
blossom	code/Game Theory/Matching Game On A Graph.cpp	/^  void blossom(int v, int w, int a) {$/;"	f	struct:Blossom	typeref:typename:void	file:
blossom	code/Graph Theory/Blossom Algorithm.cpp	/^  void blossom(int v, int w, int a) {$/;"	f	struct:Blossom	typeref:typename:void	file:
board	practice/usacoguide/gold/introDP/king2.cpp	/^ll dp[mxN][mxN], board[mxN][mxN];$/;"	v	typeref:typename:ll[][]
board	practice/usacoguide/silver/idk/maze/main.cpp	/^int board[3][3];$/;"	v	typeref:typename:int[3][3]
body	code-library/Geometry/Point Location.cpp	/^    vector<edge*> body;$/;"	m	struct:DCEL	typeref:typename:vector<edge * >	file:
body	code/Geometry/Point Location.cpp	/^    vector<edge*> body;$/;"	m	struct:DCEL	typeref:typename:vector<edge * >	file:
bottom	code-library/Data Structures/Queue Undo Trick.cpp	/^  int bottom;$/;"	m	struct:DSUQueue	typeref:typename:int	file:
bottom	code/Data Structures/Queue Undo Trick.cpp	/^  int bottom;$/;"	m	struct:DSUQueue	typeref:typename:int	file:
boundedKnapsack	code-library/Dynamic Programming Optimizations/Bounded Knapsack.cpp	/^int boundedKnapsack(vector<int> ps, vector<int> ws, vector<int> ms, int W) {$/;"	f	typeref:typename:int
boundedKnapsack	code/Dynamic Programming Optimizations/Bounded Knapsack.cpp	/^int boundedKnapsack(vector<int> ps, vector<int> ws, vector<int> ms, int W) {$/;"	f	typeref:typename:int
br	code-library/Geometry/Onion Decomposition.cpp	/^        int bl, br;$/;"	m	struct:LeftHull::node	typeref:typename:int	file:
br	code-library/Graph Theory/Articulation Bridges.cpp	/^  vector<edge> br;$/;"	m	struct:TECC	typeref:typename:vector<edge>	file:
br	code/Geometry/Onion Decomposition.cpp	/^        int bl, br;$/;"	m	struct:LeftHull::node	typeref:typename:int	file:
br	code/Graph Theory/Articulation Bridges.cpp	/^  vector<edge> br;$/;"	m	struct:TECC	typeref:typename:vector<edge>	file:
bridges	code-library/Graph Theory/Online Articulation Bridges.cpp	/^int n, bridges, par[N], bl[N], comp[N], sz[N];$/;"	v	typeref:typename:int
bridges	code/Graph Theory/Online Articulation Bridges.cpp	/^int n, bridges, par[N], bl[N], comp[N], sz[N];$/;"	v	typeref:typename:int
brute	code-library/Graph Theory/Maximum Independant Set.cpp	/^int brute() {$/;"	f	typeref:typename:int
brute	code-library/Number Theory/Linear Diophantine Equation Three Variables with Nonnegative Solutions.cpp	/^T brute(T a, T b, T c, T n) {$/;"	f	typeref:typename:T
brute	code/Graph Theory/Maximum Independant Set.cpp	/^int brute() {$/;"	f	typeref:typename:int
brute	code/Number Theory/Linear Diophantine Equation Three Variables with Nonnegative Solutions.cpp	/^T brute(T a, T b, T c, T n) {$/;"	f	typeref:typename:T
bs	code-library/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^  ll bs(int l, int r, ll x) {$/;"	f	struct:CHT	typeref:typename:ll	file:
bs	code-library/Miscellaneous/Bitset Custom.cpp	/^Bitset<N> bs[101], nw, t;$/;"	v	typeref:typename:Bitset<N>[101]
bs	code-library/Strings/Bit LCS.cpp	/^} row, bs[SIGMA], x;$/;"	v	typeref:struct:Bitset[]
bs	code-library/Strings/String Matching using Bitsets.cpp	/^bitset<N>bs[26], oc;$/;"	v	typeref:typename:bitset<N>[26]
bs	code/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^  ll bs(int l, int r, ll x) {$/;"	f	struct:CHT	typeref:typename:ll	file:
bs	code/Miscellaneous/Bitset Custom.cpp	/^Bitset<N> bs[101], nw, t;$/;"	v	typeref:typename:Bitset<N>[101]
bs	code/Strings/Bit LCS.cpp	/^} row, bs[SIGMA], x;$/;"	v	typeref:struct:Bitset[]
bs	code/Strings/String Matching using Bitsets.cpp	/^bitset<N>bs[26], oc;$/;"	v	typeref:typename:bitset<N>[26]
bsz	code-library/Data Structures/Wavelet Tree.cpp	/^  int *b, *c, bsz, csz; \/\/ c holds the prefix sum of elements$/;"	m	struct:wavelet_tree	typeref:typename:int	file:
bsz	code-library/Strings/Number of Palindromes in Range.cpp	/^  int *b, *c, bsz, csz; \/\/  c holds the prefix sum of elements$/;"	m	struct:wavelet_tree	typeref:typename:int	file:
bsz	code/Data Structures/Wavelet Tree.cpp	/^  int *b, *c, bsz, csz; \/\/ c holds the prefix sum of elements$/;"	m	struct:wavelet_tree	typeref:typename:int	file:
bsz	code/Strings/Number of Palindromes in Range.cpp	/^  int *b, *c, bsz, csz; \/\/  c holds the prefix sum of elements$/;"	m	struct:wavelet_tree	typeref:typename:int	file:
bt	code-library/Graph Theory/Block Cut Tree.cpp	/^vector<int> bt[N];$/;"	v	typeref:typename:vector<int>[]
bt	code/Graph Theory/Block Cut Tree.cpp	/^vector<int> bt[N];$/;"	v	typeref:typename:vector<int>[]
buc	code-library/Strings/Suffix Array Isomorphic.cpp	/^int buc[N], r[N], suf[N], X[N], Y[N], high[N];$/;"	v	typeref:typename:int[]
buc	code/Strings/Suffix Array Isomorphic.cpp	/^int buc[N], r[N], suf[N], X[N], Y[N], high[N];$/;"	v	typeref:typename:int[]
bucket	code-library/Graph Theory/Dominator Tree.cpp	/^vector<int> t[N], rg[N], bucket[N]; \/\/t = dominator tree of the nodes reachable from root$/;"	v	typeref:typename:vector<int>[]
bucket	code/Graph Theory/Dominator Tree.cpp	/^vector<int> t[N], rg[N], bucket[N]; \/\/t = dominator tree of the nodes reachable from root$/;"	v	typeref:typename:vector<int>[]
buckets	code-library/Miscellaneous/Schreier–Sims algorithm.cpp	/^  vector<vector<vector<int>>> buckets, ibuckets;$/;"	m	struct:Group	typeref:typename:vector<vector<vector<int>>>	file:
buckets	code/Miscellaneous/Schreier–Sims algorithm.cpp	/^  vector<vector<vector<int>>> buckets, ibuckets;$/;"	m	struct:Group	typeref:typename:vector<vector<vector<int>>>	file:
bufferline	.config/nvim/init.vim	/^let bufferline = get(g:, 'bufferline', {})$/;"	v
bufferline	dotfiles/init.vim	/^let bufferline = get(g:, 'bufferline', {})$/;"	v
bufferline	dotfiles/macinit.vim	/^let bufferline = get(g:, 'bufferline', {})$/;"	v
build	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    int build(int b, int e) {$/;"	f	struct:PST	typeref:typename:int	file:
build	code-library/Data Structures/HLD.cpp	/^  void build(int n, int b, int e) {$/;"	f	struct:ST	typeref:typename:void	file:
build	code-library/Data Structures/Permutation Tree.cpp	/^  void build(int n, int b, int e) {$/;"	f	struct:ST	typeref:typename:void	file:
build	code-library/Data Structures/Permutation Tree.cpp	/^int build(int n) { \/\/returns root of the tree$/;"	f	typeref:typename:int
build	code-library/Data Structures/Persistent Array.cpp	/^  int build(vector<T> v) {$/;"	f	struct:PersistentArray	typeref:typename:int	file:
build	code-library/Data Structures/Persistent Array.cpp	/^  node* build(int l, int r, vector<T>& v) {$/;"	f	struct:PersistentArray	typeref:typename:node *	file:
build	code-library/Data Structures/Persistent Queue.cpp	/^  int build(vector<T> v) {$/;"	f	struct:PersistentArray	typeref:typename:int	file:
build	code-library/Data Structures/Persistent Queue.cpp	/^  node* build(int l, int r, vector<T>& v) {$/;"	f	struct:PersistentArray	typeref:typename:node *	file:
build	code-library/Data Structures/Persistent UnionFind.cpp	/^  int build(vector<T> v) {$/;"	f	struct:PersistentArray	typeref:typename:int	file:
build	code-library/Data Structures/Persistent UnionFind.cpp	/^  node* build(int l, int r, vector<T>& v) {$/;"	f	struct:PersistentArray	typeref:typename:node *	file:
build	code-library/Data Structures/Reachability Tree.cpp	/^  void build(vector<array<int, 3>> e) { \/\/{w, u, v}$/;"	f	struct:RT	typeref:typename:void	file:
build	code-library/Data Structures/Reachability Tree.cpp	/^inline void build(int n, int l, int r) {$/;"	f	typeref:typename:void
build	code-library/Data Structures/SQRT Tree.cpp	/^  void build(int layer, int lBound, int rBound, int betweenOffs) {$/;"	f	struct:SqrtTree	typeref:typename:void	file:
build	code-library/Data Structures/Segment Tree Lazy.cpp	/^  void build(int n, int b, int e) {$/;"	f	struct:ST	typeref:typename:void	file:
build	code-library/Data Structures/Segment Tree Merging.cpp	/^  int build(int b, int e, int i) {$/;"	f	struct:STM	typeref:typename:int	file:
build	code-library/Data Structures/Segment Tree NonRecursive.cpp	/^  void build() {$/;"	f	struct:ST	typeref:typename:void	file:
build	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^  int build(int b, int e) {$/;"	f	struct:PST	typeref:typename:int	file:
build	code-library/Data Structures/Segment Tree Persistent.cpp	/^  int build(int b, int e) {$/;"	f	struct:PST	typeref:typename:int	file:
build	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  void build(int n, int b, int e) {$/;"	f	struct:ST	typeref:typename:void	file:
build	code-library/Data Structures/Segment Tree.cpp	/^  void build(int n, int b, int e) {$/;"	f	struct:ST	typeref:typename:void	file:
build	code-library/Data Structures/Sparse Table 2D.cpp	/^void build(int n, int m) { \/\/ 0 indexed$/;"	f	typeref:typename:void
build	code-library/Data Structures/Sparse Table.cpp	/^void build(int n) {$/;"	f	typeref:typename:void
build	code-library/Data Structures/Treap persistent.cpp	/^node* build(int l, int r, string &s) {$/;"	f	namespace:PersistentTreap	typeref:typename:node *
build	code-library/Geometry/Onion Decomposition.cpp	/^    void build(int w, int L, int R) {$/;"	f	struct:LeftHull	typeref:typename:void	file:
build	code-library/Graph Theory/Dijkstra on Segment Tree.cpp	/^void build(int n, int b, int e) {$/;"	f	typeref:typename:void
build	code-library/Graph Theory/Dominator Tree.cpp	/^void build(int r, int n) {$/;"	f	typeref:typename:void
build	code-library/Graph Theory/LCA in O(1).cpp	/^  void build(const vector<T>& V) {$/;"	f	struct:RMQ	typeref:typename:void	file:
build	code-library/Graph Theory/LCA in O(1).cpp	/^  void build(int root) {$/;"	f	struct:LCA	typeref:typename:void	file:
build	code-library/Graph Theory/Path Union.cpp	/^  void build(int n, int b, int e) {$/;"	f	struct:segtree	typeref:typename:void	file:
build	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^void build(int id, int l, int r) {$/;"	f	typeref:typename:void
build	code-library/Math/Polynomial.cpp	/^  poly build(vector<poly> &ans, int v, int l, int r, vector<mint> &vec) { \/\/builds evaluation /;"	f	struct:poly	typeref:typename:poly	file:
build	code-library/Miscellaneous/MEX of all Subarrays.cpp	/^  void build(int n, int b, int e) {$/;"	f	struct:ST	typeref:typename:void	file:
build	code-library/Strings/Suffix Array Isomorphic.cpp	/^  void build() {$/;"	f	struct:IsomorphicSuffixArray	typeref:typename:void	file:
build	code-library/Strings/Suffix Array Isomorphic.cpp	/^  void build() {$/;"	f	struct:SuffixArray	typeref:typename:void	file:
build	code-library/Strings/Suffix Array.cpp	/^  void build() {$/;"	f	struct:SuffixArray	typeref:typename:void	file:
build	code-library/Strings/Suffix Automaton.cpp	/^    void build(string &s) {$/;"	f	struct:SuffixAutomaton	typeref:typename:void	file:
build	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    int build(int b, int e) {$/;"	f	struct:PST	typeref:typename:int	file:
build	code/Data Structures/HLD.cpp	/^  void build(int n, int b, int e) {$/;"	f	struct:ST	typeref:typename:void	file:
build	code/Data Structures/Permutation Tree.cpp	/^  void build(int n, int b, int e) {$/;"	f	struct:ST	typeref:typename:void	file:
build	code/Data Structures/Permutation Tree.cpp	/^int build(int n) { \/\/returns root of the tree$/;"	f	typeref:typename:int
build	code/Data Structures/Persistent Array.cpp	/^  int build(vector<T> v) {$/;"	f	struct:PersistentArray	typeref:typename:int	file:
build	code/Data Structures/Persistent Array.cpp	/^  node* build(int l, int r, vector<T>& v) {$/;"	f	struct:PersistentArray	typeref:typename:node *	file:
build	code/Data Structures/Persistent Queue.cpp	/^  int build(vector<T> v) {$/;"	f	struct:PersistentArray	typeref:typename:int	file:
build	code/Data Structures/Persistent Queue.cpp	/^  node* build(int l, int r, vector<T>& v) {$/;"	f	struct:PersistentArray	typeref:typename:node *	file:
build	code/Data Structures/Persistent UnionFind.cpp	/^  int build(vector<T> v) {$/;"	f	struct:PersistentArray	typeref:typename:int	file:
build	code/Data Structures/Persistent UnionFind.cpp	/^  node* build(int l, int r, vector<T>& v) {$/;"	f	struct:PersistentArray	typeref:typename:node *	file:
build	code/Data Structures/Reachability Tree.cpp	/^  void build(vector<array<int, 3>> e) { \/\/{w, u, v}$/;"	f	struct:RT	typeref:typename:void	file:
build	code/Data Structures/Reachability Tree.cpp	/^inline void build(int n, int l, int r) {$/;"	f	typeref:typename:void
build	code/Data Structures/SQRT Tree.cpp	/^  void build(int layer, int lBound, int rBound, int betweenOffs) {$/;"	f	struct:SqrtTree	typeref:typename:void	file:
build	code/Data Structures/Segment Tree Lazy.cpp	/^  void build(int n, int b, int e) {$/;"	f	struct:ST	typeref:typename:void	file:
build	code/Data Structures/Segment Tree Merging.cpp	/^  int build(int b, int e, int i) {$/;"	f	struct:STM	typeref:typename:int	file:
build	code/Data Structures/Segment Tree NonRecursive.cpp	/^  void build() {$/;"	f	struct:ST	typeref:typename:void	file:
build	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^  int build(int b, int e) {$/;"	f	struct:PST	typeref:typename:int	file:
build	code/Data Structures/Segment Tree Persistent.cpp	/^  int build(int b, int e) {$/;"	f	struct:PST	typeref:typename:int	file:
build	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  void build(int n, int b, int e) {$/;"	f	struct:ST	typeref:typename:void	file:
build	code/Data Structures/Segment Tree.cpp	/^  void build(int n, int b, int e) {$/;"	f	struct:ST	typeref:typename:void	file:
build	code/Data Structures/Sparse Table 2D.cpp	/^void build(int n, int m) { \/\/ 0 indexed$/;"	f	typeref:typename:void
build	code/Data Structures/Sparse Table.cpp	/^void build(int n) {$/;"	f	typeref:typename:void
build	code/Data Structures/Treap persistent.cpp	/^node* build(int l, int r, string &s) {$/;"	f	namespace:PersistentTreap	typeref:typename:node *
build	code/Geometry/Onion Decomposition.cpp	/^    void build(int w, int L, int R) {$/;"	f	struct:LeftHull	typeref:typename:void	file:
build	code/Graph Theory/Dijkstra on Segment Tree.cpp	/^void build(int n, int b, int e) {$/;"	f	typeref:typename:void
build	code/Graph Theory/Dominator Tree.cpp	/^void build(int r, int n) {$/;"	f	typeref:typename:void
build	code/Graph Theory/LCA in O(1).cpp	/^  void build(const vector<T>& V) {$/;"	f	struct:RMQ	typeref:typename:void	file:
build	code/Graph Theory/LCA in O(1).cpp	/^  void build(int root) {$/;"	f	struct:LCA	typeref:typename:void	file:
build	code/Graph Theory/Path Union.cpp	/^  void build(int n, int b, int e) {$/;"	f	struct:segtree	typeref:typename:void	file:
build	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^void build(int id, int l, int r) {$/;"	f	typeref:typename:void
build	code/Math/Polynomial.cpp	/^  poly build(vector<poly> &ans, int v, int l, int r, vector<mint> &vec) { \/\/builds evaluation /;"	f	struct:poly	typeref:typename:poly	file:
build	code/Miscellaneous/MEX of all Subarrays.cpp	/^  void build(int n, int b, int e) {$/;"	f	struct:ST	typeref:typename:void	file:
build	code/Strings/Suffix Array Isomorphic.cpp	/^  void build() {$/;"	f	struct:IsomorphicSuffixArray	typeref:typename:void	file:
build	code/Strings/Suffix Array Isomorphic.cpp	/^  void build() {$/;"	f	struct:SuffixArray	typeref:typename:void	file:
build	code/Strings/Suffix Array.cpp	/^  void build() {$/;"	f	struct:SuffixArray	typeref:typename:void	file:
build	code/Strings/Suffix Automaton.cpp	/^    void build(string &s) {$/;"	f	struct:SuffixAutomaton	typeref:typename:void	file:
buildBetween	code-library/Data Structures/SQRT Tree.cpp	/^  inline void buildBetween(int layer, int lBound, int rBound, int betweenOffs) {$/;"	f	struct:SqrtTree	typeref:typename:void	file:
buildBetween	code/Data Structures/SQRT Tree.cpp	/^  inline void buildBetween(int layer, int lBound, int rBound, int betweenOffs) {$/;"	f	struct:SqrtTree	typeref:typename:void	file:
buildBetweenZero	code-library/Data Structures/SQRT Tree.cpp	/^  inline void buildBetweenZero() {$/;"	f	struct:SqrtTree	typeref:typename:void	file:
buildBetweenZero	code/Data Structures/SQRT Tree.cpp	/^  inline void buildBetweenZero() {$/;"	f	struct:SqrtTree	typeref:typename:void	file:
buildBlock	code-library/Data Structures/SQRT Tree.cpp	/^  inline void buildBlock(int layer, int l, int r) {$/;"	f	struct:SqrtTree	typeref:typename:void	file:
buildBlock	code/Data Structures/SQRT Tree.cpp	/^  inline void buildBlock(int layer, int l, int r) {$/;"	f	struct:SqrtTree	typeref:typename:void	file:
build_lps	code-library/Strings/KMP.cpp	/^vector<int> build_lps(string p) {$/;"	f	typeref:typename:vector<int>
build_lps	code/Strings/KMP.cpp	/^vector<int> build_lps(string p) {$/;"	f	typeref:typename:vector<int>
build_tree	code-library/Data Structures/KD Tree.cpp	/^void build_tree(node_ptr &node, int from, int to, int axis) {$/;"	f	typeref:typename:void
build_tree	code-library/Graph Theory/Articulation Bridges.cpp	/^  void build_tree() {$/;"	f	struct:TECC	typeref:typename:void	file:
build_tree	code-library/Strings/Suffix Automaton.cpp	/^    void build_tree() {$/;"	f	struct:SuffixAutomaton	typeref:typename:void	file:
build_tree	code/Data Structures/KD Tree.cpp	/^void build_tree(node_ptr &node, int from, int to, int axis) {$/;"	f	typeref:typename:void
build_tree	code/Graph Theory/Articulation Bridges.cpp	/^  void build_tree() {$/;"	f	struct:TECC	typeref:typename:void	file:
build_tree	code/Strings/Suffix Automaton.cpp	/^    void build_tree() {$/;"	f	struct:SuffixAutomaton	typeref:typename:void	file:
buildtree	code-library/Graph Theory/Virtual Tree.cpp	/^vector<int> buildtree(vector<int> v) {$/;"	f	typeref:typename:vector<int>
buildtree	code/Graph Theory/Virtual Tree.cpp	/^vector<int> buildtree(vector<int> v) {$/;"	f	typeref:typename:vector<int>
c	code-library/Data Structures/DSU.cpp	/^  int c;$/;"	m	struct:DSU	typeref:typename:int	file:
c	code-library/Data Structures/Dynamic Diameter Online.cpp	/^    long long a = 0, b = 0, c = 0, d = 0, e = 0;$/;"	m	struct:node	typeref:typename:long long	file:
c	code-library/Data Structures/Link Cut Tree.cpp	/^  int p = 0, c[2] = {0, 0}, pp = 0;$/;"	m	struct:node	typeref:typename:int[2]	file:
c	code-library/Data Structures/Persistent UnionFind.cpp	/^  vector<int> c; int cur = 0;$/;"	m	struct:PersistentDSU	typeref:typename:vector<int>	file:
c	code-library/Data Structures/Top Tree.cpp	/^  top_tree_node* c[3] = {nullptr, nullptr, nullptr};$/;"	m	struct:top_tree_node	typeref:typename:top_tree_node * [3]	file:
c	code-library/Data Structures/Treap persistent.cpp	/^int c = 0;$/;"	v	namespace:PersistentTreap	typeref:typename:int
c	code-library/Data Structures/Wavelet Tree.cpp	/^  int *b, *c, bsz, csz; \/\/ c holds the prefix sum of elements$/;"	m	struct:wavelet_tree	typeref:typename:int *	file:
c	code-library/Dynamic Programming Optimizations/Divide and Conquer Optimization.cpp	/^int a[N][N], c[N][N], dp[810][N]; \/\/ dp[i][j]=minimum cost for dividing [1...j] into i parts$/;"	v	typeref:typename:int[][]
c	code-library/Dynamic Programming Optimizations/Dynamic Submask Count.cpp	/^int c[N], small[N], big[N];$/;"	v	typeref:typename:int[]
c	code-library/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  ll m, c;$/;"	m	struct:Line	typeref:typename:ll	file:
c	code-library/Dynamic Programming Optimizations/Subset Union of Bitsets.cpp	/^int x[N], y[N], c[N], dp[1 << 20], msk[N], ans[N];$/;"	v	typeref:typename:int[]
c	code-library/Geometry/Geometry 2D.cpp	/^    PT v; double c;  \/\/line form: direction vec [cross] (x, y) = c $/;"	m	struct:line	typeref:typename:double	file:
c	code-library/Geometry/Geometry 3D.cpp	/^        int a, b, c; \/\/ the number of three points on one face of the convex hull$/;"	m	struct:CH3D::face	typeref:typename:int	file:
c	code-library/Graph Theory/Boruvka's Algorithm.cpp	/^  vector<int> par, rnk, size; int c;$/;"	m	struct:dsu	typeref:typename:int	file:
c	code-library/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^int c[2];$/;"	v	namespace:EdgeColoring	typeref:typename:int[2]
c	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  int c;$/;"	m	struct:dsu	typeref:typename:int	file:
c	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  vector<int> p, w, c;$/;"	m	struct:GomoryHuTree	typeref:typename:vector<int>	file:
c	code-library/Graph Theory/Hungarian Algorithm.cpp	/^  long long c[N][N], fx[N], fy[N], d[N];$/;"	m	struct:Hungarian	typeref:typename:long long[][]	file:
c	code-library/Graph Theory/Kirchoffs Theorem.cpp	/^  int c;$/;"	m	struct:dsu	typeref:typename:int	file:
c	code-library/Graph Theory/Krushkal's MST.cpp	/^  vector<int> par, rnk, size; int c;$/;"	m	struct:dsu	typeref:typename:int	file:
c	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^    cost_t c;$/;"	m	struct:mcSFlow::Edge	typeref:typename:cost_t	file:
c	code-library/Math/Lagrange Multiplier.cpp	/^int b[N], c[N];$/;"	v	typeref:typename:int[]
c	code-library/Miscellaneous/Subset Union of Bitsets.cpp	/^int x[N], y[N], c[N], dp[1 << 20], msk[N], ans[N];$/;"	v	typeref:typename:int[]
c	code-library/Strings/Number of Palindromes in Range.cpp	/^  int *b, *c, bsz, csz; \/\/  c holds the prefix sum of elements$/;"	m	struct:wavelet_tree	typeref:typename:int *	file:
c	code-library/Strings/Number of Palindromes in Range.cpp	/^int a[N], b[N], c[N], d[N];$/;"	v	typeref:typename:int[]
c	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  int par[N * 2], lazy[N * 2], last[N * 2], c[N * 2][2];$/;"	v	namespace:lct	typeref:typename:int[][2]
c	code/Data Structures/DSU.cpp	/^  int c;$/;"	m	struct:DSU	typeref:typename:int	file:
c	code/Data Structures/Dynamic Diameter Online.cpp	/^    long long a = 0, b = 0, c = 0, d = 0, e = 0;$/;"	m	struct:node	typeref:typename:long long	file:
c	code/Data Structures/Link Cut Tree.cpp	/^  int p = 0, c[2] = {0, 0}, pp = 0;$/;"	m	struct:node	typeref:typename:int[2]	file:
c	code/Data Structures/Persistent UnionFind.cpp	/^  vector<int> c; int cur = 0;$/;"	m	struct:PersistentDSU	typeref:typename:vector<int>	file:
c	code/Data Structures/Top Tree.cpp	/^  top_tree_node* c[3] = {nullptr, nullptr, nullptr};$/;"	m	struct:top_tree_node	typeref:typename:top_tree_node * [3]	file:
c	code/Data Structures/Treap persistent.cpp	/^int c = 0;$/;"	v	namespace:PersistentTreap	typeref:typename:int
c	code/Data Structures/Wavelet Tree.cpp	/^  int *b, *c, bsz, csz; \/\/ c holds the prefix sum of elements$/;"	m	struct:wavelet_tree	typeref:typename:int *	file:
c	code/Dynamic Programming Optimizations/Divide and Conquer Optimization.cpp	/^int a[N][N], c[N][N], dp[810][N]; \/\/ dp[i][j]=minimum cost for dividing [1...j] into i parts$/;"	v	typeref:typename:int[][]
c	code/Dynamic Programming Optimizations/Dynamic Submask Count.cpp	/^int c[N], small[N], big[N];$/;"	v	typeref:typename:int[]
c	code/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  ll m, c;$/;"	m	struct:Line	typeref:typename:ll	file:
c	code/Dynamic Programming Optimizations/Subset Union of Bitsets.cpp	/^int x[N], y[N], c[N], dp[1 << 20], msk[N], ans[N];$/;"	v	typeref:typename:int[]
c	code/Geometry/Geometry 2D.cpp	/^    PT v; double c;  \/\/line form: direction vec [cross] (x, y) = c $/;"	m	struct:line	typeref:typename:double	file:
c	code/Geometry/Geometry 3D.cpp	/^        int a, b, c; \/\/ the number of three points on one face of the convex hull$/;"	m	struct:CH3D::face	typeref:typename:int	file:
c	code/Graph Theory/Boruvka's Algorithm.cpp	/^  vector<int> par, rnk, size; int c;$/;"	m	struct:dsu	typeref:typename:int	file:
c	code/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^int c[2];$/;"	v	namespace:EdgeColoring	typeref:typename:int[2]
c	code/Graph Theory/Gomory Hu Tree.cpp	/^  int c;$/;"	m	struct:dsu	typeref:typename:int	file:
c	code/Graph Theory/Gomory Hu Tree.cpp	/^  vector<int> p, w, c;$/;"	m	struct:GomoryHuTree	typeref:typename:vector<int>	file:
c	code/Graph Theory/Hungarian Algorithm.cpp	/^  long long c[N][N], fx[N], fy[N], d[N];$/;"	m	struct:Hungarian	typeref:typename:long long[][]	file:
c	code/Graph Theory/Kirchoffs Theorem.cpp	/^  int c;$/;"	m	struct:dsu	typeref:typename:int	file:
c	code/Graph Theory/Krushkal's MST.cpp	/^  vector<int> par, rnk, size; int c;$/;"	m	struct:dsu	typeref:typename:int	file:
c	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^    cost_t c;$/;"	m	struct:mcSFlow::Edge	typeref:typename:cost_t	file:
c	code/Math/Lagrange Multiplier.cpp	/^int b[N], c[N];$/;"	v	typeref:typename:int[]
c	code/Miscellaneous/Subset Union of Bitsets.cpp	/^int x[N], y[N], c[N], dp[1 << 20], msk[N], ans[N];$/;"	v	typeref:typename:int[]
c	code/Strings/Number of Palindromes in Range.cpp	/^  int *b, *c, bsz, csz; \/\/  c holds the prefix sum of elements$/;"	m	struct:wavelet_tree	typeref:typename:int *	file:
c	code/Strings/Number of Palindromes in Range.cpp	/^int a[N], b[N], c[N], d[N];$/;"	v	typeref:typename:int[]
c	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  int par[N * 2], lazy[N * 2], last[N * 2], c[N * 2][2];$/;"	v	namespace:lct	typeref:typename:int[][2]
c	practice/usacoguide/gold/introDP/711C.cpp	/^int c[N];$/;"	v	typeref:typename:int[]
cache	code-library/Math/Polynomial Factorization.cpp	/^vi cache[MAXN];$/;"	v	typeref:typename:vi[]
cache	code/Math/Polynomial Factorization.cpp	/^vi cache[MAXN];$/;"	v	typeref:typename:vi[]
calc	code-library/Number Theory/Fermats Theorem on Sum of Two Squares.cpp	/^    pair<int, int> calc(long long p) {$/;"	f	namespace:FermatRepresent	typeref:typename:pair<int,int>
calc	code/Number Theory/Fermats Theorem on Sum of Two Squares.cpp	/^    pair<int, int> calc(long long p) {$/;"	f	namespace:FermatRepresent	typeref:typename:pair<int,int>
calc	practice/cf/DP/knap2.cpp	/^int calc(int l, int r){	$/;"	f	typeref:typename:int
calc	practice/cf/random/i_hate_math_problems/1336B.cpp	/^void calc(vector<int> &A, vector<int> &B, vector<int> &C) {$/;"	f	typeref:typename:void
calc_occurrences	code-library/Strings/Palindromic Tree.cpp	/^  void calc_occurrences() {$/;"	f	struct:PalindromicTree	typeref:typename:void	file:
calc_occurrences	code/Strings/Palindromic Tree.cpp	/^  void calc_occurrences() {$/;"	f	struct:PalindromicTree	typeref:typename:void	file:
calc_sz	code-library/Data Structures/Binarizing a Tree.cpp	/^void calc_sz(int u, int p) {$/;"	f	typeref:typename:void
calc_sz	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^void calc_sz(int u, int p) {$/;"	f	typeref:typename:void
calc_sz	code-library/Data Structures/Centroid Decomposition.cpp	/^void calc_sz(int u, int p) {$/;"	f	typeref:typename:void
calc_sz	code-library/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^void calc_sz(int u, int p) {$/;"	f	typeref:typename:void
calc_sz	code-library/Graph Theory/Tree Orientation.cpp	/^void calc_sz(int u, int p) {$/;"	f	typeref:typename:void
calc_sz	code/Data Structures/Binarizing a Tree.cpp	/^void calc_sz(int u, int p) {$/;"	f	typeref:typename:void
calc_sz	code/Data Structures/Centroid Decomposition Persistent.cpp	/^void calc_sz(int u, int p) {$/;"	f	typeref:typename:void
calc_sz	code/Data Structures/Centroid Decomposition.cpp	/^void calc_sz(int u, int p) {$/;"	f	typeref:typename:void
calc_sz	code/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^void calc_sz(int u, int p) {$/;"	f	typeref:typename:void
calc_sz	code/Graph Theory/Tree Orientation.cpp	/^void calc_sz(int u, int p) {$/;"	f	typeref:typename:void
can	code-library/Math/Basis Vector.cpp	/^  bool can(int x) {$/;"	f	struct:Basis	typeref:typename:bool	file:
can	code-library/Number Theory/Linear Diophantine Equation with Nonnegative Solutions.cpp	/^  bool can(ll k) { \/\/ if a solution exists$/;"	f	struct:LDE	typeref:typename:bool	file:
can	code-library/Number Theory/Linear Diophantine With N Unknowns and Two Equations.cpp	/^bool can(ll x, ll y) {$/;"	f	typeref:typename:bool
can	code/Math/Basis Vector.cpp	/^  bool can(int x) {$/;"	f	struct:Basis	typeref:typename:bool	file:
can	code/Number Theory/Linear Diophantine Equation with Nonnegative Solutions.cpp	/^  bool can(ll k) { \/\/ if a solution exists$/;"	f	struct:LDE	typeref:typename:bool	file:
can	code/Number Theory/Linear Diophantine With N Unknowns and Two Equations.cpp	/^bool can(ll x, ll y) {$/;"	f	typeref:typename:bool
can	practice/cpbook/ch1/1.6/chess/chess/main.cpp	/^void can(pair<int, int> go, pair<int, int> original) {$/;"	f	typeref:typename:void
cap	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  const F cap;  \/\/ capacity$/;"	m	struct:S	typeref:typename:const F	file:
cap	code-library/Graph Theory/L R Flow with MCMF.cpp	/^    T cap, cost;$/;"	m	struct:MCMF::edge	typeref:typename:T	file:
cap	code-library/Graph Theory/Min Cost Max Flow.cpp	/^    T cap, cost;$/;"	m	struct:MCMF::edge	typeref:typename:T	file:
cap	code/Graph Theory/Gomory Hu Tree.cpp	/^  const F cap;  \/\/ capacity$/;"	m	struct:S	typeref:typename:const F	file:
cap	code/Graph Theory/L R Flow with MCMF.cpp	/^    T cap, cost;$/;"	m	struct:MCMF::edge	typeref:typename:T	file:
cap	code/Graph Theory/Min Cost Max Flow.cpp	/^    T cap, cost;$/;"	m	struct:MCMF::edge	typeref:typename:T	file:
carSpot	practice/cpbook/ch1/1.4/medium/garage.cpp	/^int carSpot[mxN];$/;"	v	typeref:typename:int[]
cartesian_tree	code-library/Data Structures/Cartesian Tree.cpp	/^int cartesian_tree() {$/;"	f	typeref:typename:int
cartesian_tree	code/Data Structures/Cartesian Tree.cpp	/^int cartesian_tree() {$/;"	f	typeref:typename:int
catalan	code-library/Math/NTT Online.cpp	/^int catalan(int n) {$/;"	f	typeref:typename:int
catalan	code/Math/NTT Online.cpp	/^int catalan(int n) {$/;"	f	typeref:typename:int
ccw	code-library/Geometry/Voronoi Diagram.cpp	/^map<int, int> ccw[N];$/;"	v	typeref:typename:map<int,int>[]
ccw	code/Geometry/Voronoi Diagram.cpp	/^map<int, int> ccw[N];$/;"	v	typeref:typename:map<int,int>[]
cdiv	code-library/Number Theory/Smallest Nonnegative Integer x s.t. l <= ax % p <= r.cpp	/^T cdiv(T x, T y) { return (x + y - 1) \/ y; }$/;"	f	typeref:typename:T
cdiv	code/Number Theory/Smallest Nonnegative Integer x s.t. l <= ax % p <= r.cpp	/^T cdiv(T x, T y) { return (x + y - 1) \/ y; }$/;"	f	typeref:typename:T
cdiv	contests/Codeforces/1560/C/main.cpp	/^int cdiv(int a, int b) { return a \/ b + ((a ^ b) > 0 && a % b); }$/;"	f	typeref:typename:int
cdiv	contests/Codeforces/1622/upsolve/C/sol.cpp	/^ll cdiv(ll a, ll b) { return a\/b+((a^b)>0&&a%b); } \/\/ divide a by b rounded up$/;"	f	typeref:typename:ll
cdiv	contests/Codeforces/1623/C/sol.cpp	/^ll cdiv(ll a, ll b) { return a\/b+((a^b)>0&&a%b); } \/\/ divide a by b rounded up$/;"	f	typeref:typename:ll
cdiv	practice/cpbook/ch1/1.4/medium/12157.cpp	/^int cdiv(int a, int b) { return a \/ b + ((a ^ b) > 0 && a % b); }$/;"	f	typeref:typename:int
cdiv	practice/cpbook/ch1/1.4/medium/12643.cpp	/^int cdiv(int a, int b) { return a \/ b + ((a ^ b) > 0 && a % b); }$/;"	f	typeref:typename:int
cdiv	practice/cpbook/ch1/1.4/medium/fastfood.cpp	/^int cdiv(int a, int b) { return a \/ b + ((a ^ b) > 0 && a % b); }$/;"	f	typeref:typename:int
cdiv	practice/cpbook/ch1/1.6/chess/00225/main.cpp	/^int cdiv(int a, int b) { return a \/ b + ((a ^ b) > 0 && a % b); }$/;"	f	typeref:typename:int
cdiv	practice/cpbook/ch1/1.6/chess/00696/main.cpp	/^int cdiv(int a, int b) { return a \/ b + ((a ^ b) > 0 && a % b); }$/;"	f	typeref:typename:int
cdiv	practice/cpbook/ch1/1.6/reallife/medium/00161/main.cpp	/^int cdiv(int a, int b) { return a \/ b + ((a ^ b) > 0 && a % b); }$/;"	f	typeref:typename:int
cdiv	practice/cpbook/ch2/2.2/1D/13181/main.cpp	/^int cdiv(int a, int b) { return a \/ b + ((a ^ b) > 0 && a % b); }$/;"	f	typeref:typename:int
cenpar	code-library/Data Structures/Binarizing a Tree.cpp	/^int tot, done[N * 2], cenpar[N * 2];$/;"	v	typeref:typename:int[]
cenpar	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^int tot, done[N * 2], cenpar[N * 2];$/;"	v	typeref:typename:int[]
cenpar	code-library/Data Structures/Centroid Decomposition.cpp	/^int tot, done[N], cenpar[N];$/;"	v	typeref:typename:int[]
cenpar	code-library/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^int tot, done[N], cenpar[N];$/;"	v	typeref:typename:int[]
cenpar	code/Data Structures/Binarizing a Tree.cpp	/^int tot, done[N * 2], cenpar[N * 2];$/;"	v	typeref:typename:int[]
cenpar	code/Data Structures/Centroid Decomposition Persistent.cpp	/^int tot, done[N * 2], cenpar[N * 2];$/;"	v	typeref:typename:int[]
cenpar	code/Data Structures/Centroid Decomposition.cpp	/^int tot, done[N], cenpar[N];$/;"	v	typeref:typename:int[]
cenpar	code/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^int tot, done[N], cenpar[N];$/;"	v	typeref:typename:int[]
centroid	code-library/Geometry/Geometry 2D.cpp	/^PT centroid(vector<PT> &p) {$/;"	f	typeref:typename:PT
centroid	code-library/Geometry/Geometry 3D.cpp	/^    p3 centroid() { \/\/ center of gravity$/;"	f	struct:CH3D	typeref:typename:p3	file:
centroid	code/Geometry/Geometry 2D.cpp	/^PT centroid(vector<PT> &p) {$/;"	f	typeref:typename:PT
centroid	code/Geometry/Geometry 3D.cpp	/^    p3 centroid() { \/\/ center of gravity$/;"	f	struct:CH3D	typeref:typename:p3	file:
ch	code-library/Data Structures/Persistent Meldable Heap.cpp	/^    node* ch[2] = {0, 0};$/;"	m	struct:heap::node	typeref:typename:node * [2]	file:
ch	code-library/Graph Theory/Eppsteins Algorithm.cpp	/^    node* ch[2] = {0, 0};$/;"	m	struct:heap::node	typeref:typename:node * [2]	file:
ch	code/Data Structures/Persistent Meldable Heap.cpp	/^    node* ch[2] = {0, 0};$/;"	m	struct:heap::node	typeref:typename:node * [2]	file:
ch	code/Graph Theory/Eppsteins Algorithm.cpp	/^    node* ch[2] = {0, 0};$/;"	m	struct:heap::node	typeref:typename:node * [2]	file:
changes	code-library/Strings/Palindromic Tree Persistent.cpp	/^  vector<array<int, 4>> changes;$/;"	m	struct:PalindromicTree	typeref:typename:vector<array<int,4>>	file:
changes	code/Strings/Palindromic Tree Persistent.cpp	/^  vector<array<int, 4>> changes;$/;"	m	struct:PalindromicTree	typeref:typename:vector<array<int,4>>	file:
check	code-library/Geometry/Geometry 2D.cpp	/^int check(HP a, HP b, HP c) {$/;"	f	typeref:typename:int
check	code-library/Geometry/Half Plane Intersection.cpp	/^int check(HP a, HP b, HP c) {$/;"	f	typeref:typename:int
check	code-library/Math/Finite Field Arithmetic Binary.cpp	/^bool check(int n) {$/;"	f	typeref:typename:bool
check	code/Geometry/Geometry 2D.cpp	/^int check(HP a, HP b, HP c) {$/;"	f	typeref:typename:int
check	code/Geometry/Half Plane Intersection.cpp	/^int check(HP a, HP b, HP c) {$/;"	f	typeref:typename:int
check	code/Math/Finite Field Arithmetic Binary.cpp	/^bool check(int n) {$/;"	f	typeref:typename:bool
check	contests/Codeforces/1609/B.cpp	/^bool check(int pos, char c) {$/;"	f	typeref:typename:bool
check	contests/Codeforces/1622/C/sol.cpp	/^bool check(int e, int x) {$/;"	f	typeref:typename:bool
check	contests/Codeforces/1622/C_new/sol.cpp	/^bool check(int steps) {$/;"	f	typeref:typename:bool
check	contests/Codeforces/1623/C/sol.cpp	/^bool check(vector<int> A, int &N, int stones) {$/;"	f	typeref:typename:bool
check	contests/Codeforces/1623/new_C/sol.cpp	/^bool check(int stones) {$/;"	f	typeref:typename:bool
check	contests/LIT2021/C.cpp	/^void check(P a_next, P a, P k_next, P k) {$/;"	f	typeref:typename:void
check	practice/cf/random/pink/main.cpp	/^bool check(int x) {$/;"	f	typeref:typename:bool
check	practice/cpbook/ch1/1.6/chess/10284/main.cpp	/^bool check(int row, int col) {$/;"	f	typeref:typename:bool
check	practice/cpbook/ch1/1.6/chess/chess/main.cpp	/^string check(pair<int, int> cur) {$/;"	f	typeref:typename:string
check	practice/cpbook/ch1/1.6/game/easier/10189/main.cpp	/^bool check(int row, int col) {$/;"	f	typeref:typename:bool
check	practice/cpbook/ch1/1.6/reallife/medium/01091/ac.cpp	/^string check() {$/;"	f	typeref:typename:string
check	practice/cpbook/ch1/1.6/reallife/medium/01091/main.cpp	/^bool check(int a, int b, int c, int d, int e, int N) {$/;"	f	typeref:typename:bool
check	practice/cpbook/ch2/2.2/2D/11581/main.cpp	/^bool check() {$/;"	f	typeref:typename:bool
check	practice/usacoguide/gold/SP/visitfj.cpp	/^bool check(int x) {$/;"	f	typeref:typename:bool
check	practice/usacoguide/gold/SP/visitfj/main.cpp	/^bool check(int x) {$/;"	f	typeref:typename:bool
check	practice/usacoguide/gold/bfs/mecho/main.cpp	/^bool check(int seconds) {$/;"	f	typeref:typename:bool
check	practice/usacoguide/gold/bfs/mechonew/main.cpp	/^bool check(int seconds) {$/;"	f	typeref:typename:bool
check	practice/usacoguide/gold/bfs/monsters.cpp	/^void check(pair<int, int> origin, pair<int, int> dest) {$/;"	f	typeref:typename:void
check	practice/usacoguide/gold/bfs/swap.cpp	/^bool check(int x) {$/;"	f	typeref:typename:bool
check	practice/usacoguide/gold/dsu/moocast/main.cpp	/^bool check(int dist) {$/;"	f	typeref:typename:bool
check	practice/usacoguide/gold/dsu/tractor/main.cpp	/^bool check(int max_dist) {$/;"	f	typeref:typename:bool
check	practice/usacoguide/gold/dsu/wormhole/main.cpp	/^bool check(int width) {$/;"	f	typeref:typename:bool
check	practice/usacoguide/silver/binsearch/sabotage.cpp	/^bool check(double avg) {$/;"	f	typeref:typename:bool
check	practice/usacoguide/silver/idk/maze/main.cpp	/^bool check(int x) {$/;"	f	typeref:typename:bool
child	code-library/Graph Theory/DAG Reachability Dynamic.cpp	/^  vector<vector<vector<int>>> child;$/;"	m	struct:Italiano	typeref:typename:vector<vector<vector<int>>>	file:
child	code/Graph Theory/DAG Reachability Dynamic.cpp	/^  vector<vector<vector<int>>> child;$/;"	m	struct:Italiano	typeref:typename:vector<vector<vector<int>>>	file:
chirpz	code-library/Math/Faulhaber Formula Fastest.cpp	/^  vector<mint> chirpz(mint z, int n) { \/\/P(1), P(z), P(z^2), ..., P(z^(n-1))$/;"	f	struct:poly	typeref:typename:vector<mint>	file:
chirpz	code-library/Math/Polynomial.cpp	/^  vector<mint> chirpz(mint z, int n) { \/\/P(1), P(z), P(z^2), ..., P(z^(n-1))$/;"	f	struct:poly	typeref:typename:vector<mint>	file:
chirpz	code/Math/Faulhaber Formula Fastest.cpp	/^  vector<mint> chirpz(mint z, int n) { \/\/P(1), P(z), P(z^2), ..., P(z^(n-1))$/;"	f	struct:poly	typeref:typename:vector<mint>	file:
chirpz	code/Math/Polynomial.cpp	/^  vector<mint> chirpz(mint z, int n) { \/\/P(1), P(z), P(z^2), ..., P(z^(n-1))$/;"	f	struct:poly	typeref:typename:vector<mint>	file:
chirpz_even	code-library/Math/Faulhaber Formula Fastest.cpp	/^  vector<mint> chirpz_even(mint z, int n) { \/\/P(1), P(z^2), P(z^4), ..., P(z^2(n-1))$/;"	f	struct:poly	typeref:typename:vector<mint>	file:
chirpz_even	code-library/Math/Polynomial.cpp	/^  vector<mint> chirpz_even(mint z, int n) { \/\/P(1), P(z^2), P(z^4), ..., P(z^2(n-1))$/;"	f	struct:poly	typeref:typename:vector<mint>	file:
chirpz_even	code/Math/Faulhaber Formula Fastest.cpp	/^  vector<mint> chirpz_even(mint z, int n) { \/\/P(1), P(z^2), P(z^4), ..., P(z^2(n-1))$/;"	f	struct:poly	typeref:typename:vector<mint>	file:
chirpz_even	code/Math/Polynomial.cpp	/^  vector<mint> chirpz_even(mint z, int n) { \/\/P(1), P(z^2), P(z^4), ..., P(z^2(n-1))$/;"	f	struct:poly	typeref:typename:vector<mint>	file:
chk	code-library/Graph Theory/Dynamic MST.cpp	/^int st[MAXN], ed[MAXN], cost[MAXN], chk[MAXN];$/;"	v	typeref:typename:int[]
chk	code/Graph Theory/Dynamic MST.cpp	/^int st[MAXN], ed[MAXN], cost[MAXN], chk[MAXN];$/;"	v	typeref:typename:int[]
chromatic_number	code-library/Graph Theory/Chromatic Number.cpp	/^int chromatic_number(int n) {$/;"	f	typeref:typename:int
chromatic_number	code/Graph Theory/Chromatic Number.cpp	/^int chromatic_number(int n) {$/;"	f	typeref:typename:int
cht	code-library/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^CHT cht;$/;"	v	typeref:typename:CHT
cht	code-library/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^CHT* cht;$/;"	v	typeref:typename:CHT *
cht	code-library/Dynamic Programming Optimizations/Persistent CHT.cpp	/^} cht;$/;"	v	typeref:struct:PersistentCHT
cht	code/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^CHT cht;$/;"	v	typeref:typename:CHT
cht	code/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^CHT* cht;$/;"	v	typeref:typename:CHT *
cht	code/Dynamic Programming Optimizations/Persistent CHT.cpp	/^} cht;$/;"	v	typeref:struct:PersistentCHT
circ	code-library/Geometry/Delaunay Triangulation.cpp	/^bool circ(PT p, PT a, PT b, PT c) { \/\/ is p in the circumcircle?$/;"	f	typeref:typename:bool
circ	code-library/Geometry/Voronoi Diagram.cpp	/^bool circ(P p, P a, P b, P c) { \/\/ is p in the circumcircle?$/;"	f	typeref:typename:bool
circ	code/Geometry/Delaunay Triangulation.cpp	/^bool circ(PT p, PT a, PT b, PT c) { \/\/ is p in the circumcircle?$/;"	f	typeref:typename:bool
circ	code/Geometry/Voronoi Diagram.cpp	/^bool circ(P p, P a, P b, P c) { \/\/ is p in the circumcircle?$/;"	f	typeref:typename:bool
circle	code-library/Geometry/Delaunay Triangulation.cpp	/^double circle(PT A, PT B, PT C) { \/\/ radius of the circumcircle$/;"	f	typeref:typename:double
circle	code-library/Geometry/Geometry 2D.cpp	/^    circle() {}$/;"	f	struct:circle	file:
circle	code-library/Geometry/Geometry 2D.cpp	/^    circle(PT _p, double _r): p(_p), r(_r) {};$/;"	f	struct:circle	file:
circle	code-library/Geometry/Geometry 2D.cpp	/^    circle(PT a, PT b, PT c) {$/;"	f	struct:circle	file:
circle	code-library/Geometry/Geometry 2D.cpp	/^    circle(PT a, PT b, PT c, bool t) {$/;"	f	struct:circle	file:
circle	code-library/Geometry/Geometry 2D.cpp	/^    circle(double x, double y, double _r): p(PT(x, y)), r(_r) {};$/;"	f	struct:circle	file:
circle	code-library/Geometry/Geometry 2D.cpp	/^struct circle {$/;"	s	file:
circle	code-library/Geometry/Voronoi Diagram.cpp	/^PT circle(PT a, PT b, PT c) { \/\/ radius of the circumcircle$/;"	f	typeref:typename:PT
circle	code/Geometry/Delaunay Triangulation.cpp	/^double circle(PT A, PT B, PT C) { \/\/ radius of the circumcircle$/;"	f	typeref:typename:double
circle	code/Geometry/Geometry 2D.cpp	/^    circle() {}$/;"	f	struct:circle	file:
circle	code/Geometry/Geometry 2D.cpp	/^    circle(PT _p, double _r): p(_p), r(_r) {};$/;"	f	struct:circle	file:
circle	code/Geometry/Geometry 2D.cpp	/^    circle(PT a, PT b, PT c) {$/;"	f	struct:circle	file:
circle	code/Geometry/Geometry 2D.cpp	/^    circle(PT a, PT b, PT c, bool t) {$/;"	f	struct:circle	file:
circle	code/Geometry/Geometry 2D.cpp	/^    circle(double x, double y, double _r): p(PT(x, y)), r(_r) {};$/;"	f	struct:circle	file:
circle	code/Geometry/Geometry 2D.cpp	/^struct circle {$/;"	s	file:
circle	code/Geometry/Voronoi Diagram.cpp	/^PT circle(PT a, PT b, PT c) { \/\/ radius of the circumcircle$/;"	f	typeref:typename:PT
circle_center	code-library/Geometry/Geometry 3D.cpp	/^p3 circle_center(p3 a, p3 b, p3 c) {$/;"	f	typeref:typename:p3
circle_center	code/Geometry/Geometry 3D.cpp	/^p3 circle_center(p3 a, p3 b, p3 c) {$/;"	f	typeref:typename:p3
circle_circle_area	code-library/Geometry/Geometry 2D.cpp	/^double circle_circle_area(PT a, double r1, PT b, double r2) {$/;"	f	typeref:typename:double
circle_circle_area	code/Geometry/Geometry 2D.cpp	/^double circle_circle_area(PT a, double r1, PT b, double r2) {$/;"	f	typeref:typename:double
circle_circle_intersection	code-library/Geometry/Geometry 2D.cpp	/^vector<PT> circle_circle_intersection(PT a, double r, PT b, double R) {$/;"	f	typeref:typename:vector<PT>
circle_circle_intersection	code/Geometry/Geometry 2D.cpp	/^vector<PT> circle_circle_intersection(PT a, double r, PT b, double R) {$/;"	f	typeref:typename:vector<PT>
circle_circle_relation	code-library/Geometry/Geometry 2D.cpp	/^int circle_circle_relation(PT a, double r, PT b, double R) {$/;"	f	typeref:typename:int
circle_circle_relation	code/Geometry/Geometry 2D.cpp	/^int circle_circle_relation(PT a, double r, PT b, double R) {$/;"	f	typeref:typename:int
circle_line_intersection	code-library/Geometry/Geometry 2D.cpp	/^vector<PT> circle_line_intersection(PT c, double r, PT a, PT b) {$/;"	f	typeref:typename:vector<PT>
circle_line_intersection	code/Geometry/Geometry 2D.cpp	/^vector<PT> circle_line_intersection(PT c, double r, PT a, PT b) {$/;"	f	typeref:typename:vector<PT>
circle_line_relation	code-library/Geometry/Geometry 2D.cpp	/^int circle_line_relation(PT p, double r, PT a, PT b) {$/;"	f	typeref:typename:int
circle_line_relation	code/Geometry/Geometry 2D.cpp	/^int circle_line_relation(PT p, double r, PT a, PT b) {$/;"	f	typeref:typename:int
circle_point_relation	code-library/Geometry/Geometry 2D.cpp	/^int circle_point_relation(PT p, double r, PT b) {$/;"	f	typeref:typename:int
circle_point_relation	code/Geometry/Geometry 2D.cpp	/^int circle_point_relation(PT p, double r, PT b) {$/;"	f	typeref:typename:int
circumference	code-library/Geometry/Geometry 2D.cpp	/^    double circumference() { return 2.0 * PI * r; }$/;"	f	struct:circle	typeref:typename:double	file:
circumference	code/Geometry/Geometry 2D.cpp	/^    double circumference() { return 2.0 * PI * r; }$/;"	f	struct:circle	typeref:typename:double	file:
clear	code-library/Data Structures/Implicit Treap.cpp	/^  void clear() {$/;"	f	struct:treap	typeref:typename:void	file:
clear	code-library/Data Structures/Static to Dynamic Trick.cpp	/^  void clear() {$/;"	f	struct:aho_corasick	typeref:typename:void	file:
clear	code-library/Data Structures/Static to Dynamic Trick.cpp	/^  void clear() {$/;"	f	struct:aho_corasick_static	typeref:typename:void	file:
clear	code-library/Game Theory/Blue Red Hackenbush.cpp	/^  void clear() {$/;"	f	struct:surreal	typeref:typename:void	file:
clear	code-library/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  void clear() {$/;"	f	struct:Euler	typeref:typename:void	file:
clear	code-library/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^void clear(int n) {$/;"	f	namespace:EdgeColoring	typeref:typename:void
clear	code-library/Graph Theory/Edge Coloring Simple Graph.cpp	/^void clear() {$/;"	f	namespace:Vizing	typeref:typename:void
clear	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  void clear() {$/;"	f	struct:FlowGraph	typeref:typename:void	file:
clear	code-library/Strings/Aho Corasick Dynamic.cpp	/^  void clear() {$/;"	f	struct:aho_corasick	typeref:typename:void	file:
clear	code-library/Strings/Aho Corasick Dynamic.cpp	/^  void clear() {$/;"	f	struct:aho_corasick_static	typeref:typename:void	file:
clear	code-library/Strings/Bit LCS.cpp	/^    void clear() {$/;"	f	struct:Bitset	typeref:typename:void	file:
clear	code/Data Structures/Implicit Treap.cpp	/^  void clear() {$/;"	f	struct:treap	typeref:typename:void	file:
clear	code/Data Structures/Static to Dynamic Trick.cpp	/^  void clear() {$/;"	f	struct:aho_corasick	typeref:typename:void	file:
clear	code/Data Structures/Static to Dynamic Trick.cpp	/^  void clear() {$/;"	f	struct:aho_corasick_static	typeref:typename:void	file:
clear	code/Game Theory/Blue Red Hackenbush.cpp	/^  void clear() {$/;"	f	struct:surreal	typeref:typename:void	file:
clear	code/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  void clear() {$/;"	f	struct:Euler	typeref:typename:void	file:
clear	code/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^void clear(int n) {$/;"	f	namespace:EdgeColoring	typeref:typename:void
clear	code/Graph Theory/Edge Coloring Simple Graph.cpp	/^void clear() {$/;"	f	namespace:Vizing	typeref:typename:void
clear	code/Graph Theory/Gomory Hu Tree.cpp	/^  void clear() {$/;"	f	struct:FlowGraph	typeref:typename:void	file:
clear	code/Strings/Aho Corasick Dynamic.cpp	/^  void clear() {$/;"	f	struct:aho_corasick	typeref:typename:void	file:
clear	code/Strings/Aho Corasick Dynamic.cpp	/^  void clear() {$/;"	f	struct:aho_corasick_static	typeref:typename:void	file:
clear	code/Strings/Bit LCS.cpp	/^    void clear() {$/;"	f	struct:Bitset	typeref:typename:void	file:
clone	code-library/Data Structures/Persistent Trie.cpp	/^  pnode clone() {$/;"	f	struct:node_t	typeref:typename:pnode	file:
clone	code/Data Structures/Persistent Trie.cpp	/^  pnode clone() {$/;"	f	struct:node_t	typeref:typename:pnode	file:
closest_on_l1	code-library/Geometry/Geometry 3D.cpp	/^p3 closest_on_l1(line3d l1, line3d l2) {$/;"	f	typeref:typename:p3
closest_on_l1	code/Geometry/Geometry 3D.cpp	/^p3 closest_on_l1(line3d l1, line3d l2) {$/;"	f	typeref:typename:p3
closest_pair	code-library/Geometry/Closest Pair of Points.cpp	/^pair<int, int> closest_pair(vector<pair<int, int>> a) {$/;"	f	typeref:typename:pair<int,int>
closest_pair	code/Geometry/Closest Pair of Points.cpp	/^pair<int, int> closest_pair(vector<pair<int, int>> a) {$/;"	f	typeref:typename:pair<int,int>
clz	code-library/Data Structures/SQRT Tree.cpp	/^  vector<int> clz, layers, onLayer;$/;"	m	struct:SqrtTree	typeref:typename:vector<int>	file:
clz	code/Data Structures/SQRT Tree.cpp	/^  vector<int> clz, layers, onLayer;$/;"	m	struct:SqrtTree	typeref:typename:vector<int>	file:
cmp	code-library/Data Structures/MOs with DSU.cpp	/^bool cmp(query fir, query sec) {$/;"	f	typeref:typename:bool
cmp	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^  int cmp(int cur, int oth, int b, int e) {$/;"	f	struct:PST	typeref:typename:int	file:
cmp	code-library/Graph Theory/Dynamic MST.cpp	/^bool cmp(int &a, int &b){ return pair<int, int>(cost[a], a) < pair<int, int>(cost[b], b); }$/;"	f	typeref:typename:bool
cmp	code-library/Strings/Suffix Array Isomorphic.cpp	/^bool cmp(int *r, int a, int b, int x) {$/;"	f	typeref:typename:bool
cmp	code/Data Structures/MOs with DSU.cpp	/^bool cmp(query fir, query sec) {$/;"	f	typeref:typename:bool
cmp	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^  int cmp(int cur, int oth, int b, int e) {$/;"	f	struct:PST	typeref:typename:int	file:
cmp	code/Graph Theory/Dynamic MST.cpp	/^bool cmp(int &a, int &b){ return pair<int, int>(cost[a], a) < pair<int, int>(cost[b], b); }$/;"	f	typeref:typename:bool
cmp	code/Strings/Suffix Array Isomorphic.cpp	/^bool cmp(int *r, int a, int b, int x) {$/;"	f	typeref:typename:bool
cmp	contests/Codeforces/1623/B/sol.cpp	/^bool cmp(const pair<int, int> &a, const pair<int, int> &b) {$/;"	f	typeref:typename:bool
cmp	practice/cpbook/ch1/1.4/medium/poi.cpp	/^bool cmp(const int &a, const int &b) {$/;"	f	typeref:typename:bool
cmp	practice/cpbook/ch2/2.2/1D/11222/main.cpp	/^bool cmp(const pair<vector<int>, int> &a, const pair<vector<int>, int> &b) {$/;"	f	typeref:typename:bool
cmp	practice/usacoguide/silver/greedy/cielduel.cpp	/^bool cmp(const pair<string, int> &a, const pair<string, int> &b) {$/;"	f	typeref:typename:bool
cmp_by_projection	code-library/Geometry/Geometry 2D.cpp	/^    bool cmp_by_projection(PT p, PT q) { return dot(v, p) < dot(v, q); }$/;"	f	struct:line	typeref:typename:bool	file:
cmp_by_projection	code/Geometry/Geometry 2D.cpp	/^    bool cmp_by_projection(PT p, PT q) { return dot(v, p) < dot(v, q); }$/;"	f	struct:line	typeref:typename:bool	file:
cmp_points	code-library/Data Structures/KD Tree.cpp	/^  cmp_points() {}$/;"	f	struct:cmp_points	file:
cmp_points	code-library/Data Structures/KD Tree.cpp	/^  cmp_points(int x): axis(x) {}$/;"	f	struct:cmp_points	file:
cmp_points	code-library/Data Structures/KD Tree.cpp	/^struct cmp_points {$/;"	s	file:
cmp_points	code/Data Structures/KD Tree.cpp	/^  cmp_points() {}$/;"	f	struct:cmp_points	file:
cmp_points	code/Data Structures/KD Tree.cpp	/^  cmp_points(int x): axis(x) {}$/;"	f	struct:cmp_points	file:
cmp_points	code/Data Structures/KD Tree.cpp	/^struct cmp_points {$/;"	s	file:
cmp_proj	code-library/Geometry/Geometry 3D.cpp	/^    bool cmp_proj(p3 p, p3 q) { return (d | p) < (d | q); }   $/;"	f	struct:line3d	typeref:typename:bool	file:
cmp_proj	code/Geometry/Geometry 3D.cpp	/^    bool cmp_proj(p3 p, p3 q) { return (d | p) < (d | q); }   $/;"	f	struct:line3d	typeref:typename:bool	file:
cmplx	code-library/Math/FWHT in Ternary Base.cpp	/^  cmplx(int _a = 0, int _b = 0) { a = _a, b = _b; }$/;"	f	struct:cmplx	file:
cmplx	code-library/Math/FWHT in Ternary Base.cpp	/^  cmplx(mint _a, mint _b) { a = _a, b = _b; }$/;"	f	struct:cmplx	file:
cmplx	code-library/Math/FWHT in Ternary Base.cpp	/^struct cmplx {$/;"	s	file:
cmplx	code/Math/FWHT in Ternary Base.cpp	/^  cmplx(int _a = 0, int _b = 0) { a = _a, b = _b; }$/;"	f	struct:cmplx	file:
cmplx	code/Math/FWHT in Ternary Base.cpp	/^  cmplx(mint _a, mint _b) { a = _a, b = _b; }$/;"	f	struct:cmplx	file:
cmplx	code/Math/FWHT in Ternary Base.cpp	/^struct cmplx {$/;"	s	file:
cnt	code-library/Data Structures/Binarizing a Tree.cpp	/^  int level = 0, id = 0, cnt = 0;$/;"	m	struct:node	typeref:typename:int	file:
cnt	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^  int level = 0, id = 0, cnt = 0;$/;"	m	struct:node	typeref:typename:int	file:
cnt	code-library/Data Structures/DSU on Tree.cpp	/^int ans[N], col[N], sz[N], cnt[N];$/;"	v	typeref:typename:int[]
cnt	code-library/Data Structures/MOs Algorithm.cpp	/^int cnt[N], a[N];$/;"	v	typeref:typename:int[]
cnt	code-library/Data Structures/MOs Online.cpp	/^  int cnt[N * 2], f[N * 2];$/;"	m	struct:MEX	typeref:typename:int[]	file:
cnt	code-library/Data Structures/MOs on tree.cpp	/^int cnt[N], a[N], ans;$/;"	v	typeref:typename:int[]
cnt	code-library/Data Structures/MOs with DSU.cpp	/^  int cnt;$/;"	m	struct:persistent_dsu	typeref:typename:int	file:
cnt	code-library/Data Structures/MOs with Update.cpp	/^int cnt[N], f[N], ans[N], l, r, t;$/;"	v	typeref:typename:int[]
cnt	code-library/Data Structures/Static to Dynamic Trick.cpp	/^  int cnt[N], link[N], psz;$/;"	m	struct:aho_corasick_static	typeref:typename:int[]	file:
cnt	code-library/Dynamic Programming Optimizations/DP Over Divisors.cpp	/^int cnt[N], ans[N];$/;"	v	typeref:typename:int[]
cnt	code-library/Dynamic Programming Optimizations/Digit DP.cpp	/^int pw[20][20], b[1 << 10][3000], cnt[1 << 10], dp[2][20][1 << 10][2520];$/;"	v	typeref:typename:int[]
cnt	code-library/Graph Theory/Block Cut Tree.cpp	/^int dep[N], par[N][20], cnt[N], id[N];$/;"	v	typeref:typename:int[]
cnt	code-library/Math/Basis Vector Reduced Row Echelon Form.cpp	/^int cnt[30][N];$/;"	v	typeref:typename:int[30][]
cnt	code-library/Math/FWHT in Any Base.cpp	/^int cnt[N];$/;"	v	typeref:typename:int[]
cnt	code-library/Number Theory/Discrete Root Faster.cpp	/^int cnt(ll a, ll base,ll p) {$/;"	f	typeref:typename:int
cnt	code-library/Number Theory/Linear Sieve for Multiplicative Functions.cpp	/^int spf[N], f[N], cnt[N]; \/\/ cnt[i] = power of spf[i] in i$/;"	v	typeref:typename:int[]
cnt	code-library/Number Theory/Maximum Coprime Product.cpp	/^int cnt[N + 1];$/;"	v	typeref:typename:int[]
cnt	code-library/Strings/Aho Corasick Dynamic.cpp	/^  int cnt[N], link[N], psz;$/;"	m	struct:aho_corasick_static	typeref:typename:int[]	file:
cnt	code-library/Strings/Palindromic Tree Persistent.cpp	/^    int nxt[A], len, st, en, link, cnt, oc, smart_link[A];$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
cnt	code-library/Strings/Palindromic Tree.cpp	/^    int nxt[26], len, st, en, link, diff, slink, cnt, oc;$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
cnt	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^int cnt;$/;"	v	typeref:typename:int
cnt	code-library/Strings/Suffix Automaton.cpp	/^    long long cnt(int i) { \/\/number of times i-th node occurs in the string$/;"	f	struct:SuffixAutomaton	typeref:typename:long long	file:
cnt	code/Data Structures/Binarizing a Tree.cpp	/^  int level = 0, id = 0, cnt = 0;$/;"	m	struct:node	typeref:typename:int	file:
cnt	code/Data Structures/Centroid Decomposition Persistent.cpp	/^  int level = 0, id = 0, cnt = 0;$/;"	m	struct:node	typeref:typename:int	file:
cnt	code/Data Structures/DSU on Tree.cpp	/^int ans[N], col[N], sz[N], cnt[N];$/;"	v	typeref:typename:int[]
cnt	code/Data Structures/MOs Algorithm.cpp	/^int cnt[N], a[N];$/;"	v	typeref:typename:int[]
cnt	code/Data Structures/MOs Online.cpp	/^  int cnt[N * 2], f[N * 2];$/;"	m	struct:MEX	typeref:typename:int[]	file:
cnt	code/Data Structures/MOs on tree.cpp	/^int cnt[N], a[N], ans;$/;"	v	typeref:typename:int[]
cnt	code/Data Structures/MOs with DSU.cpp	/^  int cnt;$/;"	m	struct:persistent_dsu	typeref:typename:int	file:
cnt	code/Data Structures/MOs with Update.cpp	/^int cnt[N], f[N], ans[N], l, r, t;$/;"	v	typeref:typename:int[]
cnt	code/Data Structures/Static to Dynamic Trick.cpp	/^  int cnt[N], link[N], psz;$/;"	m	struct:aho_corasick_static	typeref:typename:int[]	file:
cnt	code/Dynamic Programming Optimizations/DP Over Divisors.cpp	/^int cnt[N], ans[N];$/;"	v	typeref:typename:int[]
cnt	code/Dynamic Programming Optimizations/Digit DP.cpp	/^int pw[20][20], b[1 << 10][3000], cnt[1 << 10], dp[2][20][1 << 10][2520];$/;"	v	typeref:typename:int[]
cnt	code/Graph Theory/Block Cut Tree.cpp	/^int dep[N], par[N][20], cnt[N], id[N];$/;"	v	typeref:typename:int[]
cnt	code/Math/Basis Vector Reduced Row Echelon Form.cpp	/^int cnt[30][N];$/;"	v	typeref:typename:int[30][]
cnt	code/Math/FWHT in Any Base.cpp	/^int cnt[N];$/;"	v	typeref:typename:int[]
cnt	code/Number Theory/Discrete Root Faster.cpp	/^int cnt(ll a, ll base,ll p) {$/;"	f	typeref:typename:int
cnt	code/Number Theory/Linear Sieve for Multiplicative Functions.cpp	/^int spf[N], f[N], cnt[N]; \/\/ cnt[i] = power of spf[i] in i$/;"	v	typeref:typename:int[]
cnt	code/Number Theory/Maximum Coprime Product.cpp	/^int cnt[N + 1];$/;"	v	typeref:typename:int[]
cnt	code/Strings/Aho Corasick Dynamic.cpp	/^  int cnt[N], link[N], psz;$/;"	m	struct:aho_corasick_static	typeref:typename:int[]	file:
cnt	code/Strings/Palindromic Tree Persistent.cpp	/^    int nxt[A], len, st, en, link, cnt, oc, smart_link[A];$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
cnt	code/Strings/Palindromic Tree.cpp	/^    int nxt[26], len, st, en, link, diff, slink, cnt, oc;$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
cnt	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^int cnt;$/;"	v	typeref:typename:int
cnt	code/Strings/Suffix Automaton.cpp	/^    long long cnt(int i) { \/\/number of times i-th node occurs in the string$/;"	f	struct:SuffixAutomaton	typeref:typename:long long	file:
cnt	practice/cf/random/1700/test2.cpp	/^int grid[mxN][mxN], cnt[1005];$/;"	v	typeref:typename:int[1005]
cnt	practice/cf/random/pink/main.cpp	/^vector<int> A, cnt;$/;"	v	typeref:typename:vector<int>
cnt	practice/cpbook/ch2/2.2/1D/11222/main.cpp	/^int cnt[mxN];$/;"	v	typeref:typename:int[]
cnt_q	code-library/Data Structures/MOs with DSU.cpp	/^int rt, cnt_q;$/;"	v	typeref:typename:int
cnt_q	code/Data Structures/MOs with DSU.cpp	/^int rt, cnt_q;$/;"	v	typeref:typename:int
co	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  vector<int> co;$/;"	m	struct:mcSFlow	typeref:typename:vector<int>	file:
co	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  vector<int> co;$/;"	m	struct:mcSFlow	typeref:typename:vector<int>	file:
coef	code-library/Math/Faulhaber Formula Fastest.cpp	/^  inline mint coef(const int i) const { return (i < a.size() && i >= 0) ? a[i]: mint(0); }$/;"	f	struct:poly	typeref:typename:mint	file:
coef	code-library/Math/Polynomial.cpp	/^  inline mint coef(const int i) const { return (i < a.size() && i >= 0) ? a[i]: mint(0); }$/;"	f	struct:poly	typeref:typename:mint	file:
coef	code-library/Math/Subset Sum Problem.cpp	/^  inline mint coef(const int i) const { return (i < a.size() && i >= 0) ? a[i]: mint(0); }$/;"	f	struct:poly	typeref:typename:mint	file:
coef	code-library/Number Theory/Bell Number.cpp	/^    inline mint coef(const int i) const { return (i < a.size() && i >= 0) ? a[i]: mint(0); }$/;"	f	struct:poly	typeref:typename:mint	file:
coef	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline mint coef(const int i) const { return (i < a.size() && i >= 0) ? a[i]: mint(0); }$/;"	f	struct:poly	typeref:typename:mint	file:
coef	code/Math/Faulhaber Formula Fastest.cpp	/^  inline mint coef(const int i) const { return (i < a.size() && i >= 0) ? a[i]: mint(0); }$/;"	f	struct:poly	typeref:typename:mint	file:
coef	code/Math/Polynomial.cpp	/^  inline mint coef(const int i) const { return (i < a.size() && i >= 0) ? a[i]: mint(0); }$/;"	f	struct:poly	typeref:typename:mint	file:
coef	code/Math/Subset Sum Problem.cpp	/^  inline mint coef(const int i) const { return (i < a.size() && i >= 0) ? a[i]: mint(0); }$/;"	f	struct:poly	typeref:typename:mint	file:
coef	code/Number Theory/Bell Number.cpp	/^    inline mint coef(const int i) const { return (i < a.size() && i >= 0) ? a[i]: mint(0); }$/;"	f	struct:poly	typeref:typename:mint	file:
coef	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline mint coef(const int i) const { return (i < a.size() && i >= 0) ? a[i]: mint(0); }$/;"	f	struct:poly	typeref:typename:mint	file:
coeff	code-library/Number Theory/Linear Diophantine With N Unknowns and Two Equations.cpp	/^ll a, b, coeff; \/\/ possible points that can be generated are of the form (a * m, b * m + k * c/;"	v	typeref:typename:ll
coeff	code/Number Theory/Linear Diophantine With N Unknowns and Two Equations.cpp	/^ll a, b, coeff; \/\/ possible points that can be generated are of the form (a * m, b * m + k * c/;"	v	typeref:typename:ll
coefs	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  vector<R> coefs;$/;"	m	class:poly	typeref:typename:vector<R>	file:
coefs	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  vector<R> coefs;$/;"	m	class:poly	typeref:typename:vector<R>	file:
col	code-library/Data Structures/DSU on Tree.cpp	/^int ans[N], col[N], sz[N], cnt[N];$/;"	v	typeref:typename:int[]
col	code-library/Data Structures/Link Cut Tree.cpp	/^int col[N];$/;"	v	typeref:typename:int[]
col	code-library/Graph Theory/Edge Coloring Simple Graph.cpp	/^int C[N][N], col[N][N];$/;"	v	namespace:Vizing	typeref:typename:int[][]
col	code-library/Graph Theory/Inverse Graph.cpp	/^int par[N], col[N], vis[N], ty[N], n;$/;"	v	typeref:typename:int[]
col	code-library/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^int n, m, tot, col[N], where[N], par[N];$/;"	v	typeref:typename:int[]
col	code/Data Structures/DSU on Tree.cpp	/^int ans[N], col[N], sz[N], cnt[N];$/;"	v	typeref:typename:int[]
col	code/Data Structures/Link Cut Tree.cpp	/^int col[N];$/;"	v	typeref:typename:int[]
col	code/Graph Theory/Edge Coloring Simple Graph.cpp	/^int C[N][N], col[N][N];$/;"	v	namespace:Vizing	typeref:typename:int[][]
col	code/Graph Theory/Inverse Graph.cpp	/^int par[N], col[N], vis[N], ty[N], n;$/;"	v	typeref:typename:int[]
col	code/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^int n, m, tot, col[N], where[N], par[N];$/;"	v	typeref:typename:int[]
color	code-library/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^int color[5005]; \/\/ number of edges$/;"	v	namespace:EdgeColoring	typeref:typename:int[5005]
color	code/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^int color[5005]; \/\/ number of edges$/;"	v	namespace:EdgeColoring	typeref:typename:int[5005]
colorOK	code-library/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^inline bool colorOK (int i) {$/;"	f	typeref:typename:bool
colorOK	code-library/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^inline bool colorOK (int out, int in) {$/;"	f	typeref:typename:bool
colorOK	code/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^inline bool colorOK (int i) {$/;"	f	typeref:typename:bool
colorOK	code/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^inline bool colorOK (int out, int in) {$/;"	f	typeref:typename:bool
comb	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^mint comb[N][N];$/;"	v	typeref:typename:mint[][]
comb	code/Graph Theory/Counting Labeled Graphs.cpp	/^mint comb[N][N];$/;"	v	typeref:typename:mint[][]
combi	code-library/Math/Faulhaber Formula Fastest.cpp	/^  combi(int _n): n(_n), facts(_n), finvs(_n), invs(_n){$/;"	f	struct:combi	file:
combi	code-library/Math/Faulhaber Formula Fastest.cpp	/^struct combi{$/;"	s	file:
combi	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  combi(int _n): n(_n), facts(_n), finvs(_n), invs(_n){$/;"	f	struct:combi	file:
combi	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^struct combi{$/;"	s	file:
combi	code-library/Number Theory/Combinatorics Basics.cpp	/^  combi(int _n): n(_n), facts(_n), finvs(_n), invs(_n){$/;"	f	struct:combi	file:
combi	code-library/Number Theory/Combinatorics Basics.cpp	/^struct combi{$/;"	s	file:
combi	code-library/Number Theory/Lucas Theorem.cpp	/^  combi(int _n): n(_n), facts(_n), finvs(_n), invs(_n){$/;"	f	struct:combi	file:
combi	code-library/Number Theory/Lucas Theorem.cpp	/^struct combi{$/;"	s	file:
combi	code/Math/Faulhaber Formula Fastest.cpp	/^  combi(int _n): n(_n), facts(_n), finvs(_n), invs(_n){$/;"	f	struct:combi	file:
combi	code/Math/Faulhaber Formula Fastest.cpp	/^struct combi{$/;"	s	file:
combi	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  combi(int _n): n(_n), facts(_n), finvs(_n), invs(_n){$/;"	f	struct:combi	file:
combi	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^struct combi{$/;"	s	file:
combi	code/Number Theory/Combinatorics Basics.cpp	/^  combi(int _n): n(_n), facts(_n), finvs(_n), invs(_n){$/;"	f	struct:combi	file:
combi	code/Number Theory/Combinatorics Basics.cpp	/^struct combi{$/;"	s	file:
combi	code/Number Theory/Lucas Theorem.cpp	/^  combi(int _n): n(_n), facts(_n), finvs(_n), invs(_n){$/;"	f	struct:combi	file:
combi	code/Number Theory/Lucas Theorem.cpp	/^struct combi{$/;"	s	file:
combi	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^  combi(int _n): n(_n), facts(_n), finvs(_n), invs(_n){$/;"	f	struct:combi	file:
combi	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^struct combi{$/;"	s	file:
combi	practice/cf/random/i_hate_math_problems/testing.cpp	/^  combi(int _n): n(_n), facts(_n), finvs(_n), invs(_n){$/;"	f	struct:combi	file:
combi	practice/cf/random/i_hate_math_problems/testing.cpp	/^struct combi{$/;"	s	file:
combine	code-library/Data Structures/HLD.cpp	/^  inline int combine(int a, int b) {$/;"	f	struct:ST	typeref:typename:int	file:
combine	code-library/Data Structures/Implicit Treap.cpp	/^  void combine(pnode &t, pnode l, pnode r) {$/;"	f	struct:treap	typeref:typename:void	file:
combine	code-library/Data Structures/Permutation Tree.cpp	/^  inline int combine(int a, int b) {$/;"	f	struct:ST	typeref:typename:int	file:
combine	code-library/Data Structures/Reachability Tree.cpp	/^inline pair<int, int> combine(pair<int, int> a, pair<int, int> b) {$/;"	f	typeref:typename:pair<int,int>
combine	code-library/Data Structures/Segment Tree Lazy.cpp	/^  inline long long combine(long long a,long long b) {$/;"	f	struct:ST	typeref:typename:long long	file:
combine	code-library/Data Structures/Segment Tree NonRecursive.cpp	/^  inline int combine(int l, int r) {$/;"	f	struct:ST	typeref:typename:int	file:
combine	code-library/Data Structures/Treap.cpp	/^  void combine(node *x) { \/\/combine with another treap$/;"	f	struct:treap	typeref:typename:void	file:
combine	code-library/Math/BerleKamp Massey.cpp	/^vector<mint> combine (int n, vector<mint> &a, vector<mint> &b, vector<mint> &tr) {$/;"	f	typeref:typename:vector<mint>
combine	code-library/Math/Linear Recurrence.cpp	/^vector<mint> combine (int n, vector<mint> &a, vector<mint> &b, vector<mint> &tr) {$/;"	f	typeref:typename:vector<mint>
combine	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  inline long long combine(long long a,long long b) {$/;"	f	struct:ST	typeref:typename:long long	file:
combine	code/Data Structures/HLD.cpp	/^  inline int combine(int a, int b) {$/;"	f	struct:ST	typeref:typename:int	file:
combine	code/Data Structures/Implicit Treap.cpp	/^  void combine(pnode &t, pnode l, pnode r) {$/;"	f	struct:treap	typeref:typename:void	file:
combine	code/Data Structures/Permutation Tree.cpp	/^  inline int combine(int a, int b) {$/;"	f	struct:ST	typeref:typename:int	file:
combine	code/Data Structures/Reachability Tree.cpp	/^inline pair<int, int> combine(pair<int, int> a, pair<int, int> b) {$/;"	f	typeref:typename:pair<int,int>
combine	code/Data Structures/Segment Tree Lazy.cpp	/^  inline long long combine(long long a,long long b) {$/;"	f	struct:ST	typeref:typename:long long	file:
combine	code/Data Structures/Segment Tree NonRecursive.cpp	/^  inline int combine(int l, int r) {$/;"	f	struct:ST	typeref:typename:int	file:
combine	code/Data Structures/Treap.cpp	/^  void combine(node *x) { \/\/combine with another treap$/;"	f	struct:treap	typeref:typename:void	file:
combine	code/Math/BerleKamp Massey.cpp	/^vector<mint> combine (int n, vector<mint> &a, vector<mint> &b, vector<mint> &tr) {$/;"	f	typeref:typename:vector<mint>
combine	code/Math/Linear Recurrence.cpp	/^vector<mint> combine (int n, vector<mint> &a, vector<mint> &b, vector<mint> &tr) {$/;"	f	typeref:typename:vector<mint>
combine	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  inline long long combine(long long a,long long b) {$/;"	f	struct:ST	typeref:typename:long long	file:
comp	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^  int comp;$/;"	m	struct:persistent_dsu	typeref:typename:int	file:
comp	code-library/Graph Theory/2 SAT.cpp	/^  vector<int> comp;$/;"	m	struct:twosat	typeref:typename:vector<int>	file:
comp	code-library/Graph Theory/Articulation Bridges.cpp	/^  vector<int> comp, ord, low;$/;"	m	struct:TECC	typeref:typename:vector<int>	file:
comp	code-library/Graph Theory/Kuhns Algorithm.cpp	/^vector<int> comp;$/;"	v	typeref:typename:vector<int>
comp	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  vector<int> comp;$/;"	m	struct:MaximumClosure	typeref:typename:vector<int>	file:
comp	code-library/Graph Theory/Online Articulation Bridges.cpp	/^int n, bridges, par[N], bl[N], comp[N], sz[N];$/;"	v	typeref:typename:int[]
comp	code-library/Graph Theory/SCC.cpp	/^vector<int> comp;$/;"	v	typeref:typename:vector<int>
comp	code/Data Structures/Dynamic Connectivity Problem.cpp	/^  int comp;$/;"	m	struct:persistent_dsu	typeref:typename:int	file:
comp	code/Graph Theory/2 SAT.cpp	/^  vector<int> comp;$/;"	m	struct:twosat	typeref:typename:vector<int>	file:
comp	code/Graph Theory/Articulation Bridges.cpp	/^  vector<int> comp, ord, low;$/;"	m	struct:TECC	typeref:typename:vector<int>	file:
comp	code/Graph Theory/Kuhns Algorithm.cpp	/^vector<int> comp;$/;"	v	typeref:typename:vector<int>
comp	code/Graph Theory/Maximum Closure Problem.cpp	/^  vector<int> comp;$/;"	m	struct:MaximumClosure	typeref:typename:vector<int>	file:
comp	code/Graph Theory/Online Articulation Bridges.cpp	/^int n, bridges, par[N], bl[N], comp[N], sz[N];$/;"	v	typeref:typename:int[]
comp	code/Graph Theory/SCC.cpp	/^vector<int> comp;$/;"	v	typeref:typename:vector<int>
comp_size	code-library/Graph Theory/Maximum Independant Set.cpp	/^int mn_deg, comp_size;$/;"	v	typeref:typename:int
comp_size	code/Graph Theory/Maximum Independant Set.cpp	/^int mn_deg, comp_size;$/;"	v	typeref:typename:int
compilationstuff	.compilingScripts/README.md	/^# compilationstuff$/;"	c
component_size	code-library/Data Structures/Link Cut Tree.cpp	/^  int component_size(int u) {$/;"	f	struct:LCT	typeref:typename:int	file:
component_size	code/Data Structures/Link Cut Tree.cpp	/^  int component_size(int u) {$/;"	f	struct:LCT	typeref:typename:int	file:
component_sum	code-library/Data Structures/Link Cut Tree.cpp	/^  long long component_sum(int u) {$/;"	f	struct:LCT	typeref:typename:long long	file:
component_sum	code/Data Structures/Link Cut Tree.cpp	/^  long long component_sum(int u) {$/;"	f	struct:LCT	typeref:typename:long long	file:
composition	code-library/Math/Polynomial.cpp	/^  poly composition(poly g, int deg) {$/;"	f	struct:poly	typeref:typename:poly	file:
composition	code/Math/Polynomial.cpp	/^  poly composition(poly g, int deg) {$/;"	f	struct:poly	typeref:typename:poly	file:
composition_brute	code-library/Math/Polynomial.cpp	/^  poly composition_brute(poly g, int deg){$/;"	f	struct:poly	typeref:typename:poly	file:
composition_brute	code/Math/Polynomial.cpp	/^  poly composition_brute(poly g, int deg){$/;"	f	struct:poly	typeref:typename:poly	file:
compute	code-library/Geometry/Voronoi Diagram.cpp	/^double compute(PT a, vector<PT> &can) {$/;"	f	typeref:typename:double
compute	code-library/Strings/Aho Corasick.cpp	/^  void compute() {$/;"	f	struct:AC	typeref:typename:void	file:
compute	code/Geometry/Voronoi Diagram.cpp	/^double compute(PT a, vector<PT> &can) {$/;"	f	typeref:typename:double
compute	code/Strings/Aho Corasick.cpp	/^  void compute() {$/;"	f	struct:AC	typeref:typename:void	file:
computeBasis	code-library/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^vector <ll> computeBasis (vector <ll> vec) {$/;"	f	typeref:typename:vector<ll>
computeBasis	code/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^vector <ll> computeBasis (vector <ll> vec) {$/;"	f	typeref:typename:vector<ll>
compute_automaton	code-library/Strings/Prefix Automaton.cpp	/^void compute_automaton(string s)$/;"	f	typeref:typename:void
compute_automaton	code/Strings/Prefix Automaton.cpp	/^void compute_automaton(string s)$/;"	f	typeref:typename:void
compute_xor	practice/cf/random/1700/4.cpp	/^int compute_xor(int s, int prev = -1) {$/;"	f	typeref:typename:int
congruence_equation	code-library/Number Theory/Linear Congruence Equation.cpp	/^vector<ll> congruence_equation(ll a, ll b, ll m) {$/;"	f	typeref:typename:vector<ll>
congruence_equation	code/Number Theory/Linear Congruence Equation.cpp	/^vector<ll> congruence_equation(ll a, ll b, ll m) {$/;"	f	typeref:typename:vector<ll>
conj	code-library/Math/Faulhaber Formula Fastest.cpp	/^inline base conj(base a) { return base(a.x, -a.y); }$/;"	f	typeref:typename:base
conj	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^inline base conj(base a) { return base(a.x, -a.y); }$/;"	f	typeref:typename:base
conj	code-library/Math/Linear Recurrence Fastest.cpp	/^inline base conj(base a) { return base(a.x, -a.y); }$/;"	f	typeref:typename:base
conj	code-library/Math/NTT Online.cpp	/^inline base conj(base a) { return base(a.x, -a.y); }$/;"	f	typeref:typename:base
conj	code-library/Math/NTT With Any Prime MOD.cpp	/^inline base conj(base a) { return base(a.x, -a.y); }$/;"	f	typeref:typename:base
conj	code-library/Math/Polynomial with Binomial Coefficients.cpp	/^inline base conj(base a) { return base(a.x, -a.y); }$/;"	f	typeref:typename:base
conj	code-library/Math/Polynomial.cpp	/^inline base conj(base a) { return base(a.x, -a.y); }$/;"	f	typeref:typename:base
conj	code-library/Math/Subset Sum Problem.cpp	/^inline base conj(base a) { return base(a.x, -a.y); }$/;"	f	typeref:typename:base
conj	code-library/Number Theory/Bell Number.cpp	/^inline base conj(base a) { return base(a.x, -a.y); }$/;"	f	typeref:typename:base
conj	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^inline base conj(base a) { return base(a.x, -a.y); }$/;"	f	typeref:typename:base
conj	code-library/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^inline base conj(base a) { return base(a.x, -a.y); }$/;"	f	typeref:typename:base
conj	code/Math/Faulhaber Formula Fastest.cpp	/^inline base conj(base a) { return base(a.x, -a.y); }$/;"	f	typeref:typename:base
conj	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^inline base conj(base a) { return base(a.x, -a.y); }$/;"	f	typeref:typename:base
conj	code/Math/Linear Recurrence Fastest.cpp	/^inline base conj(base a) { return base(a.x, -a.y); }$/;"	f	typeref:typename:base
conj	code/Math/NTT Online.cpp	/^inline base conj(base a) { return base(a.x, -a.y); }$/;"	f	typeref:typename:base
conj	code/Math/NTT With Any Prime MOD.cpp	/^inline base conj(base a) { return base(a.x, -a.y); }$/;"	f	typeref:typename:base
conj	code/Math/Polynomial with Binomial Coefficients.cpp	/^inline base conj(base a) { return base(a.x, -a.y); }$/;"	f	typeref:typename:base
conj	code/Math/Polynomial.cpp	/^inline base conj(base a) { return base(a.x, -a.y); }$/;"	f	typeref:typename:base
conj	code/Math/Subset Sum Problem.cpp	/^inline base conj(base a) { return base(a.x, -a.y); }$/;"	f	typeref:typename:base
conj	code/Number Theory/Bell Number.cpp	/^inline base conj(base a) { return base(a.x, -a.y); }$/;"	f	typeref:typename:base
conj	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^inline base conj(base a) { return base(a.x, -a.y); }$/;"	f	typeref:typename:base
conj	code/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^inline base conj(base a) { return base(a.x, -a.y); }$/;"	f	typeref:typename:base
connect	code-library/Geometry/Delaunay Triangulation.cpp	/^Q connect(Q a, Q b) {$/;"	f	typeref:typename:Q
connect	code-library/Geometry/Voronoi Diagram.cpp	/^Q connect(Q a, Q b) {$/;"	f	typeref:typename:Q
connect	code/Geometry/Delaunay Triangulation.cpp	/^Q connect(Q a, Q b) {$/;"	f	typeref:typename:Q
connect	code/Geometry/Voronoi Diagram.cpp	/^Q connect(Q a, Q b) {$/;"	f	typeref:typename:Q
connected	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^  bool connected(int x, int y) {$/;"	f	struct:persistent_dsu	typeref:typename:bool	file:
connected	code-library/Data Structures/Link Cut Tree.cpp	/^  bool connected(int u, int v) {$/;"	f	struct:LCT	typeref:typename:bool	file:
connected	code-library/Data Structures/MOs with DSU.cpp	/^  bool connected(int x, int y) {$/;"	f	struct:persistent_dsu	typeref:typename:bool	file:
connected	code/Data Structures/Dynamic Connectivity Problem.cpp	/^  bool connected(int x, int y) {$/;"	f	struct:persistent_dsu	typeref:typename:bool	file:
connected	code/Data Structures/Link Cut Tree.cpp	/^  bool connected(int u, int v) {$/;"	f	struct:LCT	typeref:typename:bool	file:
connected	code/Data Structures/MOs with DSU.cpp	/^  bool connected(int x, int y) {$/;"	f	struct:persistent_dsu	typeref:typename:bool	file:
cons	code-library/Math/Simplex Algorithm.cpp	/^long double obj[N],cons[N];$/;"	v	typeref:typename:long double[]
cons	code/Math/Simplex Algorithm.cpp	/^long double obj[N],cons[N];$/;"	v	typeref:typename:long double[]
constructBITree	contests/USACO/dec_silver_2021/A/A_safe.cpp	/^int *constructBITree(vector<int> &arr, int n)$/;"	f	typeref:typename:int *
constructMatrix	code-library/Math/FWHT in Any Base.cpp	/^  Matrix constructMatrix(int k, bool invert) {$/;"	f	namespace:FWHT	typeref:typename:Matrix
constructMatrix	code/Math/FWHT in Any Base.cpp	/^  Matrix constructMatrix(int k, bool invert) {$/;"	f	namespace:FWHT	typeref:typename:Matrix
cont	practice/cpbook/ch1/1.6/chess/00225/main.cpp	/^bool cont() {$/;"	f	typeref:typename:bool
contract	code-library/Graph Theory/Dynamic MST.cpp	/^void contract(int s, int e, vector<int> v, vector<int> &must_mst, vector<int> &maybe_mst){$/;"	f	typeref:typename:void
contract	code/Graph Theory/Dynamic MST.cpp	/^void contract(int s, int e, vector<int> v, vector<int> &must_mst, vector<int> &maybe_mst){$/;"	f	typeref:typename:void
convergents	code-library/Number Theory/Continued Fractions.cpp	/^vector<pair<ll, ll>> convergents(vector<ll> a) {$/;"	f	typeref:typename:vector<pair<ll,ll>>
convergents	code/Number Theory/Continued Fractions.cpp	/^vector<pair<ll, ll>> convergents(vector<ll> a) {$/;"	f	typeref:typename:vector<pair<ll,ll>>
convert	code-library/Math/FWHT in Ternary Base.cpp	/^  poly convert(int n, vector<int> &a){$/;"	f	struct:FWHT	typeref:typename:poly	file:
convert	code/Math/FWHT in Ternary Base.cpp	/^  poly convert(int n, vector<int> &a){$/;"	f	struct:FWHT	typeref:typename:poly	file:
convert_base	code-library/Miscellaneous/BigInt.cpp	/^  static vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {$/;"	f	struct:BigInt	typeref:typename:vector<int>	file:
convert_base	code/Miscellaneous/BigInt.cpp	/^  static vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {$/;"	f	struct:BigInt	typeref:typename:vector<int>	file:
convex_hull	code-library/Geometry/Geometry 2D.cpp	/^vector<PT> convex_hull(vector<PT> &p) {$/;"	f	typeref:typename:vector<PT>
convex_hull	code/Geometry/Geometry 2D.cpp	/^vector<PT> convex_hull(vector<PT> &p) {$/;"	f	typeref:typename:vector<PT>
convex_line_intersection	code-library/Geometry/Geometry 2D.cpp	/^pair<PT, PT> convex_line_intersection(vector<PT> &p, PT a, PT b) {$/;"	f	typeref:typename:pair<PT,PT>
convex_line_intersection	code/Geometry/Geometry 2D.cpp	/^pair<PT, PT> convex_line_intersection(vector<PT> &p, PT a, PT b) {$/;"	f	typeref:typename:pair<PT,PT>
convolution	code-library/Miscellaneous/BigInt.cpp	/^  static void convolution(const vector<int>& a, const vector<int>& b, vector<int>& c) {$/;"	f	struct:BigInt	typeref:typename:void	file:
convolution	code/Miscellaneous/BigInt.cpp	/^  static void convolution(const vector<int>& a, const vector<int>& b, vector<int>& c) {$/;"	f	struct:BigInt	typeref:typename:void	file:
convolve	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^void convolve(mod_t* A, int s1, mod_t* B, int s2, bool cyclic=false) {$/;"	f	namespace:ntt	typeref:typename:void
convolve	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^void convolve(mod_t* A, int s1, mod_t* B, int s2, bool cyclic=false) {$/;"	f	namespace:ntt	typeref:typename:void
coords	code-library/Geometry/Geometry 3D.cpp	/^    coords(p3 p, p3 q, p3 r) : o(p) {$/;"	f	struct:coords	file:
coords	code-library/Geometry/Geometry 3D.cpp	/^    coords(p3 p, p3 q, p3 r, p3 s) :$/;"	f	struct:coords	file:
coords	code-library/Geometry/Geometry 3D.cpp	/^struct coords {$/;"	s	file:
coords	code/Geometry/Geometry 3D.cpp	/^    coords(p3 p, p3 q, p3 r) : o(p) {$/;"	f	struct:coords	file:
coords	code/Geometry/Geometry 3D.cpp	/^    coords(p3 p, p3 q, p3 r, p3 s) :$/;"	f	struct:coords	file:
coords	code/Geometry/Geometry 3D.cpp	/^struct coords {$/;"	s	file:
coprime	code-library/Number Theory/Maximum Coprime Product.cpp	/^bool coprime(int x) {$/;"	f	typeref:typename:bool
coprime	code/Number Theory/Maximum Coprime Product.cpp	/^bool coprime(int x) {$/;"	f	typeref:typename:bool
copy	code-library/Data Structures/Treap persistent.cpp	/^inline void copy(node* &a, node* b) {$/;"	f	namespace:PersistentTreap	typeref:typename:void
copy	code/Data Structures/Treap persistent.cpp	/^inline void copy(node* &a, node* b) {$/;"	f	namespace:PersistentTreap	typeref:typename:void
cost	code-library/Dynamic Programming Optimizations/Divide and Conquer Optimization.cpp	/^int cost(int i, int j) {$/;"	f	typeref:typename:int
cost	code-library/Graph Theory/Bellman Ford.cpp	/^  int a, b, cost;$/;"	m	struct:st	typeref:typename:int	file:
cost	code-library/Graph Theory/Dynamic MST.cpp	/^int st[MAXN], ed[MAXN], cost[MAXN], chk[MAXN];$/;"	v	typeref:typename:int[]
cost	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  const W cost; \/\/ unit cost$/;"	m	struct:S	typeref:typename:const W	file:
cost	code-library/Graph Theory/L R Flow with MCMF.cpp	/^    T cap, cost;$/;"	m	struct:MCMF::edge	typeref:typename:T	file:
cost	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  T flow, cost;$/;"	m	struct:MCMF	typeref:typename:T	file:
cost	code-library/Graph Theory/Min Cost Max Flow.cpp	/^    T cap, cost;$/;"	m	struct:MCMF::edge	typeref:typename:T	file:
cost	code-library/Graph Theory/Min Cost Max Flow.cpp	/^  T flow, cost;$/;"	m	struct:MCMF	typeref:typename:T	file:
cost	code-library/Math/Simplex Algorithm.cpp	/^vector <ll> g[N],cost[N];$/;"	v	typeref:typename:vector<ll>[]
cost	code/Dynamic Programming Optimizations/Divide and Conquer Optimization.cpp	/^int cost(int i, int j) {$/;"	f	typeref:typename:int
cost	code/Graph Theory/Bellman Ford.cpp	/^  int a, b, cost;$/;"	m	struct:st	typeref:typename:int	file:
cost	code/Graph Theory/Dynamic MST.cpp	/^int st[MAXN], ed[MAXN], cost[MAXN], chk[MAXN];$/;"	v	typeref:typename:int[]
cost	code/Graph Theory/Gomory Hu Tree.cpp	/^  const W cost; \/\/ unit cost$/;"	m	struct:S	typeref:typename:const W	file:
cost	code/Graph Theory/L R Flow with MCMF.cpp	/^    T cap, cost;$/;"	m	struct:MCMF::edge	typeref:typename:T	file:
cost	code/Graph Theory/L R Flow with MCMF.cpp	/^  T flow, cost;$/;"	m	struct:MCMF	typeref:typename:T	file:
cost	code/Graph Theory/Min Cost Max Flow.cpp	/^    T cap, cost;$/;"	m	struct:MCMF::edge	typeref:typename:T	file:
cost	code/Graph Theory/Min Cost Max Flow.cpp	/^  T flow, cost;$/;"	m	struct:MCMF	typeref:typename:T	file:
cost	code/Math/Simplex Algorithm.cpp	/^vector <ll> g[N],cost[N];$/;"	v	typeref:typename:vector<ll>[]
cost	contests/Codeforces/1616/C/sol.cpp	/^int cost(vector<int> &A) {$/;"	f	typeref:typename:int
cost	practice/usacoguide/gold/SP/visitfj.cpp	/^int cost[105][105];$/;"	v	typeref:typename:int[105][105]
cost	practice/usacoguide/gold/SP/visitfj/main.cpp	/^int cost[105][105];$/;"	v	typeref:typename:int[105][105]
cost	practice/usacoguide/gold/introDP/711C.cpp	/^ll cost[N][N];$/;"	v	typeref:typename:ll[][]
costruct_lcp	code-library/Strings/Suffix Array Isomorphic.cpp	/^  void costruct_lcp() {$/;"	f	struct:IsomorphicSuffixArray	typeref:typename:void	file:
costruct_lcp	code-library/Strings/Suffix Array Isomorphic.cpp	/^  void costruct_lcp() {$/;"	f	struct:SuffixArray	typeref:typename:void	file:
costruct_lcp	code-library/Strings/Suffix Array.cpp	/^  void costruct_lcp() {$/;"	f	struct:SuffixArray	typeref:typename:void	file:
costruct_lcp	code/Strings/Suffix Array Isomorphic.cpp	/^  void costruct_lcp() {$/;"	f	struct:IsomorphicSuffixArray	typeref:typename:void	file:
costruct_lcp	code/Strings/Suffix Array Isomorphic.cpp	/^  void costruct_lcp() {$/;"	f	struct:SuffixArray	typeref:typename:void	file:
costruct_lcp	code/Strings/Suffix Array.cpp	/^  void costruct_lcp() {$/;"	f	struct:SuffixArray	typeref:typename:void	file:
count	code-library/Data Structures/DSU.cpp	/^  int count() {$/;"	f	struct:DSU	typeref:typename:int	file:
count	code-library/Data Structures/Persistent UnionFind.cpp	/^  int count(int r) { return c[r]; } \/\/connected components$/;"	f	struct:PersistentDSU	typeref:typename:int	file:
count	code-library/Data Structures/Wavelet Tree.cpp	/^  int count(int l, int r, int k) {$/;"	f	struct:wavelet_tree	typeref:typename:int	file:
count	code-library/Graph Theory/Boruvka's Algorithm.cpp	/^  int count() { return c; } \/\/connected components$/;"	f	struct:dsu	typeref:typename:int	file:
count	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  int count() {$/;"	f	struct:dsu	typeref:typename:int	file:
count	code-library/Graph Theory/Kirchoffs Theorem.cpp	/^  int count() {$/;"	f	struct:dsu	typeref:typename:int	file:
count	code-library/Graph Theory/Krushkal's MST.cpp	/^  int count() { return c; } \/\/connected components$/;"	f	struct:dsu	typeref:typename:int	file:
count	code-library/Miscellaneous/Bitset Custom.cpp	/^    int count() {$/;"	f	struct:Bitset	typeref:typename:int	file:
count	code-library/Number Theory/Linear Diophantine Equation Three Variables with Nonnegative Solutions.cpp	/^T count(T a, T b, T c, T n) {$/;"	f	typeref:typename:T
count	code-library/Number Theory/Linear Diophantine Equation with Nonnegative Solutions.cpp	/^  ll count(ll l, ll r) { \/\/ count of l <= k <= r s.t. solution for k exists$/;"	f	struct:LDE	typeref:typename:ll	file:
count	code-library/Strings/Bit LCS.cpp	/^    int count() const {$/;"	f	struct:Bitset	typeref:typename:int	file:
count	code-library/Strings/Number of Palindromes in Range.cpp	/^  int count(int l, int r, int k) {$/;"	f	struct:wavelet_tree	typeref:typename:int	file:
count	code/Data Structures/DSU.cpp	/^  int count() {$/;"	f	struct:DSU	typeref:typename:int	file:
count	code/Data Structures/Persistent UnionFind.cpp	/^  int count(int r) { return c[r]; } \/\/connected components$/;"	f	struct:PersistentDSU	typeref:typename:int	file:
count	code/Data Structures/Wavelet Tree.cpp	/^  int count(int l, int r, int k) {$/;"	f	struct:wavelet_tree	typeref:typename:int	file:
count	code/Graph Theory/Boruvka's Algorithm.cpp	/^  int count() { return c; } \/\/connected components$/;"	f	struct:dsu	typeref:typename:int	file:
count	code/Graph Theory/Gomory Hu Tree.cpp	/^  int count() {$/;"	f	struct:dsu	typeref:typename:int	file:
count	code/Graph Theory/Kirchoffs Theorem.cpp	/^  int count() {$/;"	f	struct:dsu	typeref:typename:int	file:
count	code/Graph Theory/Krushkal's MST.cpp	/^  int count() { return c; } \/\/connected components$/;"	f	struct:dsu	typeref:typename:int	file:
count	code/Miscellaneous/Bitset Custom.cpp	/^    int count() {$/;"	f	struct:Bitset	typeref:typename:int	file:
count	code/Number Theory/Linear Diophantine Equation Three Variables with Nonnegative Solutions.cpp	/^T count(T a, T b, T c, T n) {$/;"	f	typeref:typename:T
count	code/Number Theory/Linear Diophantine Equation with Nonnegative Solutions.cpp	/^  ll count(ll l, ll r) { \/\/ count of l <= k <= r s.t. solution for k exists$/;"	f	struct:LDE	typeref:typename:ll	file:
count	code/Strings/Bit LCS.cpp	/^    int count() const {$/;"	f	struct:Bitset	typeref:typename:int	file:
count	code/Strings/Number of Palindromes in Range.cpp	/^  int count(int l, int r, int k) {$/;"	f	struct:wavelet_tree	typeref:typename:int	file:
count	contests/AtCoder/ABC211/C.cpp	/^int count(string a, string b)$/;"	f	typeref:typename:int
cover	code-library/Geometry/Geometry 2D.cpp	/^    vector<pair<double, double> > seg, cover;$/;"	m	struct:CircleUnion	typeref:typename:vector<pair<double,double>>	file:
cover	code/Geometry/Geometry 2D.cpp	/^    vector<pair<double, double> > seg, cover;$/;"	m	struct:CircleUnion	typeref:typename:vector<pair<double,double>>	file:
covered	code-library/Geometry/Geometry 2D.cpp	/^    int covered[2020];$/;"	m	struct:CircleUnion	typeref:typename:int[2020]	file:
covered	code/Geometry/Geometry 2D.cpp	/^    int covered[2020];$/;"	m	struct:CircleUnion	typeref:typename:int[2020]	file:
cplx	code-library/Miscellaneous/BigInt.cpp	/^  cplx() {$/;"	f	struct:cplx	file:
cplx	code-library/Miscellaneous/BigInt.cpp	/^  cplx(T nx, T ny = 0) {$/;"	f	struct:cplx	file:
cplx	code-library/Miscellaneous/BigInt.cpp	/^template<class T> struct cplx {$/;"	s	file:
cplx	code/Miscellaneous/BigInt.cpp	/^  cplx() {$/;"	f	struct:cplx	file:
cplx	code/Miscellaneous/BigInt.cpp	/^  cplx(T nx, T ny = 0) {$/;"	f	struct:cplx	file:
cplx	code/Miscellaneous/BigInt.cpp	/^template<class T> struct cplx {$/;"	s	file:
createSets	contests/USACO/dec_silver_2021/B/B.cpp	/^void createSets(int s, vector<vector<int>> &adj_list, vector<bool> &vis) {$/;"	f	typeref:typename:void
create_hull	code-library/Geometry/Geometry 3D.cpp	/^    void create_hull() {$/;"	f	struct:CH3D	typeref:typename:void	file:
create_hull	code/Geometry/Geometry 3D.cpp	/^    void create_hull() {$/;"	f	struct:CH3D	typeref:typename:void	file:
cross	code-library/Geometry/All Pair Segment Intersection.cpp	/^inline double cross(PT a, PT b) {$/;"	f	typeref:typename:double
cross	code-library/Geometry/Convec Hull Dynamic.cpp	/^long long cross(PT a, PT b) {$/;"	f	typeref:typename:long long
cross	code-library/Geometry/Delaunay Triangulation.cpp	/^	double cross(dPT a, dPT b) const { return (a - *this).cross(b - *this); }$/;"	f	struct:dPT	typeref:typename:double	file:
cross	code-library/Geometry/Delaunay Triangulation.cpp	/^	long long cross(PT a, PT b) const { return (a - *this).cross(b - *this); }$/;"	f	struct:PT	typeref:typename:long long	file:
cross	code-library/Geometry/Delaunay Triangulation.cpp	/^    double cross(dPT p) const { return x * p.y - y * p.x; }$/;"	f	struct:dPT	typeref:typename:double	file:
cross	code-library/Geometry/Delaunay Triangulation.cpp	/^    long long cross(PT p) const { return x * p.y - y * p.x; }$/;"	f	struct:PT	typeref:typename:long long	file:
cross	code-library/Geometry/Delaunay Triangulation.cpp	/^inline double cross(dPT a, dPT b) { return a.x * b.y - a.y * b.x; }$/;"	f	typeref:typename:double
cross	code-library/Geometry/Geometry 2D.cpp	/^inline double cross(PT a, PT b) { return a.x * b.y - a.y * b.x; }$/;"	f	typeref:typename:double
cross	code-library/Geometry/Geometry 3D.cpp	/^    p3 cross(const p3 &a, const p3 &b, const p3 &c) {$/;"	f	struct:CH3D	typeref:typename:p3	file:
cross	code-library/Geometry/Geometry 3D.cpp	/^inline double cross(PT a, PT b) { return a.x * b.y - a.y * b.x; }$/;"	f	typeref:typename:double
cross	code-library/Geometry/Geometry 3D.cpp	/^inline p3 cross(p3 a, p3 b) { return p3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y /;"	f	typeref:typename:p3
cross	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^inline double cross(PT a, PT b) { return a.x * b.y - a.y * b.x; }$/;"	f	typeref:typename:double
cross	code-library/Geometry/Half Plane Intersection.cpp	/^inline double cross(PT a, PT b) { return a.x * b.y - a.y * b.x; }$/;"	f	typeref:typename:double
cross	code-library/Geometry/Onion Decomposition.cpp	/^    long long cross(PT p) const { return x * p.y- y * p.x; }$/;"	f	struct:PT	typeref:typename:long long	file:
cross	code-library/Geometry/Onion Decomposition.cpp	/^long long cross(PT a, PT b, PT c) {$/;"	f	typeref:typename:long long
cross	code-library/Geometry/Point Location.cpp	/^    ll cross(const PT& a) const { return x * a.y - y * a.x; }$/;"	f	struct:PT	typeref:typename:ll	file:
cross	code-library/Geometry/Point Location.cpp	/^    ll cross(const PT& a, const PT& b) const { return (a - *this).cross(b - *this); }$/;"	f	struct:PT	typeref:typename:ll	file:
cross	code-library/Geometry/Voronoi Diagram.cpp	/^	long long cross(P a, P b) const { return (a - *this).cross(b - *this); }$/;"	f	struct:P	typeref:typename:long long	file:
cross	code-library/Geometry/Voronoi Diagram.cpp	/^    long long cross(P p) const { return x * p.y - y * p.x; }$/;"	f	struct:P	typeref:typename:long long	file:
cross	code-library/Geometry/Voronoi Diagram.cpp	/^inline double cross(PT a, PT b) { return a.x * b.y - a.y * b.x; }$/;"	f	typeref:typename:double
cross	code/Geometry/All Pair Segment Intersection.cpp	/^inline double cross(PT a, PT b) {$/;"	f	typeref:typename:double
cross	code/Geometry/Convec Hull Dynamic.cpp	/^long long cross(PT a, PT b) {$/;"	f	typeref:typename:long long
cross	code/Geometry/Delaunay Triangulation.cpp	/^	double cross(dPT a, dPT b) const { return (a - *this).cross(b - *this); }$/;"	f	struct:dPT	typeref:typename:double	file:
cross	code/Geometry/Delaunay Triangulation.cpp	/^	long long cross(PT a, PT b) const { return (a - *this).cross(b - *this); }$/;"	f	struct:PT	typeref:typename:long long	file:
cross	code/Geometry/Delaunay Triangulation.cpp	/^    double cross(dPT p) const { return x * p.y - y * p.x; }$/;"	f	struct:dPT	typeref:typename:double	file:
cross	code/Geometry/Delaunay Triangulation.cpp	/^    long long cross(PT p) const { return x * p.y - y * p.x; }$/;"	f	struct:PT	typeref:typename:long long	file:
cross	code/Geometry/Delaunay Triangulation.cpp	/^inline double cross(dPT a, dPT b) { return a.x * b.y - a.y * b.x; }$/;"	f	typeref:typename:double
cross	code/Geometry/Geometry 2D.cpp	/^inline double cross(PT a, PT b) { return a.x * b.y - a.y * b.x; }$/;"	f	typeref:typename:double
cross	code/Geometry/Geometry 3D.cpp	/^    p3 cross(const p3 &a, const p3 &b, const p3 &c) {$/;"	f	struct:CH3D	typeref:typename:p3	file:
cross	code/Geometry/Geometry 3D.cpp	/^inline double cross(PT a, PT b) { return a.x * b.y - a.y * b.x; }$/;"	f	typeref:typename:double
cross	code/Geometry/Geometry 3D.cpp	/^inline p3 cross(p3 a, p3 b) { return p3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y /;"	f	typeref:typename:p3
cross	code/Geometry/Half Plane Intersection Dynamic.cpp	/^inline double cross(PT a, PT b) { return a.x * b.y - a.y * b.x; }$/;"	f	typeref:typename:double
cross	code/Geometry/Half Plane Intersection.cpp	/^inline double cross(PT a, PT b) { return a.x * b.y - a.y * b.x; }$/;"	f	typeref:typename:double
cross	code/Geometry/Onion Decomposition.cpp	/^    long long cross(PT p) const { return x * p.y- y * p.x; }$/;"	f	struct:PT	typeref:typename:long long	file:
cross	code/Geometry/Onion Decomposition.cpp	/^long long cross(PT a, PT b, PT c) {$/;"	f	typeref:typename:long long
cross	code/Geometry/Point Location.cpp	/^    ll cross(const PT& a) const { return x * a.y - y * a.x; }$/;"	f	struct:PT	typeref:typename:ll	file:
cross	code/Geometry/Point Location.cpp	/^    ll cross(const PT& a, const PT& b) const { return (a - *this).cross(b - *this); }$/;"	f	struct:PT	typeref:typename:ll	file:
cross	code/Geometry/Voronoi Diagram.cpp	/^	long long cross(P a, P b) const { return (a - *this).cross(b - *this); }$/;"	f	struct:P	typeref:typename:long long	file:
cross	code/Geometry/Voronoi Diagram.cpp	/^    long long cross(P p) const { return x * p.y - y * p.x; }$/;"	f	struct:P	typeref:typename:long long	file:
cross	code/Geometry/Voronoi Diagram.cpp	/^inline double cross(PT a, PT b) { return a.x * b.y - a.y * b.x; }$/;"	f	typeref:typename:double
cross2	code-library/Geometry/All Pair Segment Intersection.cpp	/^inline double cross2(PT a, PT b, PT c) {$/;"	f	typeref:typename:double
cross2	code-library/Geometry/Geometry 2D.cpp	/^inline double cross2(PT a, PT b, PT c) { return cross(b - a, c - a); }$/;"	f	typeref:typename:double
cross2	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^double cross2(PT a, PT b, PT c) { return cross(b - a, c - a); }$/;"	f	typeref:typename:double
cross2	code/Geometry/All Pair Segment Intersection.cpp	/^inline double cross2(PT a, PT b, PT c) {$/;"	f	typeref:typename:double
cross2	code/Geometry/Geometry 2D.cpp	/^inline double cross2(PT a, PT b, PT c) { return cross(b - a, c - a); }$/;"	f	typeref:typename:double
cross2	code/Geometry/Half Plane Intersection Dynamic.cpp	/^double cross2(PT a, PT b, PT c) { return cross(b - a, c - a); }$/;"	f	typeref:typename:double
crt	code-library/Math/Reeds Sloane Algorithm.cpp	/^  static ll crt(const vec &c, const vec &m) {$/;"	f	struct:LinearRecurrence	typeref:typename:ll	file:
crt	code/Math/Reeds Sloane Algorithm.cpp	/^  static ll crt(const vec &c, const vec &m) {$/;"	f	struct:LinearRecurrence	typeref:typename:ll	file:
csz	code-library/Data Structures/Wavelet Tree.cpp	/^  int *b, *c, bsz, csz; \/\/ c holds the prefix sum of elements$/;"	m	struct:wavelet_tree	typeref:typename:int	file:
csz	code-library/Strings/Number of Palindromes in Range.cpp	/^  int *b, *c, bsz, csz; \/\/  c holds the prefix sum of elements$/;"	m	struct:wavelet_tree	typeref:typename:int	file:
csz	code/Data Structures/Wavelet Tree.cpp	/^  int *b, *c, bsz, csz; \/\/ c holds the prefix sum of elements$/;"	m	struct:wavelet_tree	typeref:typename:int	file:
csz	code/Strings/Number of Palindromes in Range.cpp	/^  int *b, *c, bsz, csz; \/\/  c holds the prefix sum of elements$/;"	m	struct:wavelet_tree	typeref:typename:int	file:
ct	code-library/Data Structures/Binarizing a Tree.cpp	/^  vector<int> ct; \/\/adjacent edges in centroid tree$/;"	m	struct:node	typeref:typename:vector<int>	file:
ct	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^  vector<int> ct; \/\/adjacent edges in centroid tree$/;"	m	struct:node	typeref:typename:vector<int>	file:
ct	code/Data Structures/Binarizing a Tree.cpp	/^  vector<int> ct; \/\/adjacent edges in centroid tree$/;"	m	struct:node	typeref:typename:vector<int>	file:
ct	code/Data Structures/Centroid Decomposition Persistent.cpp	/^  vector<int> ct; \/\/adjacent edges in centroid tree$/;"	m	struct:node	typeref:typename:vector<int>	file:
ct	practice/usacoguide/gold/bfs/graphgirth2.cpp	/^int ct = 0;$/;"	v	typeref:typename:int
cu	code-library/Graph Theory/Online Articulation Bridges.cpp	/^int cu, u[N];$/;"	v	typeref:typename:int
cu	code/Graph Theory/Online Articulation Bridges.cpp	/^int cu, u[N];$/;"	v	typeref:typename:int
cur	code-library/Data Structures/MOs with Update.cpp	/^  int pos, old, cur;$/;"	m	struct:upd	typeref:typename:int	file:
cur	code-library/Data Structures/Persistent Array.cpp	/^  int cur = 0; \/\/ queue ids$/;"	m	struct:PersistentQueue	typeref:typename:int	file:
cur	code-library/Data Structures/Persistent Queue.cpp	/^  int cur = 0; \/\/ queue ids$/;"	m	struct:PersistentQueue	typeref:typename:int	file:
cur	code-library/Data Structures/Persistent UnionFind.cpp	/^  vector<int> c; int cur = 0;$/;"	m	struct:PersistentDSU	typeref:typename:int	file:
cur	code-library/Data Structures/Segment Tree Merging.cpp	/^set<int> cur; \/\/maintains the left borders of ordered substrs$/;"	v	typeref:typename:set<int>
cur	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  vector<unsigned int> isq, cur;$/;"	m	struct:mcSFlow	typeref:typename:vector<unsigned int>	file:
cur	code-library/Graph Theory/Tree Orientation.cpp	/^long long cur;$/;"	v	typeref:typename:long long
cur	code/Data Structures/MOs with Update.cpp	/^  int pos, old, cur;$/;"	m	struct:upd	typeref:typename:int	file:
cur	code/Data Structures/Persistent Array.cpp	/^  int cur = 0; \/\/ queue ids$/;"	m	struct:PersistentQueue	typeref:typename:int	file:
cur	code/Data Structures/Persistent Queue.cpp	/^  int cur = 0; \/\/ queue ids$/;"	m	struct:PersistentQueue	typeref:typename:int	file:
cur	code/Data Structures/Persistent UnionFind.cpp	/^  vector<int> c; int cur = 0;$/;"	m	struct:PersistentDSU	typeref:typename:int	file:
cur	code/Data Structures/Segment Tree Merging.cpp	/^set<int> cur; \/\/maintains the left borders of ordered substrs$/;"	v	typeref:typename:set<int>
cur	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  vector<unsigned int> isq, cur;$/;"	m	struct:mcSFlow	typeref:typename:vector<unsigned int>	file:
cur	code/Graph Theory/Tree Orientation.cpp	/^long long cur;$/;"	v	typeref:typename:long long
cut	code-library/Data Structures/Link Cut Tree.cpp	/^  void cut(int u) { \/\/ cut par[u] -> u, u is non root vertex$/;"	f	struct:LCT	typeref:typename:void	file:
cut	code-library/Data Structures/Top Tree.cpp	/^  friend std::pair<top_tree_node*, top_tree_node*> cut(top_tree_node* e) {$/;"	f	typeref:typename:std::pair<top_tree_node *,top_tree_node * >	file:
cut	code-library/Geometry/Geometry 2D.cpp	/^vector<PT> cut(vector<PT> &p, PT a, PT b) {$/;"	f	typeref:typename:vector<PT>
cut	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    void cut(Angle a, Angle b) { \/\/ O(log n) amortized$/;"	f	struct:HalfPlaneSet	typeref:typename:void	file:
cut	code/Data Structures/Link Cut Tree.cpp	/^  void cut(int u) { \/\/ cut par[u] -> u, u is non root vertex$/;"	f	struct:LCT	typeref:typename:void	file:
cut	code/Data Structures/Top Tree.cpp	/^  friend std::pair<top_tree_node*, top_tree_node*> cut(top_tree_node* e) {$/;"	f	typeref:typename:std::pair<top_tree_node *,top_tree_node * >	file:
cut	code/Geometry/Geometry 2D.cpp	/^vector<PT> cut(vector<PT> &p, PT a, PT b) {$/;"	f	typeref:typename:vector<PT>
cut	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    void cut(Angle a, Angle b) { \/\/ O(log n) amortized$/;"	f	struct:HalfPlaneSet	typeref:typename:void	file:
cut_right	code-library/Data Structures/Top Tree.cpp	/^  top_tree_node* cut_right() {$/;"	f	struct:top_tree_node	typeref:typename:top_tree_node *	file:
cut_right	code/Data Structures/Top Tree.cpp	/^  top_tree_node* cut_right() {$/;"	f	struct:top_tree_node	typeref:typename:top_tree_node *	file:
cycle	code-library/Graph Theory/Cycle Detection.cpp	/^vector<int> cycle; \/\/ simple cycle, contains edge ids$/;"	v	typeref:typename:vector<int>
cycle	code/Graph Theory/Cycle Detection.cpp	/^vector<int> cycle; \/\/ simple cycle, contains edge ids$/;"	v	typeref:typename:vector<int>
cycle3	code-library/Graph Theory/3 CYCLE and 4 CYCLE.cpp	/^long long cycle3(int n) {$/;"	f	typeref:typename:long long
cycle3	code/Graph Theory/3 CYCLE and 4 CYCLE.cpp	/^long long cycle3(int n) {$/;"	f	typeref:typename:long long
cycle4	code-library/Graph Theory/3 CYCLE and 4 CYCLE.cpp	/^long long cycle4(int n) {$/;"	f	typeref:typename:long long
cycle4	code/Graph Theory/3 CYCLE and 4 CYCLE.cpp	/^long long cycle4(int n) {$/;"	f	typeref:typename:long long
cyclic_shift	code-library/Data Structures/Implicit Treap.cpp	/^  void cyclic_shift(int qL, int qR, int k, bool left_shift = 0) {$/;"	f	struct:treap	typeref:typename:void	file:
cyclic_shift	code/Data Structures/Implicit Treap.cpp	/^  void cyclic_shift(int qL, int qR, int k, bool left_shift = 0) {$/;"	f	struct:treap	typeref:typename:void	file:
d	code-library/Data Structures/Binarizing a Tree.cpp	/^long long d[20][N * 2];$/;"	v	typeref:typename:long long[20][]
d	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^long long d[20][N * 2];$/;"	v	typeref:typename:long long[20][]
d	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^persistent_dsu d;$/;"	v	typeref:typename:persistent_dsu
d	code-library/Data Structures/Dynamic Diameter Online.cpp	/^    long long a = 0, b = 0, c = 0, d = 0, e = 0;$/;"	m	struct:node	typeref:typename:long long	file:
d	code-library/Data Structures/KD Tree.cpp	/^const int d = 2; \/\/\/dimension$/;"	v	typeref:typename:const int
d	code-library/Data Structures/MOs with DSU.cpp	/^persistent_dsu d;$/;"	v	typeref:typename:persistent_dsu
d	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^    mint a = 0, d = 0;$/;"	m	struct:ST::Int	typeref:typename:mint	file:
d	code-library/Data Structures/Top Tree.cpp	/^  int d() const {$/;"	f	struct:top_tree_node	typeref:typename:int	file:
d	code-library/Dynamic Programming Optimizations/DP Over Divisors.cpp	/^vector<int> d[N];$/;"	v	typeref:typename:vector<int>[]
d	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  ll k, d;$/;"	m	struct:Line	typeref:typename:ll	file:
d	code-library/Geometry/All Pair Segment Intersection.cpp	/^PT a[N], d[N];$/;"	v	typeref:typename:PT[]
d	code-library/Geometry/Geometry 3D.cpp	/^    p3 d, o; \/\/ p = o + k * d$/;"	m	struct:line3d	typeref:typename:p3	file:
d	code-library/Geometry/Geometry 3D.cpp	/^    p3 n; double d; \/\/ (n | p) = d$/;"	m	struct:plane	typeref:typename:double	file:
d	code-library/Graph Theory/Dinics Algorithm.cpp	/^  vector<int> d, flow_through;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
d	code-library/Graph Theory/Floyd Warshall.cpp	/^int d[N][N];$/;"	v	typeref:typename:int[][]
d	code-library/Graph Theory/HopCroft Karp Algorithm.cpp	/^  vector<int> l, r, d;$/;"	m	struct:HopcroftKarp	typeref:typename:vector<int>	file:
d	code-library/Graph Theory/Hungarian Algorithm.cpp	/^  long long c[N][N], fx[N], fy[N], d[N];$/;"	m	struct:Hungarian	typeref:typename:long long[]	file:
d	code-library/Graph Theory/L R Flow with Dinic.cpp	/^  vector<int> d, flow_through;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
d	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  vector<T> d, potential, flow_through;$/;"	m	struct:MCMF	typeref:typename:vector<T>	file:
d	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  vector<int> d, flow_through;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
d	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^  vector<int> d, flow_through;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
d	code-library/Graph Theory/Min Cost Max Flow.cpp	/^  vector<T> d, potential, flow_through;$/;"	m	struct:MCMF	typeref:typename:vector<T>	file:
d	code-library/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^ll d[N][N], W[M];$/;"	v	typeref:typename:ll[][]
d	code-library/Graph Theory/Minimum Mean Weight Cycle.cpp	/^double d[N];$/;"	v	typeref:typename:double[]
d	code-library/Graph Theory/Minimum Weight Cycle For Each Edge.cpp	/^int d[N], vis[N], par[N];$/;"	v	typeref:typename:int[]
d	code-library/Graph Theory/Minimum Weight Cycle For Each Vertex.cpp	/^int g[N][N], d[N], vis[N], par[N];$/;"	v	typeref:typename:int[]
d	code-library/Graph Theory/Number of Arborescence.cpp	/^vector<int> d[N];$/;"	v	typeref:typename:vector<int>[]
d	code-library/Graph Theory/SPFA.cpp	/^long long d[N];$/;"	v	typeref:typename:long long[]
d	code-library/Graph Theory/Steiner Tree Problem.cpp	/^long long d[32][N]; \/\/[2^k][edge count]$/;"	v	typeref:typename:long long[32][]
d	code-library/Graph Theory/System Of Difference Constraints.cpp	/^int d[N];$/;"	v	typeref:typename:int[]
d	code-library/Graph Theory/Unique Min Cut.cpp	/^  vector<int> d, flow_through;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
d	code-library/Math/Integration (Romberg).cpp	/^int z, d;$/;"	v	typeref:typename:int
d	code-library/Math/Integration (Simpsons).cpp	/^int z, d;$/;"	v	typeref:typename:int
d	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^ll ncr[N][N], d[N][N]; \/\/ N > k1 + k2$/;"	v	typeref:typename:ll[][]
d	code-library/Number Theory/K Divisors.cpp	/^vector<int> d[M];$/;"	v	typeref:typename:vector<int>[]
d	code-library/Number Theory/Linear Diophantine Equation with Nonnegative Solutions.cpp	/^  vector<ll> d;$/;"	m	struct:LDE	typeref:typename:vector<ll>	file:
d	code-library/Number Theory/Maximum Coprime Product.cpp	/^vector<int> d[N + 1];$/;"	v	typeref:typename:vector<int>[]
d	code-library/Number Theory/Mobius Function.cpp	/^vector<int> d[N];$/;"	v	typeref:typename:vector<int>[]
d	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^long long ncr[N][N], d[N][N]; \/\/ N > k1 + k2$/;"	v	typeref:typename:long long[][]
d	code-library/Strings/Number of Palindromes in Range.cpp	/^int a[N], b[N], c[N], d[N];$/;"	v	typeref:typename:int[]
d	code/Data Structures/Binarizing a Tree.cpp	/^long long d[20][N * 2];$/;"	v	typeref:typename:long long[20][]
d	code/Data Structures/Centroid Decomposition Persistent.cpp	/^long long d[20][N * 2];$/;"	v	typeref:typename:long long[20][]
d	code/Data Structures/Dynamic Connectivity Problem.cpp	/^persistent_dsu d;$/;"	v	typeref:typename:persistent_dsu
d	code/Data Structures/Dynamic Diameter Online.cpp	/^    long long a = 0, b = 0, c = 0, d = 0, e = 0;$/;"	m	struct:node	typeref:typename:long long	file:
d	code/Data Structures/KD Tree.cpp	/^const int d = 2; \/\/\/dimension$/;"	v	typeref:typename:const int
d	code/Data Structures/MOs with DSU.cpp	/^persistent_dsu d;$/;"	v	typeref:typename:persistent_dsu
d	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^    mint a = 0, d = 0;$/;"	m	struct:ST::Int	typeref:typename:mint	file:
d	code/Data Structures/Top Tree.cpp	/^  int d() const {$/;"	f	struct:top_tree_node	typeref:typename:int	file:
d	code/Dynamic Programming Optimizations/DP Over Divisors.cpp	/^vector<int> d[N];$/;"	v	typeref:typename:vector<int>[]
d	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  ll k, d;$/;"	m	struct:Line	typeref:typename:ll	file:
d	code/Geometry/All Pair Segment Intersection.cpp	/^PT a[N], d[N];$/;"	v	typeref:typename:PT[]
d	code/Geometry/Geometry 3D.cpp	/^    p3 d, o; \/\/ p = o + k * d$/;"	m	struct:line3d	typeref:typename:p3	file:
d	code/Geometry/Geometry 3D.cpp	/^    p3 n; double d; \/\/ (n | p) = d$/;"	m	struct:plane	typeref:typename:double	file:
d	code/Graph Theory/Dinics Algorithm.cpp	/^  vector<int> d, flow_through;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
d	code/Graph Theory/Floyd Warshall.cpp	/^int d[N][N];$/;"	v	typeref:typename:int[][]
d	code/Graph Theory/HopCroft Karp Algorithm.cpp	/^  vector<int> l, r, d;$/;"	m	struct:HopcroftKarp	typeref:typename:vector<int>	file:
d	code/Graph Theory/Hungarian Algorithm.cpp	/^  long long c[N][N], fx[N], fy[N], d[N];$/;"	m	struct:Hungarian	typeref:typename:long long[]	file:
d	code/Graph Theory/L R Flow with Dinic.cpp	/^  vector<int> d, flow_through;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
d	code/Graph Theory/L R Flow with MCMF.cpp	/^  vector<T> d, potential, flow_through;$/;"	m	struct:MCMF	typeref:typename:vector<T>	file:
d	code/Graph Theory/Maximum Closure Problem.cpp	/^  vector<int> d, flow_through;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
d	code/Graph Theory/Maximum Density Subgraph.cpp	/^  vector<int> d, flow_through;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
d	code/Graph Theory/Min Cost Max Flow.cpp	/^  vector<T> d, potential, flow_through;$/;"	m	struct:MCMF	typeref:typename:vector<T>	file:
d	code/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^ll d[N][N], W[M];$/;"	v	typeref:typename:ll[][]
d	code/Graph Theory/Minimum Mean Weight Cycle.cpp	/^double d[N];$/;"	v	typeref:typename:double[]
d	code/Graph Theory/Minimum Weight Cycle For Each Edge.cpp	/^int d[N], vis[N], par[N];$/;"	v	typeref:typename:int[]
d	code/Graph Theory/Minimum Weight Cycle For Each Vertex.cpp	/^int g[N][N], d[N], vis[N], par[N];$/;"	v	typeref:typename:int[]
d	code/Graph Theory/Number of Arborescence.cpp	/^vector<int> d[N];$/;"	v	typeref:typename:vector<int>[]
d	code/Graph Theory/SPFA.cpp	/^long long d[N];$/;"	v	typeref:typename:long long[]
d	code/Graph Theory/Steiner Tree Problem.cpp	/^long long d[32][N]; \/\/[2^k][edge count]$/;"	v	typeref:typename:long long[32][]
d	code/Graph Theory/System Of Difference Constraints.cpp	/^int d[N];$/;"	v	typeref:typename:int[]
d	code/Graph Theory/Unique Min Cut.cpp	/^  vector<int> d, flow_through;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
d	code/Math/Integration (Romberg).cpp	/^int z, d;$/;"	v	typeref:typename:int
d	code/Math/Integration (Simpsons).cpp	/^int z, d;$/;"	v	typeref:typename:int
d	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^ll ncr[N][N], d[N][N]; \/\/ N > k1 + k2$/;"	v	typeref:typename:ll[][]
d	code/Number Theory/K Divisors.cpp	/^vector<int> d[M];$/;"	v	typeref:typename:vector<int>[]
d	code/Number Theory/Linear Diophantine Equation with Nonnegative Solutions.cpp	/^  vector<ll> d;$/;"	m	struct:LDE	typeref:typename:vector<ll>	file:
d	code/Number Theory/Maximum Coprime Product.cpp	/^vector<int> d[N + 1];$/;"	v	typeref:typename:vector<int>[]
d	code/Number Theory/Mobius Function.cpp	/^vector<int> d[N];$/;"	v	typeref:typename:vector<int>[]
d	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^long long ncr[N][N], d[N][N]; \/\/ N > k1 + k2$/;"	v	typeref:typename:long long[][]
d	code/Strings/Number of Palindromes in Range.cpp	/^int a[N], b[N], c[N], d[N];$/;"	v	typeref:typename:int[]
d1	code-library/Strings/Number of Palindromes in Range.cpp	/^vector<int> d1, d2;$/;"	v	typeref:typename:vector<int>
d1	code/Strings/Number of Palindromes in Range.cpp	/^vector<int> d1, d2;$/;"	v	typeref:typename:vector<int>
d2	code-library/Strings/Number of Palindromes in Range.cpp	/^vector<int> d1, d2;$/;"	v	typeref:typename:vector<int>
d2	code/Strings/Number of Palindromes in Range.cpp	/^vector<int> d1, d2;$/;"	v	typeref:typename:vector<int>
dPT	code-library/Geometry/Delaunay Triangulation.cpp	/^    dPT() { x = 0, y = 0; }$/;"	f	struct:dPT	file:
dPT	code-library/Geometry/Delaunay Triangulation.cpp	/^    dPT(const dPT &p) : x(p.x), y(p.y)    {}$/;"	f	struct:dPT	file:
dPT	code-library/Geometry/Delaunay Triangulation.cpp	/^    dPT(double x, double y) : x(x), y(y) {}$/;"	f	struct:dPT	file:
dPT	code-library/Geometry/Delaunay Triangulation.cpp	/^struct dPT {$/;"	s	file:
dPT	code/Geometry/Delaunay Triangulation.cpp	/^    dPT() { x = 0, y = 0; }$/;"	f	struct:dPT	file:
dPT	code/Geometry/Delaunay Triangulation.cpp	/^    dPT(const dPT &p) : x(p.x), y(p.y)    {}$/;"	f	struct:dPT	file:
dPT	code/Geometry/Delaunay Triangulation.cpp	/^    dPT(double x, double y) : x(x), y(y) {}$/;"	f	struct:dPT	file:
dPT	code/Geometry/Delaunay Triangulation.cpp	/^struct dPT {$/;"	s	file:
data	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  R* data() { return coefs.data(); }$/;"	f	class:poly	typeref:typename:R *	file:
data	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  const R* data() const { return coefs.data(); }$/;"	f	class:poly	typeref:typename:const R *	file:
data	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  R* data() { return coefs.data(); }$/;"	f	class:poly	typeref:typename:R *	file:
data	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  const R* data() const { return coefs.data(); }$/;"	f	class:poly	typeref:typename:const R *	file:
dateToInt	code-library/Miscellaneous/Dates.cpp	/^int dateToInt(int y, int m, int d) {$/;"	f	typeref:typename:int
dateToInt	code/Miscellaneous/Dates.cpp	/^int dateToInt(int y, int m, int d) {$/;"	f	typeref:typename:int
dbg	practice/cf/random/1700/testing.cpp	/^#define dbg(/;"	d	file:
dbgm	practice/cf/random/1700/testing.cpp	/^#define dbgm(/;"	d	file:
dbgm	practice/cf/random/1700/testing.cpp	/^template <typename T, size_t N> int SIZE(const T (&t)[N]){ return N; } template<typename T> int /;"	f	typeref:typename:void
dblcmp	code-library/Geometry/Geometry 3D.cpp	/^    double dblcmp(p3 &p, face &f) {$/;"	f	struct:CH3D	typeref:typename:double	file:
dblcmp	code/Geometry/Geometry 3D.cpp	/^    double dblcmp(p3 &p, face &f) {$/;"	f	struct:CH3D	typeref:typename:double	file:
de_bruijn	code-library/Strings/De Bruijn Sequence.cpp	/^int de_bruijn(int k, int n) { \/\/ returns size (k^n)$/;"	f	typeref:typename:int
de_bruijn	code/Strings/De Bruijn Sequence.cpp	/^int de_bruijn(int k, int n) { \/\/ returns size (k^n)$/;"	f	typeref:typename:int
deal	code-library/Geometry/Geometry 3D.cpp	/^    void deal(int p, int a, int b) {$/;"	f	struct:CH3D	typeref:typename:void	file:
deal	code/Geometry/Geometry 3D.cpp	/^    void deal(int p, int a, int b) {$/;"	f	struct:CH3D	typeref:typename:void	file:
deb	code-library/Data Structures/Disjoint Sparse Table.cpp	/^#define deb(/;"	d	file:
deb	code-library/Data Structures/Implicit Treap.cpp	/^#define deb(/;"	d	file:
deb	code-library/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^#define deb(/;"	d	file:
deb	code-library/Dynamic Programming Optimizations/DP Over Divisors.cpp	/^#define deb(/;"	d	file:
deb	code-library/Dynamic Programming Optimizations/Digit DP.cpp	/^#define deb(/;"	d	file:
deb	code-library/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^#define deb(/;"	d	file:
deb	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^#define deb(/;"	d	file:
deb	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^#define deb(/;"	d	file:
deb	code-library/Strings/Prefix Automaton.cpp	/^#define deb(/;"	d	file:
deb	code/Data Structures/Disjoint Sparse Table.cpp	/^#define deb(/;"	d	file:
deb	code/Data Structures/Implicit Treap.cpp	/^#define deb(/;"	d	file:
deb	code/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^#define deb(/;"	d	file:
deb	code/Dynamic Programming Optimizations/DP Over Divisors.cpp	/^#define deb(/;"	d	file:
deb	code/Dynamic Programming Optimizations/Digit DP.cpp	/^#define deb(/;"	d	file:
deb	code/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^#define deb(/;"	d	file:
deb	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^#define deb(/;"	d	file:
deb	code/Graph Theory/Counting Labeled Graphs.cpp	/^#define deb(/;"	d	file:
deb	code/Strings/Prefix Automaton.cpp	/^#define deb(/;"	d	file:
debug	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static void debug() {$/;"	f	class:ntt::Mod	typeref:typename:void	file:
debug	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static void debug() {$/;"	f	class:ntt::Mod	typeref:typename:void	file:
decimal_to_factoradic	code-library/Number Theory/Factoradic Number System.cpp	/^vector<int> decimal_to_factoradic(int n) {$/;"	f	typeref:typename:vector<int>
decimal_to_factoradic	code/Number Theory/Factoradic Number System.cpp	/^vector<int> decimal_to_factoradic(int n) {$/;"	f	typeref:typename:vector<int>
decision_stack	code-library/Graph Theory/3 SAT.cpp	/^  vector<vector<int>> decision_stack;$/;"	m	struct:SAT_GOD	typeref:typename:vector<vector<int>>	file:
decision_stack	code/Graph Theory/3 SAT.cpp	/^  vector<vector<int>> decision_stack;$/;"	m	struct:SAT_GOD	typeref:typename:vector<vector<int>>	file:
decompose	code-library/Data Structures/Binarizing a Tree.cpp	/^int decompose(int u, int p = 0, int l = 0) {$/;"	f	typeref:typename:int
decompose	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^int decompose(int u, int p = 0, int l = 0) {$/;"	f	typeref:typename:int
decompose	code-library/Data Structures/Centroid Decomposition.cpp	/^void decompose(int u, int pre) {$/;"	f	typeref:typename:void
decompose	code-library/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^void decompose(int u, int pre) {$/;"	f	typeref:typename:void
decompose	code-library/Miscellaneous/K-th Root of a Permutation.cpp	/^vector<vector<int>> decompose(vector<int> &p) {$/;"	f	typeref:typename:vector<vector<int>>
decompose	code/Data Structures/Binarizing a Tree.cpp	/^int decompose(int u, int p = 0, int l = 0) {$/;"	f	typeref:typename:int
decompose	code/Data Structures/Centroid Decomposition Persistent.cpp	/^int decompose(int u, int p = 0, int l = 0) {$/;"	f	typeref:typename:int
decompose	code/Data Structures/Centroid Decomposition.cpp	/^void decompose(int u, int pre) {$/;"	f	typeref:typename:void
decompose	code/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^void decompose(int u, int pre) {$/;"	f	typeref:typename:void
decompose	code/Miscellaneous/K-th Root of a Permutation.cpp	/^vector<vector<int>> decompose(vector<int> &p) {$/;"	f	typeref:typename:vector<vector<int>>
deepest	practice/cf/random/1700/4.cpp	/^int deepest = INT_MIN; pair<int, int> rem;$/;"	v	typeref:typename:int
deg	code-library/Graph Theory/3 CYCLE and 4 CYCLE.cpp	/^int deg[N];\/\/degrees, precalc it$/;"	v	typeref:typename:int[]
deg	code-library/Graph Theory/Chinese Postman Problem.cpp	/^int deg[N];$/;"	v	typeref:typename:int[]
deg	code-library/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^int deg[2][N];$/;"	v	namespace:EdgeColoring	typeref:typename:int[2][]
deg	code-library/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^int deg[N][2], id[N][2], l, r;$/;"	v	typeref:typename:int[][2]
deg	code-library/Graph Theory/Kirchoffs Theorem.cpp	/^int w[N][N], deg[N], vis[N];$/;"	v	typeref:typename:int[]
deg	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^int s, t, n, m, u[N], v[N], deg[N];$/;"	v	typeref:typename:int[]
deg	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^int deg[N];$/;"	v	typeref:typename:int[]
deg	code-library/Number Theory/Min_25 Sieve.cpp	/^int primes[N], p, deg;$/;"	v	typeref:typename:int
deg	code/Graph Theory/3 CYCLE and 4 CYCLE.cpp	/^int deg[N];\/\/degrees, precalc it$/;"	v	typeref:typename:int[]
deg	code/Graph Theory/Chinese Postman Problem.cpp	/^int deg[N];$/;"	v	typeref:typename:int[]
deg	code/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^int deg[2][N];$/;"	v	namespace:EdgeColoring	typeref:typename:int[2][]
deg	code/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^int deg[N][2], id[N][2], l, r;$/;"	v	typeref:typename:int[][2]
deg	code/Graph Theory/Kirchoffs Theorem.cpp	/^int w[N][N], deg[N], vis[N];$/;"	v	typeref:typename:int[]
deg	code/Graph Theory/Maximum Density Subgraph.cpp	/^int s, t, n, m, u[N], v[N], deg[N];$/;"	v	typeref:typename:int[]
deg	code/Math/Generating Function of a Linear Recurrence.cpp	/^int deg[N];$/;"	v	typeref:typename:int[]
deg	code/Number Theory/Min_25 Sieve.cpp	/^int primes[N], p, deg;$/;"	v	typeref:typename:int
deg_to_rad	code-library/Geometry/All Pair Segment Intersection.cpp	/^double deg_to_rad(double d) {$/;"	f	typeref:typename:double
deg_to_rad	code-library/Geometry/Geometry 2D.cpp	/^double deg_to_rad(double d) { return (d * PI \/ 180.0); }$/;"	f	typeref:typename:double
deg_to_rad	code-library/Geometry/Geometry 3D.cpp	/^double deg_to_rad(double d) { return (d * PI \/ 180.0); }$/;"	f	typeref:typename:double
deg_to_rad	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^double deg_to_rad(double d) { return (d * PI \/ 180.0); }$/;"	f	typeref:typename:double
deg_to_rad	code-library/Geometry/Half Plane Intersection.cpp	/^double deg_to_rad(double d) { return (d * PI \/ 180.0); }$/;"	f	typeref:typename:double
deg_to_rad	code-library/Geometry/Voronoi Diagram.cpp	/^double deg_to_rad(double d) { return (d * PI \/ 180.0); }$/;"	f	typeref:typename:double
deg_to_rad	code/Geometry/All Pair Segment Intersection.cpp	/^double deg_to_rad(double d) {$/;"	f	typeref:typename:double
deg_to_rad	code/Geometry/Geometry 2D.cpp	/^double deg_to_rad(double d) { return (d * PI \/ 180.0); }$/;"	f	typeref:typename:double
deg_to_rad	code/Geometry/Geometry 3D.cpp	/^double deg_to_rad(double d) { return (d * PI \/ 180.0); }$/;"	f	typeref:typename:double
deg_to_rad	code/Geometry/Half Plane Intersection Dynamic.cpp	/^double deg_to_rad(double d) { return (d * PI \/ 180.0); }$/;"	f	typeref:typename:double
deg_to_rad	code/Geometry/Half Plane Intersection.cpp	/^double deg_to_rad(double d) { return (d * PI \/ 180.0); }$/;"	f	typeref:typename:double
deg_to_rad	code/Geometry/Voronoi Diagram.cpp	/^double deg_to_rad(double d) { return (d * PI \/ 180.0); }$/;"	f	typeref:typename:double
degree	code-library/Graph Theory/Prufer Code.cpp	/^int parent[N], degree[N];$/;"	v	typeref:typename:int[]
degree	code/Graph Theory/Prufer Code.cpp	/^int parent[N], degree[N];$/;"	v	typeref:typename:int[]
degx	code-library/Graph Theory/L R Flow with Dinic.cpp	/^int Lx[N], Rx[N], Ly[N], Ry[N], degx[N], degy[N];$/;"	v	typeref:typename:int[]
degx	code/Graph Theory/L R Flow with Dinic.cpp	/^int Lx[N], Rx[N], Ly[N], Ry[N], degx[N], degy[N];$/;"	v	typeref:typename:int[]
degy	code-library/Graph Theory/L R Flow with Dinic.cpp	/^int Lx[N], Rx[N], Ly[N], Ry[N], degx[N], degy[N];$/;"	v	typeref:typename:int[]
degy	code/Graph Theory/L R Flow with Dinic.cpp	/^int Lx[N], Rx[N], Ly[N], Ry[N], degx[N], degy[N];$/;"	v	typeref:typename:int[]
del	code-library/Data Structures/MOs Online.cpp	/^  void del(int x) {$/;"	f	struct:MEX	typeref:typename:void	file:
del	code-library/Data Structures/MOs with Update.cpp	/^inline void del(int x) {$/;"	f	typeref:typename:void
del	code-library/Data Structures/Trie.cpp	/^  void del(node* cur) {$/;"	f	struct:Trie	typeref:typename:void	file:
del	code-library/Geometry/Convec Hull Dynamic.cpp	/^inline void del(set<pair<int, int>>& hull, iter it, long long& scross) {$/;"	f	typeref:typename:void
del	code-library/Geometry/Delaunay Triangulation.cpp	/^	#define del(/;"	d	file:
del	code-library/Geometry/Voronoi Diagram.cpp	/^	#define del(/;"	d	file:
del	code-library/Graph Theory/Boruvka's Algorithm.cpp	/^void del(int x, int id) {$/;"	f	typeref:typename:void
del	code/Data Structures/MOs Online.cpp	/^  void del(int x) {$/;"	f	struct:MEX	typeref:typename:void	file:
del	code/Data Structures/MOs with Update.cpp	/^inline void del(int x) {$/;"	f	typeref:typename:void
del	code/Data Structures/Trie.cpp	/^  void del(node* cur) {$/;"	f	struct:Trie	typeref:typename:void	file:
del	code/Geometry/Convec Hull Dynamic.cpp	/^inline void del(set<pair<int, int>>& hull, iter it, long long& scross) {$/;"	f	typeref:typename:void
del	code/Geometry/Delaunay Triangulation.cpp	/^	#define del(/;"	d	file:
del	code/Geometry/Voronoi Diagram.cpp	/^	#define del(/;"	d	file:
del	code/Graph Theory/Boruvka's Algorithm.cpp	/^void del(int x, int id) {$/;"	f	typeref:typename:void
delaunay	code-library/Geometry/Delaunay Triangulation.cpp	/^vector<PT> delaunay(vector<PT> p) {$/;"	f	typeref:typename:vector<PT>
delaunay	code-library/Geometry/Voronoi Diagram.cpp	/^vector<P> delaunay(vector<P> p) {$/;"	f	typeref:typename:vector<P>
delaunay	code/Geometry/Delaunay Triangulation.cpp	/^vector<PT> delaunay(vector<PT> p) {$/;"	f	typeref:typename:vector<PT>
delaunay	code/Geometry/Voronoi Diagram.cpp	/^vector<P> delaunay(vector<P> p) {$/;"	f	typeref:typename:vector<P>
delim	code-library/Miscellaneous/Expression Parsing.cpp	/^bool delim(char c) {$/;"	f	typeref:typename:bool
delim	code/Miscellaneous/Expression Parsing.cpp	/^bool delim(char c) {$/;"	f	typeref:typename:bool
dep	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int par[N][LG + 1], dep[N], sz[N];$/;"	v	typeref:typename:int[]
dep	code-library/Data Structures/HLD.cpp	/^int par[N][LG + 1], dep[N], sz[N];$/;"	v	typeref:typename:int[]
dep	code-library/Data Structures/LCA.cpp	/^int par[N][LG + 1], dep[N], sz[N];$/;"	v	typeref:typename:int[]
dep	code-library/Data Structures/MOs on tree.cpp	/^int st[N], en[N], T, par[N][20], dep[N], id[N * 2];$/;"	v	typeref:typename:int[]
dep	code-library/Dynamic Programming Optimizations/Subset Sum in SQRT.cpp	/^int ans[N], dep[N], sz[N];$/;"	v	typeref:typename:int[]
dep	code-library/Graph Theory/Block Cut Tree.cpp	/^int dep[N], par[N][20], cnt[N], id[N];$/;"	v	typeref:typename:int[]
dep	code-library/Graph Theory/LCA.cpp	/^int par[N][LG + 1], dep[N], sz[N];$/;"	v	typeref:typename:int[]
dep	code-library/Graph Theory/Path Intersection.cpp	/^int par[N][20], dep[N], sz[N];$/;"	v	typeref:typename:int[]
dep	code-library/Graph Theory/Path Union.cpp	/^int par[N][20], dep[N], sz[N];$/;"	v	typeref:typename:int[]
dep	code-library/Graph Theory/Virtual Tree.cpp	/^int par[N][20], dep[N], sz[N], st[N], en[N], T;$/;"	v	typeref:typename:int[]
dep	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int par[N][LG + 1], dep[N], sz[N];$/;"	v	typeref:typename:int[]
dep	code/Data Structures/HLD.cpp	/^int par[N][LG + 1], dep[N], sz[N];$/;"	v	typeref:typename:int[]
dep	code/Data Structures/LCA.cpp	/^int par[N][LG + 1], dep[N], sz[N];$/;"	v	typeref:typename:int[]
dep	code/Data Structures/MOs on tree.cpp	/^int st[N], en[N], T, par[N][20], dep[N], id[N * 2];$/;"	v	typeref:typename:int[]
dep	code/Dynamic Programming Optimizations/Subset Sum in SQRT.cpp	/^int ans[N], dep[N], sz[N];$/;"	v	typeref:typename:int[]
dep	code/Graph Theory/Block Cut Tree.cpp	/^int dep[N], par[N][20], cnt[N], id[N];$/;"	v	typeref:typename:int[]
dep	code/Graph Theory/LCA.cpp	/^int par[N][LG + 1], dep[N], sz[N];$/;"	v	typeref:typename:int[]
dep	code/Graph Theory/Path Intersection.cpp	/^int par[N][20], dep[N], sz[N];$/;"	v	typeref:typename:int[]
dep	code/Graph Theory/Path Union.cpp	/^int par[N][20], dep[N], sz[N];$/;"	v	typeref:typename:int[]
dep	code/Graph Theory/Virtual Tree.cpp	/^int par[N][20], dep[N], sz[N], st[N], en[N], T;$/;"	v	typeref:typename:int[]
depth	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^  int par[N], depth[N];$/;"	m	struct:persistent_dsu	typeref:typename:int[]	file:
depth	code-library/Data Structures/Link Cut Tree.cpp	/^  int depth(int u) {$/;"	f	struct:LCT	typeref:typename:int	file:
depth	code-library/Data Structures/MOs with DSU.cpp	/^  int depth[N], par[N];$/;"	m	struct:persistent_dsu	typeref:typename:int[]	file:
depth	code-library/Graph Theory/LCA in O(1).cpp	/^  vector<int> enter, depth, exxit;$/;"	m	struct:LCA	typeref:typename:vector<int>	file:
depth	code/Data Structures/Dynamic Connectivity Problem.cpp	/^  int par[N], depth[N];$/;"	m	struct:persistent_dsu	typeref:typename:int[]	file:
depth	code/Data Structures/Link Cut Tree.cpp	/^  int depth(int u) {$/;"	f	struct:LCT	typeref:typename:int	file:
depth	code/Data Structures/MOs with DSU.cpp	/^  int depth[N], par[N];$/;"	m	struct:persistent_dsu	typeref:typename:int[]	file:
depth	code/Graph Theory/LCA in O(1).cpp	/^  vector<int> enter, depth, exxit;$/;"	m	struct:LCA	typeref:typename:vector<int>	file:
det	code-library/Graph Theory/Kirchoffs Theorem.cpp	/^int det(vector<vector<int>> a) {$/;"	f	typeref:typename:int
det	code/Graph Theory/Kirchoffs Theorem.cpp	/^int det(vector<vector<int>> a) {$/;"	f	typeref:typename:int
detZero	code-library/Math/Finite Field Arithmetic Binary.cpp	/^bool detZero(int m[N][N], int d) {$/;"	f	typeref:typename:bool
detZero	code/Math/Finite Field Arithmetic Binary.cpp	/^bool detZero(int m[N][N], int d) {$/;"	f	typeref:typename:bool
determinant	code-library/Graph Theory/Tuttes Theorem.cpp	/^double determinant(vector<vector<double>>a) {$/;"	f	typeref:typename:double
determinant	code/Graph Theory/Tuttes Theorem.cpp	/^double determinant(vector<vector<double>>a) {$/;"	f	typeref:typename:double
dfs	code-library/Data Structures/Cartesian Tree.cpp	/^int dfs(int u) {$/;"	f	typeref:typename:int
dfs	code-library/Data Structures/Centroid Decomposition.cpp	/^void dfs(int u, int pre, int len) {$/;"	f	typeref:typename:void
dfs	code-library/Data Structures/DSU on Tree.cpp	/^void dfs(int u, int p) {$/;"	f	typeref:typename:void
dfs	code-library/Data Structures/Dynamic Diameter Online.cpp	/^void dfs (int u, int p = 0) {$/;"	f	typeref:typename:void
dfs	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^void dfs(int u, int p = 0) {$/;"	f	typeref:typename:void
dfs	code-library/Data Structures/HLD.cpp	/^void dfs(int u, int p = 0) {$/;"	f	typeref:typename:void
dfs	code-library/Data Structures/LCA.cpp	/^void dfs(int u, int p = 0) {$/;"	f	typeref:typename:void
dfs	code-library/Data Structures/Link Cut Tree.cpp	/^void dfs(int u, int p = 0) {$/;"	f	typeref:typename:void
dfs	code-library/Data Structures/MOs on tree.cpp	/^void dfs(int u, int p = 0) {$/;"	f	typeref:typename:void
dfs	code-library/Data Structures/Permutation Tree.cpp	/^void dfs(int u, int p = 0) {$/;"	f	typeref:typename:void
dfs	code-library/Data Structures/Reachability Tree.cpp	/^  void dfs(int u) {$/;"	f	struct:RT	typeref:typename:void	file:
dfs	code-library/Data Structures/Treap.cpp	/^  void dfs(node* cur) {$/;"	f	struct:treap	typeref:typename:void	file:
dfs	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^void dfs(int u, int pre = 0) {$/;"	f	typeref:typename:void
dfs	code-library/Dynamic Programming Optimizations/Subset Sum in SQRT.cpp	/^void dfs(int u, int p = 0) {$/;"	f	typeref:typename:void
dfs	code-library/Game Theory/Blue Red Hackenbush.cpp	/^void dfs(int u) {$/;"	f	typeref:typename:void
dfs	code-library/Game Theory/Green Hackenbush.cpp	/^int dfs (int u, int pre = 0) {$/;"	f	typeref:typename:int
dfs	code-library/Geometry/Geometry 3D.cpp	/^    void dfs(int p, int now) {$/;"	f	struct:CH3D	typeref:typename:void	file:
dfs	code-library/Graph Theory/Articulation Bridges.cpp	/^  void dfs(int x, int prv, int &c) {$/;"	f	struct:TECC	typeref:typename:void	file:
dfs	code-library/Graph Theory/Articulation Points.cpp	/^void dfs(int u, int pre = 0) {$/;"	f	typeref:typename:void
dfs	code-library/Graph Theory/Block Cut Tree.cpp	/^void dfs(int u, int pre = 0) {$/;"	f	typeref:typename:void
dfs	code-library/Graph Theory/Cycle Detection.cpp	/^bool dfs(int u) {$/;"	f	typeref:typename:bool
dfs	code-library/Graph Theory/Dinics Algorithm.cpp	/^  long long dfs(int u, long long flow) {$/;"	f	struct:Dinic	typeref:typename:long long	file:
dfs	code-library/Graph Theory/Dominator Tree.cpp	/^void dfs(int u) {$/;"	f	typeref:typename:void
dfs	code-library/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^void dfs(int x, int p) {$/;"	f	namespace:EdgeColoring	typeref:typename:void
dfs	code-library/Graph Theory/Euler Path Directed.cpp	/^void dfs(int u) {$/;"	f	typeref:typename:void
dfs	code-library/Graph Theory/Euler Path Undirected.cpp	/^void dfs(int u) {$/;"	f	typeref:typename:void
dfs	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  void dfs(int u, const FlowGraph &fg) {$/;"	f	struct:GomoryHuTree	typeref:typename:void	file:
dfs	code-library/Graph Theory/HopCroft Karp Algorithm.cpp	/^  bool dfs(int u) {$/;"	f	struct:HopcroftKarp	typeref:typename:bool	file:
dfs	code-library/Graph Theory/Inverse Graph.cpp	/^void dfs(int u, int c) {$/;"	f	typeref:typename:void
dfs	code-library/Graph Theory/Kirchoffs Theorem.cpp	/^void dfs(int u) {$/;"	f	typeref:typename:void
dfs	code-library/Graph Theory/L R Flow with Dinic.cpp	/^  long long dfs(int u, long long flow) {$/;"	f	struct:Dinic	typeref:typename:long long	file:
dfs	code-library/Graph Theory/LCA in O(1).cpp	/^  void dfs(int node, int dep) {$/;"	f	struct:LCA	typeref:typename:void	file:
dfs	code-library/Graph Theory/LCA.cpp	/^void dfs(int u, int p = 0) {$/;"	f	typeref:typename:void
dfs	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  long long dfs(int u, long long flow) {$/;"	f	struct:Dinic	typeref:typename:long long	file:
dfs	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^  double dfs(int u, double flow) {$/;"	f	struct:Dinic	typeref:typename:double	file:
dfs	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^void dfs(int u) {$/;"	f	typeref:typename:void
dfs	code-library/Graph Theory/Maximum Independant Set.cpp	/^void dfs(int u) {$/;"	f	typeref:typename:void
dfs	code-library/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^void dfs(int u, int pre, int len) {$/;"	f	typeref:typename:void
dfs	code-library/Graph Theory/Path Intersection.cpp	/^void dfs(int u, int pre) {$/;"	f	typeref:typename:void
dfs	code-library/Graph Theory/Path Union.cpp	/^void dfs(int u, int pre) {$/;"	f	typeref:typename:void
dfs	code-library/Graph Theory/Prufer Code.cpp	/^void dfs (int v) {$/;"	f	typeref:typename:void
dfs	code-library/Graph Theory/Randomized Matching Unweighted.cpp	/^  bool dfs(int x) {$/;"	f	struct:RandomizedMatching	typeref:typename:bool	file:
dfs	code-library/Graph Theory/Tree Orientation.cpp	/^void dfs(int u, int p = 0) {$/;"	f	typeref:typename:void
dfs	code-library/Graph Theory/Unique Min Cut.cpp	/^  long long dfs(int u, long long flow) {$/;"	f	struct:Dinic	typeref:typename:long long	file:
dfs	code-library/Graph Theory/Virtual Tree.cpp	/^void dfs(int u, int pre) {$/;"	f	typeref:typename:void
dfs	code-library/Math/Basis Vector Reduced Row Echelon Form.cpp	/^void dfs(int u) {$/;"	f	typeref:typename:void
dfs	code-library/Math/Simplex Algorithm.cpp	/^void dfs(ll u,ll p,ll d,ll cur) {$/;"	f	typeref:typename:void
dfs	code-library/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^void dfs(int u, int p = 0) {$/;"	f	typeref:typename:void
dfs	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^void dfs(int u, int side) {$/;"	f	typeref:typename:void
dfs	code/Data Structures/Cartesian Tree.cpp	/^int dfs(int u) {$/;"	f	typeref:typename:int
dfs	code/Data Structures/Centroid Decomposition.cpp	/^void dfs(int u, int pre, int len) {$/;"	f	typeref:typename:void
dfs	code/Data Structures/DSU on Tree.cpp	/^void dfs(int u, int p) {$/;"	f	typeref:typename:void
dfs	code/Data Structures/Dynamic Diameter Online.cpp	/^void dfs (int u, int p = 0) {$/;"	f	typeref:typename:void
dfs	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^void dfs(int u, int p = 0) {$/;"	f	typeref:typename:void
dfs	code/Data Structures/HLD.cpp	/^void dfs(int u, int p = 0) {$/;"	f	typeref:typename:void
dfs	code/Data Structures/LCA.cpp	/^void dfs(int u, int p = 0) {$/;"	f	typeref:typename:void
dfs	code/Data Structures/Link Cut Tree.cpp	/^void dfs(int u, int p = 0) {$/;"	f	typeref:typename:void
dfs	code/Data Structures/MOs on tree.cpp	/^void dfs(int u, int p = 0) {$/;"	f	typeref:typename:void
dfs	code/Data Structures/Permutation Tree.cpp	/^void dfs(int u, int p = 0) {$/;"	f	typeref:typename:void
dfs	code/Data Structures/Reachability Tree.cpp	/^  void dfs(int u) {$/;"	f	struct:RT	typeref:typename:void	file:
dfs	code/Data Structures/Treap.cpp	/^  void dfs(node* cur) {$/;"	f	struct:treap	typeref:typename:void	file:
dfs	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^void dfs(int u, int pre = 0) {$/;"	f	typeref:typename:void
dfs	code/Dynamic Programming Optimizations/Subset Sum in SQRT.cpp	/^void dfs(int u, int p = 0) {$/;"	f	typeref:typename:void
dfs	code/Game Theory/Blue Red Hackenbush.cpp	/^void dfs(int u) {$/;"	f	typeref:typename:void
dfs	code/Game Theory/Green Hackenbush.cpp	/^int dfs (int u, int pre = 0) {$/;"	f	typeref:typename:int
dfs	code/Geometry/Geometry 3D.cpp	/^    void dfs(int p, int now) {$/;"	f	struct:CH3D	typeref:typename:void	file:
dfs	code/Graph Theory/Articulation Bridges.cpp	/^  void dfs(int x, int prv, int &c) {$/;"	f	struct:TECC	typeref:typename:void	file:
dfs	code/Graph Theory/Articulation Points.cpp	/^void dfs(int u, int pre = 0) {$/;"	f	typeref:typename:void
dfs	code/Graph Theory/Block Cut Tree.cpp	/^void dfs(int u, int pre = 0) {$/;"	f	typeref:typename:void
dfs	code/Graph Theory/Cycle Detection.cpp	/^bool dfs(int u) {$/;"	f	typeref:typename:bool
dfs	code/Graph Theory/Dinics Algorithm.cpp	/^  long long dfs(int u, long long flow) {$/;"	f	struct:Dinic	typeref:typename:long long	file:
dfs	code/Graph Theory/Dominator Tree.cpp	/^void dfs(int u) {$/;"	f	typeref:typename:void
dfs	code/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^void dfs(int x, int p) {$/;"	f	namespace:EdgeColoring	typeref:typename:void
dfs	code/Graph Theory/Euler Path Directed.cpp	/^void dfs(int u) {$/;"	f	typeref:typename:void
dfs	code/Graph Theory/Euler Path Undirected.cpp	/^void dfs(int u) {$/;"	f	typeref:typename:void
dfs	code/Graph Theory/Gomory Hu Tree.cpp	/^  void dfs(int u, const FlowGraph &fg) {$/;"	f	struct:GomoryHuTree	typeref:typename:void	file:
dfs	code/Graph Theory/HopCroft Karp Algorithm.cpp	/^  bool dfs(int u) {$/;"	f	struct:HopcroftKarp	typeref:typename:bool	file:
dfs	code/Graph Theory/Inverse Graph.cpp	/^void dfs(int u, int c) {$/;"	f	typeref:typename:void
dfs	code/Graph Theory/Kirchoffs Theorem.cpp	/^void dfs(int u) {$/;"	f	typeref:typename:void
dfs	code/Graph Theory/L R Flow with Dinic.cpp	/^  long long dfs(int u, long long flow) {$/;"	f	struct:Dinic	typeref:typename:long long	file:
dfs	code/Graph Theory/LCA in O(1).cpp	/^  void dfs(int node, int dep) {$/;"	f	struct:LCA	typeref:typename:void	file:
dfs	code/Graph Theory/LCA.cpp	/^void dfs(int u, int p = 0) {$/;"	f	typeref:typename:void
dfs	code/Graph Theory/Maximum Closure Problem.cpp	/^  long long dfs(int u, long long flow) {$/;"	f	struct:Dinic	typeref:typename:long long	file:
dfs	code/Graph Theory/Maximum Density Subgraph.cpp	/^  double dfs(int u, double flow) {$/;"	f	struct:Dinic	typeref:typename:double	file:
dfs	code/Graph Theory/Maximum Density Subgraph.cpp	/^void dfs(int u) {$/;"	f	typeref:typename:void
dfs	code/Graph Theory/Maximum Independant Set.cpp	/^void dfs(int u) {$/;"	f	typeref:typename:void
dfs	code/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^void dfs(int u, int pre, int len) {$/;"	f	typeref:typename:void
dfs	code/Graph Theory/Path Intersection.cpp	/^void dfs(int u, int pre) {$/;"	f	typeref:typename:void
dfs	code/Graph Theory/Path Union.cpp	/^void dfs(int u, int pre) {$/;"	f	typeref:typename:void
dfs	code/Graph Theory/Prufer Code.cpp	/^void dfs (int v) {$/;"	f	typeref:typename:void
dfs	code/Graph Theory/Randomized Matching Unweighted.cpp	/^  bool dfs(int x) {$/;"	f	struct:RandomizedMatching	typeref:typename:bool	file:
dfs	code/Graph Theory/Tree Orientation.cpp	/^void dfs(int u, int p = 0) {$/;"	f	typeref:typename:void
dfs	code/Graph Theory/Unique Min Cut.cpp	/^  long long dfs(int u, long long flow) {$/;"	f	struct:Dinic	typeref:typename:long long	file:
dfs	code/Graph Theory/Virtual Tree.cpp	/^void dfs(int u, int pre) {$/;"	f	typeref:typename:void
dfs	code/Math/Basis Vector Reduced Row Echelon Form.cpp	/^void dfs(int u) {$/;"	f	typeref:typename:void
dfs	code/Math/Simplex Algorithm.cpp	/^void dfs(ll u,ll p,ll d,ll cur) {$/;"	f	typeref:typename:void
dfs	code/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^void dfs(int u, int p = 0) {$/;"	f	typeref:typename:void
dfs	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^void dfs(int u, int side) {$/;"	f	typeref:typename:void
dfs	contests/AtCoder/231/D.cpp	/^void dfs(int s) {$/;"	f	typeref:typename:void
dfs	practice/cf/random/1700/1476D.cpp	/^void dfs(int u, vector<vector<int>> &visited, vector<vector<int>> &adj_1, vector<vector<int>> &a/;"	f	typeref:typename:void
dfs	practice/cf/random/1700/test1.cpp	/^void dfs(int s) {$/;"	f	typeref:typename:void
dfs1	code-library/Graph Theory/2 SAT.cpp	/^  void dfs1(int u) {$/;"	f	struct:twosat	typeref:typename:void	file:
dfs1	code-library/Graph Theory/Block Cut Tree.cpp	/^void dfs1(int u, int pre = 0) {$/;"	f	typeref:typename:void
dfs1	code-library/Graph Theory/Kuhns Algorithm.cpp	/^void dfs1(int u) {$/;"	f	typeref:typename:void
dfs1	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  void dfs1(int u) {$/;"	f	struct:MaximumClosure	typeref:typename:void	file:
dfs1	code-library/Graph Theory/SCC.cpp	/^void dfs1(int u) {$/;"	f	typeref:typename:void
dfs1	code-library/Graph Theory/ST Numbering.cpp	/^bool dfs1(int u, int pre = -1) { \/\/ check if there is any articulation point$/;"	f	typeref:typename:bool
dfs1	code-library/Graph Theory/Unique Min Cut.cpp	/^void dfs1(int u) {$/;"	f	typeref:typename:void
dfs1	code/Graph Theory/2 SAT.cpp	/^  void dfs1(int u) {$/;"	f	struct:twosat	typeref:typename:void	file:
dfs1	code/Graph Theory/Block Cut Tree.cpp	/^void dfs1(int u, int pre = 0) {$/;"	f	typeref:typename:void
dfs1	code/Graph Theory/Kuhns Algorithm.cpp	/^void dfs1(int u) {$/;"	f	typeref:typename:void
dfs1	code/Graph Theory/Maximum Closure Problem.cpp	/^  void dfs1(int u) {$/;"	f	struct:MaximumClosure	typeref:typename:void	file:
dfs1	code/Graph Theory/SCC.cpp	/^void dfs1(int u) {$/;"	f	typeref:typename:void
dfs1	code/Graph Theory/ST Numbering.cpp	/^bool dfs1(int u, int pre = -1) { \/\/ check if there is any articulation point$/;"	f	typeref:typename:bool
dfs1	code/Graph Theory/Unique Min Cut.cpp	/^void dfs1(int u) {$/;"	f	typeref:typename:void
dfs1	contests/USACO/dec_silver_2021/B/B_new.cpp	/^void dfs1(int s, vector<vector<int>> &adj_list, vector<bool> &vis, set<int> &cur) {$/;"	f	typeref:typename:void
dfs2	code-library/Graph Theory/2 SAT.cpp	/^  void dfs2(int u, int c) {$/;"	f	struct:twosat	typeref:typename:void	file:
dfs2	code-library/Graph Theory/Articulation Bridges.cpp	/^  void dfs2(int x, int num) {$/;"	f	struct:TECC	typeref:typename:void	file:
dfs2	code-library/Graph Theory/Kuhns Algorithm.cpp	/^void dfs2(int u) {$/;"	f	typeref:typename:void
dfs2	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  void dfs2(int u) {$/;"	f	struct:MaximumClosure	typeref:typename:void	file:
dfs2	code-library/Graph Theory/SCC.cpp	/^void dfs2(int u) {$/;"	f	typeref:typename:void
dfs2	code-library/Graph Theory/ST Numbering.cpp	/^void dfs2(int u, int pre = -1) { \/\/construct the dfs tree and preorder treversal$/;"	f	typeref:typename:void
dfs2	code-library/Graph Theory/Unique Min Cut.cpp	/^void dfs2(int u) {$/;"	f	typeref:typename:void
dfs2	code/Graph Theory/2 SAT.cpp	/^  void dfs2(int u, int c) {$/;"	f	struct:twosat	typeref:typename:void	file:
dfs2	code/Graph Theory/Articulation Bridges.cpp	/^  void dfs2(int x, int num) {$/;"	f	struct:TECC	typeref:typename:void	file:
dfs2	code/Graph Theory/Kuhns Algorithm.cpp	/^void dfs2(int u) {$/;"	f	typeref:typename:void
dfs2	code/Graph Theory/Maximum Closure Problem.cpp	/^  void dfs2(int u) {$/;"	f	struct:MaximumClosure	typeref:typename:void	file:
dfs2	code/Graph Theory/SCC.cpp	/^void dfs2(int u) {$/;"	f	typeref:typename:void
dfs2	code/Graph Theory/ST Numbering.cpp	/^void dfs2(int u, int pre = -1) { \/\/construct the dfs tree and preorder treversal$/;"	f	typeref:typename:void
dfs2	code/Graph Theory/Unique Min Cut.cpp	/^void dfs2(int u) {$/;"	f	typeref:typename:void
dfs2	contests/USACO/dec_silver_2021/B/B_new.cpp	/^void dfs2(int s, vector<vector<int>> &adj_list, vector<bool> &vis, set<int> &component_1, set<in/;"	f	typeref:typename:void
dfs_hld	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^void dfs_hld(int u) {$/;"	f	typeref:typename:void
dfs_hld	code-library/Data Structures/HLD.cpp	/^void dfs_hld(int u) {$/;"	f	typeref:typename:void
dfs_hld	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^void dfs_hld(int u) {$/;"	f	typeref:typename:void
dfs_hld	code/Data Structures/HLD.cpp	/^void dfs_hld(int u) {$/;"	f	typeref:typename:void
diameter	code-library/Geometry/Geometry 2D.cpp	/^double diameter(vector<PT> &p) {$/;"	f	typeref:typename:double
diameter	code/Geometry/Geometry 2D.cpp	/^double diameter(vector<PT> &p) {$/;"	f	typeref:typename:double
dif	practice/usacoguide/silver/orderedsets/coveredpoints.cpp	/^int dif[mxN];$/;"	v	typeref:typename:int[]
diff	code-library/Strings/Palindromic Tree.cpp	/^    int nxt[26], len, st, en, link, diff, slink, cnt, oc;$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
diff	code/Strings/Palindromic Tree.cpp	/^    int nxt[26], len, st, en, link, diff, slink, cnt, oc;$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
diff	contests/USACO/dec_silver_2021/C/C.cpp	/^int diff[mxN], elements[mxN];$/;"	v	typeref:typename:int[]
differantiate	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly differantiate() const {$/;"	f	struct:poly	typeref:typename:poly	file:
differantiate	code/Math/Faulhaber Formula Fastest.cpp	/^  poly differantiate() const {$/;"	f	struct:poly	typeref:typename:poly	file:
differentiate	code-library/Math/Polynomial.cpp	/^  poly differentiate() const {$/;"	f	struct:poly	typeref:typename:poly	file:
differentiate	code-library/Math/Subset Sum Problem.cpp	/^  poly differentiate() const {$/;"	f	struct:poly	typeref:typename:poly	file:
differentiate	code-library/Number Theory/Bell Number.cpp	/^    poly differentiate() const {$/;"	f	struct:poly	typeref:typename:poly	file:
differentiate	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly differentiate() const {$/;"	f	struct:poly	typeref:typename:poly	file:
differentiate	code/Math/Polynomial.cpp	/^  poly differentiate() const {$/;"	f	struct:poly	typeref:typename:poly	file:
differentiate	code/Math/Subset Sum Problem.cpp	/^  poly differentiate() const {$/;"	f	struct:poly	typeref:typename:poly	file:
differentiate	code/Number Theory/Bell Number.cpp	/^    poly differentiate() const {$/;"	f	struct:poly	typeref:typename:poly	file:
differentiate	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly differentiate() const {$/;"	f	struct:poly	typeref:typename:poly	file:
dijkstra	code-library/Graph Theory/Dijkstra on Segment Tree.cpp	/^vector<long long> dijkstra(int s) {$/;"	f	typeref:typename:vector<long long>
dijkstra	code-library/Graph Theory/Dijkstra.cpp	/^vector<long long> dijkstra(int s, int t, vector<int> &cnt) {$/;"	f	typeref:typename:vector<long long>
dijkstra	code-library/Graph Theory/Johnson's Algorithm.cpp	/^vector <long long> dijkstra(int n, int s, vector <struct edge> ed, vector <long long> &h){$/;"	f	typeref:typename:vector<long long>
dijkstra	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  bool dijkstra() {$/;"	f	struct:MCMF	typeref:typename:bool	file:
dijkstra	code-library/Graph Theory/Min Cost Max Flow.cpp	/^  bool dijkstra() {$/;"	f	struct:MCMF	typeref:typename:bool	file:
dijkstra	code-library/Graph Theory/Min Cut in a Planar Graph.cpp	/^vector<long long> dijkstra(int s, int t, vector<pair<int, int>> g[]) {$/;"	f	typeref:typename:vector<long long>
dijkstra	code/Graph Theory/Dijkstra on Segment Tree.cpp	/^vector<long long> dijkstra(int s) {$/;"	f	typeref:typename:vector<long long>
dijkstra	code/Graph Theory/Dijkstra.cpp	/^vector<long long> dijkstra(int s, int t, vector<int> &cnt) {$/;"	f	typeref:typename:vector<long long>
dijkstra	code/Graph Theory/Johnson's Algorithm.cpp	/^vector <long long> dijkstra(int n, int s, vector <struct edge> ed, vector <long long> &h){$/;"	f	typeref:typename:vector<long long>
dijkstra	code/Graph Theory/L R Flow with MCMF.cpp	/^  bool dijkstra() {$/;"	f	struct:MCMF	typeref:typename:bool	file:
dijkstra	code/Graph Theory/Min Cost Max Flow.cpp	/^  bool dijkstra() {$/;"	f	struct:MCMF	typeref:typename:bool	file:
dijkstra	code/Graph Theory/Min Cut in a Planar Graph.cpp	/^vector<long long> dijkstra(int s, int t, vector<pair<int, int>> g[]) {$/;"	f	typeref:typename:vector<long long>
dijkstra	practice/usacoguide/gold/SP/flightdiscount.cpp	/^void dijkstra(int src) { $/;"	f	typeref:typename:void
dijkstra	practice/usacoguide/gold/SP/pump.cpp	/^void dijkstra(int src, int min_flow) { \/\/ Source and destination$/;"	f	typeref:typename:void
dijkstra	practice/usacoguide/gold/SP/visitfj.cpp	/^void dijkstra(pair<int, int> src) { \/\/ Source and destination$/;"	f	typeref:typename:void
dijkstra	practice/usacoguide/gold/SP/visitfj/main.cpp	/^void dijkstra(pair<int, int> src) { \/\/ Source and destination$/;"	f	typeref:typename:void
dir	code-library/Data Structures/Link Cut Tree.cpp	/^  int dir(int x, int y) { return t[x].c[1] == y; }$/;"	f	struct:LCT	typeref:typename:int	file:
dir	code/Data Structures/Link Cut Tree.cpp	/^  int dir(int x, int y) { return t[x].c[1] == y; }$/;"	f	struct:LCT	typeref:typename:int	file:
direction	practice/usacoguide/gold/bfs/cownav.cpp	/^	int first, second, direction;$/;"	m	struct:Point	typeref:typename:int	file:
dis	code-library/Game Theory/Green Hackenbush.cpp	/^int n, T, low[N], dis[N];$/;"	v	typeref:typename:int[]
dis	code-library/Graph Theory/Articulation Points.cpp	/^int T, low[N], dis[N], art[N];$/;"	v	typeref:typename:int[]
dis	code-library/Graph Theory/Block Cut Tree.cpp	/^int T, low[N], dis[N], art[N], sz;$/;"	v	typeref:typename:int[]
dis	code-library/Graph Theory/Chinese Postman Problem.cpp	/^  long long G[N][N], dis[N];$/;"	m	struct:RandomizedMatching	typeref:typename:long long[]	file:
dis	code-library/Graph Theory/Randomized Matching Weighted.cpp	/^	long long G[N][N], dis[N];$/;"	m	struct:RandomizedMatching	typeref:typename:long long[]	file:
dis	code-library/Graph Theory/ST Numbering.cpp	/^int low[N], dis[N], T = 0, par[N], sign[N];$/;"	v	typeref:typename:int[]
dis	code-library/Graph Theory/Stoer Wagner Algorithm.cpp	/^  long long G[N][N], dis[N];$/;"	m	struct:StoerWagner	typeref:typename:long long[]	file:
dis	code-library/Math/Simplex Algorithm.cpp	/^ll n,k,a[N],dis[N][N];$/;"	v	typeref:typename:ll[][]
dis	code/Game Theory/Green Hackenbush.cpp	/^int n, T, low[N], dis[N];$/;"	v	typeref:typename:int[]
dis	code/Graph Theory/Articulation Points.cpp	/^int T, low[N], dis[N], art[N];$/;"	v	typeref:typename:int[]
dis	code/Graph Theory/Block Cut Tree.cpp	/^int T, low[N], dis[N], art[N], sz;$/;"	v	typeref:typename:int[]
dis	code/Graph Theory/Chinese Postman Problem.cpp	/^  long long G[N][N], dis[N];$/;"	m	struct:RandomizedMatching	typeref:typename:long long[]	file:
dis	code/Graph Theory/Randomized Matching Weighted.cpp	/^	long long G[N][N], dis[N];$/;"	m	struct:RandomizedMatching	typeref:typename:long long[]	file:
dis	code/Graph Theory/ST Numbering.cpp	/^int low[N], dis[N], T = 0, par[N], sign[N];$/;"	v	typeref:typename:int[]
dis	code/Graph Theory/Stoer Wagner Algorithm.cpp	/^  long long G[N][N], dis[N];$/;"	m	struct:StoerWagner	typeref:typename:long long[]	file:
dis	code/Math/Simplex Algorithm.cpp	/^ll n,k,a[N],dis[N][N];$/;"	v	typeref:typename:ll[][]
discrete_log	code-library/Number Theory/Discrete Log.cpp	/^int discrete_log(int a, int b, int m) {$/;"	f	typeref:typename:int
discrete_log	code/Number Theory/Discrete Log.cpp	/^int discrete_log(int a, int b, int m) {$/;"	f	typeref:typename:int
discrete_log_noncoprime	code-library/Number Theory/Discrete Log.cpp	/^int discrete_log_noncoprime(int a, int b, int m) {$/;"	f	typeref:typename:int
discrete_log_noncoprime	code/Number Theory/Discrete Log.cpp	/^int discrete_log_noncoprime(int a, int b, int m) {$/;"	f	typeref:typename:int
discrete_root	code-library/Number Theory/Discrete Root Faster.cpp	/^ll discrete_root(ll k, ll a, ll p) {$/;"	f	typeref:typename:ll
discrete_root	code-library/Number Theory/Discrete Root.cpp	/^int discrete_root(int k, int a, int m) {$/;"	f	typeref:typename:int
discrete_root	code/Number Theory/Discrete Root Faster.cpp	/^ll discrete_root(ll k, ll a, ll p) {$/;"	f	typeref:typename:ll
discrete_root	code/Number Theory/Discrete Root.cpp	/^int discrete_root(int k, int a, int m) {$/;"	f	typeref:typename:int
disj	code-library/Graph Theory/Dynamic MST.cpp	/^struct disj{$/;"	s	file:
disj	code-library/Graph Theory/Dynamic MST.cpp	/^}disj;$/;"	v	typeref:struct:disj
disj	code/Graph Theory/Dynamic MST.cpp	/^struct disj{$/;"	s	file:
disj	code/Graph Theory/Dynamic MST.cpp	/^}disj;$/;"	v	typeref:struct:disj
dist	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int dist(int u, int v) {$/;"	f	typeref:typename:int
dist	code-library/Data Structures/LCA.cpp	/^int dist(int u, int v) {$/;"	f	typeref:typename:int
dist	code-library/Geometry/All Pair Segment Intersection.cpp	/^inline double dist(PT a, PT b) {$/;"	f	typeref:typename:double
dist	code-library/Geometry/Delaunay Triangulation.cpp	/^inline double dist(dPT a, dPT b) { return sqrt(dot(a - b, a - b)); }$/;"	f	typeref:typename:double
dist	code-library/Geometry/Geometry 2D.cpp	/^    inline double dist(double x1, double y1, double x2, double y2) {return sqrt(SQ(x1 - x2) + SQ/;"	f	struct:CircleUnion	typeref:typename:double	file:
dist	code-library/Geometry/Geometry 2D.cpp	/^inline double dist(PT a, PT b) { return sqrt(dot(a - b, a - b)); }$/;"	f	typeref:typename:double
dist	code-library/Geometry/Geometry 3D.cpp	/^    double dist(p3 p) { return fabs(side(p)) \/ abs(n); }$/;"	f	struct:plane	typeref:typename:double	file:
dist	code-library/Geometry/Geometry 3D.cpp	/^    double dist(p3 p) { return sqrt(dist2(p)); }$/;"	f	struct:line3d	typeref:typename:double	file:
dist	code-library/Geometry/Geometry 3D.cpp	/^double dist(line3d l1, line3d l2) {$/;"	f	typeref:typename:double
dist	code-library/Geometry/Geometry 3D.cpp	/^inline double dist(PT a, PT b) { return sqrt(dot(a - b, a - b)); }$/;"	f	typeref:typename:double
dist	code-library/Geometry/Geometry 3D.cpp	/^inline double dist(p3 a, p3 b) { return sqrt(dot(a - b, a - b)); }$/;"	f	typeref:typename:double
dist	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^inline double dist(PT a, PT b) { return sqrt(dot(a - b, a - b)); }$/;"	f	typeref:typename:double
dist	code-library/Geometry/Half Plane Intersection.cpp	/^inline double dist(PT a, PT b) { return sqrt(dot(a - b, a - b)); }$/;"	f	typeref:typename:double
dist	code-library/Geometry/Voronoi Diagram.cpp	/^inline double dist(PT a, PT b) { return sqrt(dot(a - b, a - b)); }$/;"	f	typeref:typename:double
dist	code-library/Graph Theory/Block Cut Tree.cpp	/^int dist(int u, int v) {$/;"	f	typeref:typename:int
dist	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^#define dist(/;"	d	file:
dist	code-library/Graph Theory/LCA in O(1).cpp	/^  int dist(int a, int b) {$/;"	f	struct:LCA	typeref:typename:int	file:
dist	code-library/Graph Theory/LCA.cpp	/^int dist(int u, int v) {$/;"	f	typeref:typename:int
dist	code-library/Graph Theory/Manhattan MST.cpp	/^int dist(PT &a, PT &b) {$/;"	f	typeref:typename:int
dist	code-library/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^ll ed, far, global = LLONG_MAX, dist[N];$/;"	v	typeref:typename:ll[]
dist	code-library/Graph Theory/Virtual Tree.cpp	/^int dist(int u, int v) {$/;"	f	typeref:typename:int
dist	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int dist(int u, int v) {$/;"	f	typeref:typename:int
dist	code/Data Structures/LCA.cpp	/^int dist(int u, int v) {$/;"	f	typeref:typename:int
dist	code/Geometry/All Pair Segment Intersection.cpp	/^inline double dist(PT a, PT b) {$/;"	f	typeref:typename:double
dist	code/Geometry/Delaunay Triangulation.cpp	/^inline double dist(dPT a, dPT b) { return sqrt(dot(a - b, a - b)); }$/;"	f	typeref:typename:double
dist	code/Geometry/Geometry 2D.cpp	/^    inline double dist(double x1, double y1, double x2, double y2) {return sqrt(SQ(x1 - x2) + SQ/;"	f	struct:CircleUnion	typeref:typename:double	file:
dist	code/Geometry/Geometry 2D.cpp	/^inline double dist(PT a, PT b) { return sqrt(dot(a - b, a - b)); }$/;"	f	typeref:typename:double
dist	code/Geometry/Geometry 3D.cpp	/^    double dist(p3 p) { return fabs(side(p)) \/ abs(n); }$/;"	f	struct:plane	typeref:typename:double	file:
dist	code/Geometry/Geometry 3D.cpp	/^    double dist(p3 p) { return sqrt(dist2(p)); }$/;"	f	struct:line3d	typeref:typename:double	file:
dist	code/Geometry/Geometry 3D.cpp	/^double dist(line3d l1, line3d l2) {$/;"	f	typeref:typename:double
dist	code/Geometry/Geometry 3D.cpp	/^inline double dist(PT a, PT b) { return sqrt(dot(a - b, a - b)); }$/;"	f	typeref:typename:double
dist	code/Geometry/Geometry 3D.cpp	/^inline double dist(p3 a, p3 b) { return sqrt(dot(a - b, a - b)); }$/;"	f	typeref:typename:double
dist	code/Geometry/Half Plane Intersection Dynamic.cpp	/^inline double dist(PT a, PT b) { return sqrt(dot(a - b, a - b)); }$/;"	f	typeref:typename:double
dist	code/Geometry/Half Plane Intersection.cpp	/^inline double dist(PT a, PT b) { return sqrt(dot(a - b, a - b)); }$/;"	f	typeref:typename:double
dist	code/Geometry/Voronoi Diagram.cpp	/^inline double dist(PT a, PT b) { return sqrt(dot(a - b, a - b)); }$/;"	f	typeref:typename:double
dist	code/Graph Theory/Block Cut Tree.cpp	/^int dist(int u, int v) {$/;"	f	typeref:typename:int
dist	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^#define dist(/;"	d	file:
dist	code/Graph Theory/LCA in O(1).cpp	/^  int dist(int a, int b) {$/;"	f	struct:LCA	typeref:typename:int	file:
dist	code/Graph Theory/LCA.cpp	/^int dist(int u, int v) {$/;"	f	typeref:typename:int
dist	code/Graph Theory/Manhattan MST.cpp	/^int dist(PT &a, PT &b) {$/;"	f	typeref:typename:int
dist	code/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^ll ed, far, global = LLONG_MAX, dist[N];$/;"	v	typeref:typename:ll[]
dist	code/Graph Theory/Virtual Tree.cpp	/^int dist(int u, int v) {$/;"	f	typeref:typename:int
dist	contests/AtCoder/ABC211/D.cpp	/^int dp[mxN], dist[mxN];$/;"	v	typeref:typename:int[]
dist	practice/cf/random/1700/4.cpp	/^vector<int> A, subtree_xor, dist;$/;"	v	typeref:typename:vector<int>
dist	practice/usacoguide/gold/SP/flightdiscount.cpp	/^int dist[mxN][2]; $/;"	v	typeref:typename:int[][2]
dist	practice/usacoguide/gold/SP/pump.cpp	/^ll dist[100000];$/;"	v	typeref:typename:ll[100000]
dist	practice/usacoguide/gold/SP/shortestroutesii.cpp	/^int dist[mxN][mxN], edges[mxN][mxN];$/;"	v	typeref:typename:int[][]
dist	practice/usacoguide/gold/SP/visitfj.cpp	/^ll dist[105][105];$/;"	v	typeref:typename:ll[105][105]
dist	practice/usacoguide/gold/SP/visitfj/main.cpp	/^ll dist[105][105];$/;"	v	typeref:typename:ll[105][105]
dist	practice/usacoguide/gold/bfs/cownav.cpp	/^int dist[mxN][mxN][4][mxN][mxN][4];$/;"	v	typeref:typename:int[][][4][][][4]
dist	practice/usacoguide/gold/bfs/graphgirth.cpp	/^int dist[mxN];$/;"	v	typeref:typename:int[]
dist	practice/usacoguide/gold/bfs/mecho/main.cpp	/^int dist[mxN][mxN];$/;"	v	typeref:typename:int[][]
dist	practice/usacoguide/gold/bfs/mechonew/main.cpp	/^int dist[mxN][mxN];$/;"	v	typeref:typename:int[][]
dist	practice/usacoguide/gold/bfs/milkpails.cpp	/^int dist[105][105];$/;"	v	typeref:typename:int[105][105]
dist	practice/usacoguide/gold/bfs/monsters.cpp	/^int dist[mxN][mxN];$/;"	v	typeref:typename:int[][]
dist1	contests/USACO/dec_silver_2021/B/B_new.cpp	/^int dist1 = 1e16, dist2 = 1e16;$/;"	v	typeref:typename:int
dist2	code-library/Geometry/All Pair Segment Intersection.cpp	/^inline double dist2(PT a, PT b) {$/;"	f	typeref:typename:double
dist2	code-library/Geometry/Closest Pair of Points.cpp	/^long long dist2(pair<int, int> a, pair<int, int> b) {$/;"	f	typeref:typename:long long
dist2	code-library/Geometry/Delaunay Triangulation.cpp	/^inline double dist2(dPT a, dPT b) { return dot(a - b, a - b); }$/;"	f	typeref:typename:double
dist2	code-library/Geometry/Geometry 2D.cpp	/^inline double dist2(PT a, PT b) { return dot(a - b, a - b); }$/;"	f	typeref:typename:double
dist2	code-library/Geometry/Geometry 3D.cpp	/^    double dist2(p3 p) { return sq(d * (p - o)) \/ sq(d); }$/;"	f	struct:line3d	typeref:typename:double	file:
dist2	code-library/Geometry/Geometry 3D.cpp	/^inline double dist2(PT a, PT b) { return dot(a - b, a - b); }$/;"	f	typeref:typename:double
dist2	code-library/Geometry/Geometry 3D.cpp	/^inline double dist2(p3 a, p3 b) { return dot(a - b, a - b); }$/;"	f	typeref:typename:double
dist2	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^inline double dist2(PT a, PT b) { return dot(a - b, a - b); }$/;"	f	typeref:typename:double
dist2	code-library/Geometry/Half Plane Intersection.cpp	/^inline double dist2(PT a, PT b) { return dot(a - b, a - b); }$/;"	f	typeref:typename:double
dist2	code-library/Geometry/Voronoi Diagram.cpp	/^inline double dist2(PT a, PT b) { return dot(a - b, a - b); }$/;"	f	typeref:typename:double
dist2	code/Geometry/All Pair Segment Intersection.cpp	/^inline double dist2(PT a, PT b) {$/;"	f	typeref:typename:double
dist2	code/Geometry/Closest Pair of Points.cpp	/^long long dist2(pair<int, int> a, pair<int, int> b) {$/;"	f	typeref:typename:long long
dist2	code/Geometry/Delaunay Triangulation.cpp	/^inline double dist2(dPT a, dPT b) { return dot(a - b, a - b); }$/;"	f	typeref:typename:double
dist2	code/Geometry/Geometry 2D.cpp	/^inline double dist2(PT a, PT b) { return dot(a - b, a - b); }$/;"	f	typeref:typename:double
dist2	code/Geometry/Geometry 3D.cpp	/^    double dist2(p3 p) { return sq(d * (p - o)) \/ sq(d); }$/;"	f	struct:line3d	typeref:typename:double	file:
dist2	code/Geometry/Geometry 3D.cpp	/^inline double dist2(PT a, PT b) { return dot(a - b, a - b); }$/;"	f	typeref:typename:double
dist2	code/Geometry/Geometry 3D.cpp	/^inline double dist2(p3 a, p3 b) { return dot(a - b, a - b); }$/;"	f	typeref:typename:double
dist2	code/Geometry/Half Plane Intersection Dynamic.cpp	/^inline double dist2(PT a, PT b) { return dot(a - b, a - b); }$/;"	f	typeref:typename:double
dist2	code/Geometry/Half Plane Intersection.cpp	/^inline double dist2(PT a, PT b) { return dot(a - b, a - b); }$/;"	f	typeref:typename:double
dist2	code/Geometry/Voronoi Diagram.cpp	/^inline double dist2(PT a, PT b) { return dot(a - b, a - b); }$/;"	f	typeref:typename:double
dist2	contests/USACO/dec_silver_2021/B/B_new.cpp	/^int dist1 = 1e16, dist2 = 1e16;$/;"	v	typeref:typename:int
distToNode1	contests/USACO/dec_silver_2021/B/B.cpp	/^int distToNode1 = LLONG_MAX, distToNodeN = LLONG_MAX;$/;"	v	typeref:typename:int
distToNodeN	contests/USACO/dec_silver_2021/B/B.cpp	/^int distToNode1 = LLONG_MAX, distToNodeN = LLONG_MAX;$/;"	v	typeref:typename:int
dist_from_point_to_line	code-library/Geometry/Geometry 2D.cpp	/^double dist_from_point_to_line(PT a, PT b, PT c) {$/;"	f	typeref:typename:double
dist_from_point_to_line	code/Geometry/Geometry 2D.cpp	/^double dist_from_point_to_line(PT a, PT b, PT c) {$/;"	f	typeref:typename:double
dist_from_point_to_polygon	code-library/Geometry/Geometry 2D.cpp	/^double dist_from_point_to_polygon(vector<PT> &v, PT p) { \/\/ O(log n)$/;"	f	typeref:typename:double
dist_from_point_to_polygon	code/Geometry/Geometry 2D.cpp	/^double dist_from_point_to_polygon(vector<PT> &v, PT p) { \/\/ O(log n)$/;"	f	typeref:typename:double
dist_from_point_to_ray	code-library/Geometry/Geometry 2D.cpp	/^double dist_from_point_to_ray(PT a, PT b, PT c) {$/;"	f	typeref:typename:double
dist_from_point_to_ray	code/Geometry/Geometry 2D.cpp	/^double dist_from_point_to_ray(PT a, PT b, PT c) {$/;"	f	typeref:typename:double
dist_from_point_to_seg	code-library/Geometry/Geometry 2D.cpp	/^double dist_from_point_to_seg(PT a, PT b, PT c) {$/;"	f	typeref:typename:double
dist_from_point_to_seg	code/Geometry/Geometry 2D.cpp	/^double dist_from_point_to_seg(PT a, PT b, PT c) {$/;"	f	typeref:typename:double
dist_from_polygon_to_line	code-library/Geometry/Geometry 2D.cpp	/^double dist_from_polygon_to_line(vector<PT> &p, PT a, PT b, int top) { \/\/O(log n)$/;"	f	typeref:typename:double
dist_from_polygon_to_line	code/Geometry/Geometry 2D.cpp	/^double dist_from_polygon_to_line(vector<PT> &p, PT a, PT b, int top) { \/\/O(log n)$/;"	f	typeref:typename:double
dist_from_polygon_to_polygon	code-library/Geometry/Geometry 2D.cpp	/^double dist_from_polygon_to_polygon(vector<PT> &p1, vector<PT> &p2) { \/\/ O(n log n)$/;"	f	typeref:typename:double
dist_from_polygon_to_polygon	code/Geometry/Geometry 2D.cpp	/^double dist_from_polygon_to_polygon(vector<PT> &p1, vector<PT> &p2) { \/\/ O(n log n)$/;"	f	typeref:typename:double
dist_from_seg_to_seg	code-library/Geometry/Geometry 2D.cpp	/^double dist_from_seg_to_seg(PT a, PT b, PT c, PT d) {$/;"	f	typeref:typename:double
dist_from_seg_to_seg	code/Geometry/Geometry 2D.cpp	/^double dist_from_seg_to_seg(PT a, PT b, PT c, PT d) {$/;"	f	typeref:typename:double
distance_from_segment_to_point	code-library/Geometry/Geometry 3D.cpp	/^double distance_from_segment_to_point(p3 a, p3 b, p3 c) {$/;"	f	typeref:typename:double
distance_from_segment_to_point	code/Geometry/Geometry 3D.cpp	/^double distance_from_segment_to_point(p3 a, p3 b, p3 c) {$/;"	f	typeref:typename:double
distance_from_triangle_to_point	code-library/Geometry/Geometry 3D.cpp	/^double distance_from_triangle_to_point(p3 a, p3 b, p3 c, p3 d) {$/;"	f	typeref:typename:double
distance_from_triangle_to_point	code/Geometry/Geometry 3D.cpp	/^double distance_from_triangle_to_point(p3 a, p3 b, p3 c, p3 d) {$/;"	f	typeref:typename:double
distance_from_triangle_to_segment	code-library/Geometry/Geometry 3D.cpp	/^double distance_from_triangle_to_segment(p3 a, p3 b, p3 c, p3 d, p3 e) {$/;"	f	typeref:typename:double
distance_from_triangle_to_segment	code/Geometry/Geometry 3D.cpp	/^double distance_from_triangle_to_segment(p3 a, p3 b, p3 c, p3 d, p3 e) {$/;"	f	typeref:typename:double
distance_from_triangle_to_triangle	code-library/Geometry/Geometry 3D.cpp	/^double distance_from_triangle_to_triangle(p3 a, p3 b, p3 c, p3 d, p3 e, p3 f) {$/;"	f	typeref:typename:double
distance_from_triangle_to_triangle	code/Geometry/Geometry 3D.cpp	/^double distance_from_triangle_to_triangle(p3 a, p3 b, p3 c, p3 d, p3 e, p3 f) {$/;"	f	typeref:typename:double
div	code-library/Math/Polynomial Factorization.cpp	/^void div(vi &a, int e) {$/;"	f	typeref:typename:void
div	code/Math/Polynomial Factorization.cpp	/^void div(vi &a, int e) {$/;"	f	typeref:typename:void
div_xk	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly div_xk(int k) const { \/\/ divide by x^k$/;"	f	struct:poly	typeref:typename:poly	file:
div_xk	code-library/Math/Polynomial.cpp	/^  poly div_xk(int k) const { \/\/ divide by x^k$/;"	f	struct:poly	typeref:typename:poly	file:
div_xk	code-library/Math/Subset Sum Problem.cpp	/^  poly div_xk(int k) const { \/\/ divide by x^k$/;"	f	struct:poly	typeref:typename:poly	file:
div_xk	code-library/Number Theory/Bell Number.cpp	/^  poly div_xk(int k) const { \/\/ divide by x^k$/;"	f	struct:poly	typeref:typename:poly	file:
div_xk	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  poly div_xk(int k) const { \/\/ divide by x^k$/;"	f	struct:poly	typeref:typename:poly	file:
div_xk	code/Math/Faulhaber Formula Fastest.cpp	/^  poly div_xk(int k) const { \/\/ divide by x^k$/;"	f	struct:poly	typeref:typename:poly	file:
div_xk	code/Math/Polynomial.cpp	/^  poly div_xk(int k) const { \/\/ divide by x^k$/;"	f	struct:poly	typeref:typename:poly	file:
div_xk	code/Math/Subset Sum Problem.cpp	/^  poly div_xk(int k) const { \/\/ divide by x^k$/;"	f	struct:poly	typeref:typename:poly	file:
div_xk	code/Number Theory/Bell Number.cpp	/^  poly div_xk(int k) const { \/\/ divide by x^k$/;"	f	struct:poly	typeref:typename:poly	file:
div_xk	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  poly div_xk(int k) const { \/\/ divide by x^k$/;"	f	struct:poly	typeref:typename:poly	file:
divide	code-library/Game Theory/Blue Red Hackenbush.cpp	/^  void divide(int x) {$/;"	f	struct:surreal	typeref:typename:void	file:
divide	code/Game Theory/Blue Red Hackenbush.cpp	/^  void divide(int x) {$/;"	f	struct:surreal	typeref:typename:void	file:
divisor_gap	code-library/Number Theory/Pisano Period.cpp	/^ll divisor_gap(ll n) {$/;"	f	typeref:typename:ll
divisor_gap	code/Number Theory/Pisano Period.cpp	/^ll divisor_gap(ll n) {$/;"	f	typeref:typename:ll
divmod	code-library/Math/Faulhaber Formula Fastest.cpp	/^  pair<poly, poly> divmod(const poly &b) const { \/\/ returns quotient and remainder of a mod b$/;"	f	struct:poly	typeref:typename:pair<poly,poly>	file:
divmod	code-library/Math/Polynomial.cpp	/^  pair<poly, poly> divmod(const poly &b) const { \/\/ returns quotient and remainder of a mod b$/;"	f	struct:poly	typeref:typename:pair<poly,poly>	file:
divmod	code-library/Miscellaneous/BigInt.cpp	/^  friend pair<BigInt, BigInt> divmod(const BigInt& a1, const BigInt& b1) {$/;"	f	typeref:typename:pair<BigInt,BigInt>	file:
divmod	code/Math/Faulhaber Formula Fastest.cpp	/^  pair<poly, poly> divmod(const poly &b) const { \/\/ returns quotient and remainder of a mod b$/;"	f	struct:poly	typeref:typename:pair<poly,poly>	file:
divmod	code/Math/Polynomial.cpp	/^  pair<poly, poly> divmod(const poly &b) const { \/\/ returns quotient and remainder of a mod b$/;"	f	struct:poly	typeref:typename:pair<poly,poly>	file:
divmod	code/Miscellaneous/BigInt.cpp	/^  friend pair<BigInt, BigInt> divmod(const BigInt& a1, const BigInt& b1) {$/;"	f	typeref:typename:pair<BigInt,BigInt>	file:
divmod_slow	code-library/Math/Faulhaber Formula Fastest.cpp	/^  pair<poly, poly> divmod_slow(const poly &b) const { \/\/ when divisor or quotient is small$/;"	f	struct:poly	typeref:typename:pair<poly,poly>	file:
divmod_slow	code-library/Math/Polynomial.cpp	/^  pair<poly, poly> divmod_slow(const poly &b) const { \/\/ when divisor or quotient is small$/;"	f	struct:poly	typeref:typename:pair<poly,poly>	file:
divmod_slow	code/Math/Faulhaber Formula Fastest.cpp	/^  pair<poly, poly> divmod_slow(const poly &b) const { \/\/ when divisor or quotient is small$/;"	f	struct:poly	typeref:typename:pair<poly,poly>	file:
divmod_slow	code/Math/Polynomial.cpp	/^  pair<poly, poly> divmod_slow(const poly &b) const { \/\/ when divisor or quotient is small$/;"	f	struct:poly	typeref:typename:pair<poly,poly>	file:
do_POST	.compilingScripts/download_prob.py	/^        def do_POST(self):$/;"	m	class:listen_once.CompetitiveCompanionHandler
do_flip_path	code-library/Data Structures/Top Tree.cpp	/^  void do_flip_path() {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
do_flip_path	code/Data Structures/Top Tree.cpp	/^  void do_flip_path() {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
do_path_increment	code-library/Data Structures/Top Tree.cpp	/^  void do_path_increment(int64_t v = 1) {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
do_path_increment	code/Data Structures/Top Tree.cpp	/^  void do_path_increment(int64_t v = 1) {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
do_subtree_increment	code-library/Data Structures/Top Tree.cpp	/^  void do_subtree_increment(int64_t v = 1) {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
do_subtree_increment	code/Data Structures/Top Tree.cpp	/^  void do_subtree_increment(int64_t v = 1) {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
done	code-library/Data Structures/Binarizing a Tree.cpp	/^int tot, done[N * 2], cenpar[N * 2];$/;"	v	typeref:typename:int[]
done	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^int tot, done[N * 2], cenpar[N * 2];$/;"	v	typeref:typename:int[]
done	code-library/Data Structures/Centroid Decomposition.cpp	/^int tot, done[N], cenpar[N];$/;"	v	typeref:typename:int[]
done	code-library/Graph Theory/Dinics Algorithm.cpp	/^  vector<int> done;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
done	code-library/Graph Theory/Euler Path Directed.cpp	/^int done[N];$/;"	v	typeref:typename:int[]
done	code-library/Graph Theory/Euler Path Undirected.cpp	/^int done[N];$/;"	v	typeref:typename:int[]
done	code-library/Graph Theory/L R Flow with Dinic.cpp	/^  vector<int> done;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
done	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  vector<int> done;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
done	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^  vector<int> done;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
done	code-library/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^int tot, done[N], cenpar[N];$/;"	v	typeref:typename:int[]
done	code-library/Graph Theory/Tree Orientation.cpp	/^int tot, done[N];$/;"	v	typeref:typename:int[]
done	code-library/Graph Theory/Unique Min Cut.cpp	/^  vector<int> done;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
done	code/Data Structures/Binarizing a Tree.cpp	/^int tot, done[N * 2], cenpar[N * 2];$/;"	v	typeref:typename:int[]
done	code/Data Structures/Centroid Decomposition Persistent.cpp	/^int tot, done[N * 2], cenpar[N * 2];$/;"	v	typeref:typename:int[]
done	code/Data Structures/Centroid Decomposition.cpp	/^int tot, done[N], cenpar[N];$/;"	v	typeref:typename:int[]
done	code/Graph Theory/Dinics Algorithm.cpp	/^  vector<int> done;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
done	code/Graph Theory/Euler Path Directed.cpp	/^int done[N];$/;"	v	typeref:typename:int[]
done	code/Graph Theory/Euler Path Undirected.cpp	/^int done[N];$/;"	v	typeref:typename:int[]
done	code/Graph Theory/L R Flow with Dinic.cpp	/^  vector<int> done;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
done	code/Graph Theory/Maximum Closure Problem.cpp	/^  vector<int> done;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
done	code/Graph Theory/Maximum Density Subgraph.cpp	/^  vector<int> done;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
done	code/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^int tot, done[N], cenpar[N];$/;"	v	typeref:typename:int[]
done	code/Graph Theory/Tree Orientation.cpp	/^int tot, done[N];$/;"	v	typeref:typename:int[]
done	code/Graph Theory/Unique Min Cut.cpp	/^  vector<int> done;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
dot	code-library/Dynamic Programming Optimizations/Persistent CHT.cpp	/^  friend ll dot(PT &a, PT &b) {$/;"	f	typeref:typename:ll	file:
dot	code-library/Geometry/All Pair Segment Intersection.cpp	/^inline double dot(PT a, PT b) {$/;"	f	typeref:typename:double
dot	code-library/Geometry/Delaunay Triangulation.cpp	/^inline double dot(dPT a, dPT b) { return a.x * b.x + a.y * b.y; }$/;"	f	typeref:typename:double
dot	code-library/Geometry/Geometry 2D.cpp	/^inline double dot(PT a, PT b) { return a.x * b.x + a.y * b.y; }$/;"	f	typeref:typename:double
dot	code-library/Geometry/Geometry 3D.cpp	/^inline double dot(PT a, PT b) { return a.x * b.x + a.y * b.y; }$/;"	f	typeref:typename:double
dot	code-library/Geometry/Geometry 3D.cpp	/^inline double dot(p3 a, p3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }$/;"	f	typeref:typename:double
dot	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^inline double dot(PT a, PT b) { return a.x * b.x + a.y * b.y; }$/;"	f	typeref:typename:double
dot	code-library/Geometry/Half Plane Intersection.cpp	/^inline double dot(PT a, PT b) { return a.x * b.x + a.y * b.y; }$/;"	f	typeref:typename:double
dot	code-library/Geometry/Onion Decomposition.cpp	/^    long long dot(PT p) const { return x * p.x + y * p.y; }$/;"	f	struct:PT	typeref:typename:long long	file:
dot	code-library/Geometry/Point Location.cpp	/^    ll dot(const PT& a) const { return x * a.x + y * a.y; }$/;"	f	struct:PT	typeref:typename:ll	file:
dot	code-library/Geometry/Point Location.cpp	/^    ll dot(const PT& a, const PT& b) const { return (a - *this).dot(b - *this); }$/;"	f	struct:PT	typeref:typename:ll	file:
dot	code-library/Geometry/Voronoi Diagram.cpp	/^inline double dot(PT a, PT b) { return a.x * b.x + a.y * b.y; }$/;"	f	typeref:typename:double
dot	code/Dynamic Programming Optimizations/Persistent CHT.cpp	/^  friend ll dot(PT &a, PT &b) {$/;"	f	typeref:typename:ll	file:
dot	code/Geometry/All Pair Segment Intersection.cpp	/^inline double dot(PT a, PT b) {$/;"	f	typeref:typename:double
dot	code/Geometry/Delaunay Triangulation.cpp	/^inline double dot(dPT a, dPT b) { return a.x * b.x + a.y * b.y; }$/;"	f	typeref:typename:double
dot	code/Geometry/Geometry 2D.cpp	/^inline double dot(PT a, PT b) { return a.x * b.x + a.y * b.y; }$/;"	f	typeref:typename:double
dot	code/Geometry/Geometry 3D.cpp	/^inline double dot(PT a, PT b) { return a.x * b.x + a.y * b.y; }$/;"	f	typeref:typename:double
dot	code/Geometry/Geometry 3D.cpp	/^inline double dot(p3 a, p3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }$/;"	f	typeref:typename:double
dot	code/Geometry/Half Plane Intersection Dynamic.cpp	/^inline double dot(PT a, PT b) { return a.x * b.x + a.y * b.y; }$/;"	f	typeref:typename:double
dot	code/Geometry/Half Plane Intersection.cpp	/^inline double dot(PT a, PT b) { return a.x * b.x + a.y * b.y; }$/;"	f	typeref:typename:double
dot	code/Geometry/Onion Decomposition.cpp	/^    long long dot(PT p) const { return x * p.x + y * p.y; }$/;"	f	struct:PT	typeref:typename:long long	file:
dot	code/Geometry/Point Location.cpp	/^    ll dot(const PT& a) const { return x * a.x + y * a.y; }$/;"	f	struct:PT	typeref:typename:ll	file:
dot	code/Geometry/Point Location.cpp	/^    ll dot(const PT& a, const PT& b) const { return (a - *this).dot(b - *this); }$/;"	f	struct:PT	typeref:typename:ll	file:
dot	code/Geometry/Voronoi Diagram.cpp	/^inline double dot(PT a, PT b) { return a.x * b.x + a.y * b.y; }$/;"	f	typeref:typename:double
double	code-library/Geometry/All Pair Segment Intersection.cpp	/^#define double /;"	d	file:
double	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^#define double /;"	d	file:
double	code-library/Geometry/Half Plane Intersection.cpp	/^#define double /;"	d	file:
double	code-library/Math/Integration (Romberg).cpp	/^#define double /;"	d	file:
double	code-library/Math/Integration (Simpsons).cpp	/^#define double /;"	d	file:
double	code/Geometry/All Pair Segment Intersection.cpp	/^#define double /;"	d	file:
double	code/Geometry/Half Plane Intersection Dynamic.cpp	/^#define double /;"	d	file:
double	code/Geometry/Half Plane Intersection.cpp	/^#define double /;"	d	file:
double	code/Math/Integration (Romberg).cpp	/^#define double /;"	d	file:
double	code/Math/Integration (Simpsons).cpp	/^#define double /;"	d	file:
down	practice/cpbook/ch1/1.6/card/10388/main2.cpp	/^char up[2][100], down[2][100];$/;"	v	typeref:typename:char[2][100]
downdate	code-library/Data Structures/Top Tree.cpp	/^  void downdate() {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
downdate	code/Data Structures/Top Tree.cpp	/^  void downdate() {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
downdate_all	code-library/Data Structures/Top Tree.cpp	/^  void downdate_all() {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
downdate_all	code/Data Structures/Top Tree.cpp	/^  void downdate_all() {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
dp	code-library/Dynamic Programming Optimizations/1D1D DP.cpp	/^int dp[N];$/;"	v	typeref:typename:int[]
dp	code-library/Dynamic Programming Optimizations/Connected Component DP.cpp	/^int n, k, a[N], dp[N][N][1005][3];$/;"	v	typeref:typename:int[][][1005][3]
dp	code-library/Dynamic Programming Optimizations/Digit DP.cpp	/^int pw[20][20], b[1 << 10][3000], cnt[1 << 10], dp[2][20][1 << 10][2520];$/;"	v	typeref:typename:int[2][20][][2520]
dp	code-library/Dynamic Programming Optimizations/Divide and Conquer Optimization.cpp	/^int a[N][N], c[N][N], dp[810][N]; \/\/ dp[i][j]=minimum cost for dividing [1...j] into i parts$/;"	v	typeref:typename:int[810][]
dp	code-library/Dynamic Programming Optimizations/Subset Union of Bitsets.cpp	/^int x[N], y[N], c[N], dp[1 << 20], msk[N], ans[N];$/;"	v	typeref:typename:int[]
dp	code-library/Dynamic Programming Optimizations/XOR Equation.cpp	/^int dp[N][2][2];$/;"	v	typeref:typename:int[][2][2]
dp	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^mint dp[N][N], C[N], G[N];$/;"	v	typeref:typename:mint[][]
dp	code-library/Graph Theory/Minimum Weight Cycle For Each Edge.cpp	/^int g[N][N], ans[N * N], last[N], dp[N * N], id[N][N], W[N * N];$/;"	v	typeref:typename:int[]
dp	code-library/Graph Theory/Number of Arborescence.cpp	/^mint dp[N];$/;"	v	typeref:typename:mint[]
dp	code-library/Graph Theory/Number of DAG.cpp	/^mint dp[1 << 18]; \/\/ dp[i] = number of DAG containing vertices of mask i$/;"	v	typeref:typename:mint[]
dp	code-library/Graph Theory/Number of Different Cliques.cpp	/^int dp[(1 << (M \/ 2))];$/;"	v	typeref:typename:int[]
dp	code-library/Math/BerleKamp Massey.cpp	/^int dp[2000][20];$/;"	v	typeref:typename:int[2000][20]
dp	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^mint dp[N * 2][N];$/;"	v	typeref:typename:mint[][]
dp	code-library/Math/NTT Online.cpp	/^int ans[N], a[N], dp[N];$/;"	v	typeref:typename:int[]
dp	code-library/Math/Permanent of a Matrix.cpp	/^long long dp[1 << N];$/;"	v	typeref:typename:long long[]
dp	code-library/Miscellaneous/Subset Union of Bitsets.cpp	/^int x[N], y[N], c[N], dp[1 << 20], msk[N], ans[N];$/;"	v	typeref:typename:int[]
dp	code-library/Miscellaneous/XOR Equation Arbitrary Range.cpp	/^int dp[N][2][2];$/;"	v	typeref:typename:int[][2][2]
dp	code-library/Number Theory/Dirichlet Convolution.cpp	/^  mint dp[T], inv;$/;"	v	namespace:Dirichlet	typeref:typename:mint[]
dp	code-library/Number Theory/K Divisors.cpp	/^  int dp[PHI_N][PHI_K]; \/\/ precal of yo(n,k)$/;"	v	namespace:pcf	typeref:typename:int[][]
dp	code-library/Number Theory/LCM of Fibonacci Numbers.cpp	/^map<vector<int>, int> dp;$/;"	v	typeref:typename:map<vector<int>,int>
dp	code-library/Number Theory/Prime Counting Function.cpp	/^  int dp[PHI_N][PHI_K]; \/\/ precal of yo(n,k)$/;"	v	namespace:pcf	typeref:typename:int[][]
dp	code-library/Number Theory/Smallest Number Having Exactly K Divisors.cpp	/^unordered_map<long long, pair<double, int>> dp[100];$/;"	v	typeref:typename:unordered_map<long long,pair<double,int>>[100]
dp	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  int link[L], sz, to[L][2], dp[L][2], term[L], last[L]; \/\/ each string contains 'a' and 'b'$/;"	m	struct:AhoCorasick	typeref:typename:int[][2]	file:
dp	code-library/Strings/Cyclic LCS.cpp	/^int dp[N * 2][N], from[N * 2][N];$/;"	v	typeref:typename:int[][]
dp	code-library/Strings/Prefix Automaton.cpp	/^vector< vector<int> > dp;$/;"	v	typeref:typename:vector<vector<int>>
dp	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  vector<int> dp;$/;"	m	struct:SuffixAutomaton	typeref:typename:vector<int>	file:
dp	code-library/Strings/Suffix Automaton.cpp	/^    vector<long long> dp;$/;"	m	struct:SuffixAutomaton	typeref:typename:vector<long long>	file:
dp	code/Dynamic Programming Optimizations/1D1D DP.cpp	/^int dp[N];$/;"	v	typeref:typename:int[]
dp	code/Dynamic Programming Optimizations/Connected Component DP.cpp	/^int n, k, a[N], dp[N][N][1005][3];$/;"	v	typeref:typename:int[][][1005][3]
dp	code/Dynamic Programming Optimizations/Digit DP.cpp	/^int pw[20][20], b[1 << 10][3000], cnt[1 << 10], dp[2][20][1 << 10][2520];$/;"	v	typeref:typename:int[2][20][][2520]
dp	code/Dynamic Programming Optimizations/Divide and Conquer Optimization.cpp	/^int a[N][N], c[N][N], dp[810][N]; \/\/ dp[i][j]=minimum cost for dividing [1...j] into i parts$/;"	v	typeref:typename:int[810][]
dp	code/Dynamic Programming Optimizations/Subset Union of Bitsets.cpp	/^int x[N], y[N], c[N], dp[1 << 20], msk[N], ans[N];$/;"	v	typeref:typename:int[]
dp	code/Dynamic Programming Optimizations/XOR Equation.cpp	/^int dp[N][2][2];$/;"	v	typeref:typename:int[][2][2]
dp	code/Graph Theory/Counting Labeled Graphs.cpp	/^mint dp[N][N], C[N], G[N];$/;"	v	typeref:typename:mint[][]
dp	code/Graph Theory/Minimum Weight Cycle For Each Edge.cpp	/^int g[N][N], ans[N * N], last[N], dp[N * N], id[N][N], W[N * N];$/;"	v	typeref:typename:int[]
dp	code/Graph Theory/Number of Arborescence.cpp	/^mint dp[N];$/;"	v	typeref:typename:mint[]
dp	code/Graph Theory/Number of DAG.cpp	/^mint dp[1 << 18]; \/\/ dp[i] = number of DAG containing vertices of mask i$/;"	v	typeref:typename:mint[]
dp	code/Graph Theory/Number of Different Cliques.cpp	/^int dp[(1 << (M \/ 2))];$/;"	v	typeref:typename:int[]
dp	code/Math/BerleKamp Massey.cpp	/^int dp[2000][20];$/;"	v	typeref:typename:int[2000][20]
dp	code/Math/Generating Function of a Linear Recurrence.cpp	/^mint dp[N * 2][N];$/;"	v	typeref:typename:mint[][]
dp	code/Math/NTT Online.cpp	/^int ans[N], a[N], dp[N];$/;"	v	typeref:typename:int[]
dp	code/Math/Permanent of a Matrix.cpp	/^long long dp[1 << N];$/;"	v	typeref:typename:long long[]
dp	code/Miscellaneous/Subset Union of Bitsets.cpp	/^int x[N], y[N], c[N], dp[1 << 20], msk[N], ans[N];$/;"	v	typeref:typename:int[]
dp	code/Miscellaneous/XOR Equation Arbitrary Range.cpp	/^int dp[N][2][2];$/;"	v	typeref:typename:int[][2][2]
dp	code/Number Theory/Dirichlet Convolution.cpp	/^  mint dp[T], inv;$/;"	v	namespace:Dirichlet	typeref:typename:mint[]
dp	code/Number Theory/K Divisors.cpp	/^  int dp[PHI_N][PHI_K]; \/\/ precal of yo(n,k)$/;"	v	namespace:pcf	typeref:typename:int[][]
dp	code/Number Theory/LCM of Fibonacci Numbers.cpp	/^map<vector<int>, int> dp;$/;"	v	typeref:typename:map<vector<int>,int>
dp	code/Number Theory/Prime Counting Function.cpp	/^  int dp[PHI_N][PHI_K]; \/\/ precal of yo(n,k)$/;"	v	namespace:pcf	typeref:typename:int[][]
dp	code/Number Theory/Smallest Number Having Exactly K Divisors.cpp	/^unordered_map<long long, pair<double, int>> dp[100];$/;"	v	typeref:typename:unordered_map<long long,pair<double,int>>[100]
dp	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  int link[L], sz, to[L][2], dp[L][2], term[L], last[L]; \/\/ each string contains 'a' and 'b'$/;"	m	struct:AhoCorasick	typeref:typename:int[][2]	file:
dp	code/Strings/Cyclic LCS.cpp	/^int dp[N * 2][N], from[N * 2][N];$/;"	v	typeref:typename:int[][]
dp	code/Strings/Prefix Automaton.cpp	/^vector< vector<int> > dp;$/;"	v	typeref:typename:vector<vector<int>>
dp	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  vector<int> dp;$/;"	m	struct:SuffixAutomaton	typeref:typename:vector<int>	file:
dp	code/Strings/Suffix Automaton.cpp	/^    vector<long long> dp;$/;"	m	struct:SuffixAutomaton	typeref:typename:vector<long long>	file:
dp	contests/AtCoder/ABC211/D.cpp	/^int dp[mxN], dist[mxN];$/;"	v	typeref:typename:int[]
dp	practice/cf/DP/knap1.cpp	/^int64_t dp[mxN][mxW];$/;"	v	typeref:typename:int64_t[][]
dp	practice/cf/DP/knap2.cpp	/^int dp[N][N];$/;"	v	typeref:typename:int[][]
dp	practice/club/prob3/solution_prob3.cpp	/^int dp[mxN][mxN];$/;"	v	typeref:typename:int[][]
dp	practice/december2021/DP/counting_towers/sol.cpp	/^Modular<MOD> dp[mxN][2];$/;"	v	typeref:typename:Modular<MOD>[][2]
dp	practice/december2021/DP/rectangle_cutting/sol.cpp	/^int dp[mxN][mxN];$/;"	v	typeref:typename:int[][]
dp	practice/december2021/DP/removal_game/sol.cpp	/^vector<vector<pi>> dp(mxN, vector<pi>(mxN, {0, 0}));$/;"	v	typeref:typename:vector<vector<pi>>
dp	practice/usacoguide/gold/introDP/711C.cpp	/^ll dp[N][N][N];$/;"	v	typeref:typename:ll[][][]
dp	practice/usacoguide/gold/introDP/arraydescription.cpp	/^mi dp[mxN][105];$/;"	v	typeref:typename:mi[][105]
dp	practice/usacoguide/gold/introDP/cannonballs.cpp	/^int dp[mxN];$/;"	v	typeref:typename:int[]
dp	practice/usacoguide/gold/introDP/editdistance.cpp	/^int dp[mxN][mxN];$/;"	v	typeref:typename:int[][]
dp	practice/usacoguide/gold/introDP/gridpaths.cpp	/^int dp[mxN][mxN];$/;"	v	typeref:typename:int[][]
dp	practice/usacoguide/gold/introDP/hoofpaperscissors.cpp	/^int dp[mxN][25][3];$/;"	v	typeref:typename:int[][25][3]
dp	practice/usacoguide/gold/introDP/king2.cpp	/^ll dp[mxN][mxN], board[mxN][mxN];$/;"	v	typeref:typename:ll[][]
dp	practice/usacoguide/gold/introDP/knight.cpp	/^int dp[mxN][mxN];$/;"	v	typeref:typename:int[][]
dp	practice/usacoguide/gold/introDP/ladder.cpp	/^int dp[mxN];$/;"	v	typeref:typename:int[]
dp	practice/usacoguide/gold/introDP/mooney.cpp	/^int dp[1005][1005];$/;"	v	typeref:typename:int[1005][1005]
dp	practice/usacoguide/gold/introDP/rabbit.cpp	/^int dp[mxN];$/;"	v	typeref:typename:int[]
dp	practice/usacoguide/gold/introDP/slalom.cpp	/^int grid[mxN][mxN], dp[mxN][mxN];$/;"	v	typeref:typename:int[][]
dp	practice/usacoguide/gold/introDP/time.cpp	/^int dp[mxN][mxN];$/;"	v	typeref:typename:int[][]
dp1	code-library/Dynamic Programming Optimizations/Number of Subsequences Having Product at least K.cpp	/^int dp1[N][SQ], dp2[N][SQ];$/;"	v	typeref:typename:int[][]
dp1	code/Dynamic Programming Optimizations/Number of Subsequences Having Product at least K.cpp	/^int dp1[N][SQ], dp2[N][SQ];$/;"	v	typeref:typename:int[][]
dp2	code-library/Dynamic Programming Optimizations/Number of Subsequences Having Product at least K.cpp	/^int dp1[N][SQ], dp2[N][SQ];$/;"	v	typeref:typename:int[][]
dp2	code/Dynamic Programming Optimizations/Number of Subsequences Having Product at least K.cpp	/^int dp1[N][SQ], dp2[N][SQ];$/;"	v	typeref:typename:int[][]
ds	code-library/Data Structures/MOs Online.cpp	/^} t[C * (C + 1) \/ 2 + 10], ds;$/;"	v	typeref:struct:MEX
ds	code/Data Structures/MOs Online.cpp	/^} t[C * (C + 1) \/ 2 + 10], ds;$/;"	v	typeref:struct:MEX
dsu	code-library/Data Structures/DSU on Tree.cpp	/^void dsu(int u, int p, bool keep) {$/;"	f	typeref:typename:void
dsu	code-library/Graph Theory/Boruvka's Algorithm.cpp	/^  dsu(int n) : par(n+1), rnk(n+1,0), size(n+1,1), c(n) {$/;"	f	struct:dsu	file:
dsu	code-library/Graph Theory/Boruvka's Algorithm.cpp	/^struct dsu {$/;"	s	file:
dsu	code-library/Graph Theory/Dominator Tree.cpp	/^int sdom[N], par[N], idom[N], dsu[N], label[N];$/;"	v	typeref:typename:int[]
dsu	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  dsu(int n) : par(n), rank(n, 0), size(n, 1), c(n) {$/;"	f	struct:dsu	file:
dsu	code-library/Graph Theory/Gomory Hu Tree.cpp	/^struct dsu {$/;"	s	file:
dsu	code-library/Graph Theory/Kirchoffs Theorem.cpp	/^  dsu(int n) : par(n + 1), rnk(n + 1, 0), size(n + 1, 1), c(n) {$/;"	f	struct:dsu	file:
dsu	code-library/Graph Theory/Kirchoffs Theorem.cpp	/^struct dsu {$/;"	s	file:
dsu	code-library/Graph Theory/Krushkal's MST.cpp	/^  dsu(int n) : par(n+1), rnk(n+1,0), size(n+1,1), c(n) {$/;"	f	struct:dsu	file:
dsu	code-library/Graph Theory/Krushkal's MST.cpp	/^struct dsu {$/;"	s	file:
dsu	code-library/Graph Theory/Manhattan MST.cpp	/^} dsu;$/;"	v	typeref:struct:DSU
dsu	code/Data Structures/DSU on Tree.cpp	/^void dsu(int u, int p, bool keep) {$/;"	f	typeref:typename:void
dsu	code/Graph Theory/Boruvka's Algorithm.cpp	/^  dsu(int n) : par(n+1), rnk(n+1,0), size(n+1,1), c(n) {$/;"	f	struct:dsu	file:
dsu	code/Graph Theory/Boruvka's Algorithm.cpp	/^struct dsu {$/;"	s	file:
dsu	code/Graph Theory/Dominator Tree.cpp	/^int sdom[N], par[N], idom[N], dsu[N], label[N];$/;"	v	typeref:typename:int[]
dsu	code/Graph Theory/Gomory Hu Tree.cpp	/^  dsu(int n) : par(n), rank(n, 0), size(n, 1), c(n) {$/;"	f	struct:dsu	file:
dsu	code/Graph Theory/Gomory Hu Tree.cpp	/^struct dsu {$/;"	s	file:
dsu	code/Graph Theory/Kirchoffs Theorem.cpp	/^  dsu(int n) : par(n + 1), rnk(n + 1, 0), size(n + 1, 1), c(n) {$/;"	f	struct:dsu	file:
dsu	code/Graph Theory/Kirchoffs Theorem.cpp	/^struct dsu {$/;"	s	file:
dsu	code/Graph Theory/Krushkal's MST.cpp	/^  dsu(int n) : par(n+1), rnk(n+1,0), size(n+1,1), c(n) {$/;"	f	struct:dsu	file:
dsu	code/Graph Theory/Krushkal's MST.cpp	/^struct dsu {$/;"	s	file:
dsu	code/Graph Theory/Manhattan MST.cpp	/^} dsu;$/;"	v	typeref:struct:DSU
dword_t	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  using dword_t = __uint128_t;$/;"	t	namespace:ntt	typeref:typename:__uint128_t	file:
dword_t	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  using dword_t = __uint128_t;$/;"	t	namespace:ntt	typeref:typename:__uint128_t	file:
dx	code-library/Geometry/Geometry 3D.cpp	/^    p3 o, dx, dy, dz;$/;"	m	struct:coords	typeref:typename:p3	file:
dx	code/Geometry/Geometry 3D.cpp	/^    p3 o, dx, dy, dz;$/;"	m	struct:coords	typeref:typename:p3	file:
dx	contests/LIT2021/C.cpp	/^int dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, 1, -1};$/;"	v	typeref:typename:int[4]
dx	practice/usacoguide/gold/SP/visitfj.cpp	/^int dx[] = {0, 1, 2, 3, 2, 1, 0, -1, -2, -3, -2, -1, -1, 1, 0, 0};$/;"	v	typeref:typename:int[]
dx	practice/usacoguide/gold/SP/visitfj/main.cpp	/^int dx[4] = {0, 1, -1, 0};$/;"	v	typeref:typename:int[4]
dx	practice/usacoguide/gold/bfs/mecho/main.cpp	/^int dx[4] = {-1, 0, 1, 0};$/;"	v	typeref:typename:int[4]
dx	practice/usacoguide/gold/bfs/mechonew/main.cpp	/^int dx[4] = {-1, 0, 1, 0};$/;"	v	typeref:typename:int[4]
dx	practice/usacoguide/gold/bfs/swap.cpp	/^int dx[4] = {0, -1, 0, 1};$/;"	v	typeref:typename:int[4]
dx	practice/usacoguide/gold/dsu/tractor/main.cpp	/^int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};$/;"	v	typeref:typename:int[4]
dx	practice/usacoguide/silver/idk/maze/main.cpp	/^int dx[] = {0, -1, 0, 1};$/;"	v	typeref:typename:int[]
dy	code-library/Geometry/Geometry 3D.cpp	/^    p3 o, dx, dy, dz;$/;"	m	struct:coords	typeref:typename:p3	file:
dy	code/Geometry/Geometry 3D.cpp	/^    p3 o, dx, dy, dz;$/;"	m	struct:coords	typeref:typename:p3	file:
dy	contests/LIT2021/C.cpp	/^int dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, 1, -1};$/;"	v	typeref:typename:int[4]
dy	practice/usacoguide/gold/SP/visitfj.cpp	/^int dy[] = {3, 2, 1, 0, -1, -2, -3, -2, -1, 0, 1, 2, 0, 0, -1, 1};$/;"	v	typeref:typename:int[]
dy	practice/usacoguide/gold/SP/visitfj/main.cpp	/^int dy[4] = {1, 0, 0, -1};$/;"	v	typeref:typename:int[4]
dy	practice/usacoguide/gold/bfs/mecho/main.cpp	/^int dy[4] = {0, -1, 0, 1};$/;"	v	typeref:typename:int[4]
dy	practice/usacoguide/gold/bfs/mechonew/main.cpp	/^int dy[4] = {0, -1, 0, 1};$/;"	v	typeref:typename:int[4]
dy	practice/usacoguide/gold/bfs/swap.cpp	/^int dy[4] = {1, 0, -1, 0};$/;"	v	typeref:typename:int[4]
dy	practice/usacoguide/gold/dsu/tractor/main.cpp	/^int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};$/;"	v	typeref:typename:int[4]
dy	practice/usacoguide/silver/idk/maze/main.cpp	/^int dy[] = {1, 0, -1, 0};$/;"	v	typeref:typename:int[]
dz	code-library/Geometry/Geometry 3D.cpp	/^    p3 o, dx, dy, dz;$/;"	m	struct:coords	typeref:typename:p3	file:
dz	code/Geometry/Geometry 3D.cpp	/^    p3 o, dx, dy, dz;$/;"	m	struct:coords	typeref:typename:p3	file:
e	code-library/Data Structures/Dynamic Diameter Online.cpp	/^    long long a = 0, b = 0, c = 0, d = 0, e = 0;$/;"	m	struct:node	typeref:typename:long long	file:
e	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  int b, e;$/;"	m	struct:ST	typeref:typename:int	file:
e	code-library/Graph Theory/Bellman Ford.cpp	/^} e[N];$/;"	v	typeref:struct:st[]
e	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  vector<edge> e;$/;"	m	struct:MCMF	typeref:typename:vector<edge>	file:
e	code-library/Graph Theory/Min Cost Max Flow.cpp	/^  vector<edge> e;$/;"	m	struct:MCMF	typeref:typename:vector<edge>	file:
e	code-library/Graph Theory/Number of DAG.cpp	/^int e[1 << 18];$/;"	v	typeref:typename:int[]
e	code/Data Structures/Dynamic Diameter Online.cpp	/^    long long a = 0, b = 0, c = 0, d = 0, e = 0;$/;"	m	struct:node	typeref:typename:long long	file:
e	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  int b, e;$/;"	m	struct:ST	typeref:typename:int	file:
e	code/Graph Theory/Bellman Ford.cpp	/^} e[N];$/;"	v	typeref:struct:st[]
e	code/Graph Theory/L R Flow with MCMF.cpp	/^  vector<edge> e;$/;"	m	struct:MCMF	typeref:typename:vector<edge>	file:
e	code/Graph Theory/Min Cost Max Flow.cpp	/^  vector<edge> e;$/;"	m	struct:MCMF	typeref:typename:vector<edge>	file:
e	code/Graph Theory/Number of DAG.cpp	/^int e[1 << 18];$/;"	v	typeref:typename:int[]
e	contests/USACO/dec_silver_2021/B/brute.cpp	/^	vector<int> e;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
e	practice/usacoguide/gold/dsu/closing/main.cpp	/^	vector<int> e;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
e	practice/usacoguide/gold/dsu/moocast/main.cpp	/^	vector<int> e;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
e	practice/usacoguide/gold/dsu/mootube/main.cpp	/^	vector<int> e;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
e	practice/usacoguide/gold/dsu/tractor/main.cpp	/^	vector<int> e;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
e	practice/usacoguide/gold/dsu/tractor/mountain.cpp	/^	vector<int> e;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
e	practice/usacoguide/gold/dsu/wormhole/main.cpp	/^	vector<int> e;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
e	practice/usacoguide/silver/idk/lirs/main.cpp	/^	vector<int> e;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
e_id	code-library/Graph Theory/Cycle Detection.cpp	/^int vis[N], par[N], e_id[N];$/;"	v	typeref:typename:int[]
e_id	code/Graph Theory/Cycle Detection.cpp	/^int vis[N], par[N], e_id[N];$/;"	v	typeref:typename:int[]
eb	code-library/Data Structures/Disjoint Sparse Table.cpp	/^#define eb /;"	d	file:
eb	code-library/Data Structures/Implicit Treap.cpp	/^#define eb /;"	d	file:
eb	code-library/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^#define eb /;"	d	file:
eb	code-library/Dynamic Programming Optimizations/DP Over Divisors.cpp	/^#define eb /;"	d	file:
eb	code-library/Dynamic Programming Optimizations/Digit DP.cpp	/^#define eb /;"	d	file:
eb	code-library/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^#define eb /;"	d	file:
eb	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^#define eb /;"	d	file:
eb	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^#define eb /;"	d	file:
eb	code-library/Strings/Prefix Automaton.cpp	/^#define eb /;"	d	file:
eb	code/Data Structures/Disjoint Sparse Table.cpp	/^#define eb /;"	d	file:
eb	code/Data Structures/Implicit Treap.cpp	/^#define eb /;"	d	file:
eb	code/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^#define eb /;"	d	file:
eb	code/Dynamic Programming Optimizations/DP Over Divisors.cpp	/^#define eb /;"	d	file:
eb	code/Dynamic Programming Optimizations/Digit DP.cpp	/^#define eb /;"	d	file:
eb	code/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^#define eb /;"	d	file:
eb	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^#define eb /;"	d	file:
eb	code/Graph Theory/Counting Labeled Graphs.cpp	/^#define eb /;"	d	file:
eb	code/Strings/Prefix Automaton.cpp	/^#define eb /;"	d	file:
ed	code-library/Data Structures/MOs with DSU.cpp	/^int n, ed, m;$/;"	v	typeref:typename:int
ed	code-library/Graph Theory/Dynamic MST.cpp	/^int st[MAXN], ed[MAXN], cost[MAXN], chk[MAXN];$/;"	v	typeref:typename:int[]
ed	code-library/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  vector<T> ed;$/;"	m	struct:EdgeColoring	typeref:typename:vector<T>	file:
ed	code-library/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^ll ed, far, global = LLONG_MAX, dist[N];$/;"	v	typeref:typename:ll
ed	code/Data Structures/MOs with DSU.cpp	/^int n, ed, m;$/;"	v	typeref:typename:int
ed	code/Graph Theory/Dynamic MST.cpp	/^int st[MAXN], ed[MAXN], cost[MAXN], chk[MAXN];$/;"	v	typeref:typename:int[]
ed	code/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  vector<T> ed;$/;"	m	struct:EdgeColoring	typeref:typename:vector<T>	file:
ed	code/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^ll ed, far, global = LLONG_MAX, dist[N];$/;"	v	typeref:typename:ll
edge	code-library/Data Structures/MOs with DSU.cpp	/^  edge() {$/;"	f	struct:edge	file:
edge	code-library/Data Structures/MOs with DSU.cpp	/^  edge(int _u, int _v) {$/;"	f	struct:edge	file:
edge	code-library/Data Structures/MOs with DSU.cpp	/^struct edge {$/;"	s	file:
edge	code-library/Geometry/Geometry 3D.cpp	/^struct edge {$/;"	s	file:
edge	code-library/Geometry/Point Location.cpp	/^    struct edge {$/;"	s	struct:DCEL	file:
edge	code-library/Geometry/Point Location.cpp	/^struct edge {$/;"	s	file:
edge	code-library/Graph Theory/Articulation Bridges.cpp	/^  using edge = pair<int, int>;$/;"	t	struct:TECC	typeref:typename:pair<int,int>	file:
edge	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  struct edge {$/;"	s	struct:Blossom	file:
edge	code-library/Graph Theory/Dinics Algorithm.cpp	/^  struct edge {$/;"	s	struct:Dinic	file:
edge	code-library/Graph Theory/Directed MST.cpp	/^struct edge {$/;"	s	file:
edge	code-library/Graph Theory/Gomory Hu Tree.cpp	/^struct edge {$/;"	s	file:
edge	code-library/Graph Theory/Johnson's Algorithm.cpp	/^  edge(){}$/;"	f	struct:edge	file:
edge	code-library/Graph Theory/Johnson's Algorithm.cpp	/^  edge(int u, int v, long long w) : u(u), v(v), w(w){}$/;"	f	struct:edge	file:
edge	code-library/Graph Theory/Johnson's Algorithm.cpp	/^struct edge {$/;"	s	file:
edge	code-library/Graph Theory/L R Flow with Dinic.cpp	/^  struct edge {$/;"	s	struct:Dinic	file:
edge	code-library/Graph Theory/L R Flow with Dinic.cpp	/^  struct edge {$/;"	s	struct:LR_Flow	file:
edge	code-library/Graph Theory/L R Flow with MCMF.cpp	/^    edge(int _u, int _v, T _cap, T _cost, int _id) {$/;"	f	struct:MCMF::edge	file:
edge	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  struct edge {$/;"	s	struct:MCMF	file:
edge	code-library/Graph Theory/Manhattan MST.cpp	/^struct edge {$/;"	s	file:
edge	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  struct edge {$/;"	s	struct:Dinic	file:
edge	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^  struct edge {$/;"	s	struct:Dinic	file:
edge	code-library/Graph Theory/Min Cost Max Flow.cpp	/^    edge(int _u, int _v, T _cap, T _cost, int _id) {$/;"	f	struct:MCMF::edge	file:
edge	code-library/Graph Theory/Min Cost Max Flow.cpp	/^  struct edge {$/;"	s	struct:MCMF	file:
edge	code-library/Graph Theory/Unique Min Cut.cpp	/^  struct edge {$/;"	s	struct:Dinic	file:
edge	code/Data Structures/MOs with DSU.cpp	/^  edge() {$/;"	f	struct:edge	file:
edge	code/Data Structures/MOs with DSU.cpp	/^  edge(int _u, int _v) {$/;"	f	struct:edge	file:
edge	code/Data Structures/MOs with DSU.cpp	/^struct edge {$/;"	s	file:
edge	code/Geometry/Geometry 3D.cpp	/^struct edge {$/;"	s	file:
edge	code/Geometry/Point Location.cpp	/^    struct edge {$/;"	s	struct:DCEL	file:
edge	code/Geometry/Point Location.cpp	/^struct edge {$/;"	s	file:
edge	code/Graph Theory/Articulation Bridges.cpp	/^  using edge = pair<int, int>;$/;"	t	struct:TECC	typeref:typename:pair<int,int>	file:
edge	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  struct edge {$/;"	s	struct:Blossom	file:
edge	code/Graph Theory/Dinics Algorithm.cpp	/^  struct edge {$/;"	s	struct:Dinic	file:
edge	code/Graph Theory/Directed MST.cpp	/^struct edge {$/;"	s	file:
edge	code/Graph Theory/Gomory Hu Tree.cpp	/^struct edge {$/;"	s	file:
edge	code/Graph Theory/Johnson's Algorithm.cpp	/^  edge(){}$/;"	f	struct:edge	file:
edge	code/Graph Theory/Johnson's Algorithm.cpp	/^  edge(int u, int v, long long w) : u(u), v(v), w(w){}$/;"	f	struct:edge	file:
edge	code/Graph Theory/Johnson's Algorithm.cpp	/^struct edge {$/;"	s	file:
edge	code/Graph Theory/L R Flow with Dinic.cpp	/^  struct edge {$/;"	s	struct:Dinic	file:
edge	code/Graph Theory/L R Flow with Dinic.cpp	/^  struct edge {$/;"	s	struct:LR_Flow	file:
edge	code/Graph Theory/L R Flow with MCMF.cpp	/^    edge(int _u, int _v, T _cap, T _cost, int _id) {$/;"	f	struct:MCMF::edge	file:
edge	code/Graph Theory/L R Flow with MCMF.cpp	/^  struct edge {$/;"	s	struct:MCMF	file:
edge	code/Graph Theory/Manhattan MST.cpp	/^struct edge {$/;"	s	file:
edge	code/Graph Theory/Maximum Closure Problem.cpp	/^  struct edge {$/;"	s	struct:Dinic	file:
edge	code/Graph Theory/Maximum Density Subgraph.cpp	/^  struct edge {$/;"	s	struct:Dinic	file:
edge	code/Graph Theory/Min Cost Max Flow.cpp	/^    edge(int _u, int _v, T _cap, T _cost, int _id) {$/;"	f	struct:MCMF::edge	file:
edge	code/Graph Theory/Min Cost Max Flow.cpp	/^  struct edge {$/;"	s	struct:MCMF	file:
edge	code/Graph Theory/Unique Min Cut.cpp	/^  struct edge {$/;"	s	struct:Dinic	file:
edge_cmp	code-library/Geometry/Point Location.cpp	/^bool edge_cmp(edge* edge1, edge* edge2) {$/;"	f	typeref:typename:bool
edge_cmp	code/Geometry/Point Location.cpp	/^bool edge_cmp(edge* edge1, edge* edge2) {$/;"	f	typeref:typename:bool
edge_color	code-library/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  vector<vector<int>> edge_color(vector<int> lab) { \/\/ regular bipartite graph!$/;"	f	struct:EdgeColoring	typeref:typename:vector<vector<int>>	file:
edge_color	code/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  vector<vector<int>> edge_color(vector<int> lab) { \/\/ regular bipartite graph!$/;"	f	struct:EdgeColoring	typeref:typename:vector<vector<int>>	file:
edges	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  FlowGraph &edges;$/;"	m	struct:Dinic	typeref:typename:FlowGraph &	file:
edges	code-library/Graph Theory/L R Flow with Dinic.cpp	/^  vector<edge> edges;$/;"	m	struct:LR_Flow	typeref:typename:vector<edge>	file:
edges	code-library/Graph Theory/Manhattan MST.cpp	/^vector<edge> edges;$/;"	v	typeref:typename:vector<edge>
edges	code-library/Graph Theory/Maximum Clique.cpp	/^long long edges[N];$/;"	v	typeref:typename:long long[]
edges	code/Graph Theory/Gomory Hu Tree.cpp	/^  FlowGraph &edges;$/;"	m	struct:Dinic	typeref:typename:FlowGraph &	file:
edges	code/Graph Theory/L R Flow with Dinic.cpp	/^  vector<edge> edges;$/;"	m	struct:LR_Flow	typeref:typename:vector<edge>	file:
edges	code/Graph Theory/Manhattan MST.cpp	/^vector<edge> edges;$/;"	v	typeref:typename:vector<edge>
edges	code/Graph Theory/Maximum Clique.cpp	/^long long edges[N];$/;"	v	typeref:typename:long long[]
edges	practice/usacoguide/gold/SP/shortestroutesii.cpp	/^int dist[mxN][mxN], edges[mxN][mxN];$/;"	v	typeref:typename:int[][]
el	code-library/Graph Theory/Boruvka's Algorithm.cpp	/^int el[N * 30], tot[N * 30];$/;"	v	typeref:typename:int[]
el	code/Graph Theory/Boruvka's Algorithm.cpp	/^int el[N * 30], tot[N * 30];$/;"	v	typeref:typename:int[]
elements	contests/USACO/dec_silver_2021/C/C.cpp	/^int diff[mxN], elements[mxN];$/;"	v	typeref:typename:int[]
empty	code-library/Data Structures/Persistent Meldable Heap.cpp	/^  bool empty() {$/;"	f	struct:heap	typeref:typename:bool	file:
empty	code-library/Graph Theory/Eppsteins Algorithm.cpp	/^  bool empty() {$/;"	f	struct:heap	typeref:typename:bool	file:
empty	code/Data Structures/Persistent Meldable Heap.cpp	/^  bool empty() {$/;"	f	struct:heap	typeref:typename:bool	file:
empty	code/Graph Theory/Eppsteins Algorithm.cpp	/^  bool empty() {$/;"	f	struct:heap	typeref:typename:bool	file:
en	code-library/Data Structures/Binarizing a Tree.cpp	/^int st[N * 2], en[N * 2], DT;$/;"	v	typeref:typename:int[]
en	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^int st[N * 2], en[N * 2], DT;$/;"	v	typeref:typename:int[]
en	code-library/Data Structures/Dynamic Diameter Online.cpp	/^int T, st[N * 2], en[N * 2], pos[N];$/;"	v	typeref:typename:int[]
en	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int T, head[N], st[N], en[N];$/;"	v	typeref:typename:int[]
en	code-library/Data Structures/HLD.cpp	/^int T, head[N], st[N], en[N];$/;"	v	typeref:typename:int[]
en	code-library/Data Structures/MOs Online.cpp	/^int st[C], en[C], BC = 0;$/;"	v	typeref:typename:int[]
en	code-library/Data Structures/MOs on tree.cpp	/^int st[N], en[N], T, par[N][20], dep[N], id[N * 2];$/;"	v	typeref:typename:int[]
en	code-library/Data Structures/Reachability Tree.cpp	/^  int T, st[2 * N], en[2 * N];$/;"	m	struct:RT	typeref:typename:int[]	file:
en	code-library/Graph Theory/Dominator Tree.cpp	/^int st[N], en[N];$/;"	v	typeref:typename:int[]
en	code-library/Graph Theory/Virtual Tree.cpp	/^int par[N][20], dep[N], sz[N], st[N], en[N], T;$/;"	v	typeref:typename:int[]
en	code-library/Miscellaneous/Parallel Binary Search.cpp	/^int amount[N], want[N], st[N], en[N], l[N], r[N], ans[N];$/;"	v	typeref:typename:int[]
en	code-library/Strings/Palindromic Tree Persistent.cpp	/^    int nxt[A], len, st, en, link, cnt, oc, smart_link[A];$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
en	code-library/Strings/Palindromic Tree.cpp	/^    int nxt[26], len, st, en, link, diff, slink, cnt, oc;$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
en	code/Data Structures/Binarizing a Tree.cpp	/^int st[N * 2], en[N * 2], DT;$/;"	v	typeref:typename:int[]
en	code/Data Structures/Centroid Decomposition Persistent.cpp	/^int st[N * 2], en[N * 2], DT;$/;"	v	typeref:typename:int[]
en	code/Data Structures/Dynamic Diameter Online.cpp	/^int T, st[N * 2], en[N * 2], pos[N];$/;"	v	typeref:typename:int[]
en	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int T, head[N], st[N], en[N];$/;"	v	typeref:typename:int[]
en	code/Data Structures/HLD.cpp	/^int T, head[N], st[N], en[N];$/;"	v	typeref:typename:int[]
en	code/Data Structures/MOs Online.cpp	/^int st[C], en[C], BC = 0;$/;"	v	typeref:typename:int[]
en	code/Data Structures/MOs on tree.cpp	/^int st[N], en[N], T, par[N][20], dep[N], id[N * 2];$/;"	v	typeref:typename:int[]
en	code/Data Structures/Reachability Tree.cpp	/^  int T, st[2 * N], en[2 * N];$/;"	m	struct:RT	typeref:typename:int[]	file:
en	code/Graph Theory/Dominator Tree.cpp	/^int st[N], en[N];$/;"	v	typeref:typename:int[]
en	code/Graph Theory/Virtual Tree.cpp	/^int par[N][20], dep[N], sz[N], st[N], en[N], T;$/;"	v	typeref:typename:int[]
en	code/Miscellaneous/Parallel Binary Search.cpp	/^int amount[N], want[N], st[N], en[N], l[N], r[N], ans[N];$/;"	v	typeref:typename:int[]
en	code/Strings/Palindromic Tree Persistent.cpp	/^    int nxt[A], len, st, en, link, cnt, oc, smart_link[A];$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
en	code/Strings/Palindromic Tree.cpp	/^    int nxt[26], len, st, en, link, diff, slink, cnt, oc;$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
endNode	contests/USACO/dec_silver_2021/B/B.cpp	/^set<int> endNode, beginNode;$/;"	v	typeref:typename:set<int>
end_vis	practice/cpbook/ch1/1.6/chess/chess/realsol.cpp	/^bool start_vis[9][9], end_vis[9][9];$/;"	v	typeref:typename:bool[9][9]
endl	code-library/Data Structures/MOs with DSU.cpp	/^#define endl /;"	d	file:
endl	code/Data Structures/MOs with DSU.cpp	/^#define endl /;"	d	file:
endl	contests/Codeforces/737/C.cpp	/^#define endl /;"	d	file:
endl	practice/usacoguide/gold/bfs/graphgirth2.cpp	/^#define endl /;"	d	file:
ensure_base	code-library/Math/Faulhaber Formula Fastest.cpp	/^void ensure_base(int p) {$/;"	f	typeref:typename:void
ensure_base	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^void ensure_base(int p) {$/;"	f	typeref:typename:void
ensure_base	code-library/Math/Linear Recurrence Fastest.cpp	/^void ensure_base(int p) {$/;"	f	typeref:typename:void
ensure_base	code-library/Math/NTT Online.cpp	/^void ensure_base(int p) {$/;"	f	typeref:typename:void
ensure_base	code-library/Math/NTT With Any Prime MOD.cpp	/^void ensure_base(int p) {$/;"	f	typeref:typename:void
ensure_base	code-library/Math/Polynomial with Binomial Coefficients.cpp	/^void ensure_base(int p) {$/;"	f	typeref:typename:void
ensure_base	code-library/Math/Polynomial.cpp	/^void ensure_base(int p) {$/;"	f	typeref:typename:void
ensure_base	code-library/Math/Subset Sum Problem.cpp	/^void ensure_base(int p) {$/;"	f	typeref:typename:void
ensure_base	code-library/Number Theory/Bell Number.cpp	/^void ensure_base(int p) {$/;"	f	typeref:typename:void
ensure_base	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^void ensure_base(int p) {$/;"	f	typeref:typename:void
ensure_base	code-library/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^void ensure_base(int p) {$/;"	f	typeref:typename:void
ensure_base	code/Math/Faulhaber Formula Fastest.cpp	/^void ensure_base(int p) {$/;"	f	typeref:typename:void
ensure_base	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^void ensure_base(int p) {$/;"	f	typeref:typename:void
ensure_base	code/Math/Linear Recurrence Fastest.cpp	/^void ensure_base(int p) {$/;"	f	typeref:typename:void
ensure_base	code/Math/NTT Online.cpp	/^void ensure_base(int p) {$/;"	f	typeref:typename:void
ensure_base	code/Math/NTT With Any Prime MOD.cpp	/^void ensure_base(int p) {$/;"	f	typeref:typename:void
ensure_base	code/Math/Polynomial with Binomial Coefficients.cpp	/^void ensure_base(int p) {$/;"	f	typeref:typename:void
ensure_base	code/Math/Polynomial.cpp	/^void ensure_base(int p) {$/;"	f	typeref:typename:void
ensure_base	code/Math/Subset Sum Problem.cpp	/^void ensure_base(int p) {$/;"	f	typeref:typename:void
ensure_base	code/Number Theory/Bell Number.cpp	/^void ensure_base(int p) {$/;"	f	typeref:typename:void
ensure_base	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^void ensure_base(int p) {$/;"	f	typeref:typename:void
ensure_base	code/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^void ensure_base(int p) {$/;"	f	typeref:typename:void
enter	code-library/Graph Theory/LCA in O(1).cpp	/^  vector<int> enter, depth, exxit;$/;"	m	struct:LCA	typeref:typename:vector<int>	file:
enter	code/Graph Theory/LCA in O(1).cpp	/^  vector<int> enter, depth, exxit;$/;"	m	struct:LCA	typeref:typename:vector<int>	file:
enumerate	code-library/Graph Theory/Three Edge Connectivity.cpp	/^  vector<int> enumerate(int x) {$/;"	f	struct:Components	typeref:typename:vector<int>	file:
enumerate	code/Graph Theory/Three Edge Connectivity.cpp	/^  vector<int> enumerate(int x) {$/;"	f	struct:Components	typeref:typename:vector<int>	file:
eps	code-library/Geometry/All Pair Segment Intersection.cpp	/^const double eps = 1e-12;$/;"	v	typeref:typename:const double
eps	code-library/Geometry/Geometry 2D.cpp	/^const double eps = 1e-9;$/;"	v	typeref:typename:const double
eps	code-library/Geometry/Geometry 3D.cpp	/^const double eps = 1e-9;$/;"	v	typeref:typename:const double
eps	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^const double eps = 1e-12;$/;"	v	typeref:typename:const double
eps	code-library/Geometry/Half Plane Intersection.cpp	/^const double eps = 1e-12;$/;"	v	typeref:typename:const double
eps	code-library/Geometry/Voronoi Diagram.cpp	/^const double eps = 1e-9;$/;"	v	typeref:typename:const double
eps	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^const double eps = 1e-9;$/;"	v	typeref:typename:const double
eps	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  cost_t eps;$/;"	m	struct:mcSFlow	typeref:typename:cost_t	file:
eps	code-library/Graph Theory/Tuttes Theorem.cpp	/^const double eps = 1e-9;$/;"	v	typeref:typename:const double
eps	code-library/Math/Determinant.cpp	/^const double eps = 1e-9;$/;"	v	typeref:typename:const double
eps	code-library/Math/Gaussian Elimination.cpp	/^const double eps = 1e-9;$/;"	v	typeref:typename:const double
eps	code-library/Math/Integration (Romberg).cpp	/^const double eps = 1e-6;$/;"	v	typeref:typename:const double
eps	code-library/Math/Integration (Simpsons).cpp	/^const double eps = 1e-6;$/;"	v	typeref:typename:const double
eps	code-library/Math/Simplex Algorithm.cpp	/^const ld eps=1e-9;$/;"	v	typeref:typename:const ld
eps	code/Geometry/All Pair Segment Intersection.cpp	/^const double eps = 1e-12;$/;"	v	typeref:typename:const double
eps	code/Geometry/Geometry 2D.cpp	/^const double eps = 1e-9;$/;"	v	typeref:typename:const double
eps	code/Geometry/Geometry 3D.cpp	/^const double eps = 1e-9;$/;"	v	typeref:typename:const double
eps	code/Geometry/Half Plane Intersection Dynamic.cpp	/^const double eps = 1e-12;$/;"	v	typeref:typename:const double
eps	code/Geometry/Half Plane Intersection.cpp	/^const double eps = 1e-12;$/;"	v	typeref:typename:const double
eps	code/Geometry/Voronoi Diagram.cpp	/^const double eps = 1e-9;$/;"	v	typeref:typename:const double
eps	code/Graph Theory/Maximum Density Subgraph.cpp	/^const double eps = 1e-9;$/;"	v	typeref:typename:const double
eps	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  cost_t eps;$/;"	m	struct:mcSFlow	typeref:typename:cost_t	file:
eps	code/Graph Theory/Tuttes Theorem.cpp	/^const double eps = 1e-9;$/;"	v	typeref:typename:const double
eps	code/Math/Determinant.cpp	/^const double eps = 1e-9;$/;"	v	typeref:typename:const double
eps	code/Math/Gaussian Elimination.cpp	/^const double eps = 1e-9;$/;"	v	typeref:typename:const double
eps	code/Math/Integration (Romberg).cpp	/^const double eps = 1e-6;$/;"	v	typeref:typename:const double
eps	code/Math/Integration (Simpsons).cpp	/^const double eps = 1e-6;$/;"	v	typeref:typename:const double
eps	code/Math/Simplex Algorithm.cpp	/^const ld eps=1e-9;$/;"	v	typeref:typename:const ld
eq	code-library/Geometry/Point Location.cpp	/^bool eq(const ll& a, const ll& b) { return a == b; }$/;"	f	typeref:typename:bool
eq	code/Geometry/Point Location.cpp	/^bool eq(const ll& a, const ll& b) { return a == b; }$/;"	f	typeref:typename:bool
erase	code-library/Data Structures/Implicit Treap.cpp	/^  void erase(int qL, int qR) {$/;"	f	struct:treap	typeref:typename:void	file:
erase	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^void erase(int i) {$/;"	f	typeref:typename:void
erase	code-library/Data Structures/Treap persistent.cpp	/^node* erase(node* t, int L, int R) {$/;"	f	namespace:PersistentTreap	typeref:typename:node *
erase	code-library/Data Structures/Treap.cpp	/^  node* erase(int L, int R) {$/;"	f	struct:treap	typeref:typename:node *	file:
erase	code-library/Geometry/Onion Decomposition.cpp	/^    int erase(int w, int L, int R) {$/;"	f	struct:LeftHull	typeref:typename:int	file:
erase	code-library/Geometry/Onion Decomposition.cpp	/^    void erase(int L) {$/;"	f	struct:LeftHull	typeref:typename:void	file:
erase	code/Data Structures/Implicit Treap.cpp	/^  void erase(int qL, int qR) {$/;"	f	struct:treap	typeref:typename:void	file:
erase	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^void erase(int i) {$/;"	f	typeref:typename:void
erase	code/Data Structures/Treap persistent.cpp	/^node* erase(node* t, int L, int R) {$/;"	f	namespace:PersistentTreap	typeref:typename:node *
erase	code/Data Structures/Treap.cpp	/^  node* erase(int L, int R) {$/;"	f	struct:treap	typeref:typename:node *	file:
erase	code/Geometry/Onion Decomposition.cpp	/^    int erase(int w, int L, int R) {$/;"	f	struct:LeftHull	typeref:typename:int	file:
erase	code/Geometry/Onion Decomposition.cpp	/^    void erase(int L) {$/;"	f	struct:LeftHull	typeref:typename:void	file:
erase_edge	practice/cf/random/1700/4.cpp	/^void erase_edge() {$/;"	f	typeref:typename:void
eval	code-library/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  ll eval(ll x) {$/;"	f	struct:Line	typeref:typename:ll	file:
eval	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  ll eval(ll x) {$/;"	f	struct:Line	typeref:typename:ll	file:
eval	code-library/Math/Faulhaber Formula Fastest.cpp	/^  mint eval(mint x) { \/\/ evaluates in single point x$/;"	f	struct:poly	typeref:typename:mint	file:
eval	code-library/Math/Finite Field Arithmetic Binary.cpp	/^int eval(string s) {$/;"	f	typeref:typename:int
eval	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^mint eval(poly a, mint x) {$/;"	f	typeref:typename:mint
eval	code-library/Math/Polynomial.cpp	/^  mint eval(mint x) { \/\/ evaluates in single point x$/;"	f	struct:poly	typeref:typename:mint	file:
eval	code-library/Math/Polynomial.cpp	/^  vector<mint> eval(vector<mint> x) {\/\/ evaluate polynomial in (x_0, ..., x_n-1)$/;"	f	struct:poly	typeref:typename:vector<mint>	file:
eval	code-library/Math/Polynomial.cpp	/^  vector<mint> eval(vector<poly> &tree, int v, int l, int r, vector<mint> &vec) { \/\/ auxiliary/;"	f	struct:poly	typeref:typename:vector<mint>	file:
eval	code-library/Number Theory/Min_25 Sieve.cpp	/^inline T eval(int p, int k, ll pw) { \/\/ pw = p^k, pw <= n$/;"	f	typeref:typename:T
eval	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^mint eval(poly a, mint x) {$/;"	f	typeref:typename:mint
eval	code/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  ll eval(ll x) {$/;"	f	struct:Line	typeref:typename:ll	file:
eval	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  ll eval(ll x) {$/;"	f	struct:Line	typeref:typename:ll	file:
eval	code/Math/Faulhaber Formula Fastest.cpp	/^  mint eval(mint x) { \/\/ evaluates in single point x$/;"	f	struct:poly	typeref:typename:mint	file:
eval	code/Math/Finite Field Arithmetic Binary.cpp	/^int eval(string s) {$/;"	f	typeref:typename:int
eval	code/Math/Number of Solutions of A Equation MITM.cpp	/^mint eval(poly a, mint x) {$/;"	f	typeref:typename:mint
eval	code/Math/Polynomial.cpp	/^  mint eval(mint x) { \/\/ evaluates in single point x$/;"	f	struct:poly	typeref:typename:mint	file:
eval	code/Math/Polynomial.cpp	/^  vector<mint> eval(vector<mint> x) {\/\/ evaluate polynomial in (x_0, ..., x_n-1)$/;"	f	struct:poly	typeref:typename:vector<mint>	file:
eval	code/Math/Polynomial.cpp	/^  vector<mint> eval(vector<poly> &tree, int v, int l, int r, vector<mint> &vec) { \/\/ auxiliary/;"	f	struct:poly	typeref:typename:vector<mint>	file:
eval	code/Number Theory/Min_25 Sieve.cpp	/^inline T eval(int p, int k, ll pw) { \/\/ pw = p^k, pw <= n$/;"	f	typeref:typename:T
eval	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^mint eval(poly a, mint x) {$/;"	f	typeref:typename:mint
eval_y	code-library/Geometry/All Pair Segment Intersection.cpp	/^    double eval_y(double x) const {$/;"	f	struct:seg	typeref:typename:double	file:
eval_y	code/Geometry/All Pair Segment Intersection.cpp	/^    double eval_y(double x) const {$/;"	f	struct:seg	typeref:typename:double	file:
evaluate	code-library/Miscellaneous/Expression Parsing.cpp	/^int evaluate(string s) {$/;"	f	typeref:typename:int
evaluate	code/Miscellaneous/Expression Parsing.cpp	/^int evaluate(string s) {$/;"	f	typeref:typename:int
even	code-library/Strings/Number of Palindromes in Range.cpp	/^int even(int l, int r) {$/;"	f	typeref:typename:int
even	code/Strings/Number of Palindromes in Range.cpp	/^int even(int l, int r) {$/;"	f	typeref:typename:int
evenl	code-library/Strings/Number of Palindromes in Range.cpp	/^wavelet_tree evenl, evenr;$/;"	v	typeref:typename:wavelet_tree
evenl	code/Strings/Number of Palindromes in Range.cpp	/^wavelet_tree evenl, evenr;$/;"	v	typeref:typename:wavelet_tree
evenr	code-library/Strings/Number of Palindromes in Range.cpp	/^wavelet_tree evenl, evenr;$/;"	v	typeref:typename:wavelet_tree
evenr	code/Strings/Number of Palindromes in Range.cpp	/^wavelet_tree evenl, evenr;$/;"	v	typeref:typename:wavelet_tree
event	code-library/Geometry/All Pair Segment Intersection.cpp	/^    event() {}$/;"	f	struct:event	file:
event	code-library/Geometry/All Pair Segment Intersection.cpp	/^    event(double x, int ty, int id) : x(x), ty(ty), id(id) {}$/;"	f	struct:event	file:
event	code-library/Geometry/All Pair Segment Intersection.cpp	/^struct event {$/;"	s	file:
event	code/Geometry/All Pair Segment Intersection.cpp	/^    event() {}$/;"	f	struct:event	file:
event	code/Geometry/All Pair Segment Intersection.cpp	/^    event(double x, int ty, int id) : x(x), ty(ty), id(id) {}$/;"	f	struct:event	file:
event	code/Geometry/All Pair Segment Intersection.cpp	/^struct event {$/;"	s	file:
ex	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  vector<flow_t> ex;$/;"	m	struct:mcSFlow	typeref:typename:vector<flow_t>	file:
ex	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  vector<flow_t> ex;$/;"	m	struct:mcSFlow	typeref:typename:vector<flow_t>	file:
ex	practice/usacoguide/gold/bfs/monsters.cpp	/^pair<int, int> ex;$/;"	v	typeref:typename:pair<int,int>
exgcd	code-library/Math/Reeds Sloane Algorithm.cpp	/^  static void exgcd(ll a, ll b, ll &g, ll &x, ll &y) {$/;"	f	struct:LinearRecurrence	typeref:typename:void	file:
exgcd	code/Math/Reeds Sloane Algorithm.cpp	/^  static void exgcd(ll a, ll b, ll &g, ll &x, ll &y) {$/;"	f	struct:LinearRecurrence	typeref:typename:void	file:
exist	code-library/Data Structures/Implicit Treap.cpp	/^  bool exist;$/;"	m	struct:treap	typeref:typename:bool	file:
exist	code/Data Structures/Implicit Treap.cpp	/^  bool exist;$/;"	m	struct:treap	typeref:typename:bool	file:
exp	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly exp(int n) const { \/\/e ^ p(x) mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
exp	code-library/Math/Polynomial.cpp	/^  poly exp(int n) const { \/\/e ^ p(x) mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
exp	code-library/Math/Subset Sum Problem.cpp	/^  poly exp(int n) const { \/\/e ^ p(x) mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
exp	code-library/Number Theory/Bell Number.cpp	/^  poly exp(int n) const { \/\/e ^ p(x) mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
exp	code/Math/Faulhaber Formula Fastest.cpp	/^  poly exp(int n) const { \/\/e ^ p(x) mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
exp	code/Math/Polynomial.cpp	/^  poly exp(int n) const { \/\/e ^ p(x) mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
exp	code/Math/Subset Sum Problem.cpp	/^  poly exp(int n) const { \/\/e ^ p(x) mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
exp	code/Number Theory/Bell Number.cpp	/^  poly exp(int n) const { \/\/e ^ p(x) mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
expand	init.lua	/^    expand = function(args)$/;"	f
expand_blossom	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  inline void expand_blossom(int b) { \/\/ S[b] == 1$/;"	f	struct:Blossom	typeref:typename:void	file:
expand_blossom	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  inline void expand_blossom(int b) { \/\/ S[b] == 1$/;"	f	struct:Blossom	typeref:typename:void	file:
expose	code-library/Data Structures/Top Tree.cpp	/^  top_tree_node* expose() {$/;"	f	struct:top_tree_node	typeref:typename:top_tree_node *	file:
expose	code/Data Structures/Top Tree.cpp	/^  top_tree_node* expose() {$/;"	f	struct:top_tree_node	typeref:typename:top_tree_node *	file:
extend	code-library/Math/Reeds Sloane Algorithm.cpp	/^  static void extend(vec &a, size_t d, ll value = 0) {$/;"	f	struct:LinearRecurrence	typeref:typename:void	file:
extend	code-library/Strings/Palindromic Tree Persistent.cpp	/^  int extend(char c) {$/;"	f	struct:PalindromicTree	typeref:typename:int	file:
extend	code-library/Strings/Palindromic Tree.cpp	/^  int extend(int pos) { \/\/ returns 1 if it creates a new palindrome$/;"	f	struct:PalindromicTree	typeref:typename:int	file:
extend	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  void extend(char c) {$/;"	f	struct:SuffixAutomaton	typeref:typename:void	file:
extend	code-library/Strings/Suffix Automaton.cpp	/^    void extend(char c) {$/;"	f	struct:SuffixAutomaton	typeref:typename:void	file:
extend	code/Math/Reeds Sloane Algorithm.cpp	/^  static void extend(vec &a, size_t d, ll value = 0) {$/;"	f	struct:LinearRecurrence	typeref:typename:void	file:
extend	code/Strings/Palindromic Tree Persistent.cpp	/^  int extend(char c) {$/;"	f	struct:PalindromicTree	typeref:typename:int	file:
extend	code/Strings/Palindromic Tree.cpp	/^  int extend(int pos) { \/\/ returns 1 if it creates a new palindrome$/;"	f	struct:PalindromicTree	typeref:typename:int	file:
extend	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  void extend(char c) {$/;"	f	struct:SuffixAutomaton	typeref:typename:void	file:
extend	code/Strings/Suffix Automaton.cpp	/^    void extend(char c) {$/;"	f	struct:SuffixAutomaton	typeref:typename:void	file:
extended	code-library/Math/Linear Recurrence With Polynomial Coefficients.cpp	/^vector<int> extended(int n,$/;"	f	typeref:typename:vector<int>
extended	code/Math/Linear Recurrence With Polynomial Coefficients.cpp	/^vector<int> extended(int n,$/;"	f	typeref:typename:vector<int>
extended_euclid	code-library/Number Theory/CRT.cpp	/^T extended_euclid(T a, T b, T &x, T &y) {$/;"	f	typeref:typename:T
extended_euclid	code-library/Number Theory/Discrete Log.cpp	/^ll extended_euclid(ll a, ll b, ll &x, ll &y) {$/;"	f	typeref:typename:ll
extended_euclid	code-library/Number Theory/Extended Euclid.cpp	/^ll extended_euclid(ll a, ll b, ll &x, ll &y) {$/;"	f	typeref:typename:ll
extended_euclid	code-library/Number Theory/Intersection of Arithmetic Progressions.cpp	/^T extended_euclid(T a, T b, T &x, T &y) {$/;"	f	typeref:typename:T
extended_euclid	code-library/Number Theory/Linear Congruence Equation.cpp	/^ll extended_euclid(ll a, ll b, ll &x, ll &y) {$/;"	f	typeref:typename:ll
extended_euclid	code-library/Number Theory/Linear Diophantine Equation Three Variables with Nonnegative Solutions.cpp	/^T extended_euclid(T a, T b, T &x, T &y) {$/;"	f	typeref:typename:T
extended_euclid	code-library/Number Theory/Linear Diophantine Equation with Two Variables.cpp	/^ll extended_euclid(ll a, ll b, ll &x, ll &y) {$/;"	f	typeref:typename:ll
extended_euclid	code-library/Number Theory/Linear Diophantine With N Unknowns and Two Equations.cpp	/^ll extended_euclid(ll a, ll b, ll& x, ll& y) {$/;"	f	typeref:typename:ll
extended_euclid	code-library/Number Theory/Smallest Nonnegative Integer x s.t. l <= ax % p <= r.cpp	/^T extended_euclid(T a, T b, T &x, T &y) {$/;"	f	typeref:typename:T
extended_euclid	code-library/Number Theory/nCr Modulo Any Mod.cpp	/^ll extended_euclid(ll a, ll b, ll &x, ll &y) {$/;"	f	typeref:typename:ll
extended_euclid	code/Number Theory/CRT.cpp	/^T extended_euclid(T a, T b, T &x, T &y) {$/;"	f	typeref:typename:T
extended_euclid	code/Number Theory/Discrete Log.cpp	/^ll extended_euclid(ll a, ll b, ll &x, ll &y) {$/;"	f	typeref:typename:ll
extended_euclid	code/Number Theory/Extended Euclid.cpp	/^ll extended_euclid(ll a, ll b, ll &x, ll &y) {$/;"	f	typeref:typename:ll
extended_euclid	code/Number Theory/Intersection of Arithmetic Progressions.cpp	/^T extended_euclid(T a, T b, T &x, T &y) {$/;"	f	typeref:typename:T
extended_euclid	code/Number Theory/Linear Congruence Equation.cpp	/^ll extended_euclid(ll a, ll b, ll &x, ll &y) {$/;"	f	typeref:typename:ll
extended_euclid	code/Number Theory/Linear Diophantine Equation Three Variables with Nonnegative Solutions.cpp	/^T extended_euclid(T a, T b, T &x, T &y) {$/;"	f	typeref:typename:T
extended_euclid	code/Number Theory/Linear Diophantine Equation with Two Variables.cpp	/^ll extended_euclid(ll a, ll b, ll &x, ll &y) {$/;"	f	typeref:typename:ll
extended_euclid	code/Number Theory/Linear Diophantine With N Unknowns and Two Equations.cpp	/^ll extended_euclid(ll a, ll b, ll& x, ll& y) {$/;"	f	typeref:typename:ll
extended_euclid	code/Number Theory/Smallest Nonnegative Integer x s.t. l <= ax % p <= r.cpp	/^T extended_euclid(T a, T b, T &x, T &y) {$/;"	f	typeref:typename:T
extended_euclid	code/Number Theory/nCr Modulo Any Mod.cpp	/^ll extended_euclid(ll a, ll b, ll &x, ll &y) {$/;"	f	typeref:typename:ll
extra	code-library/Miscellaneous/Bitset Custom.cpp	/^    const static int sz = (S + 63) \/ 64, extra = 64 - sz * 64 + S;$/;"	m	struct:Bitset	typeref:typename:const int	file:
extra	code/Miscellaneous/Bitset Custom.cpp	/^    const static int sz = (S + 63) \/ 64, extra = 64 - sz * 64 + S;$/;"	m	struct:Bitset	typeref:typename:const int	file:
extract	code-library/Math/Polynomial with Binomial Coefficients.cpp	/^vector<int> extract(vector<int> &p) {$/;"	f	typeref:typename:vector<int>
extract	code/Math/Polynomial with Binomial Coefficients.cpp	/^vector<int> extract(vector<int> &p) {$/;"	f	typeref:typename:vector<int>
extreme_vertex	code-library/Geometry/Geometry 2D.cpp	/^int extreme_vertex(vector<PT> &p, const PT &z, const int top) { \/\/ O(log n)$/;"	f	typeref:typename:int
extreme_vertex	code/Geometry/Geometry 2D.cpp	/^int extreme_vertex(vector<PT> &p, const PT &z, const int top) { \/\/ O(log n)$/;"	f	typeref:typename:int
exxit	code-library/Graph Theory/LCA in O(1).cpp	/^  vector<int> enter, depth, exxit;$/;"	m	struct:LCA	typeref:typename:vector<int>	file:
exxit	code/Graph Theory/LCA in O(1).cpp	/^  vector<int> enter, depth, exxit;$/;"	m	struct:LCA	typeref:typename:vector<int>	file:
f	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^mint f[N];$/;"	v	typeref:typename:mint[]
f	code-library/Data Structures/MOs Online.cpp	/^  int cnt[N * 2], f[N * 2];$/;"	m	struct:MEX	typeref:typename:int[]	file:
f	code-library/Data Structures/MOs with Update.cpp	/^int cnt[N], f[N], ans[N], l, r, t;$/;"	v	typeref:typename:int[]
f	code-library/Dynamic Programming Optimizations/1D1D DP.cpp	/^int n, s, t[N], f[N];$/;"	v	typeref:typename:int[]
f	code-library/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^  ll f(int i, ll x) {$/;"	f	struct:CHT	typeref:typename:ll	file:
f	code-library/Geometry/Maximum Area of Triangle, Given are Lengths.cpp	/^bitset<N> f;$/;"	v	typeref:typename:bitset<N>
f	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  F f;      \/\/ current flow$/;"	m	struct:S	typeref:typename:F	file:
f	code-library/Graph Theory/Kirchoffs Theorem.cpp	/^int f;$/;"	v	typeref:typename:int
f	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^    flow_t f;$/;"	m	struct:mcSFlow::Edge	typeref:typename:flow_t	file:
f	code-library/Math/Integration (Romberg).cpp	/^double f(double x) {$/;"	f	typeref:typename:double
f	code-library/Math/Integration (Simpsons).cpp	/^double f(double x) {$/;"	f	typeref:typename:double
f	code-library/Math/NTT Online.cpp	/^int f[N],inv[N],finv[N];$/;"	v	typeref:typename:int[]
f	code-library/Math/NTT.cpp	/^int f(int n, int k) {$/;"	f	typeref:typename:int
f	code-library/Math/Polynomial Sum.cpp	/^mint f(int i) { \/\/ f(i)$/;"	f	typeref:typename:mint
f	code-library/Math/Polynomial with Binomial Coefficients.cpp	/^int f[N],inv[N],finv[N];$/;"	v	typeref:typename:int[]
f	code-library/Miscellaneous/Fraction Binary Search.cpp	/^bool f(frac x) {$/;"	f	typeref:typename:bool
f	code-library/Miscellaneous/MEX of all Subarrays.cpp	/^int a[N], f[N];$/;"	v	typeref:typename:int[]
f	code-library/Number Theory/K Divisors.cpp	/^  bitset <MAXN> f;$/;"	v	namespace:pcf	typeref:typename:bitset<MAXN>
f	code-library/Number Theory/Linear Sieve for Multiplicative Functions.cpp	/^int spf[N], f[N], cnt[N]; \/\/ cnt[i] = power of spf[i] in i$/;"	v	typeref:typename:int[]
f	code-library/Number Theory/Number of Distinct Kth Powers Modulo n.cpp	/^ll f(ll p, ll cnt, ll k) {$/;"	f	typeref:typename:ll
f	code-library/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^int f(int p, int k) {$/;"	f	typeref:typename:int
f	code-library/Number Theory/Prime Counting Function.cpp	/^  bitset <MAXN> f;$/;"	v	namespace:pcf	typeref:typename:bitset<MAXN>
f	code-library/Number Theory/Smallest Nonnegative Integer x s.t. l <= ax % p <= r.cpp	/^long long f(long long p, long long a, long long l, long long r) { $/;"	f	typeref:typename:long long
f	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^mint f[N];$/;"	v	typeref:typename:mint[]
f	code-library/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^int f[N], ifac[N];$/;"	v	typeref:typename:int[]
f	code-library/Strings/All Substring Longest Common Subsequence.cpp	/^int f[N][N], g[N][N];$/;"	v	typeref:typename:int[][]
f	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^mint f[N];$/;"	v	typeref:typename:mint[]
f	code/Data Structures/MOs Online.cpp	/^  int cnt[N * 2], f[N * 2];$/;"	m	struct:MEX	typeref:typename:int[]	file:
f	code/Data Structures/MOs with Update.cpp	/^int cnt[N], f[N], ans[N], l, r, t;$/;"	v	typeref:typename:int[]
f	code/Dynamic Programming Optimizations/1D1D DP.cpp	/^int n, s, t[N], f[N];$/;"	v	typeref:typename:int[]
f	code/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^  ll f(int i, ll x) {$/;"	f	struct:CHT	typeref:typename:ll	file:
f	code/Geometry/Maximum Area of Triangle, Given are Lengths.cpp	/^bitset<N> f;$/;"	v	typeref:typename:bitset<N>
f	code/Graph Theory/Gomory Hu Tree.cpp	/^  F f;      \/\/ current flow$/;"	m	struct:S	typeref:typename:F	file:
f	code/Graph Theory/Kirchoffs Theorem.cpp	/^int f;$/;"	v	typeref:typename:int
f	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^    flow_t f;$/;"	m	struct:mcSFlow::Edge	typeref:typename:flow_t	file:
f	code/Math/Integration (Romberg).cpp	/^double f(double x) {$/;"	f	typeref:typename:double
f	code/Math/Integration (Simpsons).cpp	/^double f(double x) {$/;"	f	typeref:typename:double
f	code/Math/NTT Online.cpp	/^int f[N],inv[N],finv[N];$/;"	v	typeref:typename:int[]
f	code/Math/NTT.cpp	/^int f(int n, int k) {$/;"	f	typeref:typename:int
f	code/Math/Polynomial Sum.cpp	/^mint f(int i) { \/\/ f(i)$/;"	f	typeref:typename:mint
f	code/Math/Polynomial with Binomial Coefficients.cpp	/^int f[N],inv[N],finv[N];$/;"	v	typeref:typename:int[]
f	code/Miscellaneous/Fraction Binary Search.cpp	/^bool f(frac x) {$/;"	f	typeref:typename:bool
f	code/Miscellaneous/MEX of all Subarrays.cpp	/^int a[N], f[N];$/;"	v	typeref:typename:int[]
f	code/Number Theory/K Divisors.cpp	/^  bitset <MAXN> f;$/;"	v	namespace:pcf	typeref:typename:bitset<MAXN>
f	code/Number Theory/Linear Sieve for Multiplicative Functions.cpp	/^int spf[N], f[N], cnt[N]; \/\/ cnt[i] = power of spf[i] in i$/;"	v	typeref:typename:int[]
f	code/Number Theory/Number of Distinct Kth Powers Modulo n.cpp	/^ll f(ll p, ll cnt, ll k) {$/;"	f	typeref:typename:ll
f	code/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^int f(int p, int k) {$/;"	f	typeref:typename:int
f	code/Number Theory/Prime Counting Function.cpp	/^  bitset <MAXN> f;$/;"	v	namespace:pcf	typeref:typename:bitset<MAXN>
f	code/Number Theory/Smallest Nonnegative Integer x s.t. l <= ax % p <= r.cpp	/^long long f(long long p, long long a, long long l, long long r) { $/;"	f	typeref:typename:long long
f	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^mint f[N];$/;"	v	typeref:typename:mint[]
f	code/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^int f[N], ifac[N];$/;"	v	typeref:typename:int[]
f	code/Strings/All Substring Longest Common Subsequence.cpp	/^int f[N][N], g[N][N];$/;"	v	typeref:typename:int[][]
f	contests/Codeforces/1560/F1/main1.cpp	/^int f()$/;"	f	typeref:typename:int
f1	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  m32_1 f1[size], g1[size];$/;"	v	namespace:ntt	typeref:typename:m32_1[]
f1	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  m64_1 f1[size], g1[size];$/;"	v	namespace:ntt	typeref:typename:m64_1[]
f1	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  m32_1 f1[size], g1[size];$/;"	v	namespace:ntt	typeref:typename:m32_1[]
f1	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  m64_1 f1[size], g1[size];$/;"	v	namespace:ntt	typeref:typename:m64_1[]
f2	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  m32_2 f2[size], g2[size];$/;"	v	namespace:ntt	typeref:typename:m32_2[]
f2	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  m64_2 f2[size], g2[size];$/;"	v	namespace:ntt	typeref:typename:m64_2[]
f2	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  m32_2 f2[size], g2[size];$/;"	v	namespace:ntt	typeref:typename:m32_2[]
f2	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  m64_2 f2[size], g2[size];$/;"	v	namespace:ntt	typeref:typename:m64_2[]
f3	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  m32_3 f3[size], g3[size];$/;"	v	namespace:ntt	typeref:typename:m32_3[]
f3	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  m32_3 f3[size], g3[size];$/;"	v	namespace:ntt	typeref:typename:m32_3[]
f80	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^using f80 = long double;$/;"	t	typeref:typename:long double	file:
f80	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^using f80 = long double;$/;"	t	typeref:typename:long double	file:
fa	code-library/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^int fa[N], sz[N];$/;"	v	typeref:typename:int[]
fa	code/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^int fa[N], sz[N];$/;"	v	typeref:typename:int[]
face	code-library/Geometry/Geometry 3D.cpp	/^    struct face {$/;"	s	struct:CH3D	file:
face	code-library/Geometry/Point Location.cpp	/^        int face;$/;"	m	struct:DCEL::edge	typeref:typename:int	file:
face	code/Geometry/Geometry 3D.cpp	/^    struct face {$/;"	s	struct:CH3D	file:
face	code/Geometry/Point Location.cpp	/^        int face;$/;"	m	struct:DCEL::edge	typeref:typename:int	file:
fact	code-library/Math/Faulhaber Formula Fastest.cpp	/^  inline mint fact(int n) { return facts[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
fact	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline mint fact(int n) { return facts[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
fact	code-library/Math/NTT.cpp	/^int fact[N], ifact[N];$/;"	v	typeref:typename:int[]
fact	code-library/Math/Polynomial Sum.cpp	/^  inline mint fact(int n) { return facts[n]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
fact	code-library/Number Theory/Combinatorics Basics.cpp	/^  inline mint fact(int n) { return facts[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
fact	code-library/Number Theory/Lucas Theorem.cpp	/^  inline mint fact(int n) { return facts[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
fact	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline mint fact(int n) { return facts[n]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
fact	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline mint fact(int n) { return facts[n]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
fact	code-library/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^int fact[N], ifact[N];$/;"	v	typeref:typename:int[]
fact	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  inline mint fact(int n) { return facts[n]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
fact	code/Math/Faulhaber Formula Fastest.cpp	/^  inline mint fact(int n) { return facts[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
fact	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline mint fact(int n) { return facts[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
fact	code/Math/NTT.cpp	/^int fact[N], ifact[N];$/;"	v	typeref:typename:int[]
fact	code/Math/Polynomial Sum.cpp	/^  inline mint fact(int n) { return facts[n]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
fact	code/Number Theory/Combinatorics Basics.cpp	/^  inline mint fact(int n) { return facts[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
fact	code/Number Theory/Lucas Theorem.cpp	/^  inline mint fact(int n) { return facts[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
fact	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline mint fact(int n) { return facts[n]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
fact	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline mint fact(int n) { return facts[n]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
fact	code/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^int fact[N], ifact[N];$/;"	v	typeref:typename:int[]
fact	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  inline mint fact(int n) { return facts[n]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
fact	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^  inline mint fact(int n) { return facts[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
fact	practice/cf/random/i_hate_math_problems/testing.cpp	/^  inline mint fact(int n) { return facts[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
factmod	code-library/Number Theory/nCr Modulo Any Mod.cpp	/^int factmod(ll n, int p, const int mod) {$/;"	f	typeref:typename:int
factmod	code/Number Theory/nCr Modulo Any Mod.cpp	/^int factmod(ll n, int p, const int mod) {$/;"	f	typeref:typename:int
factor	code-library/Number Theory/Prime Factorization Fastest.cpp	/^vector<T> factor(T n) {$/;"	f	typeref:typename:vector<T>
factor	code/Number Theory/Prime Factorization Fastest.cpp	/^vector<T> factor(T n) {$/;"	f	typeref:typename:vector<T>
factoradic_order	code-library/Number Theory/Factoradic Number System.cpp	/^vector<int> factoradic_order(vector<int> p) {$/;"	f	typeref:typename:vector<int>
factoradic_order	code/Number Theory/Factoradic Number System.cpp	/^vector<int> factoradic_order(vector<int> p) {$/;"	f	typeref:typename:vector<int>
factoradic_to_decimal	code-library/Number Theory/Factoradic Number System.cpp	/^int factoradic_to_decimal(vector<int> v) {$/;"	f	typeref:typename:int
factoradic_to_decimal	code/Number Theory/Factoradic Number System.cpp	/^int factoradic_to_decimal(vector<int> v) {$/;"	f	typeref:typename:int
factorize	code-library/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^  vector<ll> factorize(ll n) {$/;"	f	namespace:PollardRho	typeref:typename:vector<ll>
factorize	code-library/Number Theory/Pisano Period.cpp	/^  vector<ll> factorize(ll n) {$/;"	f	namespace:PollardRho	typeref:typename:vector<ll>
factorize	code-library/Number Theory/Pollard Rho.cpp	/^  vector<ll> factorize(ll n) {$/;"	f	namespace:PollardRho	typeref:typename:vector<ll>
factorize	code/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^  vector<ll> factorize(ll n) {$/;"	f	namespace:PollardRho	typeref:typename:vector<ll>
factorize	code/Number Theory/Pisano Period.cpp	/^  vector<ll> factorize(ll n) {$/;"	f	namespace:PollardRho	typeref:typename:vector<ll>
factorize	code/Number Theory/Pollard Rho.cpp	/^  vector<ll> factorize(ll n) {$/;"	f	namespace:PollardRho	typeref:typename:vector<ll>
facts	code-library/Math/Faulhaber Formula Fastest.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
facts	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
facts	code-library/Math/Polynomial Sum.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:vector<mint>	file:
facts	code-library/Number Theory/Combinatorics Basics.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
facts	code-library/Number Theory/Lucas Theorem.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
facts	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:vector<mint>	file:
facts	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:vector<mint>	file:
facts	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:vector<mint>	file:
facts	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static vector<R> invs, facts, ifacts;$/;"	m	class:poly	typeref:typename:vector<R>	file:
facts	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^vector<R> poly::invs, poly::facts, poly::ifacts;$/;"	m	class:poly	typeref:typename:vector<R>
facts	code/Math/Faulhaber Formula Fastest.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
facts	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
facts	code/Math/Polynomial Sum.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:vector<mint>	file:
facts	code/Number Theory/Combinatorics Basics.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
facts	code/Number Theory/Lucas Theorem.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
facts	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:vector<mint>	file:
facts	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:vector<mint>	file:
facts	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:vector<mint>	file:
facts	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static vector<R> invs, facts, ifacts;$/;"	m	class:poly	typeref:typename:vector<R>	file:
facts	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^vector<R> poly::invs, poly::facts, poly::ifacts;$/;"	m	class:poly	typeref:typename:vector<R>
facts	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
facts	practice/cf/random/i_hate_math_problems/testing.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
falling	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^poly falling(long long n, int k) {$/;"	f	typeref:typename:poly
falling	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^poly falling(long long n, int k) {$/;"	f	typeref:typename:poly
falling	code/Math/Number of Solutions of A Equation MITM.cpp	/^poly falling(long long n, int k) {$/;"	f	typeref:typename:poly
falling	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^poly falling(long long n, int k) {$/;"	f	typeref:typename:poly
far	code-library/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^ll ed, far, global = LLONG_MAX, dist[N];$/;"	v	typeref:typename:ll
far	code/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^ll ed, far, global = LLONG_MAX, dist[N];$/;"	v	typeref:typename:ll
fast_div	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^    fast_div() {}$/;"	f	struct:poly::fast_div	file:
fast_div	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^    fast_div(u32 n) : m(n) {}$/;"	f	struct:poly::fast_div	file:
fast_div	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^    fast_div(u64 n) : m(n) {$/;"	f	struct:poly::fast_div	file:
fast_div	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  struct fast_div {$/;"	s	class:poly	file:
fast_div	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^    fast_div() {}$/;"	f	struct:poly::fast_div	file:
fast_div	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^    fast_div(u32 n) : m(n) {}$/;"	f	struct:poly::fast_div	file:
fast_div	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^    fast_div(u64 n) : m(n) {$/;"	f	struct:poly::fast_div	file:
fast_div	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  struct fast_div {$/;"	s	class:poly	file:
fast_mod	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static fast_div fast_mod;$/;"	m	class:poly	typeref:typename:fast_div	file:
fast_mod	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^poly::fast_div poly::fast_mod;$/;"	m	class:poly	typeref:typename:poly::fast_div
fast_mod	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static fast_div fast_mod;$/;"	m	class:poly	typeref:typename:fast_div	file:
fast_mod	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^poly::fast_div poly::fast_mod;$/;"	m	class:poly	typeref:typename:poly::fast_div
fastio	contests/Codeforces/737/D.cpp	/^void fastio()$/;"	f	typeref:typename:void
fastio	contests/Codeforces/737/E.cpp	/^void fastio()$/;"	f	typeref:typename:void
faulhaber	code-library/Math/Faulhaber Formula Fastest.cpp	/^poly faulhaber(int t, int k) {$/;"	f	typeref:typename:poly
faulhaber	code/Math/Faulhaber Formula Fastest.cpp	/^poly faulhaber(int t, int k) {$/;"	f	typeref:typename:poly
fbo	practice/usacoguide/gold/introDP/711C.cpp	/^#define fbo /;"	d	file:
fdiv	contests/Codeforces/1560/C/main.cpp	/^int fdiv(int a, int b) { return a \/ b - ((a ^ b) < 0 && a % b); }$/;"	f	typeref:typename:int
fdiv	contests/Codeforces/1622/upsolve/C/sol.cpp	/^ll fdiv(ll a, ll b) { return a\/b-((a^b)<0&&a%b); } \/\/ divide a by b rounded down$/;"	f	typeref:typename:ll
fdiv	contests/Codeforces/1623/C/sol.cpp	/^ll fdiv(ll a, ll b) { return a\/b-((a^b)<0&&a%b); } \/\/ divide a by b rounded down$/;"	f	typeref:typename:ll
fdiv	practice/cpbook/ch1/1.4/medium/12157.cpp	/^int fdiv(int a, int b) { return a \/ b - ((a ^ b) < 0 && a % b); }$/;"	f	typeref:typename:int
fdiv	practice/cpbook/ch1/1.4/medium/12643.cpp	/^int fdiv(int a, int b) { return a \/ b - ((a ^ b) < 0 && a % b); }$/;"	f	typeref:typename:int
fdiv	practice/cpbook/ch1/1.4/medium/fastfood.cpp	/^int fdiv(int a, int b) { return a \/ b - ((a ^ b) < 0 && a % b); }$/;"	f	typeref:typename:int
fdiv	practice/cpbook/ch1/1.6/chess/00225/main.cpp	/^int fdiv(int a, int b) { return a \/ b - ((a ^ b) < 0 && a % b); }$/;"	f	typeref:typename:int
fdiv	practice/cpbook/ch1/1.6/chess/00696/main.cpp	/^int fdiv(int a, int b) { return a \/ b - ((a ^ b) < 0 && a % b); }$/;"	f	typeref:typename:int
fdiv	practice/cpbook/ch1/1.6/reallife/medium/00161/main.cpp	/^int fdiv(int a, int b) { return a \/ b - ((a ^ b) < 0 && a % b); }$/;"	f	typeref:typename:int
fdiv	practice/cpbook/ch2/2.2/1D/13181/main.cpp	/^int fdiv(int a, int b) { return a \/ b - ((a ^ b) < 0 && a % b); }$/;"	f	typeref:typename:int
feasible	code-library/Graph Theory/L R Flow with Dinic.cpp	/^  bool feasible(int _s = -1, int _t = -1, int L = -1, int R = -1) {$/;"	f	struct:LR_Flow	typeref:typename:bool	file:
feasible	code/Graph Theory/L R Flow with Dinic.cpp	/^  bool feasible(int _s = -1, int _t = -1, int L = -1, int R = -1) {$/;"	f	struct:LR_Flow	typeref:typename:bool	file:
fft	code-library/Data Structures/Centroid Decomposition.cpp	/^void fft(vector<base> &p, bool inv = 0) {$/;"	f	typeref:typename:void
fft	code-library/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^void fft(vector<base> &p, bool inv = 0) {$/;"	f	typeref:typename:void
fft	code-library/Math/FFT.cpp	/^void fft(vector<base> &p, bool inv = 0) {$/;"	f	typeref:typename:void
fft	code-library/Math/Faulhaber Formula Fastest.cpp	/^void fft(vector<base> &a, int n = -1) {$/;"	f	typeref:typename:void
fft	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^void fft(vector<base> &a, int n = -1) {$/;"	f	typeref:typename:void
fft	code-library/Math/Linear Recurrence Fastest.cpp	/^void fft(vector<base> &a, int n = -1) {$/;"	f	typeref:typename:void
fft	code-library/Math/NTT Online.cpp	/^void fft(vector<base> &a, int n = -1) {$/;"	f	typeref:typename:void
fft	code-library/Math/NTT With Any Prime MOD.cpp	/^void fft(vector<base> &a, int n = -1) {$/;"	f	typeref:typename:void
fft	code-library/Math/Polynomial with Binomial Coefficients.cpp	/^void fft(vector<base> &a, int n = -1) {$/;"	f	typeref:typename:void
fft	code-library/Math/Polynomial.cpp	/^void fft(vector<base> &a, int n = -1) {$/;"	f	typeref:typename:void
fft	code-library/Math/Subset Sum Problem.cpp	/^void fft(vector<base> &a, int n = -1) {$/;"	f	typeref:typename:void
fft	code-library/Miscellaneous/BigInt.cpp	/^  void fft(vector<Cplx>& a, bool invert) const {$/;"	f	struct:BigInt	typeref:typename:void	file:
fft	code-library/Number Theory/Bell Number.cpp	/^void fft(vector<base> &a, int n = -1) {$/;"	f	typeref:typename:void
fft	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^void fft(vector<base> &a, int n = -1) {$/;"	f	typeref:typename:void
fft	code-library/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^void fft(vector<base> &a, int n = -1) {$/;"	f	typeref:typename:void
fft	code-library/Strings/String Matching With FFT.cpp	/^void fft(vector<base> &p, bool inv = 0) {$/;"	f	typeref:typename:void
fft	code/Data Structures/Centroid Decomposition.cpp	/^void fft(vector<base> &p, bool inv = 0) {$/;"	f	typeref:typename:void
fft	code/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^void fft(vector<base> &p, bool inv = 0) {$/;"	f	typeref:typename:void
fft	code/Math/FFT.cpp	/^void fft(vector<base> &p, bool inv = 0) {$/;"	f	typeref:typename:void
fft	code/Math/Faulhaber Formula Fastest.cpp	/^void fft(vector<base> &a, int n = -1) {$/;"	f	typeref:typename:void
fft	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^void fft(vector<base> &a, int n = -1) {$/;"	f	typeref:typename:void
fft	code/Math/Linear Recurrence Fastest.cpp	/^void fft(vector<base> &a, int n = -1) {$/;"	f	typeref:typename:void
fft	code/Math/NTT Online.cpp	/^void fft(vector<base> &a, int n = -1) {$/;"	f	typeref:typename:void
fft	code/Math/NTT With Any Prime MOD.cpp	/^void fft(vector<base> &a, int n = -1) {$/;"	f	typeref:typename:void
fft	code/Math/Polynomial with Binomial Coefficients.cpp	/^void fft(vector<base> &a, int n = -1) {$/;"	f	typeref:typename:void
fft	code/Math/Polynomial.cpp	/^void fft(vector<base> &a, int n = -1) {$/;"	f	typeref:typename:void
fft	code/Math/Subset Sum Problem.cpp	/^void fft(vector<base> &a, int n = -1) {$/;"	f	typeref:typename:void
fft	code/Miscellaneous/BigInt.cpp	/^  void fft(vector<Cplx>& a, bool invert) const {$/;"	f	struct:BigInt	typeref:typename:void	file:
fft	code/Number Theory/Bell Number.cpp	/^void fft(vector<base> &a, int n = -1) {$/;"	f	typeref:typename:void
fft	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^void fft(vector<base> &a, int n = -1) {$/;"	f	typeref:typename:void
fft	code/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^void fft(vector<base> &a, int n = -1) {$/;"	f	typeref:typename:void
fft	code/Strings/String Matching With FFT.cpp	/^void fft(vector<base> &p, bool inv = 0) {$/;"	f	typeref:typename:void
fi	practice/usacoguide/gold/introDP/711C.cpp	/^#defin/;"	d	file:
fib	code-library/Number Theory/Fibonacci Number Faster.cpp	/^int fib(long long n, int mod) {$/;"	f	typeref:typename:int
fib	code-library/Number Theory/LCM of Fibonacci Numbers.cpp	/^int fib(long long n) {$/;"	f	typeref:typename:int
fib	code-library/Number Theory/Phi Field.cpp	/^mint fib(ll n) {$/;"	f	typeref:typename:mint
fib	code-library/Number Theory/Pisano Period.cpp	/^ll fib(ll n, ll mod) {$/;"	f	typeref:typename:ll
fib	code/Number Theory/Fibonacci Number Faster.cpp	/^int fib(long long n, int mod) {$/;"	f	typeref:typename:int
fib	code/Number Theory/LCM of Fibonacci Numbers.cpp	/^int fib(long long n) {$/;"	f	typeref:typename:int
fib	code/Number Theory/Phi Field.cpp	/^mint fib(ll n) {$/;"	f	typeref:typename:mint
fib	code/Number Theory/Pisano Period.cpp	/^ll fib(ll n, ll mod) {$/;"	f	typeref:typename:ll
field	code-library/Number Theory/Phi Field.cpp	/^  field (mint a = 0, mint b = 0) : a(a), b(b) {}$/;"	f	struct:field	file:
field	code-library/Number Theory/Phi Field.cpp	/^struct field { \/\/ a . 1 + b . sqrt(5)$/;"	s	file:
field	code/Number Theory/Phi Field.cpp	/^  field (mint a = 0, mint b = 0) : a(a), b(b) {}$/;"	f	struct:field	file:
field	code/Number Theory/Phi Field.cpp	/^struct field { \/\/ a . 1 + b . sqrt(5)$/;"	s	file:
fileName	practice/usacoguide/gold/SP/dining/problem.json	/^{"name": "Problem 1. Fine Dining", "group": "USACO - USACO 2018 December Contest, Gold", "url": /;"	s	object:input
fileName	practice/usacoguide/gold/SP/dining/problem.json	/^{"name": "Problem 1. Fine Dining", "group": "USACO - USACO 2018 December Contest, Gold", "url": /;"	s	object:output
fileName	practice/usacoguide/gold/SP/visitfj/problem.json	/^{"name": "Problem 1. Why Did the Cow Cross the Road", "group": "USACO - USACO 2017 February Cont/;"	s	object:input
fileName	practice/usacoguide/gold/SP/visitfj/problem.json	/^{"name": "Problem 1. Why Did the Cow Cross the Road", "group": "USACO - USACO 2017 February Cont/;"	s	object:output
fileName	practice/usacoguide/gold/bfs/cownav/problem.json	/^{"name": "Problem 3. Cow Navigation", "group": "USACO - USACO 2017 January Contest, Gold", "url"/;"	s	object:input
fileName	practice/usacoguide/gold/bfs/cownav/problem.json	/^{"name": "Problem 3. Cow Navigation", "group": "USACO - USACO 2017 January Contest, Gold", "url"/;"	s	object:output
fileName	practice/usacoguide/gold/dsu/closing/problem.json	/^{"name": "Problem 2. Closing the Farm", "group": "USACO - USACO 2016 US Open Contest, Gold", "ur/;"	s	object:input
fileName	practice/usacoguide/gold/dsu/closing/problem.json	/^{"name": "Problem 2. Closing the Farm", "group": "USACO - USACO 2016 US Open Contest, Gold", "ur/;"	s	object:output
fileName	practice/usacoguide/gold/dsu/moocast/problem.json	/^{"name": "Problem 1. Moocast", "group": "USACO - USACO 2016 December Contest, Gold", "url": "htt/;"	s	object:input
fileName	practice/usacoguide/gold/dsu/moocast/problem.json	/^{"name": "Problem 1. Moocast", "group": "USACO - USACO 2016 December Contest, Gold", "url": "htt/;"	s	object:output
fileName	practice/usacoguide/gold/dsu/mootube/problem.json	/^{"name": "Problem 1. MooTube", "group": "USACO - USACO 2018 January Contest, Gold", "url": "http/;"	s	object:input
fileName	practice/usacoguide/gold/dsu/mootube/problem.json	/^{"name": "Problem 1. MooTube", "group": "USACO - USACO 2018 January Contest, Gold", "url": "http/;"	s	object:output
fileName	practice/usacoguide/gold/dsu/wormhole/problem.json	/^{"name": "Problem 3. Wormhole Sort", "group": "USACO - USACO 2020 January Contest, Silver", "url/;"	s	object:input
fileName	practice/usacoguide/gold/dsu/wormhole/problem.json	/^{"name": "Problem 3. Wormhole Sort", "group": "USACO - USACO 2020 January Contest, Silver", "url/;"	s	object:output
find	code-library/Data Structures/Augmented DSU.cpp	/^int find(int x) {$/;"	f	typeref:typename:int
find	code-library/Data Structures/DSU with Rollbacks.cpp	/^  pair<int, int> find(int u) {$/;"	f	struct:DSU	typeref:typename:pair<int,int>	file:
find	code-library/Data Structures/DSU.cpp	/^  int find(int i) {$/;"	f	struct:DSU	typeref:typename:int	file:
find	code-library/Data Structures/Implicit Treap.cpp	/^  bool find(int val) {$/;"	f	struct:treap	typeref:typename:bool	file:
find	code-library/Data Structures/Persistent UnionFind.cpp	/^  int find(int r, int u) {$/;"	f	struct:PersistentDSU	typeref:typename:int	file:
find	code-library/Data Structures/Queue Undo Trick.cpp	/^  pair<int, int> find(int u) {$/;"	f	struct:DSU	typeref:typename:pair<int,int>	file:
find	code-library/Data Structures/Reachability Tree.cpp	/^  int find(int x) {$/;"	f	struct:RT	typeref:typename:int	file:
find	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  bool find(int pos) {$/;"	f	struct:treap	typeref:typename:bool	file:
find	code-library/Graph Theory/Boruvka's Algorithm.cpp	/^  int find(int i) { return (par[i] == i ? i : (par[i] = find(par[i]))); }$/;"	f	struct:dsu	typeref:typename:int	file:
find	code-library/Graph Theory/Dynamic MST.cpp	/^  int find(int x){$/;"	f	struct:disj	typeref:typename:int	file:
find	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  int find(int i) {$/;"	f	struct:dsu	typeref:typename:int	file:
find	code-library/Graph Theory/Kirchoffs Theorem.cpp	/^  int find(int i) {$/;"	f	struct:dsu	typeref:typename:int	file:
find	code-library/Graph Theory/Krushkal's MST.cpp	/^  int find(int i) { return (par[i] == i ? i : (par[i] = find(par[i]))); }$/;"	f	struct:dsu	typeref:typename:int	file:
find	code-library/Graph Theory/Manhattan MST.cpp	/^  int find(int u) { return p[u] == u ? u : p[u] = find(p[u]); }$/;"	f	struct:DSU	typeref:typename:int	file:
find	code/Data Structures/Augmented DSU.cpp	/^int find(int x) {$/;"	f	typeref:typename:int
find	code/Data Structures/DSU with Rollbacks.cpp	/^  pair<int, int> find(int u) {$/;"	f	struct:DSU	typeref:typename:pair<int,int>	file:
find	code/Data Structures/DSU.cpp	/^  int find(int i) {$/;"	f	struct:DSU	typeref:typename:int	file:
find	code/Data Structures/Implicit Treap.cpp	/^  bool find(int val) {$/;"	f	struct:treap	typeref:typename:bool	file:
find	code/Data Structures/Persistent UnionFind.cpp	/^  int find(int r, int u) {$/;"	f	struct:PersistentDSU	typeref:typename:int	file:
find	code/Data Structures/Queue Undo Trick.cpp	/^  pair<int, int> find(int u) {$/;"	f	struct:DSU	typeref:typename:pair<int,int>	file:
find	code/Data Structures/Reachability Tree.cpp	/^  int find(int x) {$/;"	f	struct:RT	typeref:typename:int	file:
find	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  bool find(int pos) {$/;"	f	struct:treap	typeref:typename:bool	file:
find	code/Graph Theory/Boruvka's Algorithm.cpp	/^  int find(int i) { return (par[i] == i ? i : (par[i] = find(par[i]))); }$/;"	f	struct:dsu	typeref:typename:int	file:
find	code/Graph Theory/Dynamic MST.cpp	/^  int find(int x){$/;"	f	struct:disj	typeref:typename:int	file:
find	code/Graph Theory/Gomory Hu Tree.cpp	/^  int find(int i) {$/;"	f	struct:dsu	typeref:typename:int	file:
find	code/Graph Theory/Kirchoffs Theorem.cpp	/^  int find(int i) {$/;"	f	struct:dsu	typeref:typename:int	file:
find	code/Graph Theory/Krushkal's MST.cpp	/^  int find(int i) { return (par[i] == i ? i : (par[i] = find(par[i]))); }$/;"	f	struct:dsu	typeref:typename:int	file:
find	code/Graph Theory/Manhattan MST.cpp	/^  int find(int u) { return p[u] == u ? u : p[u] = find(p[u]); }$/;"	f	struct:DSU	typeref:typename:int	file:
findAugPath	code-library/Graph Theory/Hungarian Algorithm.cpp	/^  void findAugPath() {$/;"	f	struct:Hungarian	typeref:typename:void	file:
findAugPath	code/Graph Theory/Hungarian Algorithm.cpp	/^  void findAugPath() {$/;"	f	struct:Hungarian	typeref:typename:void	file:
findGreater	contests/USACO/dec_silver_2021/C/C_new.cpp	/^int findGreater(vector<int> &nums, int K) {$/;"	f	typeref:typename:int
findLess	contests/USACO/dec_silver_2021/C/C_new.cpp	/^int findLess(vector<int> &nums, int K) {$/;"	f	typeref:typename:int
find_	code-library/Graph Theory/Dominator Tree.cpp	/^int find_(int u, int x = 0) {$/;"	f	typeref:typename:int
find_	code/Graph Theory/Dominator Tree.cpp	/^int find_(int u, int x = 0) {$/;"	f	typeref:typename:int
find_all_solutions	code-library/Number Theory/Linear Diophantine Equation with Two Variables.cpp	/^ll find_all_solutions(ll a, ll b, ll c, ll minx, ll maxx, ll miny,ll maxy) {$/;"	f	typeref:typename:ll
find_all_solutions	code/Number Theory/Linear Diophantine Equation with Two Variables.cpp	/^ll find_all_solutions(ll a, ll b, ll c, ll minx, ll maxx, ll miny,ll maxy) {$/;"	f	typeref:typename:ll
find_any_solution	code-library/Number Theory/Linear Diophantine Equation with Two Variables.cpp	/^bool find_any_solution (ll a, ll b, ll c, ll &x0, ll &y0, ll &g) {$/;"	f	typeref:typename:bool
find_any_solution	code/Number Theory/Linear Diophantine Equation with Two Variables.cpp	/^bool find_any_solution (ll a, ll b, ll c, ll &x0, ll &y0, ll &g) {$/;"	f	typeref:typename:bool
find_cen	code-library/Data Structures/Binarizing a Tree.cpp	/^int find_cen(int u, int p) {$/;"	f	typeref:typename:int
find_cen	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^int find_cen(int u, int p) {$/;"	f	typeref:typename:int
find_cen	code-library/Data Structures/Centroid Decomposition.cpp	/^int find_cen(int u, int p) {$/;"	f	typeref:typename:int
find_cen	code-library/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^int find_cen(int u, int p) {$/;"	f	typeref:typename:int
find_cen	code-library/Graph Theory/Tree Orientation.cpp	/^int find_cen(int u, int p) {$/;"	f	typeref:typename:int
find_cen	code/Data Structures/Binarizing a Tree.cpp	/^int find_cen(int u, int p) {$/;"	f	typeref:typename:int
find_cen	code/Data Structures/Centroid Decomposition Persistent.cpp	/^int find_cen(int u, int p) {$/;"	f	typeref:typename:int
find_cen	code/Data Structures/Centroid Decomposition.cpp	/^int find_cen(int u, int p) {$/;"	f	typeref:typename:int
find_cen	code/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^int find_cen(int u, int p) {$/;"	f	typeref:typename:int
find_cen	code/Graph Theory/Tree Orientation.cpp	/^int find_cen(int u, int p) {$/;"	f	typeref:typename:int
find_closest1	contests/USACO/dec_silver_2021/B/B_new.cpp	/^int find_closest1(int x, set<int> &cur) {$/;"	f	typeref:typename:int
find_dist	practice/cf/random/1700/4.cpp	/^void find_dist() {$/;"	f	typeref:typename:void
find_dists	contests/USACO/dec_silver_2021/B/B.cpp	/^void find_dists(int s, vector<vector<int>> &adj_list, vector<bool> &vis) {$/;"	f	typeref:typename:void
find_edge	practice/cf/random/1700/4.cpp	/^void find_edge(int s, int prev = -1) {$/;"	f	typeref:typename:void
find_occurrence	code-library/Strings/Suffix Array Isomorphic.cpp	/^  pair<int, int> find_occurrence(int p, int len) {$/;"	f	struct:IsomorphicSuffixArray	typeref:typename:pair<int,int>	file:
find_occurrence	code-library/Strings/Suffix Array.cpp	/^  pair<int, int> find_occurrence(int p, int len) {$/;"	f	struct:SuffixArray	typeref:typename:pair<int,int>	file:
find_occurrence	code/Strings/Suffix Array Isomorphic.cpp	/^  pair<int, int> find_occurrence(int p, int len) {$/;"	f	struct:IsomorphicSuffixArray	typeref:typename:pair<int,int>	file:
find_occurrence	code/Strings/Suffix Array.cpp	/^  pair<int, int> find_occurrence(int p, int len) {$/;"	f	struct:SuffixArray	typeref:typename:pair<int,int>	file:
find_recurrence_relation	code-library/Math/Linear Recurrence With Polynomial Coefficients.cpp	/^vector< vector<int> > find_recurrence_relation($/;"	f	typeref:typename:vector<vector<int>>
find_recurrence_relation	code/Math/Linear Recurrence With Polynomial Coefficients.cpp	/^vector< vector<int> > find_recurrence_relation($/;"	f	typeref:typename:vector<vector<int>>
find_root	code-library/Data Structures/Link Cut Tree.cpp	/^  int find_root(int u) {$/;"	f	struct:LCT	typeref:typename:int	file:
find_root	code/Data Structures/Link Cut Tree.cpp	/^  int find_root(int u) {$/;"	f	struct:LCT	typeref:typename:int	file:
find_slope	practice/usacoguide/gold/divisibility/dilucandkaeya.cpp	/^pair<int, int> find_slope(int a, int b) {$/;"	f	typeref:typename:pair<int,int>
finish	code-library/Graph Theory/Hungarian Algorithm.cpp	/^  int start, finish, n;$/;"	m	struct:Hungarian	typeref:typename:int	file:
finish	code/Graph Theory/Hungarian Algorithm.cpp	/^  int start, finish, n;$/;"	m	struct:Hungarian	typeref:typename:int	file:
finish	practice/usacoguide/gold/bfs/mecho/main.cpp	/^pair<int, int> start, finish;$/;"	v	typeref:typename:pair<int,int>
finish	practice/usacoguide/gold/bfs/mechonew/main.cpp	/^pair<int, int> start, finish;$/;"	v	typeref:typename:pair<int,int>
finv	code-library/Math/Faulhaber Formula Fastest.cpp	/^  inline mint finv(int n) { return finvs[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
finv	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline mint finv(int n) { return finvs[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
finv	code-library/Math/NTT Online.cpp	/^int f[N],inv[N],finv[N];$/;"	v	typeref:typename:int[]
finv	code-library/Math/Polynomial Sum.cpp	/^  inline mint finv(int n) { return finvs[n]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
finv	code-library/Math/Polynomial with Binomial Coefficients.cpp	/^int f[N],inv[N],finv[N];$/;"	v	typeref:typename:int[]
finv	code-library/Number Theory/Combinatorics Basics.cpp	/^  inline mint finv(int n) { return finvs[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
finv	code-library/Number Theory/Lucas Theorem.cpp	/^  inline mint finv(int n) { return finvs[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
finv	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline mint finv(int n) { return finvs[n]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
finv	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline mint finv(int n) { return finvs[n]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
finv	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  inline mint finv(int n) { return finvs[n]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
finv	code/Math/Faulhaber Formula Fastest.cpp	/^  inline mint finv(int n) { return finvs[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
finv	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline mint finv(int n) { return finvs[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
finv	code/Math/NTT Online.cpp	/^int f[N],inv[N],finv[N];$/;"	v	typeref:typename:int[]
finv	code/Math/Polynomial Sum.cpp	/^  inline mint finv(int n) { return finvs[n]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
finv	code/Math/Polynomial with Binomial Coefficients.cpp	/^int f[N],inv[N],finv[N];$/;"	v	typeref:typename:int[]
finv	code/Number Theory/Combinatorics Basics.cpp	/^  inline mint finv(int n) { return finvs[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
finv	code/Number Theory/Lucas Theorem.cpp	/^  inline mint finv(int n) { return finvs[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
finv	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline mint finv(int n) { return finvs[n]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
finv	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline mint finv(int n) { return finvs[n]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
finv	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  inline mint finv(int n) { return finvs[n]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
finv	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^  inline mint finv(int n) { return finvs[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
finv	practice/cf/random/i_hate_math_problems/testing.cpp	/^  inline mint finv(int n) { return finvs[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
finvs	code-library/Math/Faulhaber Formula Fastest.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
finvs	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
finvs	code-library/Math/Polynomial Sum.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:vector<mint>	file:
finvs	code-library/Number Theory/Combinatorics Basics.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
finvs	code-library/Number Theory/Lucas Theorem.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
finvs	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:vector<mint>	file:
finvs	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:vector<mint>	file:
finvs	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:vector<mint>	file:
finvs	code/Math/Faulhaber Formula Fastest.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
finvs	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
finvs	code/Math/Polynomial Sum.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:vector<mint>	file:
finvs	code/Number Theory/Combinatorics Basics.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
finvs	code/Number Theory/Lucas Theorem.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
finvs	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:vector<mint>	file:
finvs	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:vector<mint>	file:
finvs	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:vector<mint>	file:
finvs	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
finvs	practice/cf/random/i_hate_math_problems/testing.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
first	practice/usacoguide/gold/bfs/cownav.cpp	/^	int first, second, direction;$/;"	m	struct:Point	typeref:typename:int	file:
firstpos	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  int len, link, firstpos;$/;"	m	struct:node	typeref:typename:int	file:
firstpos	code-library/Strings/Suffix Automaton.cpp	/^        int len, link, firstpos;$/;"	m	struct:SuffixAutomaton::node	typeref:typename:int	file:
firstpos	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  int len, link, firstpos;$/;"	m	struct:node	typeref:typename:int	file:
firstpos	code/Strings/Suffix Automaton.cpp	/^        int len, link, firstpos;$/;"	m	struct:SuffixAutomaton::node	typeref:typename:int	file:
fix	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  void fix(int pos) {$/;"	f	struct:ST	typeref:typename:void	file:
fix	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    iter fix(iter it) { return it == end() ? begin() : it; }$/;"	f	struct:HalfPlaneSet	typeref:typename:iter	file:
fix	code-library/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^void fix(vector<int> &ans) {$/;"	f	typeref:typename:void
fix	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  void fix(int pos) {$/;"	f	struct:ST	typeref:typename:void	file:
fix	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    iter fix(iter it) { return it == end() ? begin() : it; }$/;"	f	struct:HalfPlaneSet	typeref:typename:iter	file:
fix	code/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^void fix(vector<int> &ans) {$/;"	f	typeref:typename:void
flag	code-library/Data Structures/DSU with Rollbacks.cpp	/^  bool flag;$/;"	m	struct:DSU	typeref:typename:bool	file:
flag	code-library/Data Structures/Queue Undo Trick.cpp	/^  bool flag;$/;"	m	struct:DSU	typeref:typename:bool	file:
flag	code/Data Structures/DSU with Rollbacks.cpp	/^  bool flag;$/;"	m	struct:DSU	typeref:typename:bool	file:
flag	code/Data Structures/Queue Undo Trick.cpp	/^  bool flag;$/;"	m	struct:DSU	typeref:typename:bool	file:
flaw	code-library/Data Structures/Augmented DSU.cpp	/^int flaw;     \/\/counting numbers of inconsistent assertions$/;"	v	typeref:typename:int
flaw	code/Data Structures/Augmented DSU.cpp	/^int flaw;     \/\/counting numbers of inconsistent assertions$/;"	v	typeref:typename:int
flip	code-library/Data Structures/Link Cut Tree.cpp	/^  bool flip = 0;$/;"	m	struct:node	typeref:typename:bool	file:
flip	code-library/Miscellaneous/Bitset Custom.cpp	/^    void flip(int i) {$/;"	f	struct:Bitset	typeref:typename:void	file:
flip	code-library/Miscellaneous/Bitset Custom.cpp	/^    void flip(int l, int r) {$/;"	f	struct:Bitset	typeref:typename:void	file:
flip	code/Data Structures/Link Cut Tree.cpp	/^  bool flip = 0;$/;"	m	struct:node	typeref:typename:bool	file:
flip	code/Miscellaneous/Bitset Custom.cpp	/^    void flip(int i) {$/;"	f	struct:Bitset	typeref:typename:void	file:
flip	code/Miscellaneous/Bitset Custom.cpp	/^    void flip(int l, int r) {$/;"	f	struct:Bitset	typeref:typename:void	file:
flip_path	code-library/Data Structures/Top Tree.cpp	/^  bool flip_path = false;$/;"	m	struct:top_tree_node	typeref:typename:bool	file:
flip_path	code/Data Structures/Top Tree.cpp	/^  bool flip_path = false;$/;"	m	struct:top_tree_node	typeref:typename:bool	file:
floodfill	practice/cf/random/1700/1618E/main.cpp	/^void floodfill(int r, int c) {$/;"	f	typeref:typename:void
floodfill	practice/usacoguide/silver/idk/maze/main.cpp	/^void floodfill(int r, int c, int hash) {$/;"	f	typeref:typename:void
floor_sum	code-library/Number Theory/Floor Sum of  Arithmetic Progressions.cpp	/^ll floor_sum(ll a, ll d, ll m, ll n) {$/;"	f	typeref:typename:ll
floor_sum	code-library/Number Theory/Linear Diophantine Equation Three Variables with Nonnegative Solutions.cpp	/^T floor_sum(T a, T d, T m, T n) {$/;"	f	typeref:typename:T
floor_sum	code-library/Number Theory/Sum of Arithmetic Progression Modular and Divided.cpp	/^long long floor_sum(long long a, long long d, long long m, long long n) {$/;"	f	typeref:typename:long long
floor_sum	code-library/Number Theory/Sum of Floors.cpp	/^ll floor_sum(ll n) {$/;"	f	typeref:typename:ll
floor_sum	code/Number Theory/Floor Sum of  Arithmetic Progressions.cpp	/^ll floor_sum(ll a, ll d, ll m, ll n) {$/;"	f	typeref:typename:ll
floor_sum	code/Number Theory/Linear Diophantine Equation Three Variables with Nonnegative Solutions.cpp	/^T floor_sum(T a, T d, T m, T n) {$/;"	f	typeref:typename:T
floor_sum	code/Number Theory/Sum of Arithmetic Progression Modular and Divided.cpp	/^long long floor_sum(long long a, long long d, long long m, long long n) {$/;"	f	typeref:typename:long long
floor_sum	code/Number Theory/Sum of Floors.cpp	/^ll floor_sum(ll n) {$/;"	f	typeref:typename:ll
flow	code-library/Graph Theory/Dinics Algorithm.cpp	/^    long long flow, w;$/;"	m	struct:Dinic::edge	typeref:typename:long long	file:
flow	code-library/Graph Theory/L R Flow with Dinic.cpp	/^    long long flow, w;$/;"	m	struct:Dinic::edge	typeref:typename:long long	file:
flow	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  T flow, cost;$/;"	m	struct:MCMF	typeref:typename:T	file:
flow	code-library/Graph Theory/Maximum Closure Problem.cpp	/^    long long flow, w;$/;"	m	struct:Dinic::edge	typeref:typename:long long	file:
flow	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^    double flow, w;$/;"	m	struct:Dinic::edge	typeref:typename:double	file:
flow	code-library/Graph Theory/Min Cost Max Flow.cpp	/^  T flow, cost;$/;"	m	struct:MCMF	typeref:typename:T	file:
flow	code-library/Graph Theory/Unique Min Cut.cpp	/^    long long flow, w;$/;"	m	struct:Dinic::edge	typeref:typename:long long	file:
flow	code/Graph Theory/Dinics Algorithm.cpp	/^    long long flow, w;$/;"	m	struct:Dinic::edge	typeref:typename:long long	file:
flow	code/Graph Theory/L R Flow with Dinic.cpp	/^    long long flow, w;$/;"	m	struct:Dinic::edge	typeref:typename:long long	file:
flow	code/Graph Theory/L R Flow with MCMF.cpp	/^  T flow, cost;$/;"	m	struct:MCMF	typeref:typename:T	file:
flow	code/Graph Theory/Maximum Closure Problem.cpp	/^    long long flow, w;$/;"	m	struct:Dinic::edge	typeref:typename:long long	file:
flow	code/Graph Theory/Maximum Density Subgraph.cpp	/^    double flow, w;$/;"	m	struct:Dinic::edge	typeref:typename:double	file:
flow	code/Graph Theory/Min Cost Max Flow.cpp	/^  T flow, cost;$/;"	m	struct:MCMF	typeref:typename:T	file:
flow	code/Graph Theory/Unique Min Cut.cpp	/^    long long flow, w;$/;"	m	struct:Dinic::edge	typeref:typename:long long	file:
flow_through	code-library/Graph Theory/Dinics Algorithm.cpp	/^  vector<int> d, flow_through;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
flow_through	code-library/Graph Theory/L R Flow with Dinic.cpp	/^  vector<int> d, flow_through;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
flow_through	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  vector<T> d, potential, flow_through;$/;"	m	struct:MCMF	typeref:typename:vector<T>	file:
flow_through	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  vector<int> d, flow_through;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
flow_through	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^  vector<int> d, flow_through;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
flow_through	code-library/Graph Theory/Min Cost Max Flow.cpp	/^  vector<T> d, potential, flow_through;$/;"	m	struct:MCMF	typeref:typename:vector<T>	file:
flow_through	code-library/Graph Theory/Unique Min Cut.cpp	/^  vector<int> d, flow_through;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
flow_through	code/Graph Theory/Dinics Algorithm.cpp	/^  vector<int> d, flow_through;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
flow_through	code/Graph Theory/L R Flow with Dinic.cpp	/^  vector<int> d, flow_through;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
flow_through	code/Graph Theory/L R Flow with MCMF.cpp	/^  vector<T> d, potential, flow_through;$/;"	m	struct:MCMF	typeref:typename:vector<T>	file:
flow_through	code/Graph Theory/Maximum Closure Problem.cpp	/^  vector<int> d, flow_through;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
flow_through	code/Graph Theory/Maximum Density Subgraph.cpp	/^  vector<int> d, flow_through;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
flow_through	code/Graph Theory/Min Cost Max Flow.cpp	/^  vector<T> d, potential, flow_through;$/;"	m	struct:MCMF	typeref:typename:vector<T>	file:
flow_through	code/Graph Theory/Unique Min Cut.cpp	/^  vector<int> d, flow_through;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
flower	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  vector<int> flower[N * 2];$/;"	m	struct:Blossom	typeref:typename:vector<int>[]	file:
flower	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  vector<int> flower[N * 2];$/;"	m	struct:Blossom	typeref:typename:vector<int>[]	file:
flower_from	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  int n, n_x, match[N * 2], slack[N * 2], st[N * 2], pa[N * 2], flower_from[N * 2][N * 2], S[N */;"	m	struct:Blossom	typeref:typename:int[][]	file:
flower_from	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  int n, n_x, match[N * 2], slack[N * 2], st[N * 2], pa[N * 2], flower_from[N * 2][N * 2], S[N */;"	m	struct:Blossom	typeref:typename:int[][]	file:
fmt	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^  void fmt(vector<mint> &vec, bool inv) {$/;"	f	struct:ChromaticPolynomial	typeref:typename:void	file:
fmt	code/Graph Theory/Chromatic Polynoimial.cpp	/^  void fmt(vector<mint> &vec, bool inv) {$/;"	f	struct:ChromaticPolynomial	typeref:typename:void	file:
fpow	code-library/Number Theory/Fermats Theorem on Sum of Two Squares.cpp	/^    inline num_t fpow(num_t n, num_t k, num_t p) {$/;"	f	namespace:FermatRepresent	typeref:typename:num_t
fpow	code/Number Theory/Fermats Theorem on Sum of Two Squares.cpp	/^    inline num_t fpow(num_t n, num_t k, num_t p) {$/;"	f	namespace:FermatRepresent	typeref:typename:num_t
frac	code-library/Game Theory/Blue Red Hackenbush.cpp	/^  map<int, int>frac; \/\/ fraction part$/;"	m	struct:surreal	typeref:typename:map<int,int>	file:
frac	code-library/Miscellaneous/Fraction Binary Search.cpp	/^struct frac { long long p, q; };$/;"	s	file:
frac	code/Game Theory/Blue Red Hackenbush.cpp	/^  map<int, int>frac; \/\/ fraction part$/;"	m	struct:surreal	typeref:typename:map<int,int>	file:
frac	code/Miscellaneous/Fraction Binary Search.cpp	/^struct frac { long long p, q; };$/;"	s	file:
fracBS	code-library/Miscellaneous/Fraction Binary Search.cpp	/^frac fracBS(long long n) {$/;"	f	typeref:typename:frac
fracBS	code/Miscellaneous/Fraction Binary Search.cpp	/^frac fracBS(long long n) {$/;"	f	typeref:typename:frac
from	code-library/Data Structures/Persistent Meldable Heap.cpp	/^    int from, to;$/;"	m	struct:heap::node	typeref:typename:int	file:
from	code-library/Graph Theory/Eppsteins Algorithm.cpp	/^    int from, to;$/;"	m	struct:heap::node	typeref:typename:int	file:
from	code-library/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^  int from, to, rev;$/;"	m	struct:EDGE	typeref:typename:int	file:
from	code-library/Strings/Cyclic LCS.cpp	/^int dp[N * 2][N], from[N * 2][N];$/;"	v	typeref:typename:int[][]
from	code/Data Structures/Persistent Meldable Heap.cpp	/^    int from, to;$/;"	m	struct:heap::node	typeref:typename:int	file:
from	code/Graph Theory/Eppsteins Algorithm.cpp	/^    int from, to;$/;"	m	struct:heap::node	typeref:typename:int	file:
from	code/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^  int from, to, rev;$/;"	m	struct:EDGE	typeref:typename:int	file:
from	code/Strings/Cyclic LCS.cpp	/^int dp[N * 2][N], from[N * 2][N];$/;"	v	typeref:typename:int[][]
from	practice/usacoguide/gold/bfs/monsters.cpp	/^pair<int, int> from[mxN][mxN];$/;"	v	typeref:typename:pair<int,int>[][]
func	code-library/Number Theory/Fermats Theorem on Sum of Two Squares.cpp	/^    long long func(long long p) {$/;"	f	namespace:FermatRepresent	typeref:typename:long long
func	code/Number Theory/Fermats Theorem on Sum of Two Squares.cpp	/^    long long func(long long p) {$/;"	f	namespace:FermatRepresent	typeref:typename:long long
fwht	code-library/Math/FWHT in Ternary Base.cpp	/^  void fwht(poly &coefs, poly &vals, bool invert = false) {$/;"	f	struct:FWHT	typeref:typename:void	file:
fwht	code/Math/FWHT in Ternary Base.cpp	/^  void fwht(poly &coefs, poly &vals, bool invert = false) {$/;"	f	struct:FWHT	typeref:typename:void	file:
fx	code-library/Graph Theory/Hungarian Algorithm.cpp	/^  long long c[N][N], fx[N], fy[N], d[N];$/;"	m	struct:Hungarian	typeref:typename:long long[]	file:
fx	code/Graph Theory/Hungarian Algorithm.cpp	/^  long long c[N][N], fx[N], fy[N], d[N];$/;"	m	struct:Hungarian	typeref:typename:long long[]	file:
fy	code-library/Graph Theory/Hungarian Algorithm.cpp	/^  long long c[N][N], fx[N], fy[N], d[N];$/;"	m	struct:Hungarian	typeref:typename:long long[]	file:
fy	code/Graph Theory/Hungarian Algorithm.cpp	/^  long long c[N][N], fx[N], fy[N], d[N];$/;"	m	struct:Hungarian	typeref:typename:long long[]	file:
g	code-library/Data Structures/Binarizing a Tree.cpp	/^vector<pair<int, int>> g[N * 2], G[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^vector<pair<int, int>> g[N * 2], G[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code-library/Data Structures/Centroid Decomposition.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code-library/Data Structures/DSU on Tree.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code-library/Data Structures/Dynamic Diameter Online.cpp	/^vector<pair<int, int>> g[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code-library/Data Structures/HLD.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code-library/Data Structures/LCA.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code-library/Data Structures/Link Cut Tree.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code-library/Data Structures/MOs on tree.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code-library/Data Structures/Persistent Meldable Heap.cpp	/^vector<vector<array<int, 3>>> g;$/;"	v	typeref:typename:vector<vector<array<int,3>>>
g	code-library/Data Structures/Reachability Tree.cpp	/^  vector<int> g[2 * N]; \/\/reachability tree$/;"	m	struct:RT	typeref:typename:vector<int>[]	file:
g	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  long long val, g;$/;"	m	struct:node	typeref:typename:long long	file:
g	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^mint g[N][N];$/;"	v	typeref:typename:mint[][]
g	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^vector<pair<int, int>> g[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code-library/Dynamic Programming Optimizations/Subset Sum in SQRT.cpp	/^vector<int> g[N], id[N];$/;"	v	typeref:typename:vector<int>[]
g	code-library/Game Theory/Blue Red Hackenbush.cpp	/^vector<pair<int, int> >g[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code-library/Game Theory/Green Hackenbush.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code-library/Game Theory/Matching Game On A Graph.cpp	/^  vector<int> g[N];$/;"	m	struct:Blossom	typeref:typename:vector<int>[]	file:
g	code-library/Geometry/Geometry 3D.cpp	/^    vector<vector<int>> g;$/;"	m	struct:CH3D	typeref:typename:vector<vector<int>>	file:
g	code-library/Graph Theory/2 SAT.cpp	/^  vector< vector<int> > g, gt;$/;"	m	struct:twosat	typeref:typename:vector<vector<int>>	file:
g	code-library/Graph Theory/3 CYCLE and 4 CYCLE.cpp	/^vector<int> g[N], G[N];$/;"	v	typeref:typename:vector<int>[]
g	code-library/Graph Theory/3 SAT.cpp	/^  vector<vector<int>> g, lit;$/;"	m	struct:SAT_GOD	typeref:typename:vector<vector<int>>	file:
g	code-library/Graph Theory/Articulation Bridges.cpp	/^  vector<vector<int>> g, t;$/;"	m	struct:TECC	typeref:typename:vector<vector<int>>	file:
g	code-library/Graph Theory/Articulation Points.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code-library/Graph Theory/Block Cut Tree.cpp	/^vector<int> g[N], bcc[N], st;$/;"	v	typeref:typename:vector<int>[]
g	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  } g[N * 2][N * 2];$/;"	m	struct:Blossom	typeref:struct:Blossom::edge[][]	file:
g	code-library/Graph Theory/Blossom Algorithm.cpp	/^  vector<int> g[N];$/;"	m	struct:Blossom	typeref:typename:vector<int>[]	file:
g	code-library/Graph Theory/Chordal Graph.cpp	/^vector<int> g[N]; \/\/each node should be unique in the adjacency list$/;"	v	typeref:typename:vector<int>[]
g	code-library/Graph Theory/Chromatic Number.cpp	/^vector<int> g[20];$/;"	v	typeref:typename:vector<int>[20]
g	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code-library/Graph Theory/Cycle Detection.cpp	/^vector<pair<int, int>> g[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code-library/Graph Theory/Dijkstra on Segment Tree.cpp	/^vector<pair<int, int>> g[N * 9];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code-library/Graph Theory/Dijkstra.cpp	/^vector<pair<int, int>> g[N], r[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code-library/Graph Theory/Dinics Algorithm.cpp	/^  vector<vector<edge>> g;$/;"	m	struct:Dinic	typeref:typename:vector<vector<edge>>	file:
g	code-library/Graph Theory/Dominator Tree.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code-library/Graph Theory/Eppsteins Algorithm.cpp	/^vector<vector<array<int, 3>>> g;$/;"	v	typeref:typename:vector<vector<array<int,3>>>
g	code-library/Graph Theory/Euler Path Directed.cpp	/^vector<int> g[N], ans;$/;"	v	typeref:typename:vector<int>[]
g	code-library/Graph Theory/Euler Path Undirected.cpp	/^vector<pair<int, int>> g[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code-library/Graph Theory/HopCroft Karp Algorithm.cpp	/^  vector<vector<int>> g;$/;"	m	struct:HopcroftKarp	typeref:typename:vector<vector<int>>	file:
g	code-library/Graph Theory/Inverse Graph.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code-library/Graph Theory/Kirchoffs Theorem.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code-library/Graph Theory/Kuhns Algorithm.cpp	/^  vector<vector<int>> g;$/;"	m	struct:Kuhn	typeref:typename:vector<vector<int>>	file:
g	code-library/Graph Theory/Kuhns Algorithm.cpp	/^vector<int> g[N], r[N], G[N], vec; \/\/G is the condensed graph$/;"	v	typeref:typename:vector<int>[]
g	code-library/Graph Theory/L R Flow with Dinic.cpp	/^  vector<vector<edge>> g;$/;"	m	struct:Dinic	typeref:typename:vector<vector<edge>>	file:
g	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  vector<vector<int>> g;$/;"	m	struct:MCMF	typeref:typename:vector<vector<int>>	file:
g	code-library/Graph Theory/LCA.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code-library/Graph Theory/Manhattan MST.cpp	/^vector<pair<int, int>> g[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code-library/Graph Theory/Maximum Clique.cpp	/^int g[N][N];$/;"	v	typeref:typename:int[][]
g	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  vector<vector<edge>> g;$/;"	m	struct:Dinic	typeref:typename:vector<vector<edge>>	file:
g	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  vector<vector<int>> g, r, G;\/\/G is the condensed graph$/;"	m	struct:MaximumClosure	typeref:typename:vector<vector<int>>	file:
g	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^  vector<vector<edge>> g;$/;"	m	struct:Dinic	typeref:typename:vector<vector<edge>>	file:
g	code-library/Graph Theory/Maximum Independant Set.cpp	/^int g[N][N], n;$/;"	v	typeref:typename:int[][]
g	code-library/Graph Theory/Min Cost Max Flow.cpp	/^  vector<vector<int>> g;$/;"	m	struct:MCMF	typeref:typename:vector<vector<int>>	file:
g	code-library/Graph Theory/Min Cut in a Planar Graph.cpp	/^vector<pair<int, int>> g[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code-library/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^vector <int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code-library/Graph Theory/Minimum Mean Weight Cycle.cpp	/^vector<pair<int, int>> g[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code-library/Graph Theory/Minimum Weight Cycle For Each Edge.cpp	/^int g[N][N], ans[N * N], last[N], dp[N * N], id[N][N], W[N * N];$/;"	v	typeref:typename:int[][]
g	code-library/Graph Theory/Minimum Weight Cycle For Each Vertex.cpp	/^int g[N][N], d[N], vis[N], par[N];$/;"	v	typeref:typename:int[][]
g	code-library/Graph Theory/Number of Different Cliques.cpp	/^ll g[M];$/;"	v	typeref:typename:ll[]
g	code-library/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code-library/Graph Theory/Path Intersection.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code-library/Graph Theory/Path Union.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code-library/Graph Theory/Prim's MST.cpp	/^int g[N][N], w[N], to[N], selected[N];$/;"	v	typeref:typename:int[][]
g	code-library/Graph Theory/Prufer Code.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code-library/Graph Theory/Randomized Matching Unweighted.cpp	/^  vector<int> g[N];$/;"	m	struct:RandomizedMatching	typeref:typename:vector<int>[]	file:
g	code-library/Graph Theory/SCC.cpp	/^vector<int> g[N], r[N], G[N], vec; \/\/G is the condensed graph$/;"	v	typeref:typename:vector<int>[]
g	code-library/Graph Theory/SPFA.cpp	/^vector<pair<int, int>> g[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code-library/Graph Theory/ST Numbering.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code-library/Graph Theory/Steiner Tree Problem.cpp	/^vector<pair<int, long long>> g[N];$/;"	v	typeref:typename:vector<pair<int,long long>>[]
g	code-library/Graph Theory/System Of Difference Constraints.cpp	/^vector<pair<int, int>> g[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code-library/Graph Theory/Tree Isomorphism.cpp	/^  vector<vector<int>> g;$/;"	m	struct:Tree	typeref:typename:vector<vector<int>>	file:
g	code-library/Graph Theory/Tree Orientation.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code-library/Graph Theory/Tuttes Theorem.cpp	/^int g[N][N], in[N];$/;"	v	typeref:typename:int[][]
g	code-library/Graph Theory/Unique Min Cut.cpp	/^  vector<vector<edge>> g;$/;"	m	struct:Dinic	typeref:typename:vector<vector<edge>>	file:
g	code-library/Graph Theory/Virtual Tree.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code-library/Math/Basis Vector Reduced Row Echelon Form.cpp	/^vector<pair<int, int>> g[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code-library/Math/Simplex Algorithm.cpp	/^vector <ll> g[N],cost[N];$/;"	v	typeref:typename:vector<ll>[]
g	code-library/Miscellaneous/Gray Code.cpp	/^int g (int n) {$/;"	f	typeref:typename:int
g	code-library/Number Theory/Min_25 Sieve.cpp	/^T g[D][N];$/;"	v	typeref:typename:T[][]
g	code-library/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  vector<vector<int>> g;$/;"	m	struct:Kuhn	typeref:typename:vector<vector<int>>	file:
g	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code-library/Strings/All Substring Longest Common Subsequence.cpp	/^int f[N][N], g[N][N];$/;"	v	typeref:typename:int[][]
g	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  vector<vector<int>> g;$/;"	m	struct:SuffixAutomaton	typeref:typename:vector<vector<int>>	file:
g	code-library/Strings/Suffix Automaton.cpp	/^    vector<vector<int>> g;$/;"	m	struct:SuffixAutomaton	typeref:typename:vector<vector<int>>	file:
g	code/Data Structures/Binarizing a Tree.cpp	/^vector<pair<int, int>> g[N * 2], G[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code/Data Structures/Centroid Decomposition Persistent.cpp	/^vector<pair<int, int>> g[N * 2], G[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code/Data Structures/Centroid Decomposition.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code/Data Structures/DSU on Tree.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code/Data Structures/Dynamic Diameter Online.cpp	/^vector<pair<int, int>> g[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code/Data Structures/HLD.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code/Data Structures/LCA.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code/Data Structures/Link Cut Tree.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code/Data Structures/MOs on tree.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code/Data Structures/Persistent Meldable Heap.cpp	/^vector<vector<array<int, 3>>> g;$/;"	v	typeref:typename:vector<vector<array<int,3>>>
g	code/Data Structures/Reachability Tree.cpp	/^  vector<int> g[2 * N]; \/\/reachability tree$/;"	m	struct:RT	typeref:typename:vector<int>[]	file:
g	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  long long val, g;$/;"	m	struct:node	typeref:typename:long long	file:
g	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^mint g[N][N];$/;"	v	typeref:typename:mint[][]
g	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^vector<pair<int, int>> g[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code/Dynamic Programming Optimizations/Subset Sum in SQRT.cpp	/^vector<int> g[N], id[N];$/;"	v	typeref:typename:vector<int>[]
g	code/Game Theory/Blue Red Hackenbush.cpp	/^vector<pair<int, int> >g[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code/Game Theory/Green Hackenbush.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code/Game Theory/Matching Game On A Graph.cpp	/^  vector<int> g[N];$/;"	m	struct:Blossom	typeref:typename:vector<int>[]	file:
g	code/Geometry/Geometry 3D.cpp	/^    vector<vector<int>> g;$/;"	m	struct:CH3D	typeref:typename:vector<vector<int>>	file:
g	code/Graph Theory/2 SAT.cpp	/^  vector< vector<int> > g, gt;$/;"	m	struct:twosat	typeref:typename:vector<vector<int>>	file:
g	code/Graph Theory/3 CYCLE and 4 CYCLE.cpp	/^vector<int> g[N], G[N];$/;"	v	typeref:typename:vector<int>[]
g	code/Graph Theory/3 SAT.cpp	/^  vector<vector<int>> g, lit;$/;"	m	struct:SAT_GOD	typeref:typename:vector<vector<int>>	file:
g	code/Graph Theory/Articulation Bridges.cpp	/^  vector<vector<int>> g, t;$/;"	m	struct:TECC	typeref:typename:vector<vector<int>>	file:
g	code/Graph Theory/Articulation Points.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code/Graph Theory/Block Cut Tree.cpp	/^vector<int> g[N], bcc[N], st;$/;"	v	typeref:typename:vector<int>[]
g	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  } g[N * 2][N * 2];$/;"	m	struct:Blossom	typeref:struct:Blossom::edge[][]	file:
g	code/Graph Theory/Blossom Algorithm.cpp	/^  vector<int> g[N];$/;"	m	struct:Blossom	typeref:typename:vector<int>[]	file:
g	code/Graph Theory/Chordal Graph.cpp	/^vector<int> g[N]; \/\/each node should be unique in the adjacency list$/;"	v	typeref:typename:vector<int>[]
g	code/Graph Theory/Chromatic Number.cpp	/^vector<int> g[20];$/;"	v	typeref:typename:vector<int>[20]
g	code/Graph Theory/Chromatic Polynoimial.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code/Graph Theory/Cycle Detection.cpp	/^vector<pair<int, int>> g[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code/Graph Theory/Dijkstra on Segment Tree.cpp	/^vector<pair<int, int>> g[N * 9];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code/Graph Theory/Dijkstra.cpp	/^vector<pair<int, int>> g[N], r[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code/Graph Theory/Dinics Algorithm.cpp	/^  vector<vector<edge>> g;$/;"	m	struct:Dinic	typeref:typename:vector<vector<edge>>	file:
g	code/Graph Theory/Dominator Tree.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code/Graph Theory/Eppsteins Algorithm.cpp	/^vector<vector<array<int, 3>>> g;$/;"	v	typeref:typename:vector<vector<array<int,3>>>
g	code/Graph Theory/Euler Path Directed.cpp	/^vector<int> g[N], ans;$/;"	v	typeref:typename:vector<int>[]
g	code/Graph Theory/Euler Path Undirected.cpp	/^vector<pair<int, int>> g[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code/Graph Theory/HopCroft Karp Algorithm.cpp	/^  vector<vector<int>> g;$/;"	m	struct:HopcroftKarp	typeref:typename:vector<vector<int>>	file:
g	code/Graph Theory/Inverse Graph.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code/Graph Theory/Kirchoffs Theorem.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code/Graph Theory/Kuhns Algorithm.cpp	/^  vector<vector<int>> g;$/;"	m	struct:Kuhn	typeref:typename:vector<vector<int>>	file:
g	code/Graph Theory/Kuhns Algorithm.cpp	/^vector<int> g[N], r[N], G[N], vec; \/\/G is the condensed graph$/;"	v	typeref:typename:vector<int>[]
g	code/Graph Theory/L R Flow with Dinic.cpp	/^  vector<vector<edge>> g;$/;"	m	struct:Dinic	typeref:typename:vector<vector<edge>>	file:
g	code/Graph Theory/L R Flow with MCMF.cpp	/^  vector<vector<int>> g;$/;"	m	struct:MCMF	typeref:typename:vector<vector<int>>	file:
g	code/Graph Theory/LCA.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code/Graph Theory/Manhattan MST.cpp	/^vector<pair<int, int>> g[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code/Graph Theory/Maximum Clique.cpp	/^int g[N][N];$/;"	v	typeref:typename:int[][]
g	code/Graph Theory/Maximum Closure Problem.cpp	/^  vector<vector<edge>> g;$/;"	m	struct:Dinic	typeref:typename:vector<vector<edge>>	file:
g	code/Graph Theory/Maximum Closure Problem.cpp	/^  vector<vector<int>> g, r, G;\/\/G is the condensed graph$/;"	m	struct:MaximumClosure	typeref:typename:vector<vector<int>>	file:
g	code/Graph Theory/Maximum Density Subgraph.cpp	/^  vector<vector<edge>> g;$/;"	m	struct:Dinic	typeref:typename:vector<vector<edge>>	file:
g	code/Graph Theory/Maximum Independant Set.cpp	/^int g[N][N], n;$/;"	v	typeref:typename:int[][]
g	code/Graph Theory/Min Cost Max Flow.cpp	/^  vector<vector<int>> g;$/;"	m	struct:MCMF	typeref:typename:vector<vector<int>>	file:
g	code/Graph Theory/Min Cut in a Planar Graph.cpp	/^vector<pair<int, int>> g[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^vector <int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code/Graph Theory/Minimum Mean Weight Cycle.cpp	/^vector<pair<int, int>> g[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code/Graph Theory/Minimum Weight Cycle For Each Edge.cpp	/^int g[N][N], ans[N * N], last[N], dp[N * N], id[N][N], W[N * N];$/;"	v	typeref:typename:int[][]
g	code/Graph Theory/Minimum Weight Cycle For Each Vertex.cpp	/^int g[N][N], d[N], vis[N], par[N];$/;"	v	typeref:typename:int[][]
g	code/Graph Theory/Number of Different Cliques.cpp	/^ll g[M];$/;"	v	typeref:typename:ll[]
g	code/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code/Graph Theory/Path Intersection.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code/Graph Theory/Path Union.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code/Graph Theory/Prim's MST.cpp	/^int g[N][N], w[N], to[N], selected[N];$/;"	v	typeref:typename:int[][]
g	code/Graph Theory/Prufer Code.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code/Graph Theory/Randomized Matching Unweighted.cpp	/^  vector<int> g[N];$/;"	m	struct:RandomizedMatching	typeref:typename:vector<int>[]	file:
g	code/Graph Theory/SCC.cpp	/^vector<int> g[N], r[N], G[N], vec; \/\/G is the condensed graph$/;"	v	typeref:typename:vector<int>[]
g	code/Graph Theory/SPFA.cpp	/^vector<pair<int, int>> g[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code/Graph Theory/ST Numbering.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code/Graph Theory/Steiner Tree Problem.cpp	/^vector<pair<int, long long>> g[N];$/;"	v	typeref:typename:vector<pair<int,long long>>[]
g	code/Graph Theory/System Of Difference Constraints.cpp	/^vector<pair<int, int>> g[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code/Graph Theory/Tree Isomorphism.cpp	/^  vector<vector<int>> g;$/;"	m	struct:Tree	typeref:typename:vector<vector<int>>	file:
g	code/Graph Theory/Tree Orientation.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code/Graph Theory/Tuttes Theorem.cpp	/^int g[N][N], in[N];$/;"	v	typeref:typename:int[][]
g	code/Graph Theory/Unique Min Cut.cpp	/^  vector<vector<edge>> g;$/;"	m	struct:Dinic	typeref:typename:vector<vector<edge>>	file:
g	code/Graph Theory/Virtual Tree.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code/Math/Basis Vector Reduced Row Echelon Form.cpp	/^vector<pair<int, int>> g[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
g	code/Math/Generating Function of a Linear Recurrence.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code/Math/Simplex Algorithm.cpp	/^vector <ll> g[N],cost[N];$/;"	v	typeref:typename:vector<ll>[]
g	code/Miscellaneous/Gray Code.cpp	/^int g (int n) {$/;"	f	typeref:typename:int
g	code/Number Theory/Min_25 Sieve.cpp	/^T g[D][N];$/;"	v	typeref:typename:T[][]
g	code/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  vector<vector<int>> g;$/;"	m	struct:Kuhn	typeref:typename:vector<vector<int>>	file:
g	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^vector<int> g[N];$/;"	v	typeref:typename:vector<int>[]
g	code/Strings/All Substring Longest Common Subsequence.cpp	/^int f[N][N], g[N][N];$/;"	v	typeref:typename:int[][]
g	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  vector<vector<int>> g;$/;"	m	struct:SuffixAutomaton	typeref:typename:vector<vector<int>>	file:
g	code/Strings/Suffix Automaton.cpp	/^    vector<vector<int>> g;$/;"	m	struct:SuffixAutomaton	typeref:typename:vector<vector<int>>	file:
g1	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  m32_1 f1[size], g1[size];$/;"	v	namespace:ntt	typeref:typename:m32_1[]
g1	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  m64_1 f1[size], g1[size];$/;"	v	namespace:ntt	typeref:typename:m64_1[]
g1	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  m32_1 f1[size], g1[size];$/;"	v	namespace:ntt	typeref:typename:m32_1[]
g1	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  m64_1 f1[size], g1[size];$/;"	v	namespace:ntt	typeref:typename:m64_1[]
g2	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  m32_2 f2[size], g2[size];$/;"	v	namespace:ntt	typeref:typename:m32_2[]
g2	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  m64_2 f2[size], g2[size];$/;"	v	namespace:ntt	typeref:typename:m64_2[]
g2	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  m32_2 f2[size], g2[size];$/;"	v	namespace:ntt	typeref:typename:m32_2[]
g2	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  m64_2 f2[size], g2[size];$/;"	v	namespace:ntt	typeref:typename:m64_2[]
g3	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  m32_3 f3[size], g3[size];$/;"	v	namespace:ntt	typeref:typename:m32_3[]
g3	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  m32_3 f3[size], g3[size];$/;"	v	namespace:ntt	typeref:typename:m32_3[]
g:airline#extensions#tabline#enabled	.compilingScripts/init.vim	/^let g:airline#extensions#tabline#enabled = 1$/;"	v
g:airline#extensions#tabline#enabled	dotfiles/macinit.vim	/^let g:airline#extensions#tabline#enabled = 1$/;"	v
g:airline_powerline_fonts	.compilingScripts/init.vim	/^let g:airline_powerline_fonts = 1$/;"	v
g:airline_powerline_fonts	dotfiles/init.vim	/^let g:airline_powerline_fonts=1$/;"	v
g:airline_powerline_fonts	dotfiles/macinit.vim	/^let g:airline_powerline_fonts = 1$/;"	v
g:airline_theme	dotfiles/init.vim	/^let g:airline_theme = 'codedark'$/;"	v
g:compe	dotfiles/macinit.vim	/^let g:compe = {}$/;"	v
g:compe	dotfiles/macinit.vim	/^let g:compe.autocomplete = v:true$/;"	v
g:compe	dotfiles/macinit.vim	/^let g:compe.debug = v:false$/;"	v
g:compe	dotfiles/macinit.vim	/^let g:compe.documentation = v:true$/;"	v
g:compe	dotfiles/macinit.vim	/^let g:compe.enabled = v:true$/;"	v
g:compe	dotfiles/macinit.vim	/^let g:compe.incomplete_delay = 400$/;"	v
g:compe	dotfiles/macinit.vim	/^let g:compe.max_abbr_width = 100$/;"	v
g:compe	dotfiles/macinit.vim	/^let g:compe.max_kind_width = 100$/;"	v
g:compe	dotfiles/macinit.vim	/^let g:compe.max_menu_width = 100$/;"	v
g:compe	dotfiles/macinit.vim	/^let g:compe.min_length = 1$/;"	v
g:compe	dotfiles/macinit.vim	/^let g:compe.preselect = 'enable'$/;"	v
g:compe	dotfiles/macinit.vim	/^let g:compe.resolve_timeout = 800$/;"	v
g:compe	dotfiles/macinit.vim	/^let g:compe.source = {}$/;"	v
g:compe	dotfiles/macinit.vim	/^let g:compe.source.buffer = v:true$/;"	v
g:compe	dotfiles/macinit.vim	/^let g:compe.source.calc = v:true$/;"	v
g:compe	dotfiles/macinit.vim	/^let g:compe.source.luasnip = v:true$/;"	v
g:compe	dotfiles/macinit.vim	/^let g:compe.source.nvim_lsp = v:true$/;"	v
g:compe	dotfiles/macinit.vim	/^let g:compe.source.nvim_lua = v:true$/;"	v
g:compe	dotfiles/macinit.vim	/^let g:compe.source.path = v:true$/;"	v
g:compe	dotfiles/macinit.vim	/^let g:compe.source.ultisnips = v:true$/;"	v
g:compe	dotfiles/macinit.vim	/^let g:compe.source.vsnip = v:true$/;"	v
g:compe	dotfiles/macinit.vim	/^let g:compe.source_timeout = 200$/;"	v
g:compe	dotfiles/macinit.vim	/^let g:compe.throttle_time = 80$/;"	v
g:vimtex_view_general_viewer	dotfiles/init.vim	/^let g:vimtex_view_general_viewer = 'evince'$/;"	v
g:vsnip_filetypes	.config/nvim/init.vim	/^let g:vsnip_filetypes = {}$/;"	v
g:vsnip_filetypes	.config/nvim/init.vim	/^let g:vsnip_filetypes.javascriptreact = ['javascript']$/;"	v
g:vsnip_filetypes	.config/nvim/init.vim	/^let g:vsnip_filetypes.typescriptreact = ['typescript']$/;"	v
g:vsnip_filetypes	dotfiles/init.vim	/^let g:vsnip_filetypes = {}$/;"	v
g:vsnip_filetypes	dotfiles/init.vim	/^let g:vsnip_filetypes.javascriptreact = ['javascript']$/;"	v
g:vsnip_filetypes	dotfiles/init.vim	/^let g:vsnip_filetypes.typescriptreact = ['typescript']$/;"	v
gA	.compilingScripts/init.vim	/^nnoremap gA :%y+<CR>$/;"	m
gA	.config/nvim/init.vim	/^nnoremap gA :%y+<CR>$/;"	m
gA	dotfiles/init.vim	/^nnoremap gA :%y+<CR>$/;"	m
gA	dotfiles/macinit.vim	/^nnoremap gA :%y+<CR>$/;"	m
gcd	code-library/Math/Polynomial.cpp	/^poly gcd(poly a, poly b) {$/;"	f	typeref:typename:poly
gcd	code-library/Miscellaneous/BigInt.cpp	/^  friend BigInt gcd(const BigInt &a, const BigInt &b) {$/;"	f	typeref:typename:BigInt	file:
gcd	code-library/Number Theory/Discrete Root Faster.cpp	/^ll gcd(ll a,ll b) {$/;"	f	typeref:typename:ll
gcd	code/Math/Polynomial.cpp	/^poly gcd(poly a, poly b) {$/;"	f	typeref:typename:poly
gcd	code/Miscellaneous/BigInt.cpp	/^  friend BigInt gcd(const BigInt &a, const BigInt &b) {$/;"	f	typeref:typename:BigInt	file:
gcd	code/Number Theory/Discrete Root Faster.cpp	/^ll gcd(ll a,ll b) {$/;"	f	typeref:typename:ll
gcd	contests/Codeforces/737/C.cpp	/^ll int gcd(ll int a  , ll int b){$/;"	f	typeref:typename:ll int
ge	code-library/Geometry/Point Location.cpp	/^bool ge(const ll& a, const ll& b) { return a >= b; }$/;"	f	typeref:typename:bool
ge	code/Geometry/Point Location.cpp	/^bool ge(const ll& a, const ll& b) { return a >= b; }$/;"	f	typeref:typename:bool
gen	code-library/Number Theory/Pells Equation.py	/^def gen(a, x, y, i, cur):$/;"	f
gen	code/Number Theory/Pells Equation.py	/^def gen(a, x, y, i, cur):$/;"	f
gen	contests/Codeforces/1560/F1/main.cpp	/^void gen(int n, int i, int arr[]) {$/;"	f	typeref:typename:void
gen	contests/Codeforces/1560/F1/test1.cpp	/^void gen(int n, int i, vector<int> arr) {$/;"	f	typeref:typename:void
geometric_median	code-library/Geometry/Geometry 2D.cpp	/^PT geometric_median(vector<PT> p) {$/;"	f	typeref:typename:PT
geometric_median	code/Geometry/Geometry 2D.cpp	/^PT geometric_median(vector<PT> p) {$/;"	f	typeref:typename:PT
get	code-library/Data Structures/MOs Online.cpp	/^  int get() {$/;"	f	struct:MEX	typeref:typename:int	file:
get	code-library/Data Structures/MOs Online.cpp	/^int get(int x) {$/;"	f	typeref:typename:int
get	code-library/Data Structures/MOs with Update.cpp	/^int get(int x) {$/;"	f	typeref:typename:int
get	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^  int get(int x) {$/;"	f	struct:Block	typeref:typename:int	file:
get	code-library/Data Structures/Treap.cpp	/^  vector<int> get() {$/;"	f	struct:treap	typeref:typename:vector<int>	file:
get	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^  mint get(long long c) { \/\/returns P(c)$/;"	f	struct:ChromaticPolynomial	typeref:typename:mint	file:
get	code-library/Graph Theory/Online Articulation Bridges.cpp	/^int get (int v) {$/;"	f	typeref:typename:int
get	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^vector<pair<long long, int>> get(vector<long long> a) {$/;"	f	typeref:typename:vector<pair<long long,int>>
get	code-library/Math/Polynomial Factorization.cpp	/^void get(int N) { \/\/ compute the cyclotomic polynomial phi_N(x)$/;"	f	typeref:typename:void
get	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^vector<pair<long long, int>> get(vector<long long> a) {$/;"	f	typeref:typename:vector<pair<long long,int>>
get	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  word_t get() const { return reduce(this->x) % mod; }$/;"	f	class:ntt::Mod	typeref:typename:word_t	file:
get	code-library/Strings/Aho Corasick.cpp	/^  inline int get (char c) {$/;"	f	struct:AC	typeref:typename:int	file:
get	code-library/Strings/Number of Palindromes in Range.cpp	/^int get(int l, int r) {$/;"	f	typeref:typename:int
get	code/Data Structures/MOs Online.cpp	/^  int get() {$/;"	f	struct:MEX	typeref:typename:int	file:
get	code/Data Structures/MOs Online.cpp	/^int get(int x) {$/;"	f	typeref:typename:int
get	code/Data Structures/MOs with Update.cpp	/^int get(int x) {$/;"	f	typeref:typename:int
get	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^  int get(int x) {$/;"	f	struct:Block	typeref:typename:int	file:
get	code/Data Structures/Treap.cpp	/^  vector<int> get() {$/;"	f	struct:treap	typeref:typename:vector<int>	file:
get	code/Graph Theory/Chromatic Polynoimial.cpp	/^  mint get(long long c) { \/\/returns P(c)$/;"	f	struct:ChromaticPolynomial	typeref:typename:mint	file:
get	code/Graph Theory/Online Articulation Bridges.cpp	/^int get (int v) {$/;"	f	typeref:typename:int
get	code/Math/Number of Solutions of A Equation MITM.cpp	/^vector<pair<long long, int>> get(vector<long long> a) {$/;"	f	typeref:typename:vector<pair<long long,int>>
get	code/Math/Polynomial Factorization.cpp	/^void get(int N) { \/\/ compute the cyclotomic polynomial phi_N(x)$/;"	f	typeref:typename:void
get	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^vector<pair<long long, int>> get(vector<long long> a) {$/;"	f	typeref:typename:vector<pair<long long,int>>
get	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  word_t get() const { return reduce(this->x) % mod; }$/;"	f	class:ntt::Mod	typeref:typename:word_t	file:
get	code/Strings/Aho Corasick.cpp	/^  inline int get (char c) {$/;"	f	struct:AC	typeref:typename:int	file:
get	code/Strings/Number of Palindromes in Range.cpp	/^int get(int l, int r) {$/;"	f	typeref:typename:int
get	contests/USACO/dec_silver_2021/B/brute.cpp	/^	int get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }$/;"	f	struct:DSU	typeref:typename:int	file:
get	practice/usacoguide/gold/dsu/closing/main.cpp	/^	int get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }$/;"	f	struct:DSU	typeref:typename:int	file:
get	practice/usacoguide/gold/dsu/moocast/main.cpp	/^	int get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }$/;"	f	struct:DSU	typeref:typename:int	file:
get	practice/usacoguide/gold/dsu/mootube/main.cpp	/^	int get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }$/;"	f	struct:DSU	typeref:typename:int	file:
get	practice/usacoguide/gold/dsu/tractor/main.cpp	/^	int get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }$/;"	f	struct:DSU	typeref:typename:int	file:
get	practice/usacoguide/gold/dsu/tractor/mountain.cpp	/^	int get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }$/;"	f	struct:DSU	typeref:typename:int	file:
get	practice/usacoguide/gold/dsu/wormhole/main.cpp	/^	int get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }$/;"	f	struct:DSU	typeref:typename:int	file:
get	practice/usacoguide/silver/idk/lirs/main.cpp	/^	int get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }$/;"	f	struct:DSU	typeref:typename:int	file:
getC	code-library/Graph Theory/Hungarian Algorithm.cpp	/^  inline long long getC(int u, int v) {$/;"	f	struct:Hungarian	typeref:typename:long long	file:
getC	code/Graph Theory/Hungarian Algorithm.cpp	/^  inline long long getC(int u, int v) {$/;"	f	struct:Hungarian	typeref:typename:long long	file:
getCommonPath	code-library/Graph Theory/Path Intersection.cpp	/^pair<int, int> getCommonPath(int u, int a, int v, int b) { \/\/ returns common path between u->a/;"	f	typeref:typename:pair<int,int>
getCommonPath	code/Graph Theory/Path Intersection.cpp	/^pair<int, int> getCommonPath(int u, int a, int v, int b) { \/\/ returns common path between u->a/;"	f	typeref:typename:pair<int,int>
getFlow	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  flow_t getFlow(Edge const &e) {$/;"	f	struct:mcSFlow	typeref:typename:flow_t	file:
getFlow	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  flow_t getFlow(Edge const &e) {$/;"	f	struct:mcSFlow	typeref:typename:flow_t	file:
getSum	contests/USACO/dec_silver_2021/A/A_safe.cpp	/^int getSum(int BITree[], int index)$/;"	f	typeref:typename:int
get_abc	code-library/Geometry/Geometry 2D.cpp	/^    array<double, 3> get_abc() {$/;"	f	struct:line	typeref:typename:array<double,3>	file:
get_abc	code/Geometry/Geometry 2D.cpp	/^    array<double, 3> get_abc() {$/;"	f	struct:line	typeref:typename:array<double,3>	file:
get_all	code-library/Graph Theory/Three Edge Connectivity.cpp	/^  vector<vector<int>> get_all() {$/;"	f	struct:Components	typeref:typename:vector<vector<int>>	file:
get_all	code/Graph Theory/Three Edge Connectivity.cpp	/^  vector<vector<int>> get_all() {$/;"	f	struct:Components	typeref:typename:vector<vector<int>>	file:
get_angle	code-library/Geometry/All Pair Segment Intersection.cpp	/^double get_angle(PT a, PT b) {$/;"	f	typeref:typename:double
get_angle	code-library/Geometry/Geometry 2D.cpp	/^double get_angle(PT a, PT b) {$/;"	f	typeref:typename:double
get_angle	code-library/Geometry/Geometry 3D.cpp	/^double get_angle(PT a, PT b) {$/;"	f	typeref:typename:double
get_angle	code-library/Geometry/Geometry 3D.cpp	/^double get_angle(line3d l1, line3d l2) {$/;"	f	typeref:typename:double
get_angle	code-library/Geometry/Geometry 3D.cpp	/^double get_angle(p3 a, p3 b) {$/;"	f	typeref:typename:double
get_angle	code-library/Geometry/Geometry 3D.cpp	/^double get_angle(plane p, line3d l) {$/;"	f	typeref:typename:double
get_angle	code-library/Geometry/Geometry 3D.cpp	/^double get_angle(plane p1, plane p2) {$/;"	f	typeref:typename:double
get_angle	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^double get_angle(PT a, PT b) {$/;"	f	typeref:typename:double
get_angle	code-library/Geometry/Half Plane Intersection.cpp	/^double get_angle(PT a, PT b) {$/;"	f	typeref:typename:double
get_angle	code-library/Geometry/Voronoi Diagram.cpp	/^double get_angle(PT a, PT b) {$/;"	f	typeref:typename:double
get_angle	code/Geometry/All Pair Segment Intersection.cpp	/^double get_angle(PT a, PT b) {$/;"	f	typeref:typename:double
get_angle	code/Geometry/Geometry 2D.cpp	/^double get_angle(PT a, PT b) {$/;"	f	typeref:typename:double
get_angle	code/Geometry/Geometry 3D.cpp	/^double get_angle(PT a, PT b) {$/;"	f	typeref:typename:double
get_angle	code/Geometry/Geometry 3D.cpp	/^double get_angle(line3d l1, line3d l2) {$/;"	f	typeref:typename:double
get_angle	code/Geometry/Geometry 3D.cpp	/^double get_angle(p3 a, p3 b) {$/;"	f	typeref:typename:double
get_angle	code/Geometry/Geometry 3D.cpp	/^double get_angle(plane p, line3d l) {$/;"	f	typeref:typename:double
get_angle	code/Geometry/Geometry 3D.cpp	/^double get_angle(plane p1, plane p2) {$/;"	f	typeref:typename:double
get_angle	code/Geometry/Half Plane Intersection Dynamic.cpp	/^double get_angle(PT a, PT b) {$/;"	f	typeref:typename:double
get_angle	code/Geometry/Half Plane Intersection.cpp	/^double get_angle(PT a, PT b) {$/;"	f	typeref:typename:double
get_angle	code/Geometry/Voronoi Diagram.cpp	/^double get_angle(PT a, PT b) {$/;"	f	typeref:typename:double
get_centers	code-library/Graph Theory/Tree Isomorphism.cpp	/^  vector<int> get_centers() {$/;"	f	struct:Tree	typeref:typename:vector<int>	file:
get_centers	code/Graph Theory/Tree Isomorphism.cpp	/^  vector<int> get_centers() {$/;"	f	struct:Tree	typeref:typename:vector<int>	file:
get_circle	code-library/Geometry/Geometry 2D.cpp	/^int get_circle(PT a, PT b, double r, circle &c1, circle &c2) {$/;"	f	typeref:typename:int
get_circle	code-library/Geometry/Geometry 2D.cpp	/^int get_circle(line u, PT q, double r1, circle &c1, circle &c2) {$/;"	f	typeref:typename:int
get_circle	code/Geometry/Geometry 2D.cpp	/^int get_circle(PT a, PT b, double r, circle &c1, circle &c2) {$/;"	f	typeref:typename:int
get_circle	code/Geometry/Geometry 2D.cpp	/^int get_circle(line u, PT q, double r1, circle &c1, circle &c2) {$/;"	f	typeref:typename:int
get_comp	code-library/Graph Theory/Online Articulation Bridges.cpp	/^int get_comp (int v) {$/;"	f	typeref:typename:int
get_comp	code/Graph Theory/Online Articulation Bridges.cpp	/^int get_comp (int v) {$/;"	f	typeref:typename:int
get_continued_fraction	code-library/Number Theory/Pells Equation.py	/^def get_continued_fraction(ans, x):$/;"	f
get_continued_fraction	code/Number Theory/Pells Equation.py	/^def get_continued_fraction(ans, x):$/;"	f
get_count	code-library/Data Structures/Static to Dynamic Trick.cpp	/^  int get_count(string p) {$/;"	f	struct:aho_corasick_static	typeref:typename:int	file:
get_count	code-library/Data Structures/Static to Dynamic Trick.cpp	/^  int get_count(string s) {$/;"	f	struct:aho_corasick	typeref:typename:int	file:
get_count	code-library/Strings/Aho Corasick Dynamic.cpp	/^  int get_count(string p) {$/;"	f	struct:aho_corasick_static	typeref:typename:int	file:
get_count	code-library/Strings/Aho Corasick Dynamic.cpp	/^  int get_count(string s) {$/;"	f	struct:aho_corasick	typeref:typename:int	file:
get_count	code/Data Structures/Static to Dynamic Trick.cpp	/^  int get_count(string p) {$/;"	f	struct:aho_corasick_static	typeref:typename:int	file:
get_count	code/Data Structures/Static to Dynamic Trick.cpp	/^  int get_count(string s) {$/;"	f	struct:aho_corasick	typeref:typename:int	file:
get_count	code/Strings/Aho Corasick Dynamic.cpp	/^  int get_count(string p) {$/;"	f	struct:aho_corasick_static	typeref:typename:int	file:
get_count	code/Strings/Aho Corasick Dynamic.cpp	/^  int get_count(string s) {$/;"	f	struct:aho_corasick	typeref:typename:int	file:
get_deg	code-library/Graph Theory/Maximum Independant Set.cpp	/^int get_deg(int u) {$/;"	f	typeref:typename:int
get_deg	code/Graph Theory/Maximum Independant Set.cpp	/^int get_deg(int u) {$/;"	f	typeref:typename:int
get_direction	code-library/Geometry/Geometry 2D.cpp	/^bool get_direction(vector<PT> &p) {$/;"	f	typeref:typename:bool
get_direction	code/Geometry/Geometry 2D.cpp	/^bool get_direction(vector<PT> &p) {$/;"	f	typeref:typename:bool
get_frac	code-library/Number Theory/Continued Fractions.cpp	/^vector<ll> get_frac(ll p, ll q) {$/;"	f	typeref:typename:vector<ll>
get_frac	code/Number Theory/Continued Fractions.cpp	/^vector<ll> get_frac(ll p, ll q) {$/;"	f	typeref:typename:vector<ll>
get_hash	code-library/Strings/String Hashing 2D.cpp	/^  int get_hash() {$/;"	f	struct:Hashing	typeref:typename:int	file:
get_hash	code-library/Strings/String Hashing 2D.cpp	/^  int get_hash(int x1, int y1, int x2, int y2) { \/\/ 1-indexed$/;"	f	struct:Hashing	typeref:typename:int	file:
get_hash	code-library/Strings/String Hashing.cpp	/^  pair<int, int> get_hash() {$/;"	f	struct:Hashing	typeref:typename:pair<int,int>	file:
get_hash	code-library/Strings/String Hashing.cpp	/^  pair<int, int> get_hash(int l, int r) { \/\/ 1 - indexed$/;"	f	struct:Hashing	typeref:typename:pair<int,int>	file:
get_hash	code/Strings/String Hashing 2D.cpp	/^  int get_hash() {$/;"	f	struct:Hashing	typeref:typename:int	file:
get_hash	code/Strings/String Hashing 2D.cpp	/^  int get_hash(int x1, int y1, int x2, int y2) { \/\/ 1-indexed$/;"	f	struct:Hashing	typeref:typename:int	file:
get_hash	code/Strings/String Hashing.cpp	/^  pair<int, int> get_hash() {$/;"	f	struct:Hashing	typeref:typename:pair<int,int>	file:
get_hash	code/Strings/String Hashing.cpp	/^  pair<int, int> get_hash(int l, int r) { \/\/ 1 - indexed$/;"	f	struct:Hashing	typeref:typename:pair<int,int>	file:
get_hull	code-library/Geometry/Onion Decomposition.cpp	/^    vector<int> get_hull() {$/;"	f	struct:LeftHull	typeref:typename:vector<int>	file:
get_hull	code-library/Geometry/Onion Decomposition.cpp	/^    void get_hull(int w, int l, int r, vector<int>& res) {$/;"	f	struct:LeftHull	typeref:typename:void	file:
get_hull	code/Geometry/Onion Decomposition.cpp	/^    vector<int> get_hull() {$/;"	f	struct:LeftHull	typeref:typename:vector<int>	file:
get_hull	code/Geometry/Onion Decomposition.cpp	/^    void get_hull(int w, int l, int r, vector<int>& res) {$/;"	f	struct:LeftHull	typeref:typename:void	file:
get_id	code-library/Graph Theory/Kirchoffs Theorem.cpp	/^int get_id(int k) {$/;"	f	typeref:typename:int
get_id	code-library/Graph Theory/L R Flow with Dinic.cpp	/^int get_id(map<int, int> &mp, int k) {$/;"	f	typeref:typename:int
get_id	code-library/Number Theory/Min_25 Sieve.cpp	/^int get_id(ll x) {$/;"	f	typeref:typename:int
get_id	code/Graph Theory/Kirchoffs Theorem.cpp	/^int get_id(int k) {$/;"	f	typeref:typename:int
get_id	code/Graph Theory/L R Flow with Dinic.cpp	/^int get_id(map<int, int> &mp, int k) {$/;"	f	typeref:typename:int
get_id	code/Number Theory/Min_25 Sieve.cpp	/^int get_id(ll x) {$/;"	f	typeref:typename:int
get_kth	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^mint get_kth(mint a, mint b, int k) {$/;"	f	typeref:typename:mint
get_kth	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^mint get_kth(mint a, mint b, int k) {$/;"	f	typeref:typename:mint
get_lca	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  inline int get_lca(int u, int v) {$/;"	f	struct:Blossom	typeref:typename:int	file:
get_lca	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  inline int get_lca(int u, int v) {$/;"	f	struct:Blossom	typeref:typename:int	file:
get_lcp	code-library/Strings/Suffix Array Isomorphic.cpp	/^  int get_lcp(int i, int j) { \/\/ lcp of suffix starting from i and j$/;"	f	struct:IsomorphicSuffixArray	typeref:typename:int	file:
get_lcp	code-library/Strings/Suffix Array Isomorphic.cpp	/^  int get_lcp(int i, int j) { \/\/ lcp of suffix starting from i and j$/;"	f	struct:SuffixArray	typeref:typename:int	file:
get_lcp	code-library/Strings/Suffix Array.cpp	/^  int get_lcp(int i, int j) { \/\/ lcp of suffix starting from i and j$/;"	f	struct:SuffixArray	typeref:typename:int	file:
get_lcp	code/Strings/Suffix Array Isomorphic.cpp	/^  int get_lcp(int i, int j) { \/\/ lcp of suffix starting from i and j$/;"	f	struct:IsomorphicSuffixArray	typeref:typename:int	file:
get_lcp	code/Strings/Suffix Array Isomorphic.cpp	/^  int get_lcp(int i, int j) { \/\/ lcp of suffix starting from i and j$/;"	f	struct:SuffixArray	typeref:typename:int	file:
get_lcp	code/Strings/Suffix Array.cpp	/^  int get_lcp(int i, int j) { \/\/ lcp of suffix starting from i and j$/;"	f	struct:SuffixArray	typeref:typename:int	file:
get_lcp_brute	code-library/Strings/Suffix Array Isomorphic.cpp	/^  int get_lcp_brute(const int &i, const int &j) { \/\/ O(alpha)$/;"	f	struct:IsomorphicSuffixArray	typeref:typename:int	file:
get_lcp_brute	code/Strings/Suffix Array Isomorphic.cpp	/^  int get_lcp_brute(const int &i, const int &j) { \/\/ O(alpha)$/;"	f	struct:IsomorphicSuffixArray	typeref:typename:int	file:
get_max	code-library/Data Structures/Trie.cpp	/^  int get_max(int x) { \/\/ returns maximum of val ^ x$/;"	f	struct:Trie	typeref:typename:int	file:
get_max	code/Data Structures/Trie.cpp	/^  int get_max(int x) { \/\/ returns maximum of val ^ x$/;"	f	struct:Trie	typeref:typename:int	file:
get_mex	code-library/Miscellaneous/MEX of all Subarrays.cpp	/^  int get_mex(int n, int b, int e, int i) { \/\/ mex of [i... cur_id]$/;"	f	struct:ST	typeref:typename:int	file:
get_mex	code/Miscellaneous/MEX of all Subarrays.cpp	/^  int get_mex(int n, int b, int e, int i) { \/\/ mex of [i... cur_id]$/;"	f	struct:ST	typeref:typename:int	file:
get_min	code-library/Data Structures/Trie.cpp	/^  int get_min(int x) { \/\/ returns minimum of val ^ x$/;"	f	struct:Trie	typeref:typename:int	file:
get_min	code-library/Miscellaneous/MEX of all Subarrays.cpp	/^  int get_min(int n, int b, int e, int i, int j) {$/;"	f	struct:ST	typeref:typename:int	file:
get_min	code/Data Structures/Trie.cpp	/^  int get_min(int x) { \/\/ returns minimum of val ^ x$/;"	f	struct:Trie	typeref:typename:int	file:
get_min	code/Miscellaneous/MEX of all Subarrays.cpp	/^  int get_min(int n, int b, int e, int i, int j) {$/;"	f	struct:ST	typeref:typename:int	file:
get_next	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    iter get_next(iter it) { return (next(it) == end() ? begin() : next(it)); }$/;"	f	struct:HalfPlaneSet	typeref:typename:iter	file:
get_next	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    iter get_next(iter it) { return (next(it) == end() ? begin() : next(it)); }$/;"	f	struct:HalfPlaneSet	typeref:typename:iter	file:
get_parent	code-library/Data Structures/Link Cut Tree.cpp	/^  int get_parent(int u) {$/;"	f	struct:LCT	typeref:typename:int	file:
get_parent	code/Data Structures/Link Cut Tree.cpp	/^  int get_parent(int u) {$/;"	f	struct:LCT	typeref:typename:int	file:
get_path	code-library/Data Structures/Top Tree.cpp	/^  friend top_tree_node* get_path(top_tree_node* a, top_tree_node* b) {$/;"	f	typeref:typename:top_tree_node *	file:
get_path	code/Data Structures/Top Tree.cpp	/^  friend top_tree_node* get_path(top_tree_node* a, top_tree_node* b) {$/;"	f	typeref:typename:top_tree_node *	file:
get_perm	code-library/Number Theory/Factoradic Number System.cpp	/^vector<int> get_perm(int n, vector<int> f) {$/;"	f	typeref:typename:vector<int>
get_perm	code/Number Theory/Factoradic Number System.cpp	/^vector<int> get_perm(int n, vector<int> f) {$/;"	f	typeref:typename:vector<int>
get_points	code-library/Geometry/Geometry 2D.cpp	/^	pair<PT, PT> get_points() { \/\/extract any two points from this line$/;"	f	struct:line	typeref:typename:pair<PT,PT>	file:
get_points	code/Geometry/Geometry 2D.cpp	/^	pair<PT, PT> get_points() { \/\/extract any two points from this line$/;"	f	struct:line	typeref:typename:pair<PT,PT>	file:
get_pos	code-library/Data Structures/Implicit Treap.cpp	/^  int get_pos(int value) {$/;"	f	struct:treap	typeref:typename:int	file:
get_pos	code-library/Data Structures/Implicit Treap.cpp	/^  int get_pos(pnode curr, pnode son = nullptr) {$/;"	f	struct:treap	typeref:typename:int	file:
get_pos	code/Data Structures/Implicit Treap.cpp	/^  int get_pos(int value) {$/;"	f	struct:treap	typeref:typename:int	file:
get_pos	code/Data Structures/Implicit Treap.cpp	/^  int get_pos(pnode curr, pnode son = nullptr) {$/;"	f	struct:treap	typeref:typename:int	file:
get_pr	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  inline int get_pr(int b, int xr) {$/;"	f	struct:Blossom	typeref:typename:int	file:
get_pr	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  inline int get_pr(int b, int xr) {$/;"	f	struct:Blossom	typeref:typename:int	file:
get_prev	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    iter get_prev(iter it) { return (it == begin() ? prev(end()) : prev(it)); }$/;"	f	struct:HalfPlaneSet	typeref:typename:iter	file:
get_prev	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    iter get_prev(iter it) { return (it == begin() ? prev(end()) : prev(it)); }$/;"	f	struct:HalfPlaneSet	typeref:typename:iter	file:
get_prob_name	.compilingScripts/download_prob.py	/^def get_prob_name(data):$/;"	f
get_range	code-library/Data Structures/Permutation Tree.cpp	/^pair<int, int> get_range(pair<int, int> x, pair<int, int> y) {$/;"	f	typeref:typename:pair<int,int>
get_range	code/Data Structures/Permutation Tree.cpp	/^pair<int, int> get_range(pair<int, int> x, pair<int, int> y) {$/;"	f	typeref:typename:pair<int,int>
get_size	code-library/Data Structures/DSU.cpp	/^  int get_size(int i) {$/;"	f	struct:DSU	typeref:typename:int	file:
get_size	code-library/Data Structures/Persistent UnionFind.cpp	/^  int get_size(int r, int u) { return sz.get_val(r, find(r, u)); }$/;"	f	struct:PersistentDSU	typeref:typename:int	file:
get_size	code-library/Graph Theory/Boruvka's Algorithm.cpp	/^  int get_size(int i) { return size[find(i)]; }$/;"	f	struct:dsu	typeref:typename:int	file:
get_size	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  int get_size(int i) {$/;"	f	struct:dsu	typeref:typename:int	file:
get_size	code-library/Graph Theory/Kirchoffs Theorem.cpp	/^  int get_size(int i) {$/;"	f	struct:dsu	typeref:typename:int	file:
get_size	code-library/Graph Theory/Krushkal's MST.cpp	/^  int get_size(int i) { return size[find(i)]; }$/;"	f	struct:dsu	typeref:typename:int	file:
get_size	code/Data Structures/DSU.cpp	/^  int get_size(int i) {$/;"	f	struct:DSU	typeref:typename:int	file:
get_size	code/Data Structures/Persistent UnionFind.cpp	/^  int get_size(int r, int u) { return sz.get_val(r, find(r, u)); }$/;"	f	struct:PersistentDSU	typeref:typename:int	file:
get_size	code/Graph Theory/Boruvka's Algorithm.cpp	/^  int get_size(int i) { return size[find(i)]; }$/;"	f	struct:dsu	typeref:typename:int	file:
get_size	code/Graph Theory/Gomory Hu Tree.cpp	/^  int get_size(int i) {$/;"	f	struct:dsu	typeref:typename:int	file:
get_size	code/Graph Theory/Kirchoffs Theorem.cpp	/^  int get_size(int i) {$/;"	f	struct:dsu	typeref:typename:int	file:
get_size	code/Graph Theory/Krushkal's MST.cpp	/^  int get_size(int i) { return size[find(i)]; }$/;"	f	struct:dsu	typeref:typename:int	file:
get_sphere	code-library/Geometry/Geometry 3D.cpp	/^p3 get_sphere(double r, double lat, double lon) {$/;"	f	typeref:typename:p3
get_sphere	code/Geometry/Geometry 3D.cpp	/^p3 get_sphere(double r, double lat, double lon) {$/;"	f	typeref:typename:p3
get_subtree	code-library/Data Structures/Top Tree.cpp	/^  friend top_tree_node* get_subtree(top_tree_node* rt, top_tree_node* n) {$/;"	f	typeref:typename:top_tree_node *	file:
get_subtree	code/Data Structures/Top Tree.cpp	/^  friend top_tree_node* get_subtree(top_tree_node* rt, top_tree_node* n) {$/;"	f	typeref:typename:top_tree_node *	file:
get_sum	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^    mint get_sum(mint n) {return (((a * 2) + (n - 1) * d) * n) * ((mod + 1) \/ 2);}$/;"	f	struct:ST::Int	typeref:typename:mint	file:
get_sum	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^    mint get_sum(mint n) {return (((a * 2) + (n - 1) * d) * n) * ((mod + 1) \/ 2);}$/;"	f	struct:ST::Int	typeref:typename:mint	file:
get_tree	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  const vector<edge> &get_tree() {$/;"	f	struct:GomoryHuTree	typeref:typename:const vector<edge> &	file:
get_tree	code/Graph Theory/Gomory Hu Tree.cpp	/^  const vector<edge> &get_tree() {$/;"	f	struct:GomoryHuTree	typeref:typename:const vector<edge> &	file:
get_val	code-library/Data Structures/Implicit Treap.cpp	/^  int get_val(int pos) {$/;"	f	struct:treap	typeref:typename:int	file:
get_val	code-library/Data Structures/Persistent Array.cpp	/^  T get_val(int r, int i) {$/;"	f	struct:PersistentArray	typeref:typename:T	file:
get_val	code-library/Data Structures/Persistent Array.cpp	/^  T get_val(node* cur, int i, int l, int r) {$/;"	f	struct:PersistentArray	typeref:typename:T	file:
get_val	code-library/Data Structures/Persistent Queue.cpp	/^  T get_val(int r, int i) {$/;"	f	struct:PersistentArray	typeref:typename:T	file:
get_val	code-library/Data Structures/Persistent Queue.cpp	/^  T get_val(node* cur, int i, int l, int r) {$/;"	f	struct:PersistentArray	typeref:typename:T	file:
get_val	code-library/Data Structures/Persistent UnionFind.cpp	/^  T get_val(int r, int i) {$/;"	f	struct:PersistentArray	typeref:typename:T	file:
get_val	code-library/Data Structures/Persistent UnionFind.cpp	/^  T get_val(node* cur, int i, int l, int r) {$/;"	f	struct:PersistentArray	typeref:typename:T	file:
get_val	code/Data Structures/Implicit Treap.cpp	/^  int get_val(int pos) {$/;"	f	struct:treap	typeref:typename:int	file:
get_val	code/Data Structures/Persistent Array.cpp	/^  T get_val(int r, int i) {$/;"	f	struct:PersistentArray	typeref:typename:T	file:
get_val	code/Data Structures/Persistent Array.cpp	/^  T get_val(node* cur, int i, int l, int r) {$/;"	f	struct:PersistentArray	typeref:typename:T	file:
get_val	code/Data Structures/Persistent Queue.cpp	/^  T get_val(int r, int i) {$/;"	f	struct:PersistentArray	typeref:typename:T	file:
get_val	code/Data Structures/Persistent Queue.cpp	/^  T get_val(node* cur, int i, int l, int r) {$/;"	f	struct:PersistentArray	typeref:typename:T	file:
get_val	code/Data Structures/Persistent UnionFind.cpp	/^  T get_val(int r, int i) {$/;"	f	struct:PersistentArray	typeref:typename:T	file:
get_val	code/Data Structures/Persistent UnionFind.cpp	/^  T get_val(node* cur, int i, int l, int r) {$/;"	f	struct:PersistentArray	typeref:typename:T	file:
get_var	code-library/Math/Gaussian Elimination Modulo 2.cpp	/^int get_var(string t) { return atoi(t.substr(1).c_str()) - 1; }$/;"	f	typeref:typename:int
get_var	code/Math/Gaussian Elimination Modulo 2.cpp	/^int get_var(string t) { return atoi(t.substr(1).c_str()) - 1; }$/;"	f	typeref:typename:int
getarea	code-library/Geometry/Geometry 2D.cpp	/^    void getarea(int i, double lef, double rig) {$/;"	f	struct:CircleUnion	typeref:typename:void	file:
getarea	code/Geometry/Geometry 2D.cpp	/^    void getarea(int i, double lef, double rig) {$/;"	f	struct:CircleUnion	typeref:typename:void	file:
global	code-library/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^ll ed, far, global = LLONG_MAX, dist[N];$/;"	v	typeref:typename:ll
global	code/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^ll ed, far, global = LLONG_MAX, dist[N];$/;"	v	typeref:typename:ll
go	code-library/Data Structures/LCA.cpp	/^int go(int u, int v, int k) {$/;"	f	typeref:typename:int
go	code-library/Data Structures/Persistent Trie.cpp	/^  bool go(int l) const {$/;"	f	struct:node_t	typeref:typename:bool	file:
go	code-library/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  void go(int src) {$/;"	f	struct:Euler	typeref:typename:void	file:
go	code-library/Graph Theory/LCA.cpp	/^int go(int u, int v, int k) {$/;"	f	typeref:typename:int
go	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  int go(int v, char ch) {$/;"	f	struct:AhoCorasick	typeref:typename:int	file:
go	code/Data Structures/LCA.cpp	/^int go(int u, int v, int k) {$/;"	f	typeref:typename:int
go	code/Data Structures/Persistent Trie.cpp	/^  bool go(int l) const {$/;"	f	struct:node_t	typeref:typename:bool	file:
go	code/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  void go(int src) {$/;"	f	struct:Euler	typeref:typename:void	file:
go	code/Graph Theory/LCA.cpp	/^int go(int u, int v, int k) {$/;"	f	typeref:typename:int
go	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  int go(int v, char ch) {$/;"	f	struct:AhoCorasick	typeref:typename:int	file:
graph	practice/usacoguide/gold/SP/pump.cpp	/^vector<pair<int, pair<int, int>>> graph[100000];$/;"	v	typeref:typename:vector<pair<int,pair<int,int>>>[100000]
graph	practice/usacoguide/gold/SP/visitfj.cpp	/^vector<pair<pair<int, int>, int>> graph[105][105];$/;"	v	typeref:typename:vector<pair<pair<int,int>,int>>[105][105]
graph	practice/usacoguide/gold/SP/visitfj/main.cpp	/^vector<pair<pair<int, int>, int>> graph[105][105];$/;"	v	typeref:typename:vector<pair<pair<int,int>,int>>[105][105]
greatCircleDist	code-library/Geometry/Geometry 3D.cpp	/^double greatCircleDist(p3 o, double r, p3 a, p3 b) {$/;"	f	typeref:typename:double
greatCircleDist	code/Geometry/Geometry 3D.cpp	/^double greatCircleDist(p3 o, double r, p3 a, p3 b) {$/;"	f	typeref:typename:double
grid	practice/cf/random/1700/test2.cpp	/^int grid[mxN][mxN], cnt[1005];$/;"	v	typeref:typename:int[][]
grid	practice/cpbook/ch1/1.6/chess/10284/main.cpp	/^char grid[8][8];$/;"	v	typeref:typename:char[8][8]
grid	practice/cpbook/ch1/1.6/game/easier/10189/main.cpp	/^char grid[mxN][mxN];$/;"	v	typeref:typename:char[][]
grid	practice/cpbook/ch2/2.2/2D/11581/main.cpp	/^int grid[mxN][mxN], store_grid[mxN][mxN];$/;"	v	typeref:typename:int[][]
grid	practice/usacoguide/gold/bfs/cownav.cpp	/^bool grid[mxN][mxN];$/;"	v	typeref:typename:bool[][]
grid	practice/usacoguide/gold/bfs/mecho/main.cpp	/^char grid[mxN][mxN], store_grid[mxN][mxN];$/;"	v	typeref:typename:char[][]
grid	practice/usacoguide/gold/bfs/mechonew/main.cpp	/^char grid[mxN][mxN];$/;"	v	typeref:typename:char[][]
grid	practice/usacoguide/gold/bfs/monsters.cpp	/^char grid[mxN][mxN];$/;"	v	typeref:typename:char[][]
grid	practice/usacoguide/gold/dsu/tractor/main.cpp	/^int grid[mxN][mxN];$/;"	v	typeref:typename:int[][]
grid	practice/usacoguide/gold/dsu/tractor/mountain.cpp	/^int grid[mxN][mxN];$/;"	v	typeref:typename:int[][]
grid	practice/usacoguide/gold/introDP/flag.cpp	/^char grid[mxN][mxN];$/;"	v	typeref:typename:char[][]
grid	practice/usacoguide/gold/introDP/gridpaths.cpp	/^char grid[mxN][mxN];$/;"	v	typeref:typename:char[][]
grid	practice/usacoguide/gold/introDP/slalom.cpp	/^int grid[mxN][mxN], dp[mxN][mxN];$/;"	v	typeref:typename:int[][]
grid	practice/usacoguide/silver/idk/maze/main.cpp	/^pair<char, pair<int, int>> grid[mxN][mxN];$/;"	v	typeref:typename:pair<char,pair<int,int>>[][]
grid1	contests/LIT2021/C.cpp	/^char grid1[mxN][mxN], grid2[mxN][mxN];$/;"	v	typeref:typename:char[][]
grid2	contests/LIT2021/C.cpp	/^char grid1[mxN][mxN], grid2[mxN][mxN];$/;"	v	typeref:typename:char[][]
ground	code-library/Game Theory/Green Hackenbush.cpp	/^int ground[N];\/\/\/set 1 for the ground nodes$/;"	v	typeref:typename:int[]
ground	code/Game Theory/Green Hackenbush.cpp	/^int ground[N];\/\/\/set 1 for the ground nodes$/;"	v	typeref:typename:int[]
group	practice/cf/random/1700/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	s
group	practice/cf/random/1700/1618E/problem.json	/^{"name": "E. Singers' Tour", "group": "Codeforces - Codeforces Round #760 (Div. 3)", "url": "htt/;"	s
group	practice/cf/random/coloring/problem.json	/^{"name": "A. Dreamoon Likes Coloring", "group": "Codeforces - Codeforces Round #631 (Div. 1) - T/;"	s
group	practice/cf/random/diane/problem.json	/^{"name": "D. Diane", "group": "Codeforces - Codeforces Round #735 (Div. 2)", "url": "https:\/\/c/;"	s
group	practice/cf/random/pink/problem.json	/^{"name": "C. Pinkie Pie Eats Patty-cakes", "group": "Codeforces - Codeforces Round #662 (Div. 2)/;"	s
group	practice/cf/stuff/dec 20 2021/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	s
group	practice/usacoguide/gold/SP/dining/problem.json	/^{"name": "Problem 1. Fine Dining", "group": "USACO - USACO 2018 December Contest, Gold", "url": /;"	s
group	practice/usacoguide/gold/SP/visitfj/problem.json	/^{"name": "Problem 1. Why Did the Cow Cross the Road", "group": "USACO - USACO 2017 February Cont/;"	s
group	practice/usacoguide/gold/bfs/cownav/problem.json	/^{"name": "Problem 3. Cow Navigation", "group": "USACO - USACO 2017 January Contest, Gold", "url"/;"	s
group	practice/usacoguide/gold/bfs/swap/problem.json	/^{"name": "Swap Game", "group": "CSES - CSES Problem Set", "url": "https:\/\/cses.fi\/problemset\//;"	s
group	practice/usacoguide/gold/dsu/closing/problem.json	/^{"name": "Problem 2. Closing the Farm", "group": "USACO - USACO 2016 US Open Contest, Gold", "ur/;"	s
group	practice/usacoguide/gold/dsu/moocast/problem.json	/^{"name": "Problem 1. Moocast", "group": "USACO - USACO 2016 December Contest, Gold", "url": "htt/;"	s
group	practice/usacoguide/gold/dsu/mootube/problem.json	/^{"name": "Problem 1. MooTube", "group": "USACO - USACO 2018 January Contest, Gold", "url": "http/;"	s
group	practice/usacoguide/gold/dsu/tractor/problem.json	/^{"name": "Problem 2. Tractor", "group": "USACO - USACO 2013 February Contest, Silver", "url": "h/;"	s
group	practice/usacoguide/gold/dsu/wormhole/problem.json	/^{"name": "Problem 3. Wormhole Sort", "group": "USACO - USACO 2020 January Contest, Silver", "url/;"	s
group	practice/usacoguide/silver/idk/lirs/problem.json	/^{"name": "Problem 3. Liars and Truth Tellers", "group": "USACO - USACO 2013 January Contest, Bro/;"	s
group	practice/usacoguide/silver/idk/maze/problem.json	/^{"name": "Problem 1. Maze Tac Toe", "group": "USACO - USACO 2021 US Open, Silver", "url": "http:/;"	s
gt	code-library/Geometry/Point Location.cpp	/^bool gt(const ll& a, const ll& b) { return a > b; }$/;"	f	typeref:typename:bool
gt	code-library/Graph Theory/2 SAT.cpp	/^  vector< vector<int> > g, gt;$/;"	m	struct:twosat	typeref:typename:vector<vector<int>>	file:
gt	code/Geometry/Point Location.cpp	/^bool gt(const ll& a, const ll& b) { return a > b; }$/;"	f	typeref:typename:bool
gt	code/Graph Theory/2 SAT.cpp	/^  vector< vector<int> > g, gt;$/;"	m	struct:twosat	typeref:typename:vector<vector<int>>	file:
h	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^    int h;$/;"	m	struct:Hafnian	typeref:typename:int	file:
h	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  vector<cost_t> h;$/;"	m	struct:mcSFlow	typeref:typename:vector<cost_t>	file:
h	code-library/Math/Hafnian of a Matrix.cpp	/^  int h;$/;"	v	namespace:Hafnian	typeref:typename:int
h	code/Graph Theory/Hafnian of a Matrix.cpp	/^    int h;$/;"	m	struct:Hafnian	typeref:typename:int	file:
h	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  vector<cost_t> h;$/;"	m	struct:mcSFlow	typeref:typename:vector<cost_t>	file:
h	code/Math/Hafnian of a Matrix.cpp	/^  int h;$/;"	v	namespace:Hafnian	typeref:typename:int
half	code-library/Geometry/Geometry 2D.cpp	/^bool half(PT p) {$/;"	f	typeref:typename:bool
half	code-library/Geometry/Voronoi Diagram.cpp	/^bool half(PT p) {$/;"	f	typeref:typename:bool
half	code/Geometry/Geometry 2D.cpp	/^bool half(PT p) {$/;"	f	typeref:typename:bool
half	code/Geometry/Voronoi Diagram.cpp	/^bool half(PT p) {$/;"	f	typeref:typename:bool
half_plane_intersection	code-library/Geometry/Geometry 2D.cpp	/^vector<PT> half_plane_intersection(vector<HP> h) {$/;"	f	typeref:typename:vector<PT>
half_plane_intersection	code-library/Geometry/Half Plane Intersection.cpp	/^vector<PT> half_plane_intersection(vector<HP> h) {$/;"	f	typeref:typename:vector<PT>
half_plane_intersection	code/Geometry/Geometry 2D.cpp	/^vector<PT> half_plane_intersection(vector<HP> h) {$/;"	f	typeref:typename:vector<PT>
half_plane_intersection	code/Geometry/Half Plane Intersection.cpp	/^vector<PT> half_plane_intersection(vector<HP> h) {$/;"	f	typeref:typename:vector<PT>
has	code-library/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^pair<int, int> has[2][N][205]; \/\/ (2, number of nodes, number of colors)$/;"	v	namespace:EdgeColoring	typeref:typename:pair<int,int>[2][][205]
has	code/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^pair<int, int> has[2][N][205]; \/\/ (2, number of nodes, number of colors)$/;"	v	namespace:EdgeColoring	typeref:typename:pair<int,int>[2][][205]
has_words_before	init.lua	/^local has_words_before = function()$/;"	f
head	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int T, head[N], st[N], en[N];$/;"	v	typeref:typename:int[]
head	code-library/Data Structures/HLD.cpp	/^int T, head[N], st[N], en[N];$/;"	v	typeref:typename:int[]
head	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int T, head[N], st[N], en[N];$/;"	v	typeref:typename:int[]
head	code/Data Structures/HLD.cpp	/^int T, head[N], st[N], en[N];$/;"	v	typeref:typename:int[]
heap	code-library/Data Structures/Persistent Meldable Heap.cpp	/^  heap(node* t = 0): root(t) {}$/;"	f	struct:heap	file:
heap	code-library/Data Structures/Persistent Meldable Heap.cpp	/^struct heap {$/;"	s	file:
heap	code-library/Graph Theory/Eppsteins Algorithm.cpp	/^  heap(node* t = 0): root(t) {}$/;"	f	struct:heap	file:
heap	code-library/Graph Theory/Eppsteins Algorithm.cpp	/^struct heap {$/;"	s	file:
heap	code/Data Structures/Persistent Meldable Heap.cpp	/^  heap(node* t = 0): root(t) {}$/;"	f	struct:heap	file:
heap	code/Data Structures/Persistent Meldable Heap.cpp	/^struct heap {$/;"	s	file:
heap	code/Graph Theory/Eppsteins Algorithm.cpp	/^  heap(node* t = 0): root(t) {}$/;"	f	struct:heap	file:
heap	code/Graph Theory/Eppsteins Algorithm.cpp	/^struct heap {$/;"	s	file:
hexa	practice/cpbook/ch1/1.4/medium/11956.cpp	/^string hexa(int x) {$/;"	f	typeref:typename:string
hi	code-library/Data Structures/Wavelet Tree.cpp	/^  int lo, hi;$/;"	m	struct:wavelet_tree	typeref:typename:int	file:
hi	code-library/Strings/Number of Palindromes in Range.cpp	/^  int lo, hi;$/;"	m	struct:wavelet_tree	typeref:typename:int	file:
hi	code/Data Structures/Wavelet Tree.cpp	/^  int lo, hi;$/;"	m	struct:wavelet_tree	typeref:typename:int	file:
hi	code/Strings/Number of Palindromes in Range.cpp	/^  int lo, hi;$/;"	m	struct:wavelet_tree	typeref:typename:int	file:
hi	contests/Codeforces/1552/1552A.cpp	/^int hi[5] = {1, 2, 3, 4, 5};$/;"	v	typeref:typename:int[5]
high	code-library/Strings/Suffix Array Isomorphic.cpp	/^int buc[N], r[N], suf[N], X[N], Y[N], high[N];$/;"	v	typeref:typename:int[]
high	code/Strings/Suffix Array Isomorphic.cpp	/^int buc[N], r[N], suf[N], X[N], Y[N], high[N];$/;"	v	typeref:typename:int[]
hs	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  vector<vector<int> > hs;$/;"	m	struct:mcSFlow	typeref:typename:vector<vector<int>>	file:
hs	code-library/Strings/String Hashing 2D.cpp	/^  vector<vector<int>> hs;$/;"	m	struct:Hashing	typeref:typename:vector<vector<int>>	file:
hs	code-library/Strings/String Hashing.cpp	/^  vector<pair<int, int>> hs; \/\/ 1 - indexed$/;"	m	struct:Hashing	typeref:typename:vector<pair<int,int>>	file:
hs	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  vector<vector<int> > hs;$/;"	m	struct:mcSFlow	typeref:typename:vector<vector<int>>	file:
hs	code/Strings/String Hashing 2D.cpp	/^  vector<vector<int>> hs;$/;"	m	struct:Hashing	typeref:typename:vector<vector<int>>	file:
hs	code/Strings/String Hashing.cpp	/^  vector<pair<int, int>> hs; \/\/ 1 - indexed$/;"	m	struct:Hashing	typeref:typename:vector<pair<int,int>>	file:
i	code-library/Data Structures/Divide and Conquer for Insert and Query Problems.cpp	/^    for(int i = 1; i <= n; i++) {$/;"	v	typeref:typename:int
i	code/Data Structures/Divide and Conquer for Insert and Query Problems.cpp	/^    for(int i = 1; i <= n; i++) {$/;"	v	typeref:typename:int
i128	code-library/Geometry/Delaunay Triangulation.cpp	/^typedef __int128_t i128; \/\/ (can be ll if coords are < 2e4)$/;"	t	typeref:typename:__int128_t	file:
i128	code-library/Geometry/Voronoi Diagram.cpp	/^typedef __int128_t i128; \/\/ (can be ll if coords are < 2e4)$/;"	t	typeref:typename:__int128_t	file:
i128	code/Geometry/Delaunay Triangulation.cpp	/^typedef __int128_t i128; \/\/ (can be ll if coords are < 2e4)$/;"	t	typeref:typename:__int128_t	file:
i128	code/Geometry/Voronoi Diagram.cpp	/^typedef __int128_t i128; \/\/ (can be ll if coords are < 2e4)$/;"	t	typeref:typename:__int128_t	file:
i64	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^using i64 = long long;$/;"	t	typeref:typename:long long	file:
i64	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^using i64 = long long;$/;"	t	typeref:typename:long long	file:
ibuckets	code-library/Miscellaneous/Schreier–Sims algorithm.cpp	/^  vector<vector<vector<int>>> buckets, ibuckets;$/;"	m	struct:Group	typeref:typename:vector<vector<vector<int>>>	file:
ibuckets	code/Miscellaneous/Schreier–Sims algorithm.cpp	/^  vector<vector<vector<int>>> buckets, ibuckets;$/;"	m	struct:Group	typeref:typename:vector<vector<vector<int>>>	file:
id	code-library/Data Structures/Binarizing a Tree.cpp	/^  int level = 0, id = 0, cnt = 0;$/;"	m	struct:node	typeref:typename:int	file:
id	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^  int level = 0, id = 0, cnt = 0;$/;"	m	struct:node	typeref:typename:int	file:
id	code-library/Data Structures/MOs Algorithm.cpp	/^  int l, r, id;$/;"	m	struct:query	typeref:typename:int	file:
id	code-library/Data Structures/MOs on tree.cpp	/^  int l, r, id;$/;"	m	struct:query	typeref:typename:int	file:
id	code-library/Data Structures/MOs on tree.cpp	/^int st[N], en[N], T, par[N][20], dep[N], id[N * 2];$/;"	v	typeref:typename:int[]
id	code-library/Data Structures/MOs with Update.cpp	/^  int l, r, t, id;$/;"	m	struct:query	typeref:typename:int	file:
id	code-library/Data Structures/Permutation Tree.cpp	/^int id; \/\/new index to assign to nodes$/;"	v	typeref:typename:int
id	code-library/Data Structures/Segment Tree Merging.cpp	/^  int id[N * 30];$/;"	m	struct:STM	typeref:typename:int[]	file:
id	code-library/Dynamic Programming Optimizations/Subset Sum in SQRT.cpp	/^vector<int> g[N], id[N];$/;"	v	typeref:typename:vector<int>[]
id	code-library/Game Theory/Blue Red Hackenbush.cpp	/^int id[N], vis[N];$/;"	v	typeref:typename:int[]
id	code-library/Geometry/All Pair Segment Intersection.cpp	/^    int id;$/;"	m	struct:seg	typeref:typename:int	file:
id	code-library/Geometry/All Pair Segment Intersection.cpp	/^    int ty, id;$/;"	m	struct:event	typeref:typename:int	file:
id	code-library/Geometry/Onion Decomposition.cpp	/^map<PT, int> id;$/;"	v	typeref:typename:map<PT,int>
id	code-library/Geometry/Point Location.cpp	/^        int id = 0;$/;"	m	struct:DCEL::edge	typeref:typename:int	file:
id	code-library/Graph Theory/Block Cut Tree.cpp	/^int dep[N], par[N][20], cnt[N], id[N];$/;"	v	typeref:typename:int[]
id	code-library/Graph Theory/Chinese Postman Problem.cpp	/^  int mat[N], stk[N], id[N], vis[N];$/;"	m	struct:RandomizedMatching	typeref:typename:int[]	file:
id	code-library/Graph Theory/Dinics Algorithm.cpp	/^    int id;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
id	code-library/Graph Theory/Dominator Tree.cpp	/^int id[N], rev[N], T;$/;"	v	typeref:typename:int[]
id	code-library/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^int deg[N][2], id[N][2], l, r;$/;"	v	typeref:typename:int[][2]
id	code-library/Graph Theory/Euler Path Directed.cpp	/^string id[N];$/;"	v	typeref:typename:string[]
id	code-library/Graph Theory/L R Flow with Dinic.cpp	/^    int id;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
id	code-library/Graph Theory/L R Flow with Dinic.cpp	/^    int u, v, l, r, id;$/;"	m	struct:LR_Flow::edge	typeref:typename:int	file:
id	code-library/Graph Theory/L R Flow with MCMF.cpp	/^    int id;$/;"	m	struct:MCMF::edge	typeref:typename:int	file:
id	code-library/Graph Theory/Manhattan MST.cpp	/^  int val, id;$/;"	m	struct:node	typeref:typename:int	file:
id	code-library/Graph Theory/Manhattan MST.cpp	/^  int x, y, id;$/;"	m	struct:PT	typeref:typename:int	file:
id	code-library/Graph Theory/Maximum Closure Problem.cpp	/^    int id;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
id	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^    int id;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
id	code-library/Graph Theory/Min Cost Max Flow.cpp	/^    int id;$/;"	m	struct:MCMF::edge	typeref:typename:int	file:
id	code-library/Graph Theory/Min Cut in a Planar Graph.cpp	/^inline int id(int i, int j) {$/;"	f	typeref:typename:int
id	code-library/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^int n, m, U[M], V[M], id[N], par[N];$/;"	v	typeref:typename:int[]
id	code-library/Graph Theory/Minimum Weight Cycle For Each Edge.cpp	/^int g[N][N], ans[N * N], last[N], dp[N * N], id[N][N], W[N * N];$/;"	v	typeref:typename:int[][]
id	code-library/Graph Theory/Randomized Matching Weighted.cpp	/^	int mat[N], stk[N], id[N], vis[N];$/;"	m	struct:RandomizedMatching	typeref:typename:int[]	file:
id	code-library/Graph Theory/Stable Marriage Problem.cpp	/^int m[N][N], w[N][N], id[N], marry[N], ans[N], pref[N][N];$/;"	v	typeref:typename:int[]
id	code-library/Graph Theory/Unique Min Cut.cpp	/^    int id;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
id	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  int l, r, id;$/;"	m	struct:query	typeref:typename:int	file:
id	code/Data Structures/Binarizing a Tree.cpp	/^  int level = 0, id = 0, cnt = 0;$/;"	m	struct:node	typeref:typename:int	file:
id	code/Data Structures/Centroid Decomposition Persistent.cpp	/^  int level = 0, id = 0, cnt = 0;$/;"	m	struct:node	typeref:typename:int	file:
id	code/Data Structures/MOs Algorithm.cpp	/^  int l, r, id;$/;"	m	struct:query	typeref:typename:int	file:
id	code/Data Structures/MOs on tree.cpp	/^  int l, r, id;$/;"	m	struct:query	typeref:typename:int	file:
id	code/Data Structures/MOs on tree.cpp	/^int st[N], en[N], T, par[N][20], dep[N], id[N * 2];$/;"	v	typeref:typename:int[]
id	code/Data Structures/MOs with Update.cpp	/^  int l, r, t, id;$/;"	m	struct:query	typeref:typename:int	file:
id	code/Data Structures/Permutation Tree.cpp	/^int id; \/\/new index to assign to nodes$/;"	v	typeref:typename:int
id	code/Data Structures/Segment Tree Merging.cpp	/^  int id[N * 30];$/;"	m	struct:STM	typeref:typename:int[]	file:
id	code/Dynamic Programming Optimizations/Subset Sum in SQRT.cpp	/^vector<int> g[N], id[N];$/;"	v	typeref:typename:vector<int>[]
id	code/Game Theory/Blue Red Hackenbush.cpp	/^int id[N], vis[N];$/;"	v	typeref:typename:int[]
id	code/Geometry/All Pair Segment Intersection.cpp	/^    int id;$/;"	m	struct:seg	typeref:typename:int	file:
id	code/Geometry/All Pair Segment Intersection.cpp	/^    int ty, id;$/;"	m	struct:event	typeref:typename:int	file:
id	code/Geometry/Onion Decomposition.cpp	/^map<PT, int> id;$/;"	v	typeref:typename:map<PT,int>
id	code/Geometry/Point Location.cpp	/^        int id = 0;$/;"	m	struct:DCEL::edge	typeref:typename:int	file:
id	code/Graph Theory/Block Cut Tree.cpp	/^int dep[N], par[N][20], cnt[N], id[N];$/;"	v	typeref:typename:int[]
id	code/Graph Theory/Chinese Postman Problem.cpp	/^  int mat[N], stk[N], id[N], vis[N];$/;"	m	struct:RandomizedMatching	typeref:typename:int[]	file:
id	code/Graph Theory/Dinics Algorithm.cpp	/^    int id;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
id	code/Graph Theory/Dominator Tree.cpp	/^int id[N], rev[N], T;$/;"	v	typeref:typename:int[]
id	code/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^int deg[N][2], id[N][2], l, r;$/;"	v	typeref:typename:int[][2]
id	code/Graph Theory/Euler Path Directed.cpp	/^string id[N];$/;"	v	typeref:typename:string[]
id	code/Graph Theory/L R Flow with Dinic.cpp	/^    int id;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
id	code/Graph Theory/L R Flow with Dinic.cpp	/^    int u, v, l, r, id;$/;"	m	struct:LR_Flow::edge	typeref:typename:int	file:
id	code/Graph Theory/L R Flow with MCMF.cpp	/^    int id;$/;"	m	struct:MCMF::edge	typeref:typename:int	file:
id	code/Graph Theory/Manhattan MST.cpp	/^  int val, id;$/;"	m	struct:node	typeref:typename:int	file:
id	code/Graph Theory/Manhattan MST.cpp	/^  int x, y, id;$/;"	m	struct:PT	typeref:typename:int	file:
id	code/Graph Theory/Maximum Closure Problem.cpp	/^    int id;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
id	code/Graph Theory/Maximum Density Subgraph.cpp	/^    int id;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
id	code/Graph Theory/Min Cost Max Flow.cpp	/^    int id;$/;"	m	struct:MCMF::edge	typeref:typename:int	file:
id	code/Graph Theory/Min Cut in a Planar Graph.cpp	/^inline int id(int i, int j) {$/;"	f	typeref:typename:int
id	code/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^int n, m, U[M], V[M], id[N], par[N];$/;"	v	typeref:typename:int[]
id	code/Graph Theory/Minimum Weight Cycle For Each Edge.cpp	/^int g[N][N], ans[N * N], last[N], dp[N * N], id[N][N], W[N * N];$/;"	v	typeref:typename:int[][]
id	code/Graph Theory/Randomized Matching Weighted.cpp	/^	int mat[N], stk[N], id[N], vis[N];$/;"	m	struct:RandomizedMatching	typeref:typename:int[]	file:
id	code/Graph Theory/Stable Marriage Problem.cpp	/^int m[N][N], w[N][N], id[N], marry[N], ans[N], pref[N][N];$/;"	v	typeref:typename:int[]
id	code/Graph Theory/Unique Min Cut.cpp	/^    int id;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
id	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  int l, r, id;$/;"	m	struct:query	typeref:typename:int	file:
id	practice/cf/random/1700/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	s	object:batch
id	practice/cf/random/1700/1618E/problem.json	/^{"name": "E. Singers' Tour", "group": "Codeforces - Codeforces Round #760 (Div. 3)", "url": "htt/;"	s	object:batch
id	practice/cf/random/coloring/problem.json	/^{"name": "A. Dreamoon Likes Coloring", "group": "Codeforces - Codeforces Round #631 (Div. 1) - T/;"	s	object:batch
id	practice/cf/random/diane/problem.json	/^{"name": "D. Diane", "group": "Codeforces - Codeforces Round #735 (Div. 2)", "url": "https:\/\/c/;"	s	object:batch
id	practice/cf/random/pink/problem.json	/^{"name": "C. Pinkie Pie Eats Patty-cakes", "group": "Codeforces - Codeforces Round #662 (Div. 2)/;"	s	object:batch
id	practice/cf/stuff/dec 20 2021/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	s	object:batch
id	practice/usacoguide/gold/SP/dining/problem.json	/^{"name": "Problem 1. Fine Dining", "group": "USACO - USACO 2018 December Contest, Gold", "url": /;"	s	object:batch
id	practice/usacoguide/gold/SP/visitfj/problem.json	/^{"name": "Problem 1. Why Did the Cow Cross the Road", "group": "USACO - USACO 2017 February Cont/;"	s	object:batch
id	practice/usacoguide/gold/bfs/cownav/problem.json	/^{"name": "Problem 3. Cow Navigation", "group": "USACO - USACO 2017 January Contest, Gold", "url"/;"	s	object:batch
id	practice/usacoguide/gold/bfs/swap/problem.json	/^{"name": "Swap Game", "group": "CSES - CSES Problem Set", "url": "https:\/\/cses.fi\/problemset\//;"	s	object:batch
id	practice/usacoguide/gold/dsu/closing/problem.json	/^{"name": "Problem 2. Closing the Farm", "group": "USACO - USACO 2016 US Open Contest, Gold", "ur/;"	s	object:batch
id	practice/usacoguide/gold/dsu/moocast/problem.json	/^{"name": "Problem 1. Moocast", "group": "USACO - USACO 2016 December Contest, Gold", "url": "htt/;"	s	object:batch
id	practice/usacoguide/gold/dsu/mootube/problem.json	/^{"name": "Problem 1. MooTube", "group": "USACO - USACO 2018 January Contest, Gold", "url": "http/;"	s	object:batch
id	practice/usacoguide/gold/dsu/tractor/problem.json	/^{"name": "Problem 2. Tractor", "group": "USACO - USACO 2013 February Contest, Silver", "url": "h/;"	s	object:batch
id	practice/usacoguide/gold/dsu/wormhole/problem.json	/^{"name": "Problem 3. Wormhole Sort", "group": "USACO - USACO 2020 January Contest, Silver", "url/;"	s	object:batch
id	practice/usacoguide/silver/idk/lirs/problem.json	/^{"name": "Problem 3. Liars and Truth Tellers", "group": "USACO - USACO 2013 January Contest, Bro/;"	s	object:batch
id	practice/usacoguide/silver/idk/maze/problem.json	/^{"name": "Problem 1. Maze Tac Toe", "group": "USACO - USACO 2021 US Open, Silver", "url": "http:/;"	s	object:batch
id1	code-library/Number Theory/Min_25 Sieve.cpp	/^int r, id1[N], id2[N];$/;"	v	typeref:typename:int[]
id1	code/Number Theory/Min_25 Sieve.cpp	/^int r, id1[N], id2[N];$/;"	v	typeref:typename:int[]
id2	code-library/Number Theory/Min_25 Sieve.cpp	/^int r, id1[N], id2[N];$/;"	v	typeref:typename:int[]
id2	code/Number Theory/Min_25 Sieve.cpp	/^int r, id1[N], id2[N];$/;"	v	typeref:typename:int[]
ideg	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^mint ideg[N];$/;"	v	typeref:typename:mint[]
ideg	code/Math/Generating Function of a Linear Recurrence.cpp	/^mint ideg[N];$/;"	v	typeref:typename:mint[]
idom	code-library/Graph Theory/Dominator Tree.cpp	/^int sdom[N], par[N], idom[N], dsu[N], label[N];$/;"	v	typeref:typename:int[]
idom	code/Graph Theory/Dominator Tree.cpp	/^int sdom[N], par[N], idom[N], dsu[N], label[N];$/;"	v	typeref:typename:int[]
idx	code-library/Data Structures/MOs with DSU.cpp	/^  int l, r, idx;$/;"	m	struct:query	typeref:typename:int	file:
idx	code-library/Graph Theory/Kuhns Algorithm.cpp	/^int idx[N];$/;"	v	typeref:typename:int[]
idx	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  vector<int> vec, idx;$/;"	m	struct:MaximumClosure	typeref:typename:vector<int>	file:
idx	code-library/Graph Theory/SCC.cpp	/^int idx[N], in[N], out[N];$/;"	v	typeref:typename:int[]
idx	code-library/Graph Theory/Stoer Wagner Algorithm.cpp	/^  int idx[N];$/;"	m	struct:StoerWagner	typeref:typename:int[]	file:
idx	code/Data Structures/MOs with DSU.cpp	/^  int l, r, idx;$/;"	m	struct:query	typeref:typename:int	file:
idx	code/Graph Theory/Kuhns Algorithm.cpp	/^int idx[N];$/;"	v	typeref:typename:int[]
idx	code/Graph Theory/Maximum Closure Problem.cpp	/^  vector<int> vec, idx;$/;"	m	struct:MaximumClosure	typeref:typename:vector<int>	file:
idx	code/Graph Theory/SCC.cpp	/^int idx[N], in[N], out[N];$/;"	v	typeref:typename:int[]
idx	code/Graph Theory/Stoer Wagner Algorithm.cpp	/^  int idx[N];$/;"	m	struct:StoerWagner	typeref:typename:int[]	file:
ifac	code-library/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^int f[N], ifac[N];$/;"	v	typeref:typename:int[]
ifac	code/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^int f[N], ifac[N];$/;"	v	typeref:typename:int[]
ifact	code-library/Math/NTT.cpp	/^int fact[N], ifact[N];$/;"	v	typeref:typename:int[]
ifact	code-library/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^int fact[N], ifact[N];$/;"	v	typeref:typename:int[]
ifact	code/Math/NTT.cpp	/^int fact[N], ifact[N];$/;"	v	typeref:typename:int[]
ifact	code/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^int fact[N], ifact[N];$/;"	v	typeref:typename:int[]
ifacts	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static vector<R> invs, facts, ifacts;$/;"	m	class:poly	typeref:typename:vector<R>	file:
ifacts	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^vector<R> poly::invs, poly::facts, poly::ifacts;$/;"	m	class:poly	typeref:typename:vector<R>
ifacts	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static vector<R> invs, facts, ifacts;$/;"	m	class:poly	typeref:typename:vector<R>	file:
ifacts	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^vector<R> poly::invs, poly::facts, poly::ifacts;$/;"	m	class:poly	typeref:typename:vector<R>
ii	practice/usacoguide/gold/introDP/711C.cpp	/^typedef pair<int,int> ii;$/;"	t	typeref:typename:pair<int,int>	file:
ilog2	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static int ilog2(u64 n) {$/;"	f	class:poly	typeref:typename:int	file:
ilog2	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static int ilog2(u64 n) {$/;"	f	class:poly	typeref:typename:int	file:
imag	code-library/Miscellaneous/BigInt.cpp	/^  inline T imag() const {$/;"	f	struct:cplx	typeref:typename:T	file:
imag	code/Miscellaneous/BigInt.cpp	/^  inline T imag() const {$/;"	f	struct:cplx	typeref:typename:T	file:
imp	code-library/Graph Theory/Steiner Tree Problem.cpp	/^vector<int> imp;\/\/k important nodes$/;"	v	typeref:typename:vector<int>
imp	code-library/Graph Theory/Virtual Tree.cpp	/^int imp[N];$/;"	v	typeref:typename:int[]
imp	code/Graph Theory/Steiner Tree Problem.cpp	/^vector<int> imp;\/\/k important nodes$/;"	v	typeref:typename:vector<int>
imp	code/Graph Theory/Virtual Tree.cpp	/^int imp[N];$/;"	v	typeref:typename:int[]
in	code-library/Data Structures/Disjoint Sparse Table.cpp	/^#define/;"	d	file:
in	code-library/Data Structures/Implicit Treap.cpp	/^#define/;"	d	file:
in	code-library/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^#define/;"	d	file:
in	code-library/Dynamic Programming Optimizations/DP Over Divisors.cpp	/^#define/;"	d	file:
in	code-library/Dynamic Programming Optimizations/Digit DP.cpp	/^#define/;"	d	file:
in	code-library/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^#define/;"	d	file:
in	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^#define/;"	d	file:
in	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^#define/;"	d	file:
in	code-library/Graph Theory/SCC.cpp	/^int idx[N], in[N], out[N];$/;"	v	typeref:typename:int[]
in	code-library/Graph Theory/Tuttes Theorem.cpp	/^int g[N][N], in[N];$/;"	v	typeref:typename:int[]
in	code-library/Miscellaneous/Parallel Binary Search.cpp	/^#define/;"	d	file:
in	code-library/Strings/Prefix Automaton.cpp	/^#define/;"	d	file:
in	code/Data Structures/Disjoint Sparse Table.cpp	/^#define/;"	d	file:
in	code/Data Structures/Implicit Treap.cpp	/^#define/;"	d	file:
in	code/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^#define/;"	d	file:
in	code/Dynamic Programming Optimizations/DP Over Divisors.cpp	/^#define/;"	d	file:
in	code/Dynamic Programming Optimizations/Digit DP.cpp	/^#define/;"	d	file:
in	code/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^#define/;"	d	file:
in	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^#define/;"	d	file:
in	code/Graph Theory/Counting Labeled Graphs.cpp	/^#define/;"	d	file:
in	code/Graph Theory/SCC.cpp	/^int idx[N], in[N], out[N];$/;"	v	typeref:typename:int[]
in	code/Graph Theory/Tuttes Theorem.cpp	/^int g[N][N], in[N];$/;"	v	typeref:typename:int[]
in	code/Miscellaneous/Parallel Binary Search.cpp	/^#define/;"	d	file:
in	code/Strings/Prefix Automaton.cpp	/^#define/;"	d	file:
in_adj	practice/usacoguide/gold/introDP/time.cpp	/^vector<int> adj[mxN], in_adj[mxN];$/;"	v	typeref:typename:vector<int>[]
in_group	code-library/Miscellaneous/Schreier–Sims algorithm.cpp	/^  bool in_group(vector<int> g) { return yo(g, false) == -1; }$/;"	f	struct:Group	typeref:typename:bool	file:
in_group	code/Miscellaneous/Schreier–Sims algorithm.cpp	/^  bool in_group(vector<int> g) { return yo(g, false) == -1; }$/;"	f	struct:Group	typeref:typename:bool	file:
in_vertex	code-library/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  bool in_vertex[N];$/;"	m	struct:Euler	typeref:typename:bool[]	file:
in_vertex	code/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  bool in_vertex[N];$/;"	m	struct:Euler	typeref:typename:bool[]	file:
index	code-library/Math/Simplex Algorithm.cpp	/^  int m, n, solution_flag, minmax_flag, basis[MAXC], index[MAXV];$/;"	v	namespace:lp	typeref:typename:int[]
index	code/Math/Simplex Algorithm.cpp	/^  int m, n, solution_flag, minmax_flag, basis[MAXC], index[MAXV];$/;"	v	namespace:lp	typeref:typename:int[]
indexSz	code-library/Data Structures/SQRT Tree.cpp	/^  int n, llg, indexSz;$/;"	m	struct:SqrtTree	typeref:typename:int	file:
indexSz	code/Data Structures/SQRT Tree.cpp	/^  int n, llg, indexSz;$/;"	m	struct:SqrtTree	typeref:typename:int	file:
indexed_multiset	contests/AtCoder/231/C.cpp	/^typedef tree<long long, null_type, less_equal<>, rb_tree_tag, tree_order_statistics_node_update>/;"	t	typeref:typename:tree<long long,null_type,less_equal<>,rb_tree_tag,tree_order_statistics_node_update>	file:
indexed_multiset	practice/cf/random/1700/2.cpp	/^typedef tree<long long, null_type, less_equal<>, rb_tree_tag, tree_order_statistics_node_update>/;"	t	typeref:typename:tree<long long,null_type,less_equal<>,rb_tree_tag,tree_order_statistics_node_update>	file:
induced_sort	code-library/Strings/Suffix Array.cpp	/^void induced_sort(const vector<int> &vec, int val_range, vector<int> &SA, const vector<bool> &sl/;"	f	typeref:typename:void
induced_sort	code/Strings/Suffix Array.cpp	/^void induced_sort(const vector<int> &vec, int val_range, vector<int> &SA, const vector<bool> &sl/;"	f	typeref:typename:void
inf	code-library/Data Structures/HLD.cpp	/^const int N = 1e5 + 9, LG = 18, inf = 1e9 + 9;$/;"	v	typeref:typename:const int
inf	code-library/Data Structures/Permutation Tree.cpp	/^const int N = 1e5 + 9, inf = 1e9 + 7, LG = 19;$/;"	v	typeref:typename:const int
inf	code-library/Data Structures/Segment Tree Beats.cpp	/^  const ll inf = 1e18;$/;"	m	struct:SGTBeats	typeref:typename:const ll	file:
inf	code-library/Data Structures/Segment Tree.cpp	/^  static const int inf = 1e9;$/;"	m	struct:ST	typeref:typename:const int	file:
inf	code-library/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^const ll inf = -(1LL << 62);$/;"	v	typeref:typename:const ll
inf	code-library/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^const ll inf = 2e18;$/;"	v	typeref:typename:const ll
inf	code-library/Geometry/All Pair Segment Intersection.cpp	/^const double inf = 1e100;$/;"	v	typeref:typename:const double
inf	code-library/Geometry/Geometry 2D.cpp	/^const double inf = 1e100;$/;"	v	typeref:typename:const double
inf	code-library/Geometry/Geometry 3D.cpp	/^const double inf = 1e100;$/;"	v	typeref:typename:const double
inf	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  const long long inf = 1e18;$/;"	m	struct:Blossom	typeref:typename:const long long	file:
inf	code-library/Graph Theory/Chinese Postman Problem.cpp	/^  const long long inf = 1e18;$/;"	m	struct:RandomizedMatching	typeref:typename:const long long	file:
inf	code-library/Graph Theory/Chinese Postman Problem.cpp	/^const long long inf = 1e18;$/;"	v	typeref:typename:const long long
inf	code-library/Graph Theory/Dinics Algorithm.cpp	/^const long long inf = 1LL << 61;$/;"	v	typeref:typename:const long long
inf	code-library/Graph Theory/Directed MST.cpp	/^const long long inf = 1e18;$/;"	v	typeref:typename:const long long
inf	code-library/Graph Theory/HopCroft Karp Algorithm.cpp	/^  static const int inf = 1e9;$/;"	m	struct:HopcroftKarp	typeref:typename:const int	file:
inf	code-library/Graph Theory/Hungarian Algorithm.cpp	/^  const long long inf = 1e18;$/;"	m	struct:Hungarian	typeref:typename:const long long	file:
inf	code-library/Graph Theory/L R Flow with Dinic.cpp	/^const long long inf = 1LL << 61;$/;"	v	typeref:typename:const long long
inf	code-library/Graph Theory/L R Flow with MCMF.cpp	/^const T inf = 1LL << 61;$/;"	v	typeref:typename:const T
inf	code-library/Graph Theory/Maximum Closure Problem.cpp	/^const long long inf = 1LL << 61;$/;"	v	typeref:typename:const long long
inf	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^const double inf = 1e9;$/;"	v	typeref:typename:const double
inf	code-library/Graph Theory/Min Cost Max Flow.cpp	/^const T inf = 1LL << 61;$/;"	v	typeref:typename:const T
inf	code-library/Graph Theory/Minimum Weight Cycle For Each Edge.cpp	/^const int N = 205, inf = 1e9;$/;"	v	typeref:typename:const int
inf	code-library/Graph Theory/Minimum Weight Cycle For Each Vertex.cpp	/^const int N = 305, inf = 1e9;$/;"	v	typeref:typename:const int
inf	code-library/Graph Theory/Randomized Matching Weighted.cpp	/^	const long long inf = 1e18;$/;"	m	struct:RandomizedMatching	typeref:typename:const long long	file:
inf	code-library/Graph Theory/Steiner Tree Problem.cpp	/^const long long inf = LLONG_MAX \/ 3;$/;"	v	typeref:typename:const long long
inf	code-library/Graph Theory/Stoer Wagner Algorithm.cpp	/^  const long long inf = 1e18;$/;"	m	struct:StoerWagner	typeref:typename:const long long	file:
inf	code-library/Graph Theory/Unique Min Cut.cpp	/^const long long inf = 1LL << 61;$/;"	v	typeref:typename:const long long
inf	code-library/Miscellaneous/MEX of all Subarrays.cpp	/^const int N = 1e5 + 9, inf = 1e9;$/;"	v	typeref:typename:const int
inf	code-library/Number Theory/K Divisors.cpp	/^const ll inf = 1e12 + 9; \/\/ > max n$/;"	v	typeref:typename:const ll
inf	code-library/Number Theory/Linear Diophantine Equation with Nonnegative Solutions.cpp	/^const ll inf = 1e18;$/;"	v	typeref:typename:const ll
inf	code/Data Structures/HLD.cpp	/^const int N = 1e5 + 9, LG = 18, inf = 1e9 + 9;$/;"	v	typeref:typename:const int
inf	code/Data Structures/Permutation Tree.cpp	/^const int N = 1e5 + 9, inf = 1e9 + 7, LG = 19;$/;"	v	typeref:typename:const int
inf	code/Data Structures/Segment Tree Beats.cpp	/^  const ll inf = 1e18;$/;"	m	struct:SGTBeats	typeref:typename:const ll	file:
inf	code/Data Structures/Segment Tree.cpp	/^  static const int inf = 1e9;$/;"	m	struct:ST	typeref:typename:const int	file:
inf	code/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^const ll inf = -(1LL << 62);$/;"	v	typeref:typename:const ll
inf	code/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^const ll inf = 2e18;$/;"	v	typeref:typename:const ll
inf	code/Geometry/All Pair Segment Intersection.cpp	/^const double inf = 1e100;$/;"	v	typeref:typename:const double
inf	code/Geometry/Geometry 2D.cpp	/^const double inf = 1e100;$/;"	v	typeref:typename:const double
inf	code/Geometry/Geometry 3D.cpp	/^const double inf = 1e100;$/;"	v	typeref:typename:const double
inf	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  const long long inf = 1e18;$/;"	m	struct:Blossom	typeref:typename:const long long	file:
inf	code/Graph Theory/Chinese Postman Problem.cpp	/^  const long long inf = 1e18;$/;"	m	struct:RandomizedMatching	typeref:typename:const long long	file:
inf	code/Graph Theory/Chinese Postman Problem.cpp	/^const long long inf = 1e18;$/;"	v	typeref:typename:const long long
inf	code/Graph Theory/Dinics Algorithm.cpp	/^const long long inf = 1LL << 61;$/;"	v	typeref:typename:const long long
inf	code/Graph Theory/Directed MST.cpp	/^const long long inf = 1e18;$/;"	v	typeref:typename:const long long
inf	code/Graph Theory/HopCroft Karp Algorithm.cpp	/^  static const int inf = 1e9;$/;"	m	struct:HopcroftKarp	typeref:typename:const int	file:
inf	code/Graph Theory/Hungarian Algorithm.cpp	/^  const long long inf = 1e18;$/;"	m	struct:Hungarian	typeref:typename:const long long	file:
inf	code/Graph Theory/L R Flow with Dinic.cpp	/^const long long inf = 1LL << 61;$/;"	v	typeref:typename:const long long
inf	code/Graph Theory/L R Flow with MCMF.cpp	/^const T inf = 1LL << 61;$/;"	v	typeref:typename:const T
inf	code/Graph Theory/Maximum Closure Problem.cpp	/^const long long inf = 1LL << 61;$/;"	v	typeref:typename:const long long
inf	code/Graph Theory/Maximum Density Subgraph.cpp	/^const double inf = 1e9;$/;"	v	typeref:typename:const double
inf	code/Graph Theory/Min Cost Max Flow.cpp	/^const T inf = 1LL << 61;$/;"	v	typeref:typename:const T
inf	code/Graph Theory/Minimum Weight Cycle For Each Edge.cpp	/^const int N = 205, inf = 1e9;$/;"	v	typeref:typename:const int
inf	code/Graph Theory/Minimum Weight Cycle For Each Vertex.cpp	/^const int N = 305, inf = 1e9;$/;"	v	typeref:typename:const int
inf	code/Graph Theory/Randomized Matching Weighted.cpp	/^	const long long inf = 1e18;$/;"	m	struct:RandomizedMatching	typeref:typename:const long long	file:
inf	code/Graph Theory/Steiner Tree Problem.cpp	/^const long long inf = LLONG_MAX \/ 3;$/;"	v	typeref:typename:const long long
inf	code/Graph Theory/Stoer Wagner Algorithm.cpp	/^  const long long inf = 1e18;$/;"	m	struct:StoerWagner	typeref:typename:const long long	file:
inf	code/Graph Theory/Unique Min Cut.cpp	/^const long long inf = 1LL << 61;$/;"	v	typeref:typename:const long long
inf	code/Miscellaneous/MEX of all Subarrays.cpp	/^const int N = 1e5 + 9, inf = 1e9;$/;"	v	typeref:typename:const int
inf	code/Number Theory/K Divisors.cpp	/^const ll inf = 1e12 + 9; \/\/ > max n$/;"	v	typeref:typename:const ll
inf	code/Number Theory/Linear Diophantine Equation with Nonnegative Solutions.cpp	/^const ll inf = 1e18;$/;"	v	typeref:typename:const ll
init	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^  void init(int n) {$/;"	f	struct:persistent_dsu	typeref:typename:void	file:
init	code-library/Data Structures/Interval Set.cpp	/^  void init(int n) {$/;"	f	struct:interval_set	typeref:typename:void	file:
init	code-library/Data Structures/MOs with DSU.cpp	/^  void init(int _sz) {$/;"	f	struct:persistent_dsu	typeref:typename:void	file:
init	code-library/Data Structures/Wavelet Tree.cpp	/^  void init(int *from, int *to, int x, int y) {$/;"	f	struct:wavelet_tree	typeref:typename:void	file:
init	code-library/Geometry/Geometry 2D.cpp	/^    void init() {$/;"	f	struct:CircleUnion	typeref:typename:void	file:
init	code-library/Geometry/Geometry 3D.cpp	/^    void init(vector<p3> p) {$/;"	f	struct:CH3D	typeref:typename:void	file:
init	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^  void init(vector<bitset<V>> g) {$/;"	f	struct:ChromaticPolynomial	typeref:typename:void	file:
init	code-library/Graph Theory/Dynamic MST.cpp	/^  void init(int n){$/;"	f	struct:disj	typeref:typename:void	file:
init	code-library/Graph Theory/Manhattan MST.cpp	/^  void init(int n) { for (int i = 1; i <= n; i++)  p[i] = i; }$/;"	f	struct:DSU	typeref:typename:void	file:
init	code-library/Graph Theory/Online Articulation Bridges.cpp	/^void init() {$/;"	f	typeref:typename:void
init	code-library/Math/Reeds Sloane Algorithm.cpp	/^  vec init, trans;$/;"	m	struct:LinearRecurrence	typeref:typename:vec	file:
init	code-library/Math/Simplex Algorithm.cpp	/^  inline void init(){ \/\/\/ Initialization$/;"	f	namespace:lp	typeref:typename:void
init	code-library/Math/Simplex Algorithm.cpp	/^  inline void init(int nvars, long double f[], int flag){$/;"	f	namespace:lp	typeref:typename:void
init	code-library/Miscellaneous/Bitset Custom.cpp	/^void init()$/;"	f	typeref:typename:void
init	code-library/Miscellaneous/Parallel Binary Search.cpp	/^  void init(int n) { \/\/ max size of array$/;"	f	struct:BIT	typeref:typename:void	file:
init	code-library/Number Theory/Dirichlet Convolution.cpp	/^  void init() {$/;"	f	namespace:Dirichlet	typeref:typename:void
init	code-library/Number Theory/K Divisors.cpp	/^  void init() {$/;"	f	namespace:pcf	typeref:typename:void
init	code-library/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^  void init() {$/;"	f	namespace:PollardRho	typeref:typename:void
init	code-library/Number Theory/Pisano Period.cpp	/^  void init() {$/;"	f	namespace:PollardRho	typeref:typename:void
init	code-library/Number Theory/Pollard Rho.cpp	/^  void init() {$/;"	f	namespace:PollardRho	typeref:typename:void
init	code-library/Number Theory/Prime Counting Function.cpp	/^  void init() {$/;"	f	namespace:pcf	typeref:typename:void
init	code-library/Number Theory/Prime Factorization Fastest.cpp	/^  static uint64_t init(const uint64_t &w) { return reduce(__uint128_t(w) * r2); }$/;"	f	struct:Mint	typeref:typename:uint64_t	file:
init	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static word_t init(word_t w) { return reduce(dword_t(w) * r2); }$/;"	f	class:ntt::Mod	typeref:typename:word_t	file:
init	code-library/Strings/Number of Palindromes in Range.cpp	/^  void init(int *from, int *to, int x, int y) {$/;"	f	struct:wavelet_tree	typeref:typename:void	file:
init	code/Data Structures/Dynamic Connectivity Problem.cpp	/^  void init(int n) {$/;"	f	struct:persistent_dsu	typeref:typename:void	file:
init	code/Data Structures/Interval Set.cpp	/^  void init(int n) {$/;"	f	struct:interval_set	typeref:typename:void	file:
init	code/Data Structures/MOs with DSU.cpp	/^  void init(int _sz) {$/;"	f	struct:persistent_dsu	typeref:typename:void	file:
init	code/Data Structures/Wavelet Tree.cpp	/^  void init(int *from, int *to, int x, int y) {$/;"	f	struct:wavelet_tree	typeref:typename:void	file:
init	code/Geometry/Geometry 2D.cpp	/^    void init() {$/;"	f	struct:CircleUnion	typeref:typename:void	file:
init	code/Geometry/Geometry 3D.cpp	/^    void init(vector<p3> p) {$/;"	f	struct:CH3D	typeref:typename:void	file:
init	code/Graph Theory/Chromatic Polynoimial.cpp	/^  void init(vector<bitset<V>> g) {$/;"	f	struct:ChromaticPolynomial	typeref:typename:void	file:
init	code/Graph Theory/Dynamic MST.cpp	/^  void init(int n){$/;"	f	struct:disj	typeref:typename:void	file:
init	code/Graph Theory/Manhattan MST.cpp	/^  void init(int n) { for (int i = 1; i <= n; i++)  p[i] = i; }$/;"	f	struct:DSU	typeref:typename:void	file:
init	code/Graph Theory/Online Articulation Bridges.cpp	/^void init() {$/;"	f	typeref:typename:void
init	code/Math/Reeds Sloane Algorithm.cpp	/^  vec init, trans;$/;"	m	struct:LinearRecurrence	typeref:typename:vec	file:
init	code/Math/Simplex Algorithm.cpp	/^  inline void init(){ \/\/\/ Initialization$/;"	f	namespace:lp	typeref:typename:void
init	code/Math/Simplex Algorithm.cpp	/^  inline void init(int nvars, long double f[], int flag){$/;"	f	namespace:lp	typeref:typename:void
init	code/Miscellaneous/Bitset Custom.cpp	/^void init()$/;"	f	typeref:typename:void
init	code/Miscellaneous/Parallel Binary Search.cpp	/^  void init(int n) { \/\/ max size of array$/;"	f	struct:BIT	typeref:typename:void	file:
init	code/Number Theory/Dirichlet Convolution.cpp	/^  void init() {$/;"	f	namespace:Dirichlet	typeref:typename:void
init	code/Number Theory/K Divisors.cpp	/^  void init() {$/;"	f	namespace:pcf	typeref:typename:void
init	code/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^  void init() {$/;"	f	namespace:PollardRho	typeref:typename:void
init	code/Number Theory/Pisano Period.cpp	/^  void init() {$/;"	f	namespace:PollardRho	typeref:typename:void
init	code/Number Theory/Pollard Rho.cpp	/^  void init() {$/;"	f	namespace:PollardRho	typeref:typename:void
init	code/Number Theory/Prime Counting Function.cpp	/^  void init() {$/;"	f	namespace:pcf	typeref:typename:void
init	code/Number Theory/Prime Factorization Fastest.cpp	/^  static uint64_t init(const uint64_t &w) { return reduce(__uint128_t(w) * r2); }$/;"	f	struct:Mint	typeref:typename:uint64_t	file:
init	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static word_t init(word_t w) { return reduce(dword_t(w) * r2); }$/;"	f	class:ntt::Mod	typeref:typename:word_t	file:
init	code/Strings/Number of Palindromes in Range.cpp	/^  void init(int *from, int *to, int x, int y) {$/;"	f	struct:wavelet_tree	typeref:typename:void	file:
initBFS	code-library/Graph Theory/Hungarian Algorithm.cpp	/^  void initBFS() {$/;"	f	struct:Hungarian	typeref:typename:void	file:
initBFS	code/Graph Theory/Hungarian Algorithm.cpp	/^  void initBFS() {$/;"	f	struct:Hungarian	typeref:typename:void	file:
initialize	code-library/Data Structures/Augmented DSU.cpp	/^void initialize(int n) {$/;"	f	typeref:typename:void
initialize	code/Data Structures/Augmented DSU.cpp	/^void initialize(int n) {$/;"	f	typeref:typename:void
inorder	code-library/Data Structures/Implicit Treap.cpp	/^  void inorder(pnode cur) {$/;"	f	struct:treap	typeref:typename:void	file:
inorder	code/Data Structures/Implicit Treap.cpp	/^  void inorder(pnode cur) {$/;"	f	struct:treap	typeref:typename:void	file:
input	practice/cf/random/1700/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	o
input	practice/cf/random/1700/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	s	object:tests.0
input	practice/cf/random/1700/1618E/problem.json	/^{"name": "E. Singers' Tour", "group": "Codeforces - Codeforces Round #760 (Div. 3)", "url": "htt/;"	o
input	practice/cf/random/1700/1618E/problem.json	/^{"name": "E. Singers' Tour", "group": "Codeforces - Codeforces Round #760 (Div. 3)", "url": "htt/;"	s	object:tests.0
input	practice/cf/random/coloring/problem.json	/^{"name": "A. Dreamoon Likes Coloring", "group": "Codeforces - Codeforces Round #631 (Div. 1) - T/;"	o
input	practice/cf/random/coloring/problem.json	/^{"name": "A. Dreamoon Likes Coloring", "group": "Codeforces - Codeforces Round #631 (Div. 1) - T/;"	s	object:tests.0
input	practice/cf/random/coloring/problem.json	/^{"name": "A. Dreamoon Likes Coloring", "group": "Codeforces - Codeforces Round #631 (Div. 1) - T/;"	s	object:tests.1
input	practice/cf/random/diane/problem.json	/^{"name": "D. Diane", "group": "Codeforces - Codeforces Round #735 (Div. 2)", "url": "https:\/\/c/;"	o
input	practice/cf/random/diane/problem.json	/^{"name": "D. Diane", "group": "Codeforces - Codeforces Round #735 (Div. 2)", "url": "https:\/\/c/;"	s	object:tests.0
input	practice/cf/random/pink/problem.json	/^{"name": "C. Pinkie Pie Eats Patty-cakes", "group": "Codeforces - Codeforces Round #662 (Div. 2)/;"	o
input	practice/cf/random/pink/problem.json	/^{"name": "C. Pinkie Pie Eats Patty-cakes", "group": "Codeforces - Codeforces Round #662 (Div. 2)/;"	s	object:tests.0
input	practice/cf/stuff/dec 20 2021/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	o
input	practice/cf/stuff/dec 20 2021/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	s	object:tests.0
input	practice/usacoguide/gold/SP/dining/problem.json	/^{"name": "Problem 1. Fine Dining", "group": "USACO - USACO 2018 December Contest, Gold", "url": /;"	o
input	practice/usacoguide/gold/SP/dining/problem.json	/^{"name": "Problem 1. Fine Dining", "group": "USACO - USACO 2018 December Contest, Gold", "url": /;"	s	object:tests.0
input	practice/usacoguide/gold/SP/visitfj/problem.json	/^{"name": "Problem 1. Why Did the Cow Cross the Road", "group": "USACO - USACO 2017 February Cont/;"	o
input	practice/usacoguide/gold/SP/visitfj/problem.json	/^{"name": "Problem 1. Why Did the Cow Cross the Road", "group": "USACO - USACO 2017 February Cont/;"	s	object:tests.0
input	practice/usacoguide/gold/bfs/cownav/problem.json	/^{"name": "Problem 3. Cow Navigation", "group": "USACO - USACO 2017 January Contest, Gold", "url"/;"	o
input	practice/usacoguide/gold/bfs/cownav/problem.json	/^{"name": "Problem 3. Cow Navigation", "group": "USACO - USACO 2017 January Contest, Gold", "url"/;"	s	object:tests.0
input	practice/usacoguide/gold/bfs/swap/problem.json	/^{"name": "Swap Game", "group": "CSES - CSES Problem Set", "url": "https:\/\/cses.fi\/problemset\//;"	o
input	practice/usacoguide/gold/bfs/swap/problem.json	/^{"name": "Swap Game", "group": "CSES - CSES Problem Set", "url": "https:\/\/cses.fi\/problemset\//;"	s	object:tests.0
input	practice/usacoguide/gold/dsu/closing/problem.json	/^{"name": "Problem 2. Closing the Farm", "group": "USACO - USACO 2016 US Open Contest, Gold", "ur/;"	o
input	practice/usacoguide/gold/dsu/closing/problem.json	/^{"name": "Problem 2. Closing the Farm", "group": "USACO - USACO 2016 US Open Contest, Gold", "ur/;"	s	object:tests.0
input	practice/usacoguide/gold/dsu/moocast/problem.json	/^{"name": "Problem 1. Moocast", "group": "USACO - USACO 2016 December Contest, Gold", "url": "htt/;"	o
input	practice/usacoguide/gold/dsu/moocast/problem.json	/^{"name": "Problem 1. Moocast", "group": "USACO - USACO 2016 December Contest, Gold", "url": "htt/;"	s	object:tests.0
input	practice/usacoguide/gold/dsu/mootube/problem.json	/^{"name": "Problem 1. MooTube", "group": "USACO - USACO 2018 January Contest, Gold", "url": "http/;"	o
input	practice/usacoguide/gold/dsu/mootube/problem.json	/^{"name": "Problem 1. MooTube", "group": "USACO - USACO 2018 January Contest, Gold", "url": "http/;"	s	object:tests.0
input	practice/usacoguide/gold/dsu/tractor/problem.json	/^{"name": "Problem 2. Tractor", "group": "USACO - USACO 2013 February Contest, Silver", "url": "h/;"	o
input	practice/usacoguide/gold/dsu/wormhole/problem.json	/^{"name": "Problem 3. Wormhole Sort", "group": "USACO - USACO 2020 January Contest, Silver", "url/;"	o
input	practice/usacoguide/gold/dsu/wormhole/problem.json	/^{"name": "Problem 3. Wormhole Sort", "group": "USACO - USACO 2020 January Contest, Silver", "url/;"	s	object:tests.0
input	practice/usacoguide/gold/dsu/wormhole/problem.json	/^{"name": "Problem 3. Wormhole Sort", "group": "USACO - USACO 2020 January Contest, Silver", "url/;"	s	object:tests.1
input	practice/usacoguide/silver/idk/lirs/problem.json	/^{"name": "Problem 3. Liars and Truth Tellers", "group": "USACO - USACO 2013 January Contest, Bro/;"	o
input	practice/usacoguide/silver/idk/maze/problem.json	/^{"name": "Problem 1. Maze Tac Toe", "group": "USACO - USACO 2021 US Open, Silver", "url": "http:/;"	o
input	practice/usacoguide/silver/idk/maze/problem.json	/^{"name": "Problem 1. Maze Tac Toe", "group": "USACO - USACO 2021 US Open, Silver", "url": "http:/;"	s	object:tests.0
insert	code-library/Data Structures/Implicit Treap.cpp	/^  void insert(int pos, int val) {$/;"	f	struct:treap	typeref:typename:void	file:
insert	code-library/Data Structures/Persistent Meldable Heap.cpp	/^  heap insert(T x, int from, int to) { \/\/ from and to is needed only for this problem$/;"	f	struct:heap	typeref:typename:heap	file:
insert	code-library/Data Structures/Persistent Trie.cpp	/^void insert(int a, int time) {$/;"	f	typeref:typename:void
insert	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  void insert(int pos, long long val) { \/\/set a_pos = val$/;"	f	struct:treap	typeref:typename:void	file:
insert	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^void insert(int i, int x) {$/;"	f	typeref:typename:void
insert	code-library/Data Structures/Treap persistent.cpp	/^node* insert(node* t, int pos, int val) {$/;"	f	namespace:PersistentTreap	typeref:typename:node *
insert	code-library/Data Structures/Treap persistent.cpp	/^node* insert(node* t, int pos, node* x) {$/;"	f	namespace:PersistentTreap	typeref:typename:node *
insert	code-library/Data Structures/Treap.cpp	/^  void insert(int id) {$/;"	f	struct:treap	typeref:typename:void	file:
insert	code-library/Data Structures/Trie.cpp	/^  void insert(int val) {$/;"	f	struct:Trie	typeref:typename:void	file:
insert	code-library/Dynamic Programming Optimizations/Persistent CHT.cpp	/^  int insert(PT a, int rt) {$/;"	f	struct:PersistentCHT	typeref:typename:int	file:
insert	code-library/Geometry/Geometry 3D.cpp	/^    void insert(p3 p) {$/;"	f	struct:Set	typeref:typename:void	file:
insert	code-library/Graph Theory/Eppsteins Algorithm.cpp	/^  heap insert(T x, int from, int to) { \/\/ from and to is needed only for this problem$/;"	f	struct:heap	typeref:typename:heap	file:
insert	code-library/Math/Basis Vector Reduced Row Echelon Form.cpp	/^  void insert(int x){$/;"	f	struct:Basis	typeref:typename:void	file:
insert	code-library/Math/Basis Vector ft Weighted Linearly Independent Vectors.cpp	/^  void insert(T x, long long w) {$/;"	f	struct:Basis	typeref:typename:void	file:
insert	code-library/Math/Basis Vector.cpp	/^  void insert(int x) {$/;"	f	struct:Basis	typeref:typename:void	file:
insert	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  void insert(string &s, int id) {$/;"	f	struct:AhoCorasick	typeref:typename:void	file:
insert	code/Data Structures/Implicit Treap.cpp	/^  void insert(int pos, int val) {$/;"	f	struct:treap	typeref:typename:void	file:
insert	code/Data Structures/Persistent Meldable Heap.cpp	/^  heap insert(T x, int from, int to) { \/\/ from and to is needed only for this problem$/;"	f	struct:heap	typeref:typename:heap	file:
insert	code/Data Structures/Persistent Trie.cpp	/^void insert(int a, int time) {$/;"	f	typeref:typename:void
insert	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  void insert(int pos, long long val) { \/\/set a_pos = val$/;"	f	struct:treap	typeref:typename:void	file:
insert	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^void insert(int i, int x) {$/;"	f	typeref:typename:void
insert	code/Data Structures/Treap persistent.cpp	/^node* insert(node* t, int pos, int val) {$/;"	f	namespace:PersistentTreap	typeref:typename:node *
insert	code/Data Structures/Treap persistent.cpp	/^node* insert(node* t, int pos, node* x) {$/;"	f	namespace:PersistentTreap	typeref:typename:node *
insert	code/Data Structures/Treap.cpp	/^  void insert(int id) {$/;"	f	struct:treap	typeref:typename:void	file:
insert	code/Data Structures/Trie.cpp	/^  void insert(int val) {$/;"	f	struct:Trie	typeref:typename:void	file:
insert	code/Dynamic Programming Optimizations/Persistent CHT.cpp	/^  int insert(PT a, int rt) {$/;"	f	struct:PersistentCHT	typeref:typename:int	file:
insert	code/Geometry/Geometry 3D.cpp	/^    void insert(p3 p) {$/;"	f	struct:Set	typeref:typename:void	file:
insert	code/Graph Theory/Eppsteins Algorithm.cpp	/^  heap insert(T x, int from, int to) { \/\/ from and to is needed only for this problem$/;"	f	struct:heap	typeref:typename:heap	file:
insert	code/Math/Basis Vector Reduced Row Echelon Form.cpp	/^  void insert(int x){$/;"	f	struct:Basis	typeref:typename:void	file:
insert	code/Math/Basis Vector ft Weighted Linearly Independent Vectors.cpp	/^  void insert(T x, long long w) {$/;"	f	struct:Basis	typeref:typename:void	file:
insert	code/Math/Basis Vector.cpp	/^  void insert(int x) {$/;"	f	struct:Basis	typeref:typename:void	file:
insert	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  void insert(string &s, int id) {$/;"	f	struct:AhoCorasick	typeref:typename:void	file:
inside	code-library/Geometry/Convec Hull Dynamic.cpp	/^inline int inside(set<pair<int, int>>& hull, const PT& p) { \/\/border inclusive$/;"	f	typeref:typename:int
inside	code/Geometry/Convec Hull Dynamic.cpp	/^inline int inside(set<pair<int, int>>& hull, const PT& p) { \/\/border inclusive$/;"	f	typeref:typename:int
insub	code-library/Data Structures/Binarizing a Tree.cpp	/^int insub(int r, int c) {$/;"	f	typeref:typename:int
insub	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^int insub(int r, int c) {$/;"	f	typeref:typename:int
insub	code/Data Structures/Binarizing a Tree.cpp	/^int insub(int r, int c) {$/;"	f	typeref:typename:int
insub	code/Data Structures/Centroid Decomposition Persistent.cpp	/^int insub(int r, int c) {$/;"	f	typeref:typename:int
int	contests/AtCoder/215/B/main.cpp	/^#define int /;"	d	file:
int	contests/AtCoder/225/C.cpp	/^#define int /;"	d	file:
int	contests/AtCoder/231/C.cpp	/^#define int /;"	d	file:
int	contests/AtCoder/ABC211/C.cpp	/^#define int /;"	d	file:
int	contests/Codeforces/1560/B/main.cpp	/^#define int /;"	d	file:
int	contests/Codeforces/1560/C/main.cpp	/^#define int /;"	d	file:
int	contests/Codeforces/1560/D/main.cpp	/^#define int /;"	d	file:
int	contests/Codeforces/1560/F1/main.cpp	/^#define int /;"	d	file:
int	contests/Codeforces/1609/A.cpp	/^#define int /;"	d	file:
int	contests/Codeforces/1609/C.cpp	/^#define int /;"	d	file:
int	contests/Codeforces/1609/D.cpp	/^#define int /;"	d	file:
int	contests/Codeforces/1622/C/sol.cpp	/^#define int /;"	d	file:
int	contests/Codeforces/1622/C_new/main.cpp	/^#define int /;"	d	file:
int	contests/Codeforces/1622/C_new/sol.cpp	/^#define int /;"	d	file:
int	contests/Codeforces/1622/upsolve/C/sol.cpp	/^#define int /;"	d	file:
int	contests/Codeforces/1623/C/sol.cpp	/^#define int /;"	d	file:
int	contests/Codeforces/1623/new_C/sol.cpp	/^#define int /;"	d	file:
int	contests/Codeforces/737/A.cpp	/^#define int /;"	d	file:
int	contests/LIT2021/B.cpp	/^#define int /;"	d	file:
int	contests/USACO/dec_silver_2021/A/A.cpp	/^#define int /;"	d	file:
int	contests/USACO/dec_silver_2021/A/AA.cpp	/^#define int /;"	d	file:
int	contests/USACO/dec_silver_2021/A/AAA.cpp	/^#define int /;"	d	file:
int	contests/USACO/dec_silver_2021/A/A_safe.cpp	/^#define int /;"	d	file:
int	contests/USACO/dec_silver_2021/A/a_save.cpp	/^#define int /;"	d	file:
int	contests/USACO/dec_silver_2021/A/a_testing.cpp	/^#define int /;"	d	file:
int	contests/USACO/dec_silver_2021/A/restart_A.cpp	/^#define int /;"	d	file:
int	contests/USACO/dec_silver_2021/B/B.cpp	/^#define int /;"	d	file:
int	contests/USACO/dec_silver_2021/B/B_new.cpp	/^#define int /;"	d	file:
int	contests/USACO/dec_silver_2021/B/brute.cpp	/^#define int /;"	d	file:
int	contests/USACO/dec_silver_2021/C/C_full.cpp	/^#define int /;"	d	file:
int	practice/cf/DP/knap1.cpp	/^#define int /;"	d	file:
int	practice/cf/DP/knap2.cpp	/^#define int /;"	d	file:
int	practice/cf/random/1700/1618E/main.cpp	/^#define int /;"	d	file:
int	practice/cf/random/1700/2.cpp	/^#define int /;"	d	file:
int	practice/cf/random/1700/4.cpp	/^#define int /;"	d	file:
int	practice/cf/random/1700/6.cpp	/^#define int /;"	d	file:
int	practice/cf/random/1700/8.cpp	/^#define int /;"	d	file:
int	practice/cf/random/1700/brute.cpp	/^#define int /;"	d	file:
int	practice/cf/random/1700/test.cpp	/^#define int /;"	d	file:
int	practice/cf/random/1700/test2.cpp	/^#define int /;"	d	file:
int	practice/cf/random/1700/test3.cpp	/^#define int /;"	d	file:
int	practice/cf/random/i_hate_math_problems/1336B.cpp	/^#define int /;"	d	file:
int	practice/cf/random/i_hate_math_problems/1368D.cpp	/^#define int /;"	d	file:
int	practice/cf/random/i_hate_math_problems/1400B.cpp	/^#define int /;"	d	file:
int	practice/cf/random/i_hate_math_problems/1422C.cpp	/^#define int /;"	d	file:
int	practice/cf/random/i_hate_math_problems/1451D.cpp	/^#define int /;"	d	file:
int	practice/cpbook/ch1/1.4/medium/basicprogramming1.cpp	/^#define int /;"	d	file:
int	practice/cpbook/ch1/1.4/medium/garage.cpp	/^#define int /;"	d	file:
int	practice/cpbook/ch2/2.2/1D/pivot/main.cpp	/^#define int /;"	d	file:
int	practice/cpbook/ch3/DP/00787.cpp	/^#define int /;"	d	file:
int	practice/december2021/1572A/new_sol.cpp	/^#define int /;"	d	file:
int	practice/december2021/1572A/sol.cpp	/^#define int /;"	d	file:
int	practice/december2021/1619D/sol.cpp	/^#define int /;"	d	file:
int	practice/december2021/1619E/sol.cpp	/^#define int /;"	d	file:
int	practice/december2021/DP/counting_towers/sol.cpp	/^#define int /;"	d	file:
int	practice/usacoguide/gold/SP/dining/main.cpp	/^#define int /;"	d	file:
int	practice/usacoguide/gold/SP/flightdiscount.cpp	/^#define int /;"	d	file:
int	practice/usacoguide/gold/SP/pump.cpp	/^#define int /;"	d	file:
int	practice/usacoguide/gold/SP/shortestroutesii.cpp	/^#define int /;"	d	file:
int	practice/usacoguide/gold/bfs/cownav.cpp	/^#define int /;"	d	file:
int	practice/usacoguide/gold/bfs/mecho/main.cpp	/^#define int /;"	d	file:
int	practice/usacoguide/gold/bfs/mechonew/main.cpp	/^#define int /;"	d	file:
int	practice/usacoguide/gold/bfs/piggyback.cpp	/^#define int /;"	d	file:
int	practice/usacoguide/gold/divisibility/oraclcm.cpp	/^#define int /;"	d	file:
int	practice/usacoguide/gold/divisibility/powerproducts.cpp	/^#define int /;"	d	file:
int	practice/usacoguide/gold/dsu/tractor/main.cpp	/^#define int /;"	d	file:
int	practice/usacoguide/gold/introDP/arraydescription.cpp	/^#define int /;"	d	file:
int	practice/usacoguide/gold/introDP/cannonballs.cpp	/^#define int /;"	d	file:
int	practice/usacoguide/gold/introDP/time.cpp	/^#define int /;"	d	file:
int	practice/usacoguide/gold/modular/santasbot.cpp	/^#define int /;"	d	file:
int	practice/usacoguide/gold/modular/test.cpp	/^#define int /;"	d	file:
int	practice/usacoguide/silver/orderedsets/coveredpoints.cpp	/^#define int /;"	d	file:
intToDate	code-library/Miscellaneous/Dates.cpp	/^void intToDate(int jd, int &y, int &m, int &d) {$/;"	f	typeref:typename:void
intToDate	code/Miscellaneous/Dates.cpp	/^void intToDate(int jd, int &y, int &m, int &d) {$/;"	f	typeref:typename:void
intToDay	code-library/Miscellaneous/Dates.cpp	/^int intToDay(int jd) { return jd % 7; }$/;"	f	typeref:typename:int
intToDay	code/Miscellaneous/Dates.cpp	/^int intToDay(int jd) { return jd % 7; }$/;"	f	typeref:typename:int
integrate	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly integrate() const {$/;"	f	struct:poly	typeref:typename:poly	file:
integrate	code-library/Math/Integration (Romberg).cpp	/^double integrate(double l, double r){$/;"	f	typeref:typename:double
integrate	code-library/Math/Integration (Simpsons).cpp	/^double integrate(double l, double r){$/;"	f	typeref:typename:double
integrate	code-library/Math/Polynomial.cpp	/^  poly integrate() const {$/;"	f	struct:poly	typeref:typename:poly	file:
integrate	code-library/Math/Subset Sum Problem.cpp	/^  poly integrate() const {$/;"	f	struct:poly	typeref:typename:poly	file:
integrate	code-library/Number Theory/Bell Number.cpp	/^    poly integrate() const {$/;"	f	struct:poly	typeref:typename:poly	file:
integrate	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly integrate() const {$/;"	f	struct:poly	typeref:typename:poly	file:
integrate	code/Math/Faulhaber Formula Fastest.cpp	/^  poly integrate() const {$/;"	f	struct:poly	typeref:typename:poly	file:
integrate	code/Math/Integration (Romberg).cpp	/^double integrate(double l, double r){$/;"	f	typeref:typename:double
integrate	code/Math/Integration (Simpsons).cpp	/^double integrate(double l, double r){$/;"	f	typeref:typename:double
integrate	code/Math/Polynomial.cpp	/^  poly integrate() const {$/;"	f	struct:poly	typeref:typename:poly	file:
integrate	code/Math/Subset Sum Problem.cpp	/^  poly integrate() const {$/;"	f	struct:poly	typeref:typename:poly	file:
integrate	code/Number Theory/Bell Number.cpp	/^    poly integrate() const {$/;"	f	struct:poly	typeref:typename:poly	file:
integrate	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly integrate() const {$/;"	f	struct:poly	typeref:typename:poly	file:
inter	code-library/Geometry/Geometry 3D.cpp	/^    p3 inter(plane p) { return o - d * p.side(o) \/ (d | p.n); } \/\/ assuming plane and line ar/;"	f	struct:line3d	typeref:typename:p3	file:
inter	code/Geometry/Geometry 3D.cpp	/^    p3 inter(plane p) { return o - d * p.side(o) \/ (d | p.n); } \/\/ assuming plane and line ar/;"	f	struct:line3d	typeref:typename:p3	file:
interactive	practice/cf/random/1700/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	b
interactive	practice/cf/random/1700/1618E/problem.json	/^{"name": "E. Singers' Tour", "group": "Codeforces - Codeforces Round #760 (Div. 3)", "url": "htt/;"	b
interactive	practice/cf/random/coloring/problem.json	/^{"name": "A. Dreamoon Likes Coloring", "group": "Codeforces - Codeforces Round #631 (Div. 1) - T/;"	b
interactive	practice/cf/random/diane/problem.json	/^{"name": "D. Diane", "group": "Codeforces - Codeforces Round #735 (Div. 2)", "url": "https:\/\/c/;"	b
interactive	practice/cf/random/pink/problem.json	/^{"name": "C. Pinkie Pie Eats Patty-cakes", "group": "Codeforces - Codeforces Round #662 (Div. 2)/;"	b
interactive	practice/cf/stuff/dec 20 2021/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	b
interactive	practice/usacoguide/gold/SP/dining/problem.json	/^{"name": "Problem 1. Fine Dining", "group": "USACO - USACO 2018 December Contest, Gold", "url": /;"	b
interactive	practice/usacoguide/gold/SP/visitfj/problem.json	/^{"name": "Problem 1. Why Did the Cow Cross the Road", "group": "USACO - USACO 2017 February Cont/;"	b
interactive	practice/usacoguide/gold/bfs/cownav/problem.json	/^{"name": "Problem 3. Cow Navigation", "group": "USACO - USACO 2017 January Contest, Gold", "url"/;"	b
interactive	practice/usacoguide/gold/bfs/swap/problem.json	/^{"name": "Swap Game", "group": "CSES - CSES Problem Set", "url": "https:\/\/cses.fi\/problemset\//;"	b
interactive	practice/usacoguide/gold/dsu/closing/problem.json	/^{"name": "Problem 2. Closing the Farm", "group": "USACO - USACO 2016 US Open Contest, Gold", "ur/;"	b
interactive	practice/usacoguide/gold/dsu/moocast/problem.json	/^{"name": "Problem 1. Moocast", "group": "USACO - USACO 2016 December Contest, Gold", "url": "htt/;"	b
interactive	practice/usacoguide/gold/dsu/mootube/problem.json	/^{"name": "Problem 1. MooTube", "group": "USACO - USACO 2018 January Contest, Gold", "url": "http/;"	b
interactive	practice/usacoguide/gold/dsu/tractor/problem.json	/^{"name": "Problem 2. Tractor", "group": "USACO - USACO 2013 February Contest, Silver", "url": "h/;"	b
interactive	practice/usacoguide/gold/dsu/wormhole/problem.json	/^{"name": "Problem 3. Wormhole Sort", "group": "USACO - USACO 2020 January Contest, Silver", "url/;"	b
interactive	practice/usacoguide/silver/idk/lirs/problem.json	/^{"name": "Problem 3. Liars and Truth Tellers", "group": "USACO - USACO 2013 January Contest, Bro/;"	b
interactive	practice/usacoguide/silver/idk/maze/problem.json	/^{"name": "Problem 1. Maze Tac Toe", "group": "USACO - USACO 2021 US Open, Silver", "url": "http:/;"	b
interpolate	code-library/Math/Polynomial.cpp	/^  poly interpolate(vector<poly> &tree, int v, int l, int r, int ly, int ry, vector<mint> &y) { \//;"	f	struct:poly	typeref:typename:poly	file:
interpolate	code-library/Math/Polynomial.cpp	/^poly interpolate(vector<mint> x, vector<mint> y) { \/\/interpolates minimum polynomial from (xi,/;"	f	typeref:typename:poly
interpolate	code/Math/Polynomial.cpp	/^  poly interpolate(vector<poly> &tree, int v, int l, int r, int ly, int ry, vector<mint> &y) { \//;"	f	struct:poly	typeref:typename:poly	file:
interpolate	code/Math/Polynomial.cpp	/^poly interpolate(vector<mint> x, vector<mint> y) { \/\/interpolates minimum polynomial from (xi,/;"	f	typeref:typename:poly
intersect	code-library/Geometry/All Pair Segment Intersection.cpp	/^bool intersect (const seg & a, const seg & b) {$/;"	f	typeref:typename:bool
intersect	code-library/Number Theory/Intersection of Arithmetic Progressions.cpp	/^pair<ll, ll> intersect(ll a1, ll d1, ll a2, ll d2) {$/;"	f	typeref:typename:pair<ll,ll>
intersect	code/Geometry/All Pair Segment Intersection.cpp	/^bool intersect (const seg & a, const seg & b) {$/;"	f	typeref:typename:bool
intersect	code/Number Theory/Intersection of Arithmetic Progressions.cpp	/^pair<ll, ll> intersect(ll a1, ll d1, ll a2, ll d2) {$/;"	f	typeref:typename:pair<ll,ll>
intersect1d	code-library/Geometry/All Pair Segment Intersection.cpp	/^inline bool intersect1d (double l1, double r1, double l2, double r2) {$/;"	f	typeref:typename:bool
intersect1d	code/Geometry/All Pair Segment Intersection.cpp	/^inline bool intersect1d (double l1, double r1, double l2, double r2) {$/;"	f	typeref:typename:bool
intersection	code-library/Geometry/Geometry 2D.cpp	/^    PT intersection(const HP &v) {$/;"	f	struct:HP	typeref:typename:PT	file:
intersection	code-library/Geometry/Half Plane Intersection.cpp	/^    PT intersection(const HP &v) {$/;"	f	struct:HP	typeref:typename:PT	file:
intersection	code/Geometry/Geometry 2D.cpp	/^    PT intersection(const HP &v) {$/;"	f	struct:HP	typeref:typename:PT	file:
intersection	code/Geometry/Half Plane Intersection.cpp	/^    PT intersection(const HP &v) {$/;"	f	struct:HP	typeref:typename:PT	file:
interval_set	code-library/Data Structures/Interval Set.cpp	/^struct interval_set {$/;"	s	file:
interval_set	code/Data Structures/Interval Set.cpp	/^struct interval_set {$/;"	s	file:
inv	code-library/Data Structures/Cartesian Tree.cpp	/^ll inv[N], ans;$/;"	v	typeref:typename:ll[]
inv	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^mint inv[N];$/;"	v	typeref:typename:mint[]
inv	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^    modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Graph Theory/Number of Arborescence.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Graph Theory/Number of DAG.cpp	/^    modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Graph Theory/Tree Isomorphism.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Math/BerleKamp Massey.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Math/Characteristic Polynomial Faster.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Math/Determinant of Sparse Matrix.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Math/FWHT in Ternary Base.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Math/Faulhaber Formula Fastest.cpp	/^  inline mint inv(int n) { return invs[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
inv	code-library/Math/Faulhaber Formula Fastest.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^    modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Math/Hafnian of a Matrix.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Math/Lagrange Interpolation Brute.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline mint inv(int n) { return invs[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
inv	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Math/Lagrange Interpolation.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Math/Linear Recurrence.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Math/NTT Online.cpp	/^int f[N],inv[N],finv[N];$/;"	v	typeref:typename:int[]
inv	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Math/Polynomial Sum.cpp	/^  inline mint inv(int n) { return invs[n]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
inv	code-library/Math/Polynomial Sum.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Math/Polynomial with Binomial Coefficients.cpp	/^int f[N],inv[N],finv[N];$/;"	v	typeref:typename:int[]
inv	code-library/Math/Polynomial.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Math/Subset Sum Problem.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Math/The Slime Trick.cpp	/^    modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Math/Thomas Algorithm.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Math/Vandermonde Matrix.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Miscellaneous/Schreier–Sims algorithm.cpp	/^vector<int> inv(vector<int>& p){$/;"	f	typeref:typename:vector<int>
inv	code-library/Number Theory/Bell Number.cpp	/^    modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Number Theory/Combinatorics Basics.cpp	/^  inline mint inv(int n) { return invs[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
inv	code-library/Number Theory/Combinatorics Basics.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Number Theory/Dirichlet Convolution.cpp	/^    modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Number Theory/Dirichlet Convolution.cpp	/^  mint dp[T], inv;$/;"	v	namespace:Dirichlet	typeref:typename:mint
inv	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Number Theory/Lucas Theorem.cpp	/^  inline mint inv(int n) { return invs[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
inv	code-library/Number Theory/Lucas Theorem.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Number Theory/Min_25 Sieve.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline mint inv(int n) { return invs[n]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
inv	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Number Theory/Partition Function.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Number Theory/Phi Field.cpp	/^  field inv() {$/;"	f	struct:field	typeref:typename:field	file:
inv	code-library/Number Theory/Phi Field.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline mint inv(int n) { return invs[n]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
inv	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Number Theory/Prime Factorization Fastest.cpp	/^  static uint64_t mod, inv, r2;$/;"	m	struct:Mint	typeref:typename:uint64_t	file:
inv	code-library/Number Theory/Prime Factorization Fastest.cpp	/^uint64_t Mint::mod, Mint::inv, Mint::r2;$/;"	m	class:Mint	typeref:typename:uint64_t
inv	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  inline mint inv(int n) { return invs[n]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
inv	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static constexpr word_t inv = mul_inv(mod);$/;"	m	class:ntt::Mod	typeref:typename:word_t	file:
inv	code/Data Structures/Cartesian Tree.cpp	/^ll inv[N], ans;$/;"	v	typeref:typename:ll[]
inv	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^mint inv[N];$/;"	v	typeref:typename:mint[]
inv	code/Graph Theory/Chromatic Polynoimial.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Graph Theory/Counting Labeled Graphs.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Graph Theory/Hafnian of a Matrix.cpp	/^    modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Graph Theory/Number of Arborescence.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Graph Theory/Number of DAG.cpp	/^    modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Graph Theory/Tree Isomorphism.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Math/BerleKamp Massey.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Math/Characteristic Polynomial Faster.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Math/Determinant of Sparse Matrix.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Math/FWHT in Ternary Base.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Math/Faulhaber Formula Fastest.cpp	/^  inline mint inv(int n) { return invs[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
inv	code/Math/Faulhaber Formula Fastest.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Math/Generating Function of a Linear Recurrence.cpp	/^    modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Math/Hafnian of a Matrix.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Math/Lagrange Interpolation Brute.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline mint inv(int n) { return invs[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
inv	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Math/Lagrange Interpolation.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Math/Linear Recurrence.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Math/NTT Online.cpp	/^int f[N],inv[N],finv[N];$/;"	v	typeref:typename:int[]
inv	code/Math/Number of Solutions of A Equation MITM.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Math/Polynomial Sum.cpp	/^  inline mint inv(int n) { return invs[n]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
inv	code/Math/Polynomial Sum.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Math/Polynomial with Binomial Coefficients.cpp	/^int f[N],inv[N],finv[N];$/;"	v	typeref:typename:int[]
inv	code/Math/Polynomial.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Math/Subset Sum Problem.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Math/The Slime Trick.cpp	/^    modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Math/Thomas Algorithm.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Math/Vandermonde Matrix.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Miscellaneous/Schreier–Sims algorithm.cpp	/^vector<int> inv(vector<int>& p){$/;"	f	typeref:typename:vector<int>
inv	code/Number Theory/Bell Number.cpp	/^    modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Number Theory/Combinatorics Basics.cpp	/^  inline mint inv(int n) { return invs[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
inv	code/Number Theory/Combinatorics Basics.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Number Theory/Dirichlet Convolution.cpp	/^    modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Number Theory/Dirichlet Convolution.cpp	/^  mint dp[T], inv;$/;"	v	namespace:Dirichlet	typeref:typename:mint
inv	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Number Theory/Lucas Theorem.cpp	/^  inline mint inv(int n) { return invs[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
inv	code/Number Theory/Lucas Theorem.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Number Theory/Min_25 Sieve.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline mint inv(int n) { return invs[n]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
inv	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Number Theory/Partition Function.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Number Theory/Phi Field.cpp	/^  field inv() {$/;"	f	struct:field	typeref:typename:field	file:
inv	code/Number Theory/Phi Field.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline mint inv(int n) { return invs[n]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
inv	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Number Theory/Prime Factorization Fastest.cpp	/^  static uint64_t mod, inv, r2;$/;"	m	struct:Mint	typeref:typename:uint64_t	file:
inv	code/Number Theory/Prime Factorization Fastest.cpp	/^uint64_t Mint::mod, Mint::inv, Mint::r2;$/;"	m	class:Mint	typeref:typename:uint64_t
inv	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  inline mint inv(int n) { return invs[n]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
inv	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static constexpr word_t inv = mul_inv(mod);$/;"	m	class:ntt::Mod	typeref:typename:word_t	file:
inv	practice/cf/random/1700/6.cpp	/^mi inv(mi a) { assert(a.v != 0); return pow(a, MOD - 2); }$/;"	f	typeref:typename:mi
inv	practice/cf/random/i_hate_math_problems/1422C.cpp	/^mi inv(mi a) { assert(a.v != 0); return pow(a,MOD-2); }$/;"	f	typeref:typename:mi
inv	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^  inline mint inv(int n) { return invs[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
inv	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	practice/cf/random/i_hate_math_problems/testing.cpp	/^  inline mint inv(int n) { return invs[n]; }$/;"	f	struct:combi	typeref:typename:mint	file:
inv	practice/cf/random/i_hate_math_problems/testing.cpp	/^  modint<MOD> inv() const { return pow(MOD - 2); }  \/\/ MOD must be a prime$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
inv	practice/usacoguide/gold/divisibility/powerproducts.cpp	/^vector<pair<int, int>> inv(vector<pair<int, int>> cur) {$/;"	f	typeref:typename:vector<pair<int,int>>
inv	practice/usacoguide/gold/introDP/arraydescription.cpp	/^mi inv(mi a) { assert(a.v != 0); return pow(a,MOD-2); }$/;"	f	typeref:typename:mi
inv2	code-library/Math/FWHT.cpp	/^const int inv2 = (mod + 1) >> 1;$/;"	v	typeref:typename:const int
inv2	code/Math/FWHT.cpp	/^const int inv2 = (mod + 1) >> 1;$/;"	v	typeref:typename:const int
inv_lim	code-library/Math/NTT.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int
inv_lim	code-library/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int
inv_lim	code-library/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int
inv_lim	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int
inv_lim	code-library/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int
inv_lim	code/Math/NTT.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int
inv_lim	code/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int
inv_lim	code/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int
inv_lim	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int
inv_lim	code/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int
inverse	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly inverse(int n) const {  \/\/ 1 \/ p(x) % x^n, O(nlogn)$/;"	f	struct:poly	typeref:typename:poly	file:
inverse	code-library/Math/Inverse of A Matrix modulo 2.cpp	/^vector<bitset<N>> inverse(int n, vector<bitset<N>> mat) {$/;"	f	typeref:typename:vector<bitset<N>>
inverse	code-library/Math/Polynomial.cpp	/^  poly inverse(int n) const {  \/\/ 1 \/ p(x) % x^n, O(nlogn)$/;"	f	struct:poly	typeref:typename:poly	file:
inverse	code-library/Math/Subset Sum Problem.cpp	/^  poly inverse(int n) const {  \/\/ 1 \/ p(x) % x^n, O(nlogn)$/;"	f	struct:poly	typeref:typename:poly	file:
inverse	code-library/Math/Vandermonde Matrix.cpp	/^vv inverse(vector<mint> &x) {$/;"	f	typeref:typename:vv
inverse	code-library/Number Theory/Bell Number.cpp	/^    poly inverse(int n) const {  \/\/ 1 \/ p(x) % x^n, O(nlogn)$/;"	f	struct:poly	typeref:typename:poly	file:
inverse	code-library/Number Theory/Discrete Log.cpp	/^ll inverse(ll a, ll m) {$/;"	f	typeref:typename:ll
inverse	code-library/Number Theory/Discrete Root Faster.cpp	/^ll inverse(ll a, ll p) {$/;"	f	typeref:typename:ll
inverse	code-library/Number Theory/Extended Euclid.cpp	/^ll inverse(ll a, ll m) {$/;"	f	typeref:typename:ll
inverse	code-library/Number Theory/Linear Congruence Equation.cpp	/^ll inverse(ll a, ll m) {$/;"	f	typeref:typename:ll
inverse	code-library/Number Theory/Linear Diophantine Equation Three Variables with Nonnegative Solutions.cpp	/^T inverse(T a, T m) {$/;"	f	typeref:typename:T
inverse	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly inverse(int n) const {  \/\/ 1 \/ p(x) % x^n, O(nlogn)$/;"	f	struct:poly	typeref:typename:poly	file:
inverse	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  Mod inverse() const { return pow(mod - 2); }$/;"	f	class:ntt::Mod	typeref:typename:Mod	file:
inverse	code-library/Number Theory/nCr Modulo Any Mod.cpp	/^ll inverse(ll a, ll m) {$/;"	f	typeref:typename:ll
inverse	code/Math/Faulhaber Formula Fastest.cpp	/^  poly inverse(int n) const {  \/\/ 1 \/ p(x) % x^n, O(nlogn)$/;"	f	struct:poly	typeref:typename:poly	file:
inverse	code/Math/Inverse of A Matrix modulo 2.cpp	/^vector<bitset<N>> inverse(int n, vector<bitset<N>> mat) {$/;"	f	typeref:typename:vector<bitset<N>>
inverse	code/Math/Polynomial.cpp	/^  poly inverse(int n) const {  \/\/ 1 \/ p(x) % x^n, O(nlogn)$/;"	f	struct:poly	typeref:typename:poly	file:
inverse	code/Math/Subset Sum Problem.cpp	/^  poly inverse(int n) const {  \/\/ 1 \/ p(x) % x^n, O(nlogn)$/;"	f	struct:poly	typeref:typename:poly	file:
inverse	code/Math/Vandermonde Matrix.cpp	/^vv inverse(vector<mint> &x) {$/;"	f	typeref:typename:vv
inverse	code/Number Theory/Bell Number.cpp	/^    poly inverse(int n) const {  \/\/ 1 \/ p(x) % x^n, O(nlogn)$/;"	f	struct:poly	typeref:typename:poly	file:
inverse	code/Number Theory/Discrete Log.cpp	/^ll inverse(ll a, ll m) {$/;"	f	typeref:typename:ll
inverse	code/Number Theory/Discrete Root Faster.cpp	/^ll inverse(ll a, ll p) {$/;"	f	typeref:typename:ll
inverse	code/Number Theory/Extended Euclid.cpp	/^ll inverse(ll a, ll m) {$/;"	f	typeref:typename:ll
inverse	code/Number Theory/Linear Congruence Equation.cpp	/^ll inverse(ll a, ll m) {$/;"	f	typeref:typename:ll
inverse	code/Number Theory/Linear Diophantine Equation Three Variables with Nonnegative Solutions.cpp	/^T inverse(T a, T m) {$/;"	f	typeref:typename:T
inverse	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly inverse(int n) const {  \/\/ 1 \/ p(x) % x^n, O(nlogn)$/;"	f	struct:poly	typeref:typename:poly	file:
inverse	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  Mod inverse() const { return pow(mod - 2); }$/;"	f	class:ntt::Mod	typeref:typename:Mod	file:
inverse	code/Number Theory/nCr Modulo Any Mod.cpp	/^ll inverse(ll a, ll m) {$/;"	f	typeref:typename:ll
inverse	code/modint.hpp	/^    friend Mint inverse(Mint a) { return mexp(a, MOD - 2); }$/;"	f	typeref:typename:Mint
inverse	practice/december2021/DP/counting_towers/sol.cpp	/^    friend Modular inverse(Modular a) { return mexp(a, MOD - 2); }$/;"	f	typeref:typename:Modular	file:
inverse_mobius_transform	code-library/Dynamic Programming Optimizations/SOS convolutions.cpp	/^vector<int> inverse_mobius_transform(vector<int> f) {$/;"	f	namespace:SOS	typeref:typename:vector<int>
inverse_mobius_transform	code/Dynamic Programming Optimizations/SOS convolutions.cpp	/^vector<int> inverse_mobius_transform(vector<int> f) {$/;"	f	namespace:SOS	typeref:typename:vector<int>
inverse_zeta_transform	code-library/Dynamic Programming Optimizations/SOS convolutions.cpp	/^vector<int> inverse_zeta_transform(vector<int> f) {$/;"	f	namespace:SOS	typeref:typename:vector<int>
inverse_zeta_transform	code/Dynamic Programming Optimizations/SOS convolutions.cpp	/^vector<int> inverse_zeta_transform(vector<int> f) {$/;"	f	namespace:SOS	typeref:typename:vector<int>
invs	code-library/Math/Faulhaber Formula Fastest.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
invs	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
invs	code-library/Math/Polynomial Sum.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:vector<mint>	file:
invs	code-library/Number Theory/Combinatorics Basics.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
invs	code-library/Number Theory/Lucas Theorem.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
invs	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:vector<mint>	file:
invs	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:vector<mint>	file:
invs	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:vector<mint>	file:
invs	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static vector<R> invs, facts, ifacts;$/;"	m	class:poly	typeref:typename:vector<R>	file:
invs	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^vector<R> poly::invs, poly::facts, poly::ifacts;$/;"	m	class:poly	typeref:typename:vector<R>
invs	code/Math/Faulhaber Formula Fastest.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
invs	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
invs	code/Math/Polynomial Sum.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:vector<mint>	file:
invs	code/Number Theory/Combinatorics Basics.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
invs	code/Number Theory/Lucas Theorem.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
invs	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:vector<mint>	file:
invs	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:vector<mint>	file:
invs	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:vector<mint>	file:
invs	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static vector<R> invs, facts, ifacts;$/;"	m	class:poly	typeref:typename:vector<R>	file:
invs	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^vector<R> poly::invs, poly::facts, poly::ifacts;$/;"	m	class:poly	typeref:typename:vector<R>
invs	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
invs	practice/cf/random/i_hate_math_problems/testing.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:vector<mint>	file:
ip1	code-library/Strings/String Hashing.cpp	/^int ip1, ip2;$/;"	v	typeref:typename:int
ip1	code/Strings/String Hashing.cpp	/^int ip1, ip2;$/;"	v	typeref:typename:int
ip2	code-library/Strings/String Hashing.cpp	/^int ip1, ip2;$/;"	v	typeref:typename:int
ip2	code/Strings/String Hashing.cpp	/^int ip1, ip2;$/;"	v	typeref:typename:int
ipw	code-library/Strings/String Hashing.cpp	/^pair<int, int> pw[N], ipw[N];$/;"	v	typeref:typename:pair<int,int>[]
ipw	code/Strings/String Hashing.cpp	/^pair<int, int> pw[N], ipw[N];$/;"	v	typeref:typename:pair<int,int>[]
isPrime	code-library/Math/Polynomial Factorization.cpp	/^bool isPrime[MAXN];$/;"	v	typeref:typename:bool[]
isPrime	code/Math/Polynomial Factorization.cpp	/^bool isPrime[MAXN];$/;"	v	typeref:typename:bool[]
is_bipartite	code-library/Data Structures/DSU with Rollbacks.cpp	/^  bool is_bipartite() {$/;"	f	struct:DSU	typeref:typename:bool	file:
is_bipartite	code-library/Data Structures/DSU with Rollbacks.cpp	/^  bool is_bipartite() {$/;"	f	struct:DSUQueue	typeref:typename:bool	file:
is_bipartite	code-library/Data Structures/Queue Undo Trick.cpp	/^  bool is_bipartite() {$/;"	f	struct:DSU	typeref:typename:bool	file:
is_bipartite	code-library/Data Structures/Queue Undo Trick.cpp	/^  bool is_bipartite() {$/;"	f	struct:DSUQueue	typeref:typename:bool	file:
is_bipartite	code/Data Structures/DSU with Rollbacks.cpp	/^  bool is_bipartite() {$/;"	f	struct:DSU	typeref:typename:bool	file:
is_bipartite	code/Data Structures/DSU with Rollbacks.cpp	/^  bool is_bipartite() {$/;"	f	struct:DSUQueue	typeref:typename:bool	file:
is_bipartite	code/Data Structures/Queue Undo Trick.cpp	/^  bool is_bipartite() {$/;"	f	struct:DSU	typeref:typename:bool	file:
is_bipartite	code/Data Structures/Queue Undo Trick.cpp	/^  bool is_bipartite() {$/;"	f	struct:DSUQueue	typeref:typename:bool	file:
is_chordal	code-library/Graph Theory/Chordal Graph.cpp	/^bool is_chordal(int n, vector<int> & ord, set<pair<int, int>> &edges) {$/;"	f	typeref:typename:bool
is_chordal	code/Graph Theory/Chordal Graph.cpp	/^bool is_chordal(int n, vector<int> & ord, set<pair<int, int>> &edges) {$/;"	f	typeref:typename:bool
is_convex	code-library/Geometry/Geometry 2D.cpp	/^bool is_convex(vector<PT> &p) {$/;"	f	typeref:typename:bool
is_convex	code/Geometry/Geometry 2D.cpp	/^bool is_convex(vector<PT> &p) {$/;"	f	typeref:typename:bool
is_op	code-library/Miscellaneous/Expression Parsing.cpp	/^bool is_op(char c) {$/;"	f	typeref:typename:bool
is_op	code/Miscellaneous/Expression Parsing.cpp	/^bool is_op(char c) {$/;"	f	typeref:typename:bool
is_parallel	code-library/Geometry/Geometry 2D.cpp	/^bool is_parallel(PT a, PT b, PT c, PT d) {$/;"	f	typeref:typename:bool
is_parallel	code-library/Geometry/Geometry 3D.cpp	/^bool is_parallel(line3d l1, line3d l2) {$/;"	f	typeref:typename:bool
is_parallel	code-library/Geometry/Geometry 3D.cpp	/^bool is_parallel(plane p, line3d l) {$/;"	f	typeref:typename:bool
is_parallel	code-library/Geometry/Geometry 3D.cpp	/^bool is_parallel(plane p1, plane p2) {$/;"	f	typeref:typename:bool
is_parallel	code/Geometry/Geometry 2D.cpp	/^bool is_parallel(PT a, PT b, PT c, PT d) {$/;"	f	typeref:typename:bool
is_parallel	code/Geometry/Geometry 3D.cpp	/^bool is_parallel(line3d l1, line3d l2) {$/;"	f	typeref:typename:bool
is_parallel	code/Geometry/Geometry 3D.cpp	/^bool is_parallel(plane p, line3d l) {$/;"	f	typeref:typename:bool
is_parallel	code/Geometry/Geometry 3D.cpp	/^bool is_parallel(plane p1, plane p2) {$/;"	f	typeref:typename:bool
is_path	code-library/Data Structures/Top Tree.cpp	/^  bool is_path;$/;"	m	struct:top_tree_node	typeref:typename:bool	file:
is_path	code/Data Structures/Top Tree.cpp	/^  bool is_path;$/;"	m	struct:top_tree_node	typeref:typename:bool	file:
is_perpendicular	code-library/Geometry/Geometry 3D.cpp	/^bool is_perpendicular(line3d l1, line3d l2) {$/;"	f	typeref:typename:bool
is_perpendicular	code-library/Geometry/Geometry 3D.cpp	/^bool is_perpendicular(plane p, line3d l) {$/;"	f	typeref:typename:bool
is_perpendicular	code-library/Geometry/Geometry 3D.cpp	/^bool is_perpendicular(plane p1, plane p2) {$/;"	f	typeref:typename:bool
is_perpendicular	code/Geometry/Geometry 3D.cpp	/^bool is_perpendicular(line3d l1, line3d l2) {$/;"	f	typeref:typename:bool
is_perpendicular	code/Geometry/Geometry 3D.cpp	/^bool is_perpendicular(plane p, line3d l) {$/;"	f	typeref:typename:bool
is_perpendicular	code/Geometry/Geometry 3D.cpp	/^bool is_perpendicular(plane p1, plane p2) {$/;"	f	typeref:typename:bool
is_point_in_angle	code-library/Geometry/Geometry 2D.cpp	/^bool is_point_in_angle(PT b, PT a, PT c, PT p) { \/\/ does point p lie in angle <bac$/;"	f	typeref:typename:bool
is_point_in_angle	code-library/Geometry/Voronoi Diagram.cpp	/^bool is_point_in_angle(PT b, PT a, PT c, PT p) { \/\/ does point p lie in angle <bac$/;"	f	typeref:typename:bool
is_point_in_angle	code/Geometry/Geometry 2D.cpp	/^bool is_point_in_angle(PT b, PT a, PT c, PT p) { \/\/ does point p lie in angle <bac$/;"	f	typeref:typename:bool
is_point_in_angle	code/Geometry/Voronoi Diagram.cpp	/^bool is_point_in_angle(PT b, PT a, PT c, PT p) { \/\/ does point p lie in angle <bac$/;"	f	typeref:typename:bool
is_point_in_convex	code-library/Geometry/Geometry 2D.cpp	/^int is_point_in_convex(vector<PT> &p, const PT& x) { \/\/ O(log n)$/;"	f	typeref:typename:int
is_point_in_convex	code/Geometry/Geometry 2D.cpp	/^int is_point_in_convex(vector<PT> &p, const PT& x) { \/\/ O(log n)$/;"	f	typeref:typename:int
is_point_in_polygon	code-library/Geometry/Geometry 2D.cpp	/^int is_point_in_polygon(vector<PT> &p, const PT& z) { \/\/ O(n)$/;"	f	typeref:typename:int
is_point_in_polygon	code-library/Geometry/Voronoi Diagram.cpp	/^int is_point_in_polygon(vector<PT> &p, const PT& z) { \/\/ O(n)$/;"	f	typeref:typename:int
is_point_in_polygon	code/Geometry/Geometry 2D.cpp	/^int is_point_in_polygon(vector<PT> &p, const PT& z) { \/\/ O(n)$/;"	f	typeref:typename:int
is_point_in_polygon	code/Geometry/Voronoi Diagram.cpp	/^int is_point_in_polygon(vector<PT> &p, const PT& z) { \/\/ O(n)$/;"	f	typeref:typename:int
is_point_in_triangle	code-library/Geometry/Geometry 2D.cpp	/^int is_point_in_triangle(PT a, PT b, PT c, PT p) {$/;"	f	typeref:typename:int
is_point_in_triangle	code/Geometry/Geometry 2D.cpp	/^int is_point_in_triangle(PT a, PT b, PT c, PT p) {$/;"	f	typeref:typename:int
is_point_on_polygon	code-library/Geometry/Geometry 2D.cpp	/^bool is_point_on_polygon(vector<PT> &p, const PT& z) {$/;"	f	typeref:typename:bool
is_point_on_polygon	code-library/Geometry/Voronoi Diagram.cpp	/^bool is_point_on_polygon(vector<PT> &p, const PT& z) {$/;"	f	typeref:typename:bool
is_point_on_polygon	code/Geometry/Geometry 2D.cpp	/^bool is_point_on_polygon(vector<PT> &p, const PT& z) {$/;"	f	typeref:typename:bool
is_point_on_polygon	code/Geometry/Voronoi Diagram.cpp	/^bool is_point_on_polygon(vector<PT> &p, const PT& z) {$/;"	f	typeref:typename:bool
is_point_on_seg	code-library/Geometry/Geometry 2D.cpp	/^bool is_point_on_seg(PT a, PT b, PT p) {$/;"	f	typeref:typename:bool
is_point_on_seg	code-library/Geometry/Voronoi Diagram.cpp	/^bool is_point_on_seg(PT a, PT b, PT p) {$/;"	f	typeref:typename:bool
is_point_on_seg	code/Geometry/Geometry 2D.cpp	/^bool is_point_on_seg(PT a, PT b, PT p) {$/;"	f	typeref:typename:bool
is_point_on_seg	code/Geometry/Voronoi Diagram.cpp	/^bool is_point_on_seg(PT a, PT b, PT p) {$/;"	f	typeref:typename:bool
is_prime	code-library/Number Theory/Prime Factorization Fastest.cpp	/^bool is_prime(const uint64_t &n) {$/;"	f	typeref:typename:bool
is_prime	code/Number Theory/Prime Factorization Fastest.cpp	/^bool is_prime(const uint64_t &n) {$/;"	f	typeref:typename:bool
is_reachable	code-library/Graph Theory/DAG Reachability Dynamic.cpp	/^  bool is_reachable(int s, int t) {$/;"	f	struct:Italiano	typeref:typename:bool	file:
is_reachable	code/Graph Theory/DAG Reachability Dynamic.cpp	/^  bool is_reachable(int s, int t) {$/;"	f	struct:Italiano	typeref:typename:bool	file:
is_root	code-library/Data Structures/Link Cut Tree.cpp	/^  int is_root(int u) {$/;"	f	struct:LCT	typeref:typename:int	file:
is_root	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  bool is_root(int x) {$/;"	f	namespace:lct	typeref:typename:bool
is_root	code/Data Structures/Link Cut Tree.cpp	/^  int is_root(int u) {$/;"	f	struct:LCT	typeref:typename:int	file:
is_root	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  bool is_root(int x) {$/;"	f	namespace:lct	typeref:typename:bool
is_unary	code-library/Miscellaneous/Expression Parsing.cpp	/^bool is_unary(char c) {$/;"	f	typeref:typename:bool
is_unary	code/Miscellaneous/Expression Parsing.cpp	/^bool is_unary(char c) {$/;"	f	typeref:typename:bool
is_var	code-library/Math/Gaussian Elimination Modulo 2.cpp	/^bool is_var(string t) { return t.size() > 0 && t[0] == 'x'; }$/;"	f	typeref:typename:bool
is_var	code/Math/Gaussian Elimination Modulo 2.cpp	/^bool is_var(string t) { return t.size() > 0 && t[0] == 'x'; }$/;"	f	typeref:typename:bool
is_vert	code-library/Data Structures/Top Tree.cpp	/^  bool is_vert;$/;"	m	struct:top_tree_node	typeref:typename:bool	file:
is_vert	code/Data Structures/Top Tree.cpp	/^  bool is_vert;$/;"	m	struct:top_tree_node	typeref:typename:bool	file:
is_zero	code-library/Math/Faulhaber Formula Fastest.cpp	/^  bool is_zero() const {return a.empty();}$/;"	f	struct:poly	typeref:typename:bool	file:
is_zero	code-library/Math/Polynomial.cpp	/^  bool is_zero() const {$/;"	f	struct:poly	typeref:typename:bool	file:
is_zero	code-library/Math/Subset Sum Problem.cpp	/^  bool is_zero() const {$/;"	f	struct:poly	typeref:typename:bool	file:
is_zero	code-library/Number Theory/Bell Number.cpp	/^  bool is_zero() const {$/;"	f	struct:poly	typeref:typename:bool	file:
is_zero	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  bool is_zero() const {$/;"	f	struct:poly	typeref:typename:bool	file:
is_zero	code/Math/Faulhaber Formula Fastest.cpp	/^  bool is_zero() const {return a.empty();}$/;"	f	struct:poly	typeref:typename:bool	file:
is_zero	code/Math/Polynomial.cpp	/^  bool is_zero() const {$/;"	f	struct:poly	typeref:typename:bool	file:
is_zero	code/Math/Subset Sum Problem.cpp	/^  bool is_zero() const {$/;"	f	struct:poly	typeref:typename:bool	file:
is_zero	code/Number Theory/Bell Number.cpp	/^  bool is_zero() const {$/;"	f	struct:poly	typeref:typename:bool	file:
is_zero	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  bool is_zero() const {$/;"	f	struct:poly	typeref:typename:bool	file:
isanc	code-library/Graph Theory/Path Intersection.cpp	/^int isanc(int u, int g) {$/;"	f	typeref:typename:int
isanc	code-library/Graph Theory/Path Union.cpp	/^int isanc(int u, int g) {$/;"	f	typeref:typename:int
isanc	code-library/Graph Theory/Virtual Tree.cpp	/^int isanc(int u, int v) {$/;"	f	typeref:typename:int
isanc	code/Graph Theory/Path Intersection.cpp	/^int isanc(int u, int g) {$/;"	f	typeref:typename:int
isanc	code/Graph Theory/Path Union.cpp	/^int isanc(int u, int g) {$/;"	f	typeref:typename:int
isanc	code/Graph Theory/Virtual Tree.cpp	/^int isanc(int u, int v) {$/;"	f	typeref:typename:int
isleaf	code-library/Geometry/Onion Decomposition.cpp	/^    bool isleaf(int w) {$/;"	f	struct:LeftHull	typeref:typename:bool	file:
isleaf	code/Geometry/Onion Decomposition.cpp	/^    bool isleaf(int w) {$/;"	f	struct:LeftHull	typeref:typename:bool	file:
iso	code-library/Graph Theory/Tree Isomorphism.cpp	/^  bool iso(Tree &t) {$/;"	f	struct:Tree	typeref:typename:bool	file:
iso	code/Graph Theory/Tree Isomorphism.cpp	/^  bool iso(Tree &t) {$/;"	f	struct:Tree	typeref:typename:bool	file:
isq	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  vector<unsigned int> isq, cur;$/;"	m	struct:mcSFlow	typeref:typename:vector<unsigned int>	file:
isq	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  vector<unsigned int> isq, cur;$/;"	m	struct:mcSFlow	typeref:typename:vector<unsigned int>	file:
isqrt	code-library/Number Theory/Fermats Theorem on Sum of Two Squares.cpp	/^    inline num_t isqrt(num_t k) {$/;"	f	namespace:FermatRepresent	typeref:typename:num_t
isqrt	code/Number Theory/Fermats Theorem on Sum of Two Squares.cpp	/^    inline num_t isqrt(num_t k) {$/;"	f	namespace:FermatRepresent	typeref:typename:num_t
isquery	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^bool isquery[N];$/;"	v	typeref:typename:bool[]
isquery	code/Data Structures/Dynamic Connectivity Problem.cpp	/^bool isquery[N];$/;"	v	typeref:typename:bool[]
it	code-library/Graph Theory/ST Numbering.cpp	/^list<int>::iterator it[N];$/;"	v	typeref:typename:list<int>::iterator[]
it	code/Graph Theory/ST Numbering.cpp	/^list<int>::iterator it[N];$/;"	v	typeref:typename:list<int>::iterator[]
iter	code-library/Geometry/All Pair Segment Intersection.cpp	/^typedef set<seg>::iterator iter;$/;"	t	typeref:typename:set<seg>::iterator	file:
iter	code-library/Geometry/Convec Hull Dynamic.cpp	/^typedef set<pair<int, int> >::iterator iter;$/;"	t	typeref:typename:set<pair<int,int>>::iterator	file:
iter	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    using iter = multimap<Angle, PT>::iterator;$/;"	t	struct:HalfPlaneSet	typeref:typename:multimap<Angle,PT>::iterator	file:
iter	code-library/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  vector<pair<int, int>>::iterator iter[N];$/;"	m	struct:Euler	typeref:typename:vector<pair<int,int>>::iterator[]	file:
iter	code/Geometry/All Pair Segment Intersection.cpp	/^typedef set<seg>::iterator iter;$/;"	t	typeref:typename:set<seg>::iterator	file:
iter	code/Geometry/Convec Hull Dynamic.cpp	/^typedef set<pair<int, int> >::iterator iter;$/;"	t	typeref:typename:set<pair<int,int>>::iterator	file:
iter	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    using iter = multimap<Angle, PT>::iterator;$/;"	t	struct:HalfPlaneSet	typeref:typename:multimap<Angle,PT>::iterator	file:
iter	code/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  vector<pair<int, int>>::iterator iter[N];$/;"	m	struct:Euler	typeref:typename:vector<pair<int,int>>::iterator[]	file:
its	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  vector<vector<S>::iterator> its; \/\/ levels and iterators$/;"	m	struct:Dinic	typeref:typename:vector<vector<S>::iterator>	file:
its	code/Graph Theory/Gomory Hu Tree.cpp	/^  vector<vector<S>::iterator> its; \/\/ levels and iterators$/;"	m	struct:Dinic	typeref:typename:vector<vector<S>::iterator>	file:
iwt	code-library/Math/FWHT.cpp	/^  void iwt(int* a, int n, int flag = XOR) {$/;"	f	struct:FWHT	typeref:typename:void	file:
iwt	code/Math/FWHT.cpp	/^  void iwt(int* a, int n, int flag = XOR) {$/;"	f	struct:FWHT	typeref:typename:void	file:
j	code-library/Data Structures/Divide and Conquer for Insert and Query Problems.cpp	/^      for(int j = 1; j < i; j++) if(a[j] < a[i])$/;"	v	typeref:typename:int
j	code/Data Structures/Divide and Conquer for Insert and Query Problems.cpp	/^      for(int j = 1; j < i; j++) if(a[j] < a[i])$/;"	v	typeref:typename:int
java	practice/cf/random/1700/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	o	object:languages
java	practice/cf/random/1700/1618E/problem.json	/^{"name": "E. Singers' Tour", "group": "Codeforces - Codeforces Round #760 (Div. 3)", "url": "htt/;"	o	object:languages
java	practice/cf/random/coloring/problem.json	/^{"name": "A. Dreamoon Likes Coloring", "group": "Codeforces - Codeforces Round #631 (Div. 1) - T/;"	o	object:languages
java	practice/cf/random/diane/problem.json	/^{"name": "D. Diane", "group": "Codeforces - Codeforces Round #735 (Div. 2)", "url": "https:\/\/c/;"	o	object:languages
java	practice/cf/random/pink/problem.json	/^{"name": "C. Pinkie Pie Eats Patty-cakes", "group": "Codeforces - Codeforces Round #662 (Div. 2)/;"	o	object:languages
java	practice/cf/stuff/dec 20 2021/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	o	object:languages
java	practice/usacoguide/gold/SP/dining/problem.json	/^{"name": "Problem 1. Fine Dining", "group": "USACO - USACO 2018 December Contest, Gold", "url": /;"	o	object:languages
java	practice/usacoguide/gold/SP/visitfj/problem.json	/^{"name": "Problem 1. Why Did the Cow Cross the Road", "group": "USACO - USACO 2017 February Cont/;"	o	object:languages
java	practice/usacoguide/gold/bfs/cownav/problem.json	/^{"name": "Problem 3. Cow Navigation", "group": "USACO - USACO 2017 January Contest, Gold", "url"/;"	o	object:languages
java	practice/usacoguide/gold/bfs/swap/problem.json	/^{"name": "Swap Game", "group": "CSES - CSES Problem Set", "url": "https:\/\/cses.fi\/problemset\//;"	o	object:languages
java	practice/usacoguide/gold/dsu/closing/problem.json	/^{"name": "Problem 2. Closing the Farm", "group": "USACO - USACO 2016 US Open Contest, Gold", "ur/;"	o	object:languages
java	practice/usacoguide/gold/dsu/moocast/problem.json	/^{"name": "Problem 1. Moocast", "group": "USACO - USACO 2016 December Contest, Gold", "url": "htt/;"	o	object:languages
java	practice/usacoguide/gold/dsu/mootube/problem.json	/^{"name": "Problem 1. MooTube", "group": "USACO - USACO 2018 January Contest, Gold", "url": "http/;"	o	object:languages
java	practice/usacoguide/gold/dsu/tractor/problem.json	/^{"name": "Problem 2. Tractor", "group": "USACO - USACO 2013 February Contest, Silver", "url": "h/;"	o	object:languages
java	practice/usacoguide/gold/dsu/wormhole/problem.json	/^{"name": "Problem 3. Wormhole Sort", "group": "USACO - USACO 2020 January Contest, Silver", "url/;"	o	object:languages
java	practice/usacoguide/silver/idk/lirs/problem.json	/^{"name": "Problem 3. Liars and Truth Tellers", "group": "USACO - USACO 2013 January Contest, Bro/;"	o	object:languages
java	practice/usacoguide/silver/idk/maze/problem.json	/^{"name": "Problem 1. Maze Tac Toe", "group": "USACO - USACO 2021 US Open, Silver", "url": "http:/;"	o	object:languages
jk	.compilingScripts/init.vim	/^imap jk <Esc>$/;"	m
jk	.config/nvim/init.vim	/^imap jk <Esc>$/;"	m
jk	dotfiles/init.vim	/^imap jk <Esc>$/;"	m
jk	dotfiles/macinit.vim	/^imap jk <Esc>$/;"	m
johnson	code-library/Graph Theory/Johnson's Algorithm.cpp	/^int johnson(int n, vector <struct edge> ed){$/;"	f	typeref:typename:int
johnson	code/Graph Theory/Johnson's Algorithm.cpp	/^int johnson(int n, vector <struct edge> ed){$/;"	f	typeref:typename:int
josephus	code-library/Miscellaneous/Josephus Problem.cpp	/^ll josephus(ll n, ll k, ll m) {$/;"	f	typeref:typename:ll
josephus	code/Miscellaneous/Josephus Problem.cpp	/^ll josephus(ll n, ll k, ll m) {$/;"	f	typeref:typename:ll
k	code-library/Data Structures/Disjoint Sparse Table.cpp	/^  int k, n;$/;"	m	struct:DST	typeref:typename:int	file:
k	code-library/Dynamic Programming Optimizations/Connected Component DP.cpp	/^int n, k, a[N], dp[N][N][1005][3];$/;"	v	typeref:typename:int
k	code-library/Dynamic Programming Optimizations/Knuth Optimization.cpp	/^int n, k;$/;"	v	typeref:typename:int
k	code-library/Dynamic Programming Optimizations/Number of Subsequences Having Product at least K.cpp	/^int a[N], k;$/;"	v	typeref:typename:int
k	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  ll k, d;$/;"	m	struct:Line	typeref:typename:ll	file:
k	code-library/Dynamic Programming Optimizations/XOR Equation.cpp	/^int k, Z;$/;"	v	typeref:typename:int
k	code-library/Graph Theory/Articulation Bridges.cpp	/^  int n, k;$/;"	m	struct:TECC	typeref:typename:int	file:
k	code-library/Graph Theory/Steiner Tree Problem.cpp	/^int n, k, m;$/;"	v	typeref:typename:int
k	code-library/Math/Polynomial Sum.cpp	/^int k;$/;"	v	typeref:typename:int
k	code-library/Math/Simplex Algorithm.cpp	/^ll n,k,a[N],dis[N][N];$/;"	v	typeref:typename:ll
k	code-library/Miscellaneous/XOR Equation Arbitrary Range.cpp	/^int k, Z;$/;"	v	typeref:typename:int
k	code/Data Structures/Disjoint Sparse Table.cpp	/^  int k, n;$/;"	m	struct:DST	typeref:typename:int	file:
k	code/Dynamic Programming Optimizations/Connected Component DP.cpp	/^int n, k, a[N], dp[N][N][1005][3];$/;"	v	typeref:typename:int
k	code/Dynamic Programming Optimizations/Knuth Optimization.cpp	/^int n, k;$/;"	v	typeref:typename:int
k	code/Dynamic Programming Optimizations/Number of Subsequences Having Product at least K.cpp	/^int a[N], k;$/;"	v	typeref:typename:int
k	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  ll k, d;$/;"	m	struct:Line	typeref:typename:ll	file:
k	code/Dynamic Programming Optimizations/XOR Equation.cpp	/^int k, Z;$/;"	v	typeref:typename:int
k	code/Graph Theory/Articulation Bridges.cpp	/^  int n, k;$/;"	m	struct:TECC	typeref:typename:int	file:
k	code/Graph Theory/Steiner Tree Problem.cpp	/^int n, k, m;$/;"	v	typeref:typename:int
k	code/Math/Polynomial Sum.cpp	/^int k;$/;"	v	typeref:typename:int
k	code/Math/Simplex Algorithm.cpp	/^ll n,k,a[N],dis[N][N];$/;"	v	typeref:typename:ll
k	code/Miscellaneous/XOR Equation Arbitrary Range.cpp	/^int k, Z;$/;"	v	typeref:typename:int
k	contests/Codeforces/1560/F1/main1.cpp	/^int t, n, k;$/;"	v	typeref:typename:int
kInf	code-library/Graph Theory/LCA in O(1).cpp	/^  T kInf = numeric_limits<T>::max();$/;"	m	struct:RMQ	typeref:typename:T	file:
kInf	code/Graph Theory/LCA in O(1).cpp	/^  T kInf = numeric_limits<T>::max();$/;"	m	struct:RMQ	typeref:typename:T	file:
k_1	contests/Codeforces/1560/F1/main.cpp	/^vector<int> k_1, k_2;$/;"	v	typeref:typename:vector<int>
k_2	contests/Codeforces/1560/F1/main.cpp	/^vector<int> k_1, k_2;$/;"	v	typeref:typename:vector<int>
kd_node	code-library/Data Structures/KD Tree.cpp	/^struct kd_node {$/;"	s	file:
kd_node	code/Data Structures/KD Tree.cpp	/^struct kd_node {$/;"	s	file:
kevin_end	contests/LIT2021/C.cpp	/^P alicia_start, kevin_start, alicia_end, kevin_end;$/;"	v	typeref:typename:P
kevin_start	contests/LIT2021/C.cpp	/^P alicia_start, kevin_start, alicia_end, kevin_end;$/;"	v	typeref:typename:P
key	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  int pos, key, mn, mx;$/;"	m	struct:node	typeref:typename:int	file:
key	code-library/Data Structures/Treap.cpp	/^  int key, prior;$/;"	m	struct:node	typeref:typename:int	file:
key	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  int pos, key, mn, mx;$/;"	m	struct:node	typeref:typename:int	file:
key	code/Data Structures/Treap.cpp	/^  int key, prior;$/;"	m	struct:node	typeref:typename:int	file:
kinds	code-library/Strings/Suffix Array Isomorphic.cpp	/^const int kinds = N;$/;"	v	typeref:typename:const int
kinds	code/Strings/Suffix Array Isomorphic.cpp	/^const int kinds = N;$/;"	v	typeref:typename:const int
king	practice/cpbook/ch1/1.6/chess/00225/main.cpp	/^int king, queen, mov;$/;"	v	typeref:typename:int
king	practice/cpbook/ch1/1.6/chess/10284/main.cpp	/^void king(int row, int col, bool black) {$/;"	f	typeref:typename:void
king_pos	practice/cpbook/ch1/1.6/chess/00225/main.cpp	/^pair<int, int> queen_pos, king_pos, mov_pos;$/;"	v	typeref:typename:pair<int,int>
king_vis	practice/cpbook/ch1/1.6/chess/00225/main.cpp	/^bool queen_vis[8][8], king_vis[8][8], queen_vis1[8][8];$/;"	v	typeref:typename:bool[8][8]
kmp	code-library/Strings/KMP.cpp	/^void kmp(vector<int> lps, string s, string p) {$/;"	f	typeref:typename:void
kmp	code/Strings/KMP.cpp	/^void kmp(vector<int> lps, string s, string p) {$/;"	f	typeref:typename:void
knight	practice/cpbook/ch1/1.6/chess/10284/main.cpp	/^void knight(int row, int col, bool black) {$/;"	f	typeref:typename:void
knight_move	code-library/Miscellaneous/Knight Moves in Infinity Grid.cpp	/^ll knight_move(ll x, ll y) {$/;"	f	typeref:typename:ll
knight_move	code/Miscellaneous/Knight Moves in Infinity Grid.cpp	/^ll knight_move(ll x, ll y) {$/;"	f	typeref:typename:ll
kth	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int kth(int u, int k) {$/;"	f	typeref:typename:int
kth	code-library/Data Structures/HLD.cpp	/^int kth(int u, int k) {$/;"	f	typeref:typename:int
kth	code-library/Data Structures/LCA.cpp	/^int kth(int u, int k) {$/;"	f	typeref:typename:int
kth	code-library/Data Structures/Wavelet Tree.cpp	/^  int kth(int l, int r, int k) {$/;"	f	struct:wavelet_tree	typeref:typename:int	file:
kth	code-library/Graph Theory/LCA.cpp	/^int kth(int u, int k) {$/;"	f	typeref:typename:int
kth	code-library/Graph Theory/Path Intersection.cpp	/^int kth(int u, int k) {$/;"	f	typeref:typename:int
kth	code-library/Graph Theory/Path Union.cpp	/^int kth(int u, int k) {$/;"	f	typeref:typename:int
kth	code-library/Graph Theory/Virtual Tree.cpp	/^int kth(int u, int k) {$/;"	f	typeref:typename:int
kth	code-library/Math/Basis Vector.cpp	/^  int kth(int k) { \/\/ 1st is 0$/;"	f	struct:Basis	typeref:typename:int	file:
kth	code-library/Strings/Number of Palindromes in Range.cpp	/^  int kth(int l, int r, int k) {$/;"	f	struct:wavelet_tree	typeref:typename:int	file:
kth	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int kth(int u, int k) {$/;"	f	typeref:typename:int
kth	code/Data Structures/HLD.cpp	/^int kth(int u, int k) {$/;"	f	typeref:typename:int
kth	code/Data Structures/LCA.cpp	/^int kth(int u, int k) {$/;"	f	typeref:typename:int
kth	code/Data Structures/Wavelet Tree.cpp	/^  int kth(int l, int r, int k) {$/;"	f	struct:wavelet_tree	typeref:typename:int	file:
kth	code/Graph Theory/LCA.cpp	/^int kth(int u, int k) {$/;"	f	typeref:typename:int
kth	code/Graph Theory/Path Intersection.cpp	/^int kth(int u, int k) {$/;"	f	typeref:typename:int
kth	code/Graph Theory/Path Union.cpp	/^int kth(int u, int k) {$/;"	f	typeref:typename:int
kth	code/Graph Theory/Virtual Tree.cpp	/^int kth(int u, int k) {$/;"	f	typeref:typename:int
kth	code/Math/Basis Vector.cpp	/^  int kth(int k) { \/\/ 1st is 0$/;"	f	struct:Basis	typeref:typename:int	file:
kth	code/Strings/Number of Palindromes in Range.cpp	/^  int kth(int l, int r, int k) {$/;"	f	struct:wavelet_tree	typeref:typename:int	file:
kth_perm	code-library/Number Theory/Factoradic Number System.cpp	/^vector<int> kth_perm(int n, int k) { \/\/ k < n!$/;"	f	typeref:typename:vector<int>
kth_perm	code/Number Theory/Factoradic Number System.cpp	/^vector<int> kth_perm(int n, int k) { \/\/ k < n!$/;"	f	typeref:typename:vector<int>
l	code-library/Data Structures/BST using STL.cpp	/^map<int, int>l, r; \/\/l contains the left child of the node, r contains right child of the node$/;"	v	typeref:typename:map<int,int>
l	code-library/Data Structures/Cartesian Tree.cpp	/^int n, tot, st[N], l[N], r[N], vis[N];$/;"	v	typeref:typename:int[]
l	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^        int l = 0, r = 0; mint lf = 0, ls = 0; mint val = 0;$/;"	m	struct:PST::node	typeref:typename:int	file:
l	code-library/Data Structures/Implicit Treap.cpp	/^    node *l, *r, *par;$/;"	m	struct:treap::node	typeref:typename:node *	file:
l	code-library/Data Structures/MOs Algorithm.cpp	/^  int l, r, id;$/;"	m	struct:query	typeref:typename:int	file:
l	code-library/Data Structures/MOs on tree.cpp	/^  int l, r, id;$/;"	m	struct:query	typeref:typename:int	file:
l	code-library/Data Structures/MOs with DSU.cpp	/^  int l, r, idx;$/;"	m	struct:query	typeref:typename:int	file:
l	code-library/Data Structures/MOs with Update.cpp	/^  int l, r, t, id;$/;"	m	struct:query	typeref:typename:int	file:
l	code-library/Data Structures/MOs with Update.cpp	/^int cnt[N], f[N], ans[N], l, r, t;$/;"	v	typeref:typename:int
l	code-library/Data Structures/Monotonous Queue.cpp	/^  int a[N + 10], b[N + 10], l = 0, r = -1;$/;"	m	struct:monotonous_queue	typeref:typename:int	file:
l	code-library/Data Structures/Persistent Array.cpp	/^    node* l, * r; T x;$/;"	m	struct:PersistentArray::node	typeref:typename:node *	file:
l	code-library/Data Structures/Persistent Queue.cpp	/^    node* l, * r; T x;$/;"	m	struct:PersistentArray::node	typeref:typename:node *	file:
l	code-library/Data Structures/Persistent UnionFind.cpp	/^    node* l, * r; T x;$/;"	m	struct:PersistentArray::node	typeref:typename:node *	file:
l	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  ST *l, *r;$/;"	m	struct:ST	typeref:typename:ST *	file:
l	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  node *l, *r;$/;"	m	struct:node	typeref:typename:node *	file:
l	code-library/Data Structures/Segment Tree Merging.cpp	/^    int l, r, sz;$/;"	m	struct:STM::node	typeref:typename:int	file:
l	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^    int l = 0, r = 0, lazy = 0, p = 0;$/;"	m	struct:PST::node	typeref:typename:int	file:
l	code-library/Data Structures/Segment Tree Persistent.cpp	/^    int l = 0, r = 0, val = 0;$/;"	m	struct:PST::node	typeref:typename:int	file:
l	code-library/Data Structures/Sparse Table 2D.cpp	/^int l[N][N], u[N][N];$/;"	v	typeref:typename:int[][]
l	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^int ty[N], l[N], r[N], x[N];$/;"	v	typeref:typename:int[]
l	code-library/Data Structures/Treap persistent.cpp	/^  node *l, *r;$/;"	m	struct:node	typeref:typename:node *	file:
l	code-library/Data Structures/Treap.cpp	/^  node *l, *r;$/;"	m	struct:node	typeref:typename:node *	file:
l	code-library/Data Structures/Wavelet Tree.cpp	/^  wavelet_tree *l, *r;$/;"	m	struct:wavelet_tree	typeref:typename:wavelet_tree *	file:
l	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  int l, r;$/;"	m	struct:LiChaoNode	typeref:typename:int	file:
l	code-library/Geometry/Point Location.cpp	/^    PT l, r;$/;"	m	struct:edge	typeref:typename:PT	file:
l	code-library/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^int deg[N][2], id[N][2], l, r;$/;"	v	typeref:typename:int
l	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  vector<int> l;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
l	code-library/Graph Theory/HopCroft Karp Algorithm.cpp	/^  vector<int> l, r, d;$/;"	m	struct:HopcroftKarp	typeref:typename:vector<int>	file:
l	code-library/Graph Theory/Hungarian Algorithm.cpp	/^  int l[N], r[N], arg[N], trace[N];$/;"	m	struct:Hungarian	typeref:typename:int[]	file:
l	code-library/Graph Theory/Kuhns Algorithm.cpp	/^  vector<int> l, r;$/;"	m	struct:Kuhn	typeref:typename:vector<int>	file:
l	code-library/Graph Theory/L R Flow with Dinic.cpp	/^    int u, v, l, r, id;$/;"	m	struct:LR_Flow::edge	typeref:typename:int	file:
l	code-library/Miscellaneous/Parallel Binary Search.cpp	/^int amount[N], want[N], st[N], en[N], l[N], r[N], ans[N];$/;"	v	typeref:typename:int[]
l	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  int l, r, id;$/;"	m	struct:query	typeref:typename:int	file:
l	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  vector<int> l, r;$/;"	m	struct:Kuhn	typeref:typename:vector<int>	file:
l	code-library/Strings/Number of Palindromes in Range.cpp	/^  wavelet_tree *l, *r;$/;"	m	struct:wavelet_tree	typeref:typename:wavelet_tree *	file:
l	code/Data Structures/BST using STL.cpp	/^map<int, int>l, r; \/\/l contains the left child of the node, r contains right child of the node$/;"	v	typeref:typename:map<int,int>
l	code/Data Structures/Cartesian Tree.cpp	/^int n, tot, st[N], l[N], r[N], vis[N];$/;"	v	typeref:typename:int[]
l	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^        int l = 0, r = 0; mint lf = 0, ls = 0; mint val = 0;$/;"	m	struct:PST::node	typeref:typename:int	file:
l	code/Data Structures/Implicit Treap.cpp	/^    node *l, *r, *par;$/;"	m	struct:treap::node	typeref:typename:node *	file:
l	code/Data Structures/MOs Algorithm.cpp	/^  int l, r, id;$/;"	m	struct:query	typeref:typename:int	file:
l	code/Data Structures/MOs on tree.cpp	/^  int l, r, id;$/;"	m	struct:query	typeref:typename:int	file:
l	code/Data Structures/MOs with DSU.cpp	/^  int l, r, idx;$/;"	m	struct:query	typeref:typename:int	file:
l	code/Data Structures/MOs with Update.cpp	/^  int l, r, t, id;$/;"	m	struct:query	typeref:typename:int	file:
l	code/Data Structures/MOs with Update.cpp	/^int cnt[N], f[N], ans[N], l, r, t;$/;"	v	typeref:typename:int
l	code/Data Structures/Monotonous Queue.cpp	/^  int a[N + 10], b[N + 10], l = 0, r = -1;$/;"	m	struct:monotonous_queue	typeref:typename:int	file:
l	code/Data Structures/Persistent Array.cpp	/^    node* l, * r; T x;$/;"	m	struct:PersistentArray::node	typeref:typename:node *	file:
l	code/Data Structures/Persistent Queue.cpp	/^    node* l, * r; T x;$/;"	m	struct:PersistentArray::node	typeref:typename:node *	file:
l	code/Data Structures/Persistent UnionFind.cpp	/^    node* l, * r; T x;$/;"	m	struct:PersistentArray::node	typeref:typename:node *	file:
l	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  ST *l, *r;$/;"	m	struct:ST	typeref:typename:ST *	file:
l	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  node *l, *r;$/;"	m	struct:node	typeref:typename:node *	file:
l	code/Data Structures/Segment Tree Merging.cpp	/^    int l, r, sz;$/;"	m	struct:STM::node	typeref:typename:int	file:
l	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^    int l = 0, r = 0, lazy = 0, p = 0;$/;"	m	struct:PST::node	typeref:typename:int	file:
l	code/Data Structures/Segment Tree Persistent.cpp	/^    int l = 0, r = 0, val = 0;$/;"	m	struct:PST::node	typeref:typename:int	file:
l	code/Data Structures/Sparse Table 2D.cpp	/^int l[N][N], u[N][N];$/;"	v	typeref:typename:int[][]
l	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^int ty[N], l[N], r[N], x[N];$/;"	v	typeref:typename:int[]
l	code/Data Structures/Treap persistent.cpp	/^  node *l, *r;$/;"	m	struct:node	typeref:typename:node *	file:
l	code/Data Structures/Treap.cpp	/^  node *l, *r;$/;"	m	struct:node	typeref:typename:node *	file:
l	code/Data Structures/Wavelet Tree.cpp	/^  wavelet_tree *l, *r;$/;"	m	struct:wavelet_tree	typeref:typename:wavelet_tree *	file:
l	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  int l, r;$/;"	m	struct:LiChaoNode	typeref:typename:int	file:
l	code/Geometry/Point Location.cpp	/^    PT l, r;$/;"	m	struct:edge	typeref:typename:PT	file:
l	code/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^int deg[N][2], id[N][2], l, r;$/;"	v	typeref:typename:int
l	code/Graph Theory/Gomory Hu Tree.cpp	/^  vector<int> l;$/;"	m	struct:Dinic	typeref:typename:vector<int>	file:
l	code/Graph Theory/HopCroft Karp Algorithm.cpp	/^  vector<int> l, r, d;$/;"	m	struct:HopcroftKarp	typeref:typename:vector<int>	file:
l	code/Graph Theory/Hungarian Algorithm.cpp	/^  int l[N], r[N], arg[N], trace[N];$/;"	m	struct:Hungarian	typeref:typename:int[]	file:
l	code/Graph Theory/Kuhns Algorithm.cpp	/^  vector<int> l, r;$/;"	m	struct:Kuhn	typeref:typename:vector<int>	file:
l	code/Graph Theory/L R Flow with Dinic.cpp	/^    int u, v, l, r, id;$/;"	m	struct:LR_Flow::edge	typeref:typename:int	file:
l	code/Miscellaneous/Parallel Binary Search.cpp	/^int amount[N], want[N], st[N], en[N], l[N], r[N], ans[N];$/;"	v	typeref:typename:int[]
l	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  int l, r, id;$/;"	m	struct:query	typeref:typename:int	file:
l	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  vector<int> l, r;$/;"	m	struct:Kuhn	typeref:typename:vector<int>	file:
l	code/Strings/Number of Palindromes in Range.cpp	/^  wavelet_tree *l, *r;$/;"	m	struct:wavelet_tree	typeref:typename:wavelet_tree *	file:
l	contests/Codeforces/737/C.cpp	/^#define l /;"	d	file:
l	practice/cf/random/1700/test1.cpp	/^int l, r;$/;"	v	typeref:typename:int
l_v_l_v_l	practice/cf/random/1700/testing.cpp	/^template <typename T, size_t N> int SIZE(const T (&t)[N]){ return N; } template<typename T> int /;"	v	typeref:typename:int
lab	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  long long lab[N * 2];$/;"	m	struct:Blossom	typeref:typename:long long[]	file:
lab	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  long long lab[N * 2];$/;"	m	struct:Blossom	typeref:typename:long long[]	file:
label	code-library/Graph Theory/Dominator Tree.cpp	/^int sdom[N], par[N], idom[N], dsu[N], label[N];$/;"	v	typeref:typename:int[]
label	code/Graph Theory/Dominator Tree.cpp	/^int sdom[N], par[N], idom[N], dsu[N], label[N];$/;"	v	typeref:typename:int[]
ladd	code-library/Data Structures/Segment Tree Beats.cpp	/^  ll len[4 * N], ladd[4 * N], lval[4 * N];$/;"	m	struct:SGTBeats	typeref:typename:ll[]	file:
ladd	code/Data Structures/Segment Tree Beats.cpp	/^  ll len[4 * N], ladd[4 * N], lval[4 * N];$/;"	m	struct:SGTBeats	typeref:typename:ll[]	file:
languages	practice/cf/random/1700/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	o
languages	practice/cf/random/1700/1618E/problem.json	/^{"name": "E. Singers' Tour", "group": "Codeforces - Codeforces Round #760 (Div. 3)", "url": "htt/;"	o
languages	practice/cf/random/coloring/problem.json	/^{"name": "A. Dreamoon Likes Coloring", "group": "Codeforces - Codeforces Round #631 (Div. 1) - T/;"	o
languages	practice/cf/random/diane/problem.json	/^{"name": "D. Diane", "group": "Codeforces - Codeforces Round #735 (Div. 2)", "url": "https:\/\/c/;"	o
languages	practice/cf/random/pink/problem.json	/^{"name": "C. Pinkie Pie Eats Patty-cakes", "group": "Codeforces - Codeforces Round #662 (Div. 2)/;"	o
languages	practice/cf/stuff/dec 20 2021/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	o
languages	practice/usacoguide/gold/SP/dining/problem.json	/^{"name": "Problem 1. Fine Dining", "group": "USACO - USACO 2018 December Contest, Gold", "url": /;"	o
languages	practice/usacoguide/gold/SP/visitfj/problem.json	/^{"name": "Problem 1. Why Did the Cow Cross the Road", "group": "USACO - USACO 2017 February Cont/;"	o
languages	practice/usacoguide/gold/bfs/cownav/problem.json	/^{"name": "Problem 3. Cow Navigation", "group": "USACO - USACO 2017 January Contest, Gold", "url"/;"	o
languages	practice/usacoguide/gold/bfs/swap/problem.json	/^{"name": "Swap Game", "group": "CSES - CSES Problem Set", "url": "https:\/\/cses.fi\/problemset\//;"	o
languages	practice/usacoguide/gold/dsu/closing/problem.json	/^{"name": "Problem 2. Closing the Farm", "group": "USACO - USACO 2016 US Open Contest, Gold", "ur/;"	o
languages	practice/usacoguide/gold/dsu/moocast/problem.json	/^{"name": "Problem 1. Moocast", "group": "USACO - USACO 2016 December Contest, Gold", "url": "htt/;"	o
languages	practice/usacoguide/gold/dsu/mootube/problem.json	/^{"name": "Problem 1. MooTube", "group": "USACO - USACO 2018 January Contest, Gold", "url": "http/;"	o
languages	practice/usacoguide/gold/dsu/tractor/problem.json	/^{"name": "Problem 2. Tractor", "group": "USACO - USACO 2013 February Contest, Silver", "url": "h/;"	o
languages	practice/usacoguide/gold/dsu/wormhole/problem.json	/^{"name": "Problem 3. Wormhole Sort", "group": "USACO - USACO 2020 January Contest, Silver", "url/;"	o
languages	practice/usacoguide/silver/idk/lirs/problem.json	/^{"name": "Problem 3. Liars and Truth Tellers", "group": "USACO - USACO 2013 January Contest, Bro/;"	o
languages	practice/usacoguide/silver/idk/maze/problem.json	/^{"name": "Problem 1. Maze Tac Toe", "group": "USACO - USACO 2021 US Open, Silver", "url": "http:/;"	o
last	code-library/Data Structures/Persistent Trie.cpp	/^pnode last;$/;"	v	typeref:typename:pnode
last	code-library/Graph Theory/Minimum Weight Cycle For Each Edge.cpp	/^int g[N][N], ans[N * N], last[N], dp[N * N], id[N][N], W[N * N];$/;"	v	typeref:typename:int[]
last	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  int link[L], sz, to[L][2], dp[L][2], term[L], last[L]; \/\/ each string contains 'a' and 'b'$/;"	m	struct:AhoCorasick	typeref:typename:int[]	file:
last	code-library/Strings/Palindromic Tree Persistent.cpp	/^  int sz, last;$/;"	m	struct:PalindromicTree	typeref:typename:int	file:
last	code-library/Strings/Palindromic Tree.cpp	/^  int sz, last;$/;"	m	struct:PalindromicTree	typeref:typename:int	file:
last	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  int par[N * 2], lazy[N * 2], last[N * 2], c[N * 2][2];$/;"	v	namespace:lct	typeref:typename:int[]
last	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  int sz, last;$/;"	m	struct:SuffixAutomaton	typeref:typename:int	file:
last	code-library/Strings/Suffix Automaton.cpp	/^    int sz, last;$/;"	m	struct:SuffixAutomaton	typeref:typename:int	file:
last	code/Data Structures/Persistent Trie.cpp	/^pnode last;$/;"	v	typeref:typename:pnode
last	code/Graph Theory/Minimum Weight Cycle For Each Edge.cpp	/^int g[N][N], ans[N * N], last[N], dp[N * N], id[N][N], W[N * N];$/;"	v	typeref:typename:int[]
last	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  int link[L], sz, to[L][2], dp[L][2], term[L], last[L]; \/\/ each string contains 'a' and 'b'$/;"	m	struct:AhoCorasick	typeref:typename:int[]	file:
last	code/Strings/Palindromic Tree Persistent.cpp	/^  int sz, last;$/;"	m	struct:PalindromicTree	typeref:typename:int	file:
last	code/Strings/Palindromic Tree.cpp	/^  int sz, last;$/;"	m	struct:PalindromicTree	typeref:typename:int	file:
last	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  int par[N * 2], lazy[N * 2], last[N * 2], c[N * 2][2];$/;"	v	namespace:lct	typeref:typename:int[]
last	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  int sz, last;$/;"	m	struct:SuffixAutomaton	typeref:typename:int	file:
last	code/Strings/Suffix Automaton.cpp	/^    int sz, last;$/;"	m	struct:SuffixAutomaton	typeref:typename:int	file:
lattice_cnt	code-library/Number Theory/Number of Nonnegative Integer Solutions to ax+by <= c.cpp	/^ll lattice_cnt(ll a, ll b, ll c) {$/;"	f	typeref:typename:ll
lattice_cnt	code-library/Number Theory/Number of ax%p in a Range.cpp	/^ll lattice_cnt(ll a, ll b, ll c) {$/;"	f	typeref:typename:ll
lattice_cnt	code/Number Theory/Number of Nonnegative Integer Solutions to ax+by <= c.cpp	/^ll lattice_cnt(ll a, ll b, ll c) {$/;"	f	typeref:typename:ll
lattice_cnt	code/Number Theory/Number of ax%p in a Range.cpp	/^ll lattice_cnt(ll a, ll b, ll c) {$/;"	f	typeref:typename:ll
layer	code-library/Geometry/Onion Decomposition.cpp	/^int layer[N], ans[N];$/;"	v	typeref:typename:int[]
layer	code/Geometry/Onion Decomposition.cpp	/^int layer[N], ans[N];$/;"	v	typeref:typename:int[]
layers	code-library/Data Structures/SQRT Tree.cpp	/^  vector<int> clz, layers, onLayer;$/;"	m	struct:SqrtTree	typeref:typename:vector<int>	file:
layers	code/Data Structures/SQRT Tree.cpp	/^  vector<int> clz, layers, onLayer;$/;"	m	struct:SqrtTree	typeref:typename:vector<int>	file:
lazy	code-library/Data Structures/Dynamic Diameter Online.cpp	/^    long long lazy[4 * N * 2];$/;"	m	struct:ST	typeref:typename:long long[]	file:
lazy	code-library/Data Structures/HLD.cpp	/^  int t[4 * N], lazy[4 * N];$/;"	m	struct:ST	typeref:typename:int[]	file:
lazy	code-library/Data Structures/Implicit Treap.cpp	/^    int val, sz, prior, lazy, sum, mx, mn, repl;$/;"	m	struct:treap::node	typeref:typename:int	file:
lazy	code-library/Data Structures/Link Cut Tree.cpp	/^  long long val = 0, sum = 0, lazy = 0, subsum = 0, vsum = 0;$/;"	m	struct:node	typeref:typename:long long	file:
lazy	code-library/Data Structures/Permutation Tree.cpp	/^  int t[4 * N], lazy[4 * N];$/;"	m	struct:ST	typeref:typename:int[]	file:
lazy	code-library/Data Structures/Reachability Tree.cpp	/^int lazy[8 * N];$/;"	v	typeref:typename:int[]
lazy	code-library/Data Structures/Segment Tree Lazy.cpp	/^  long long t[4 * N], lazy[4 * N];$/;"	m	struct:ST	typeref:typename:long long[]	file:
lazy	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^    int l = 0, r = 0, lazy = 0, p = 0;$/;"	m	struct:PST::node	typeref:typename:int	file:
lazy	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  Int lazy[N << 2];$/;"	m	struct:ST	typeref:typename:Int[]	file:
lazy	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  int par[N * 2], lazy[N * 2], last[N * 2], c[N * 2][2];$/;"	v	namespace:lct	typeref:typename:int[]
lazy	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  long long t[4 * N], lazy[4 * N];$/;"	m	struct:ST	typeref:typename:long long[]	file:
lazy	code/Data Structures/Dynamic Diameter Online.cpp	/^    long long lazy[4 * N * 2];$/;"	m	struct:ST	typeref:typename:long long[]	file:
lazy	code/Data Structures/HLD.cpp	/^  int t[4 * N], lazy[4 * N];$/;"	m	struct:ST	typeref:typename:int[]	file:
lazy	code/Data Structures/Implicit Treap.cpp	/^    int val, sz, prior, lazy, sum, mx, mn, repl;$/;"	m	struct:treap::node	typeref:typename:int	file:
lazy	code/Data Structures/Link Cut Tree.cpp	/^  long long val = 0, sum = 0, lazy = 0, subsum = 0, vsum = 0;$/;"	m	struct:node	typeref:typename:long long	file:
lazy	code/Data Structures/Permutation Tree.cpp	/^  int t[4 * N], lazy[4 * N];$/;"	m	struct:ST	typeref:typename:int[]	file:
lazy	code/Data Structures/Reachability Tree.cpp	/^int lazy[8 * N];$/;"	v	typeref:typename:int[]
lazy	code/Data Structures/Segment Tree Lazy.cpp	/^  long long t[4 * N], lazy[4 * N];$/;"	m	struct:ST	typeref:typename:long long[]	file:
lazy	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^    int l = 0, r = 0, lazy = 0, p = 0;$/;"	m	struct:PST::node	typeref:typename:int	file:
lazy	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  Int lazy[N << 2];$/;"	m	struct:ST	typeref:typename:Int[]	file:
lazy	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  int par[N * 2], lazy[N * 2], last[N * 2], c[N * 2][2];$/;"	v	namespace:lct	typeref:typename:int[]
lazy	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  long long t[4 * N], lazy[4 * N];$/;"	m	struct:ST	typeref:typename:long long[]	file:
lazy_repl_upd	code-library/Data Structures/Implicit Treap.cpp	/^  void lazy_repl_upd(pnode &t) {$/;"	f	struct:treap	typeref:typename:void	file:
lazy_repl_upd	code/Data Structures/Implicit Treap.cpp	/^  void lazy_repl_upd(pnode &t) {$/;"	f	struct:treap	typeref:typename:void	file:
lazy_rev_upd	code-library/Data Structures/Implicit Treap.cpp	/^  void lazy_rev_upd(pnode &t) {$/;"	f	struct:treap	typeref:typename:void	file:
lazy_rev_upd	code/Data Structures/Implicit Treap.cpp	/^  void lazy_rev_upd(pnode &t) {$/;"	f	struct:treap	typeref:typename:void	file:
lazy_sum_upd	code-library/Data Structures/Implicit Treap.cpp	/^  void lazy_sum_upd(pnode &t) {$/;"	f	struct:treap	typeref:typename:void	file:
lazy_sum_upd	code/Data Structures/Implicit Treap.cpp	/^  void lazy_sum_upd(pnode &t) {$/;"	f	struct:treap	typeref:typename:void	file:
lc	code-library/Data Structures/Dynamic Diameter Online.cpp	/^    #define lc /;"	d	file:
lc	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    #define lc /;"	d	file:
lc	code-library/Data Structures/HLD.cpp	/^#define lc /;"	d	file:
lc	code-library/Data Structures/Permutation Tree.cpp	/^#define lc /;"	d	file:
lc	code-library/Data Structures/Segment Tree Lazy.cpp	/^  #define lc /;"	d	file:
lc	code-library/Data Structures/Segment Tree Merging.cpp	/^#define lc /;"	d	file:
lc	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^#define lc /;"	d	file:
lc	code-library/Data Structures/Segment Tree Persistent.cpp	/^#define lc /;"	d	file:
lc	code-library/Geometry/Onion Decomposition.cpp	/^        int lc, rc;$/;"	m	struct:LeftHull::node	typeref:typename:int	file:
lc	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  #define lc /;"	d	file:
lc	code/Data Structures/Dynamic Diameter Online.cpp	/^    #define lc /;"	d	file:
lc	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    #define lc /;"	d	file:
lc	code/Data Structures/HLD.cpp	/^#define lc /;"	d	file:
lc	code/Data Structures/Permutation Tree.cpp	/^#define lc /;"	d	file:
lc	code/Data Structures/Segment Tree Lazy.cpp	/^  #define lc /;"	d	file:
lc	code/Data Structures/Segment Tree Merging.cpp	/^#define lc /;"	d	file:
lc	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^#define lc /;"	d	file:
lc	code/Data Structures/Segment Tree Persistent.cpp	/^#define lc /;"	d	file:
lc	code/Geometry/Onion Decomposition.cpp	/^        int lc, rc;$/;"	m	struct:LeftHull::node	typeref:typename:int	file:
lc	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  #define lc /;"	d	file:
lca	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int lca(int u, int v) {$/;"	f	typeref:typename:int
lca	code-library/Data Structures/HLD.cpp	/^int lca(int u, int v) {$/;"	f	typeref:typename:int
lca	code-library/Data Structures/LCA.cpp	/^int lca(int u, int v) {$/;"	f	typeref:typename:int
lca	code-library/Data Structures/Link Cut Tree.cpp	/^  int lca(int u, int v) {$/;"	f	struct:LCT	typeref:typename:int	file:
lca	code-library/Data Structures/MOs on tree.cpp	/^int lca(int u, int v) {$/;"	f	typeref:typename:int
lca	code-library/Game Theory/Matching Game On A Graph.cpp	/^  int lca(int v, int w) {$/;"	f	struct:Blossom	typeref:typename:int	file:
lca	code-library/Graph Theory/Block Cut Tree.cpp	/^int lca(int u, int v) {$/;"	f	typeref:typename:int
lca	code-library/Graph Theory/Blossom Algorithm.cpp	/^  int lca(int v, int w) {$/;"	f	struct:Blossom	typeref:typename:int	file:
lca	code-library/Graph Theory/LCA in O(1).cpp	/^LCA lca;$/;"	v	typeref:typename:LCA
lca	code-library/Graph Theory/LCA.cpp	/^int lca(int u, int v) {$/;"	f	typeref:typename:int
lca	code-library/Graph Theory/Path Intersection.cpp	/^int lca(int u, int v) {$/;"	f	typeref:typename:int
lca	code-library/Graph Theory/Path Union.cpp	/^int lca(int u, int v) {$/;"	f	typeref:typename:int
lca	code-library/Graph Theory/Virtual Tree.cpp	/^int lca(int u, int v) {$/;"	f	typeref:typename:int
lca	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int lca(int u, int v) {$/;"	f	typeref:typename:int
lca	code/Data Structures/HLD.cpp	/^int lca(int u, int v) {$/;"	f	typeref:typename:int
lca	code/Data Structures/LCA.cpp	/^int lca(int u, int v) {$/;"	f	typeref:typename:int
lca	code/Data Structures/Link Cut Tree.cpp	/^  int lca(int u, int v) {$/;"	f	struct:LCT	typeref:typename:int	file:
lca	code/Data Structures/MOs on tree.cpp	/^int lca(int u, int v) {$/;"	f	typeref:typename:int
lca	code/Game Theory/Matching Game On A Graph.cpp	/^  int lca(int v, int w) {$/;"	f	struct:Blossom	typeref:typename:int	file:
lca	code/Graph Theory/Block Cut Tree.cpp	/^int lca(int u, int v) {$/;"	f	typeref:typename:int
lca	code/Graph Theory/Blossom Algorithm.cpp	/^  int lca(int v, int w) {$/;"	f	struct:Blossom	typeref:typename:int	file:
lca	code/Graph Theory/LCA in O(1).cpp	/^LCA lca;$/;"	v	typeref:typename:LCA
lca	code/Graph Theory/LCA.cpp	/^int lca(int u, int v) {$/;"	f	typeref:typename:int
lca	code/Graph Theory/Path Intersection.cpp	/^int lca(int u, int v) {$/;"	f	typeref:typename:int
lca	code/Graph Theory/Path Union.cpp	/^int lca(int u, int v) {$/;"	f	typeref:typename:int
lca	code/Graph Theory/Virtual Tree.cpp	/^int lca(int u, int v) {$/;"	f	typeref:typename:int
lcp	code-library/Strings/Suffix Array Isomorphic.cpp	/^  vector<int> sa, rank, lcp, a;$/;"	m	struct:IsomorphicSuffixArray	typeref:typename:vector<int>	file:
lcp	code-library/Strings/Suffix Array Isomorphic.cpp	/^  vector<int> sa, rank, lcp;$/;"	m	struct:SuffixArray	typeref:typename:vector<int>	file:
lcp	code-library/Strings/Suffix Array.cpp	/^  vector<int> sa, rank, lcp;$/;"	m	struct:SuffixArray	typeref:typename:vector<int>	file:
lcp	code/Strings/Suffix Array Isomorphic.cpp	/^  vector<int> sa, rank, lcp, a;$/;"	m	struct:IsomorphicSuffixArray	typeref:typename:vector<int>	file:
lcp	code/Strings/Suffix Array Isomorphic.cpp	/^  vector<int> sa, rank, lcp;$/;"	m	struct:SuffixArray	typeref:typename:vector<int>	file:
lcp	code/Strings/Suffix Array.cpp	/^  vector<int> sa, rank, lcp;$/;"	m	struct:SuffixArray	typeref:typename:vector<int>	file:
lct	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^namespace lct {$/;"	n	file:
lct	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^namespace lct {$/;"	n	file:
ld	code-library/Math/Simplex Algorithm.cpp	/^using ld = long double;$/;"	t	typeref:typename:long double	file:
ld	code-library/Miscellaneous/BigInt.cpp	/^typedef long double ld;$/;"	t	typeref:typename:long double	file:
ld	code-library/Number Theory/Rational Approximation.cpp	/^using ld = long double;$/;"	t	typeref:typename:long double	file:
ld	code/Math/Simplex Algorithm.cpp	/^using ld = long double;$/;"	t	typeref:typename:long double	file:
ld	code/Miscellaneous/BigInt.cpp	/^typedef long double ld;$/;"	t	typeref:typename:long double	file:
ld	code/Number Theory/Rational Approximation.cpp	/^using ld = long double;$/;"	t	typeref:typename:long double	file:
ld	practice/usacoguide/gold/introDP/711C.cpp	/^typedef long double ld; $/;"	t	typeref:typename:long double	file:
le	code-library/Geometry/Point Location.cpp	/^bool le(const ll& a, const ll& b) { return a <= b; }$/;"	f	typeref:typename:bool
le	code/Geometry/Point Location.cpp	/^bool le(const ll& a, const ll& b) { return a <= b; }$/;"	f	typeref:typename:bool
leading_xk	code-library/Math/Faulhaber Formula Fastest.cpp	/^  int leading_xk() const { \/\/minimum i such that C[i] > 0$/;"	f	struct:poly	typeref:typename:int	file:
leading_xk	code-library/Math/Polynomial.cpp	/^  int leading_xk() const { \/\/minimum i such that C[i] > 0$/;"	f	struct:poly	typeref:typename:int	file:
leading_xk	code/Math/Faulhaber Formula Fastest.cpp	/^  int leading_xk() const { \/\/minimum i such that C[i] > 0$/;"	f	struct:poly	typeref:typename:int	file:
leading_xk	code/Math/Polynomial.cpp	/^  int leading_xk() const { \/\/minimum i such that C[i] > 0$/;"	f	struct:poly	typeref:typename:int	file:
left	code-library/Data Structures/Disjoint Sparse Table.cpp	/^  vector<vector<int>> left, right;$/;"	m	struct:DST	typeref:typename:vector<vector<int>>	file:
left	code-library/Data Structures/KD Tree.cpp	/^  kd_node *left, *right;$/;"	m	struct:kd_node	typeref:typename:kd_node *	file:
left	code-library/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  node* left = nullptr;$/;"	m	struct:node	typeref:typename:node *	file:
left	code/Data Structures/Disjoint Sparse Table.cpp	/^  vector<vector<int>> left, right;$/;"	m	struct:DST	typeref:typename:vector<vector<int>>	file:
left	code/Data Structures/KD Tree.cpp	/^  kd_node *left, *right;$/;"	m	struct:kd_node	typeref:typename:kd_node *	file:
left	code/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  node* left = nullptr;$/;"	m	struct:node	typeref:typename:node *	file:
legal_move	practice/cpbook/ch1/1.6/chess/00225/main.cpp	/^bool legal_move() {$/;"	f	typeref:typename:bool
legal_state	practice/cpbook/ch1/1.6/chess/00225/main.cpp	/^bool legal_state() {$/;"	f	typeref:typename:bool
len	code-library/Data Structures/Segment Tree Beats.cpp	/^  ll len[4 * N], ladd[4 * N], lval[4 * N];$/;"	m	struct:SGTBeats	typeref:typename:ll[]	file:
len	code-library/Geometry/Geometry 3D.cpp	/^    double len(p3 a) {$/;"	f	struct:CH3D	typeref:typename:double	file:
len	code-library/Number Theory/K Divisors.cpp	/^  int len = 0; \/\/ total number of primes generated by sieve$/;"	v	namespace:pcf	typeref:typename:int
len	code-library/Number Theory/Prime Counting Function.cpp	/^  int len = 0; \/\/ total number of primes generated by sieve$/;"	v	namespace:pcf	typeref:typename:int
len	code-library/Strings/Palindromic Tree Persistent.cpp	/^    int nxt[A], len, st, en, link, cnt, oc, smart_link[A];$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
len	code-library/Strings/Palindromic Tree.cpp	/^    int nxt[26], len, st, en, link, diff, slink, cnt, oc;$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
len	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  int len, link, firstpos;$/;"	m	struct:node	typeref:typename:int	file:
len	code-library/Strings/Suffix Automaton.cpp	/^        int len, link, firstpos;$/;"	m	struct:SuffixAutomaton::node	typeref:typename:int	file:
len	code/Data Structures/Segment Tree Beats.cpp	/^  ll len[4 * N], ladd[4 * N], lval[4 * N];$/;"	m	struct:SGTBeats	typeref:typename:ll[]	file:
len	code/Geometry/Geometry 3D.cpp	/^    double len(p3 a) {$/;"	f	struct:CH3D	typeref:typename:double	file:
len	code/Number Theory/K Divisors.cpp	/^  int len = 0; \/\/ total number of primes generated by sieve$/;"	v	namespace:pcf	typeref:typename:int
len	code/Number Theory/Prime Counting Function.cpp	/^  int len = 0; \/\/ total number of primes generated by sieve$/;"	v	namespace:pcf	typeref:typename:int
len	code/Strings/Palindromic Tree Persistent.cpp	/^    int nxt[A], len, st, en, link, cnt, oc, smart_link[A];$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
len	code/Strings/Palindromic Tree.cpp	/^    int nxt[26], len, st, en, link, diff, slink, cnt, oc;$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
len	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  int len, link, firstpos;$/;"	m	struct:node	typeref:typename:int	file:
len	code/Strings/Suffix Automaton.cpp	/^        int len, link, firstpos;$/;"	m	struct:SuffixAutomaton::node	typeref:typename:int	file:
len	practice/cpbook/ch1/1.6/card/10388/main2.cpp	/^int pu[2], pd[2], len[2];$/;"	v	typeref:typename:int[2]
length	code-library/Data Structures/Permutation Tree.cpp	/^int length(int i) {$/;"	f	typeref:typename:int
length	code/Data Structures/Permutation Tree.cpp	/^int length(int i) {$/;"	f	typeref:typename:int
level	code-library/Data Structures/Binarizing a Tree.cpp	/^  int level = 0, id = 0, cnt = 0;$/;"	m	struct:node	typeref:typename:int	file:
level	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^  int level = 0, id = 0, cnt = 0;$/;"	m	struct:node	typeref:typename:int	file:
level	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static constexpr int level = __builtin_ctzll(mod - 1);$/;"	m	class:ntt::Mod	typeref:typename:int	file:
level	code/Data Structures/Binarizing a Tree.cpp	/^  int level = 0, id = 0, cnt = 0;$/;"	m	struct:node	typeref:typename:int	file:
level	code/Data Structures/Centroid Decomposition Persistent.cpp	/^  int level = 0, id = 0, cnt = 0;$/;"	m	struct:node	typeref:typename:int	file:
level	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static constexpr int level = __builtin_ctzll(mod - 1);$/;"	m	class:ntt::Mod	typeref:typename:int	file:
lf	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^        int l = 0, r = 0; mint lf = 0, ls = 0; mint val = 0;$/;"	m	struct:PST::node	typeref:typename:mint	file:
lf	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^        int l = 0, r = 0; mint lf = 0, ls = 0; mint val = 0;$/;"	m	struct:PST::node	typeref:typename:mint	file:
lg	code-library/Dynamic Programming Optimizations/Persistent CHT.cpp	/^  const static int lg = 22;$/;"	m	struct:PersistentCHT	typeref:typename:const int	file:
lg	code-library/Strings/Suffix Array Isomorphic.cpp	/^  vector<int> lg;$/;"	m	struct:IsomorphicSuffixArray	typeref:typename:vector<int>	file:
lg	code-library/Strings/Suffix Array Isomorphic.cpp	/^  vector<int> lg;$/;"	m	struct:SuffixArray	typeref:typename:vector<int>	file:
lg	code-library/Strings/Suffix Array.cpp	/^  vector<int> lg;$/;"	m	struct:SuffixArray	typeref:typename:vector<int>	file:
lg	code/Dynamic Programming Optimizations/Persistent CHT.cpp	/^  const static int lg = 22;$/;"	m	struct:PersistentCHT	typeref:typename:const int	file:
lg	code/Strings/Suffix Array Isomorphic.cpp	/^  vector<int> lg;$/;"	m	struct:IsomorphicSuffixArray	typeref:typename:vector<int>	file:
lg	code/Strings/Suffix Array Isomorphic.cpp	/^  vector<int> lg;$/;"	m	struct:SuffixArray	typeref:typename:vector<int>	file:
lg	code/Strings/Suffix Array.cpp	/^  vector<int> lg;$/;"	m	struct:SuffixArray	typeref:typename:vector<int>	file:
lg2	code-library/Data Structures/Sparse Table 2D.cpp	/^int a[N][N], lg2[N];$/;"	v	typeref:typename:int[]
lg2	code/Data Structures/Sparse Table 2D.cpp	/^int a[N][N], lg2[N];$/;"	v	typeref:typename:int[]
lgp	code-library/Number Theory/Smallest Number Having Exactly K Divisors.cpp	/^double lgp[N];$/;"	v	typeref:typename:double[]
lgp	code/Number Theory/Smallest Number Having Exactly K Divisors.cpp	/^double lgp[N];$/;"	v	typeref:typename:double[]
li	code-library/Data Structures/Static to Dynamic Trick.cpp	/^  vector<string> li[20];$/;"	m	struct:aho_corasick	typeref:typename:vector<string>[20]	file:
li	code-library/Strings/Aho Corasick Dynamic.cpp	/^  vector<string> li[20];$/;"	m	struct:aho_corasick	typeref:typename:vector<string>[20]	file:
li	code/Data Structures/Static to Dynamic Trick.cpp	/^  vector<string> li[20];$/;"	m	struct:aho_corasick	typeref:typename:vector<string>[20]	file:
li	code/Strings/Aho Corasick Dynamic.cpp	/^  vector<string> li[20];$/;"	m	struct:aho_corasick	typeref:typename:vector<string>[20]	file:
lift	code-library/Data Structures/Reachability Tree.cpp	/^  int lift(int u, int x) { \/\/all nodes reachable from u s.t. edges <= w, returns the coorespon/;"	f	struct:RT	typeref:typename:int	file:
lift	code/Data Structures/Reachability Tree.cpp	/^  int lift(int u, int x) { \/\/all nodes reachable from u s.t. edges <= w, returns the coorespon/;"	f	struct:RT	typeref:typename:int	file:
lim	code-library/Math/Faulhaber Formula Fastest.cpp	/^int lim = 1;$/;"	v	typeref:typename:int
lim	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^int lim = 1;$/;"	v	typeref:typename:int
lim	code-library/Math/Linear Recurrence Fastest.cpp	/^int lim = 1;$/;"	v	typeref:typename:int
lim	code-library/Math/NTT Online.cpp	/^int lim = 1;$/;"	v	typeref:typename:int
lim	code-library/Math/NTT With Any Prime MOD.cpp	/^int lim = 1;$/;"	v	typeref:typename:int
lim	code-library/Math/NTT.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int
lim	code-library/Math/Polynomial with Binomial Coefficients.cpp	/^int lim = 1;$/;"	v	typeref:typename:int
lim	code-library/Math/Polynomial.cpp	/^int lim = 1;$/;"	v	typeref:typename:int
lim	code-library/Math/Subset Sum Problem.cpp	/^int lim = 1;$/;"	v	typeref:typename:int
lim	code-library/Number Theory/Bell Number.cpp	/^int lim = 1;$/;"	v	typeref:typename:int
lim	code-library/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int
lim	code-library/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int
lim	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^int lim = 1;$/;"	v	typeref:typename:int
lim	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int
lim	code-library/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^int lim = 1;$/;"	v	typeref:typename:int
lim	code-library/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int
lim	code/Math/Faulhaber Formula Fastest.cpp	/^int lim = 1;$/;"	v	typeref:typename:int
lim	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^int lim = 1;$/;"	v	typeref:typename:int
lim	code/Math/Linear Recurrence Fastest.cpp	/^int lim = 1;$/;"	v	typeref:typename:int
lim	code/Math/NTT Online.cpp	/^int lim = 1;$/;"	v	typeref:typename:int
lim	code/Math/NTT With Any Prime MOD.cpp	/^int lim = 1;$/;"	v	typeref:typename:int
lim	code/Math/NTT.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int
lim	code/Math/Polynomial with Binomial Coefficients.cpp	/^int lim = 1;$/;"	v	typeref:typename:int
lim	code/Math/Polynomial.cpp	/^int lim = 1;$/;"	v	typeref:typename:int
lim	code/Math/Subset Sum Problem.cpp	/^int lim = 1;$/;"	v	typeref:typename:int
lim	code/Number Theory/Bell Number.cpp	/^int lim = 1;$/;"	v	typeref:typename:int
lim	code/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int
lim	code/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int
lim	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^int lim = 1;$/;"	v	typeref:typename:int
lim	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int
lim	code/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^int lim = 1;$/;"	v	typeref:typename:int
lim	code/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int
line	code-library/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^struct line {$/;"	s	file:
line	code-library/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  Line line;$/;"	m	struct:node	typeref:typename:Line	file:
line	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  Line line;$/;"	m	struct:LiChaoNode	typeref:typename:Line	file:
line	code-library/Geometry/Geometry 2D.cpp	/^	line(PT p, PT q) : v(q - p), c(cross(v, p)), a(p), b(q) {}$/;"	f	struct:line	file:
line	code-library/Geometry/Geometry 2D.cpp	/^	line(PT v, double c) : v(v), c(c) {$/;"	f	struct:line	file:
line	code-library/Geometry/Geometry 2D.cpp	/^	line(double _a, double _b, double _c) : v({_b, -_a}), c(-_c) {$/;"	f	struct:line	file:
line	code-library/Geometry/Geometry 2D.cpp	/^    line() {}$/;"	f	struct:line	file:
line	code-library/Geometry/Geometry 2D.cpp	/^struct line {$/;"	s	file:
line	code/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^struct line {$/;"	s	file:
line	code/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  Line line;$/;"	m	struct:node	typeref:typename:Line	file:
line	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  Line line;$/;"	m	struct:LiChaoNode	typeref:typename:Line	file:
line	code/Geometry/Geometry 2D.cpp	/^	line(PT p, PT q) : v(q - p), c(cross(v, p)), a(p), b(q) {}$/;"	f	struct:line	file:
line	code/Geometry/Geometry 2D.cpp	/^	line(PT v, double c) : v(v), c(c) {$/;"	f	struct:line	file:
line	code/Geometry/Geometry 2D.cpp	/^	line(double _a, double _b, double _c) : v({_b, -_a}), c(-_c) {$/;"	f	struct:line	file:
line	code/Geometry/Geometry 2D.cpp	/^    line() {}$/;"	f	struct:line	file:
line	code/Geometry/Geometry 2D.cpp	/^struct line {$/;"	s	file:
line3d	code-library/Geometry/Geometry 3D.cpp	/^    line3d(p3 p, p3 q) : d(q - p), o(p) {}$/;"	f	struct:line3d	file:
line3d	code-library/Geometry/Geometry 3D.cpp	/^    line3d(plane p1, plane p2) {$/;"	f	struct:line3d	file:
line3d	code-library/Geometry/Geometry 3D.cpp	/^struct line3d {$/;"	s	file:
line3d	code/Geometry/Geometry 3D.cpp	/^    line3d(p3 p, p3 q) : d(q - p), o(p) {}$/;"	f	struct:line3d	file:
line3d	code/Geometry/Geometry 3D.cpp	/^    line3d(plane p1, plane p2) {$/;"	f	struct:line3d	file:
line3d	code/Geometry/Geometry 3D.cpp	/^struct line3d {$/;"	s	file:
line_line_intersection	code-library/Geometry/Delaunay Triangulation.cpp	/^dPT line_line_intersection(dPT a, dPT b, dPT c, dPT d) {$/;"	f	typeref:typename:dPT
line_line_intersection	code-library/Geometry/Geometry 2D.cpp	/^    PT line_line_intersection(PT a, PT b, PT c, PT d) {$/;"	f	struct:HP	typeref:typename:PT	file:
line_line_intersection	code-library/Geometry/Geometry 2D.cpp	/^bool line_line_intersection(PT a, PT b, PT c, PT d, PT &ans) {$/;"	f	typeref:typename:bool
line_line_intersection	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^PT line_line_intersection(PT a, PT b, PT c, PT d) {$/;"	f	typeref:typename:PT
line_line_intersection	code-library/Geometry/Half Plane Intersection.cpp	/^    PT line_line_intersection(PT a, PT b, PT c, PT d) {$/;"	f	struct:HP	typeref:typename:PT	file:
line_line_intersection	code-library/Geometry/Voronoi Diagram.cpp	/^PT line_line_intersection(PT a, PT b, PT c, PT d) {$/;"	f	typeref:typename:PT
line_line_intersection	code/Geometry/Delaunay Triangulation.cpp	/^dPT line_line_intersection(dPT a, dPT b, dPT c, dPT d) {$/;"	f	typeref:typename:dPT
line_line_intersection	code/Geometry/Geometry 2D.cpp	/^    PT line_line_intersection(PT a, PT b, PT c, PT d) {$/;"	f	struct:HP	typeref:typename:PT	file:
line_line_intersection	code/Geometry/Geometry 2D.cpp	/^bool line_line_intersection(PT a, PT b, PT c, PT d, PT &ans) {$/;"	f	typeref:typename:bool
line_line_intersection	code/Geometry/Half Plane Intersection Dynamic.cpp	/^PT line_line_intersection(PT a, PT b, PT c, PT d) {$/;"	f	typeref:typename:PT
line_line_intersection	code/Geometry/Half Plane Intersection.cpp	/^    PT line_line_intersection(PT a, PT b, PT c, PT d) {$/;"	f	struct:HP	typeref:typename:PT	file:
line_line_intersection	code/Geometry/Voronoi Diagram.cpp	/^PT line_line_intersection(PT a, PT b, PT c, PT d) {$/;"	f	typeref:typename:PT
linear	code-library/Graph Theory/LCA in O(1).cpp	/^  vector<pair<int, int>> linear;$/;"	m	struct:LCA	typeref:typename:vector<pair<int,int>>	file:
linear	code/Graph Theory/LCA in O(1).cpp	/^  vector<pair<int, int>> linear;$/;"	m	struct:LCA	typeref:typename:vector<pair<int,int>>	file:
linear_sieve	code-library/Number Theory/Prime Number System.cpp	/^void linear_sieve() {$/;"	f	typeref:typename:void
linear_sieve	code/Number Theory/Prime Number System.cpp	/^void linear_sieve() {$/;"	f	typeref:typename:void
link	code-library/Data Structures/Link Cut Tree.cpp	/^  void link(int u, int v) { \/\/ u -> v$/;"	f	struct:LCT	typeref:typename:void	file:
link	code-library/Data Structures/Static to Dynamic Trick.cpp	/^  int cnt[N], link[N], psz;$/;"	m	struct:aho_corasick_static	typeref:typename:int[]	file:
link	code-library/Data Structures/Top Tree.cpp	/^  friend void link(top_tree_node* e, top_tree_node* v1, top_tree_node* v2) {$/;"	f	typeref:typename:void	file:
link	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  int link[L], sz, to[L][2], dp[L][2], term[L], last[L]; \/\/ each string contains 'a' and 'b'$/;"	m	struct:AhoCorasick	typeref:typename:int[]	file:
link	code-library/Strings/Aho Corasick Dynamic.cpp	/^  int cnt[N], link[N], psz;$/;"	m	struct:aho_corasick_static	typeref:typename:int[]	file:
link	code-library/Strings/Aho Corasick.cpp	/^  vector <int> link, out_link;$/;"	m	struct:AC	typeref:typename:vector<int>	file:
link	code-library/Strings/Palindromic Tree Persistent.cpp	/^    int nxt[A], len, st, en, link, cnt, oc, smart_link[A];$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
link	code-library/Strings/Palindromic Tree.cpp	/^    int nxt[26], len, st, en, link, diff, slink, cnt, oc;$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
link	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  int len, link, firstpos;$/;"	m	struct:node	typeref:typename:int	file:
link	code-library/Strings/Suffix Automaton.cpp	/^        int len, link, firstpos;$/;"	m	struct:SuffixAutomaton::node	typeref:typename:int	file:
link	code/Data Structures/Link Cut Tree.cpp	/^  void link(int u, int v) { \/\/ u -> v$/;"	f	struct:LCT	typeref:typename:void	file:
link	code/Data Structures/Static to Dynamic Trick.cpp	/^  int cnt[N], link[N], psz;$/;"	m	struct:aho_corasick_static	typeref:typename:int[]	file:
link	code/Data Structures/Top Tree.cpp	/^  friend void link(top_tree_node* e, top_tree_node* v1, top_tree_node* v2) {$/;"	f	typeref:typename:void	file:
link	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  int link[L], sz, to[L][2], dp[L][2], term[L], last[L]; \/\/ each string contains 'a' and 'b'$/;"	m	struct:AhoCorasick	typeref:typename:int[]	file:
link	code/Strings/Aho Corasick Dynamic.cpp	/^  int cnt[N], link[N], psz;$/;"	m	struct:aho_corasick_static	typeref:typename:int[]	file:
link	code/Strings/Aho Corasick.cpp	/^  vector <int> link, out_link;$/;"	m	struct:AC	typeref:typename:vector<int>	file:
link	code/Strings/Palindromic Tree Persistent.cpp	/^    int nxt[A], len, st, en, link, cnt, oc, smart_link[A];$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
link	code/Strings/Palindromic Tree.cpp	/^    int nxt[26], len, st, en, link, diff, slink, cnt, oc;$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
link	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  int len, link, firstpos;$/;"	m	struct:node	typeref:typename:int	file:
link	code/Strings/Suffix Automaton.cpp	/^        int len, link, firstpos;$/;"	m	struct:SuffixAutomaton::node	typeref:typename:int	file:
listen_many	.compilingScripts/download_prob.py	/^def listen_many(*, num_items=None, timeout=None):$/;"	f
listen_once	.compilingScripts/download_prob.py	/^def listen_once(*, timeout=None):$/;"	f
lit	code-library/Graph Theory/3 SAT.cpp	/^  vector<vector<int>> g, lit;$/;"	m	struct:SAT_GOD	typeref:typename:vector<vector<int>>	file:
lit	code/Graph Theory/3 SAT.cpp	/^  vector<vector<int>> g, lit;$/;"	m	struct:SAT_GOD	typeref:typename:vector<vector<int>>	file:
ll	code-library/Data Structures/Cartesian Tree.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Data Structures/Disjoint Sparse Table.cpp	/^#define ll /;"	d	file:
ll	code-library/Data Structures/Implicit Treap.cpp	/^#define ll /;"	d	file:
ll	code-library/Data Structures/Persistent Meldable Heap.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Data Structures/Segment Tree Beats.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^#define ll /;"	d	file:
ll	code-library/Dynamic Programming Optimizations/DP Over Divisors.cpp	/^#define ll /;"	d	file:
ll	code-library/Dynamic Programming Optimizations/Digit DP.cpp	/^#define ll /;"	d	file:
ll	code-library/Dynamic Programming Optimizations/Divide and Conquer Optimization.cpp	/^#define ll /;"	d	file:
ll	code-library/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^#define ll /;"	d	file:
ll	code-library/Dynamic Programming Optimizations/Knuth Optimization.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^#define ll /;"	d	file:
ll	code-library/Geometry/Point Location.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^#define ll /;"	d	file:
ll	code-library/Graph Theory/Eppsteins Algorithm.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	code-library/Graph Theory/Number of Different Cliques.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Math/Linear Recurrence With Polynomial Coefficients.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Math/Reeds Sloane Algorithm.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Math/Simplex Algorithm.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Miscellaneous/BigInt.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	code-library/Miscellaneous/Knight Moves in Infinity Grid.cpp	/^#define ll /;"	d	file:
ll	code-library/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	code-library/Miscellaneous/Parallel Binary Search.cpp	/^#define ll /;"	d	file:
ll	code-library/Miscellaneous/Schreier–Sims algorithm.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/Continued Fractions.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/Discrete Log.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/Discrete Root Faster.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/Extended Euclid.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/Floor Sum of  Arithmetic Progressions.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/Intersection of Arithmetic Progressions.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/K Divisors.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/Linear Congruence Equation.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/Linear Diophantine Equation with Nonnegative Solutions.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/Linear Diophantine Equation with Two Variables.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/Linear Diophantine With N Unknowns and Two Equations.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/Lucas Theorem.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/Maximum Coprime Product.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/Min_25 Sieve.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/Multiplicative Order.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/Number of Distinct Kth Powers Modulo n.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/Number of Nonnegative Integer Solutions to ax+by <= c.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/Number of ax%p in a Range.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/Phi Field.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/Pisano Period.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/Pollard Rho.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/Power Tower.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/Rational Approximation.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/Sum of Floors.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Number Theory/nCr Modulo Any Mod.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code-library/Strings/Prefix Automaton.cpp	/^#define ll /;"	d	file:
ll	code/Data Structures/Cartesian Tree.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Data Structures/Disjoint Sparse Table.cpp	/^#define ll /;"	d	file:
ll	code/Data Structures/Implicit Treap.cpp	/^#define ll /;"	d	file:
ll	code/Data Structures/Persistent Meldable Heap.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Data Structures/Segment Tree Beats.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^#define ll /;"	d	file:
ll	code/Dynamic Programming Optimizations/DP Over Divisors.cpp	/^#define ll /;"	d	file:
ll	code/Dynamic Programming Optimizations/Digit DP.cpp	/^#define ll /;"	d	file:
ll	code/Dynamic Programming Optimizations/Divide and Conquer Optimization.cpp	/^#define ll /;"	d	file:
ll	code/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^#define ll /;"	d	file:
ll	code/Dynamic Programming Optimizations/Knuth Optimization.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^#define ll /;"	d	file:
ll	code/Geometry/Point Location.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	code/Graph Theory/Counting Labeled Graphs.cpp	/^#define ll /;"	d	file:
ll	code/Graph Theory/Eppsteins Algorithm.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	code/Graph Theory/Number of Different Cliques.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Math/Linear Recurrence With Polynomial Coefficients.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Math/Reeds Sloane Algorithm.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Math/Simplex Algorithm.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Miscellaneous/BigInt.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	code/Miscellaneous/Knight Moves in Infinity Grid.cpp	/^#define ll /;"	d	file:
ll	code/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	code/Miscellaneous/Parallel Binary Search.cpp	/^#define ll /;"	d	file:
ll	code/Miscellaneous/Schreier–Sims algorithm.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/Continued Fractions.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/Discrete Log.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/Discrete Root Faster.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/Extended Euclid.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/Floor Sum of  Arithmetic Progressions.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/Intersection of Arithmetic Progressions.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/K Divisors.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/Linear Congruence Equation.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/Linear Diophantine Equation with Nonnegative Solutions.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/Linear Diophantine Equation with Two Variables.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/Linear Diophantine With N Unknowns and Two Equations.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/Lucas Theorem.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/Maximum Coprime Product.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/Min_25 Sieve.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/Multiplicative Order.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/Number of Distinct Kth Powers Modulo n.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/Number of Nonnegative Integer Solutions to ax+by <= c.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/Number of ax%p in a Range.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/Phi Field.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/Pisano Period.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/Pollard Rho.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/Power Tower.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/Rational Approximation.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/Sum of Floors.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Number Theory/nCr Modulo Any Mod.cpp	/^using ll = long long;$/;"	t	typeref:typename:long long	file:
ll	code/Strings/Prefix Automaton.cpp	/^#define ll /;"	d	file:
ll	code/template.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/AtCoder/214/A/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/AtCoder/214/B/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/AtCoder/214/C/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/AtCoder/214/D/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/AtCoder/215/A/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/AtCoder/215/B/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/AtCoder/215/C/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/AtCoder/215/D/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/AtCoder/225/A.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/AtCoder/225/B.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/AtCoder/225/C.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/AtCoder/225/D.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/AtCoder/225/E.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/AtCoder/225/F.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/AtCoder/231/A.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/AtCoder/231/B.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/AtCoder/231/C.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/AtCoder/231/D.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/AtCoder/231/E.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/AtCoder/ABC211/A.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/AtCoder/ABC211/B.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/AtCoder/ABC211/C.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/AtCoder/ABC211/D.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/AtCoder/ABC211/E.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1552/1552A.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1552/1552B.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1552/1552C.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1552/1552D.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1552/1552E.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1552/1552F.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1552/1552G.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1552/1552H.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1552/1552I.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1560/A/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1560/B/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1560/C/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1560/D/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1560/D/test.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1560/E/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1560/F1/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1560/F1/test1.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1560/F1/test2.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1609/A.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1609/B.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1609/C.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1609/D.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1616/A/sol.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1616/B/sol.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1616/C/sol.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1616/D/new_sol.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1616/D/sol.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1622/upsolve/C/sol.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1623/A/sol.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1623/B/sol.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1623/C/sol.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/1623/new_C/sol.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/737/A.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/Codeforces/737/C.cpp	/^#define ll /;"	d	file:
ll	contests/LIT2021/B.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/LIT2021/C.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/LIT2021/D.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/USACO/dec_silver_2021/A/A.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/USACO/dec_silver_2021/A/AA.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/USACO/dec_silver_2021/A/AAA.cpp	/^typedef long long ll; $/;"	t	typeref:typename:long long	file:
ll	contests/USACO/dec_silver_2021/A/A_safe.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/USACO/dec_silver_2021/A/A_sol.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/USACO/dec_silver_2021/A/a_save.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/USACO/dec_silver_2021/A/a_testing.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/USACO/dec_silver_2021/A/restart_A.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/USACO/dec_silver_2021/B/B.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/USACO/dec_silver_2021/B/B_new.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/USACO/dec_silver_2021/B/brute.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/USACO/dec_silver_2021/C/C.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/USACO/dec_silver_2021/C/C_full.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	contests/USACO/dec_silver_2021/C/C_new.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/DP/1051E1.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/DP/1061D.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/DP/1091D.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/DP/1461C.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/DP/altaray.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/DP/knap1.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/DP/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/greedy/1487C.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/1700/1.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/1700/1472E.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/1700/1473D.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/1700/1476D.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/1700/1608C/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/1700/1618E.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/1700/1618E/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/1700/2.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/1700/3.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/1700/4.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/1700/5.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/1700/6.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/1700/7.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/1700/8.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/1700/brute.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/1700/test.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/1700/test1.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/1700/test2.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/1700/test3.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/1700/testing.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/coloring/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/diane/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/i_hate_math_problems/1336B.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/i_hate_math_problems/1368D.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/i_hate_math_problems/1400B.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/i_hate_math_problems/1422C.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/i_hate_math_problems/1451D.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/i_hate_math_problems/1469D.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/i_hate_math_problems/testing.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/random/pink/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cf/upsolve/1557B.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/club/prob3/generator_prob3.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/club/prob3/test.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.4/medium/11507.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.4/medium/11956.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.4/medium/12157.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.4/medium/12643.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.4/medium/basicprogramming1.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.4/medium/battlesimulation.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.4/medium/bitsequalizer.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.4/medium/fastfood.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.4/medium/garage.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.4/medium/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.4/medium/poi.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.4/medium/shatteredcake.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.6/card/10388/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.6/card/10646/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.6/card/11225/karte.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.6/card/11225/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.6/card/11225/test.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.6/card/11678/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.6/card/11678/test.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.6/card/12247/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.6/chess/00225/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.6/chess/00696/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.6/chess/10284/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.6/chess/bijele/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.6/chess/chess/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.6/chess/chess/realsol.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.6/game/easier/10189/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.6/game/easier/11459/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.6/game/easier/trik/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.6/game/harder/11013/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.6/game/harder/rockpaperscissors/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.6/reallife/medium/00161/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.6/reallife/medium/01091/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.6/reallife/medium/01091/restartmain.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.6/reallife/medium/01091/test.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.6/reallife/medium/10528/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.6/reallife/medium/beatspread/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch1/1.6/reallife/medium/tenis/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch2/2.2/1D/11222/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch2/2.2/1D/12150/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch2/2.2/1D/13048/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch2/2.2/1D/13181/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch2/2.2/1D/pivot/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch2/2.2/2D/11581/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch3/DP/00787.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/cpbook/ch3/DP/10684.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/december2021/1560E/sol.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/december2021/1572A/new_sol.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/december2021/1572A/sol.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/december2021/1619D/sol.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/december2021/1619E/sol.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/december2021/1620C/sol.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/december2021/DP/LIS/sol.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/december2021/DP/counting_towers/sol.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/december2021/DP/rectangle_cutting/sol.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/december2021/DP/removal_game/sol.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/december2021/DP/teamwork/sol.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/december2021/stacks/advertisement/sol.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/december2021/stacks/balloons/sol.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/december2021/stacks/nsv/sol.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/SP/dining/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/SP/flightdiscount.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/SP/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/SP/pump.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/SP/shortestroutesii.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/SP/visitfj.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/SP/visitfj/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/bfs/bfsdfs.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/bfs/cownav.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/bfs/cownav/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/bfs/dfsbfs.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/bfs/graphgirth.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/bfs/lasers.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/bfs/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/bfs/mecho/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/bfs/mechonew/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/bfs/milkpails.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/bfs/monsters.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/bfs/piggyback.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/bfs/swap.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/bfs/swap/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/bfs/telephone.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/bfs/walls.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/divisibility/commondivisors.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/divisibility/dilucandkaeya.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/divisibility/oraclcm.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/divisibility/powerproducts.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/divisibility/test.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/dsu/closing/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/dsu/moocast/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/dsu/mootube/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/dsu/tractor/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/dsu/tractor/mountain.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/dsu/wormhole/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/introDP/711C.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/introDP/arraydescription.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/introDP/cannonballs.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/introDP/countingtowers.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/introDP/editdistance.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/introDP/feast.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/introDP/flag.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/introDP/gridpaths.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/introDP/hoofpaperscissors.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/introDP/king2.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/introDP/knight.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/introDP/ladder.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/introDP/learningdp.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/introDP/longestpath.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/introDP/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/introDP/mooney.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/introDP/rabbit.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/introDP/rectanglecutting.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/introDP/slalom.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/introDP/time.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/modular/divisoranalysis.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/modular/exponentiation.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/modular/exponentiation2.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/modular/santasbot.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/gold/modular/test.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/silver/2P/everywhere.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/silver/binsearch/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/silver/binsearch/sabotage.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/silver/greedy/cielduel.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/silver/greedy/party.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/silver/greedy/test.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/silver/idk/lirs/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/silver/idk/maze/main.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/silver/orderedsets/arraydestruction.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
ll	practice/usacoguide/silver/orderedsets/coveredpoints.cpp	/^typedef long long ll;$/;"	t	typeref:typename:long long	file:
llg	code-library/Data Structures/SQRT Tree.cpp	/^  int n, llg, indexSz;$/;"	m	struct:SqrtTree	typeref:typename:int	file:
llg	code/Data Structures/SQRT Tree.cpp	/^  int n, llg, indexSz;$/;"	m	struct:SqrtTree	typeref:typename:int	file:
lli	contests/Codeforces/737/D.cpp	/^typedef long long int lli;$/;"	t	typeref:typename:long long int	file:
lli	contests/Codeforces/737/E.cpp	/^typedef long long int lli;$/;"	t	typeref:typename:long long int	file:
llv	contests/Codeforces/737/C.cpp	/^#define llv /;"	d	file:
lmod	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static R64 lmod;$/;"	m	class:poly	typeref:typename:R64	file:
lmod	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^R64 poly::lmod;$/;"	m	class:poly	typeref:typename:R64
lmod	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static R64 lmod;$/;"	m	class:poly	typeref:typename:R64	file:
lmod	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^R64 poly::lmod;$/;"	m	class:poly	typeref:typename:R64
lo	code-library/Data Structures/Wavelet Tree.cpp	/^  int lo, hi;$/;"	m	struct:wavelet_tree	typeref:typename:int	file:
lo	code-library/Strings/Number of Palindromes in Range.cpp	/^  int lo, hi;$/;"	m	struct:wavelet_tree	typeref:typename:int	file:
lo	code/Data Structures/Wavelet Tree.cpp	/^  int lo, hi;$/;"	m	struct:wavelet_tree	typeref:typename:int	file:
lo	code/Strings/Number of Palindromes in Range.cpp	/^  int lo, hi;$/;"	m	struct:wavelet_tree	typeref:typename:int	file:
location	practice/cpbook/ch1/1.6/game/easier/11459/main.cpp	/^vector<int> location(1000000);$/;"	v	typeref:typename:vector<int>
log	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly log(int n) const { \/\/ln p(x) mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
log	code-library/Math/Polynomial.cpp	/^  poly log(int n) const { \/\/ln p(x) mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
log	code-library/Math/Subset Sum Problem.cpp	/^  poly log(int n) const { \/\/ln p(x) mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
log	code-library/Number Theory/Bell Number.cpp	/^    poly log(int n) const { \/\/ln p(x) mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
log	code/Math/Faulhaber Formula Fastest.cpp	/^  poly log(int n) const { \/\/ln p(x) mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
log	code/Math/Polynomial.cpp	/^  poly log(int n) const { \/\/ln p(x) mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
log	code/Math/Subset Sum Problem.cpp	/^  poly log(int n) const { \/\/ln p(x) mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
log	code/Number Theory/Bell Number.cpp	/^    poly log(int n) const { \/\/ln p(x) mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
log2Up	code-library/Data Structures/SQRT Tree.cpp	/^inline int log2Up(int n) {$/;"	f	typeref:typename:int
log2Up	code/Data Structures/SQRT Tree.cpp	/^inline int log2Up(int n) {$/;"	f	typeref:typename:int
log_b	practice/cf/random/i_hate_math_problems/1469D.cpp	/^double log_b(int a, int b) {$/;"	f	typeref:typename:double
lookup	code-library/Miscellaneous/Schreier–Sims algorithm.cpp	/^  vector<vector<int>> lookup;$/;"	m	struct:Group	typeref:typename:vector<vector<int>>	file:
lookup	code/Miscellaneous/Schreier–Sims algorithm.cpp	/^  vector<vector<int>> lookup;$/;"	m	struct:Group	typeref:typename:vector<vector<int>>	file:
low	code-library/Game Theory/Green Hackenbush.cpp	/^int n, T, low[N], dis[N];$/;"	v	typeref:typename:int[]
low	code-library/Graph Theory/Articulation Bridges.cpp	/^  vector<int> comp, ord, low;$/;"	m	struct:TECC	typeref:typename:vector<int>	file:
low	code-library/Graph Theory/Articulation Points.cpp	/^int T, low[N], dis[N], art[N];$/;"	v	typeref:typename:int[]
low	code-library/Graph Theory/Block Cut Tree.cpp	/^int T, low[N], dis[N], art[N], sz;$/;"	v	typeref:typename:int[]
low	code-library/Graph Theory/ST Numbering.cpp	/^int low[N], dis[N], T = 0, par[N], sign[N];$/;"	v	typeref:typename:int[]
low	code/Game Theory/Green Hackenbush.cpp	/^int n, T, low[N], dis[N];$/;"	v	typeref:typename:int[]
low	code/Graph Theory/Articulation Bridges.cpp	/^  vector<int> comp, ord, low;$/;"	m	struct:TECC	typeref:typename:vector<int>	file:
low	code/Graph Theory/Articulation Points.cpp	/^int T, low[N], dis[N], art[N];$/;"	v	typeref:typename:int[]
low	code/Graph Theory/Block Cut Tree.cpp	/^int T, low[N], dis[N], art[N], sz;$/;"	v	typeref:typename:int[]
low	code/Graph Theory/ST Numbering.cpp	/^int low[N], dis[N], T = 0, par[N], sign[N];$/;"	v	typeref:typename:int[]
lower_bound	code-library/Strings/Suffix Array.cpp	/^  int lower_bound(string &t) {$/;"	f	struct:SuffixArray	typeref:typename:int	file:
lower_bound	code/Strings/Suffix Array.cpp	/^  int lower_bound(string &t) {$/;"	f	struct:SuffixArray	typeref:typename:int	file:
lp	code-library/Math/Simplex Algorithm.cpp	/^namespace lp {$/;"	n	file:
lp	code/Math/Simplex Algorithm.cpp	/^namespace lp {$/;"	n	file:
ls	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^        int l = 0, r = 0; mint lf = 0, ls = 0; mint val = 0;$/;"	m	struct:PST::node	typeref:typename:mint	file:
ls	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^        int l = 0, r = 0; mint lf = 0, ls = 0; mint val = 0;$/;"	m	struct:PST::node	typeref:typename:mint	file:
lst	code-library/Graph Theory/ST Numbering.cpp	/^list<int> lst;$/;"	v	typeref:typename:list<int>
lst	code/Graph Theory/ST Numbering.cpp	/^list<int> lst;$/;"	v	typeref:typename:list<int>
lt	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^} lt;$/;"	v	typeref:struct:PersistentLiChaoTree
lt	code-library/Geometry/Point Location.cpp	/^bool lt(const ll& a, const ll& b) { return a < b; }$/;"	f	typeref:typename:bool
lt	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^} lt;$/;"	v	typeref:struct:PersistentLiChaoTree
lt	code/Geometry/Point Location.cpp	/^bool lt(const ll& a, const ll& b) { return a < b; }$/;"	f	typeref:typename:bool
lucas	code-library/Number Theory/Lucas Theorem.cpp	/^mint lucas(ll n, ll r) {$/;"	f	typeref:typename:mint
lucas	code/Number Theory/Lucas Theorem.cpp	/^mint lucas(ll n, ll r) {$/;"	f	typeref:typename:mint
lval	code-library/Data Structures/Segment Tree Beats.cpp	/^  ll len[4 * N], ladd[4 * N], lval[4 * N];$/;"	m	struct:SGTBeats	typeref:typename:ll[]	file:
lval	code/Data Structures/Segment Tree Beats.cpp	/^  ll len[4 * N], ladd[4 * N], lval[4 * N];$/;"	m	struct:SGTBeats	typeref:typename:ll[]	file:
m	code-library/Data Structures/MOs with DSU.cpp	/^int n, ed, m;$/;"	v	typeref:typename:int
m	code-library/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^  vector<ll> m, b;$/;"	m	struct:CHT	typeref:typename:vector<ll>	file:
m	code-library/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^  ll m, b;$/;"	m	struct:line	typeref:typename:ll	file:
m	code-library/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  ll m, c;$/;"	m	struct:Line	typeref:typename:ll	file:
m	code-library/Graph Theory/Dijkstra.cpp	/^int n, m;$/;"	v	typeref:typename:int
m	code-library/Graph Theory/Dynamic MST.cpp	/^int n, m, q;$/;"	v	typeref:typename:int
m	code-library/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^int n, m, bel[N * 4];$/;"	v	typeref:typename:int
m	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^int s, t, n, m, u[N], v[N], deg[N];$/;"	v	typeref:typename:int
m	code-library/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^int n, m, U[M], V[M], id[N], par[N];$/;"	v	typeref:typename:int
m	code-library/Graph Theory/Stable Marriage Problem.cpp	/^int m[N][N], w[N][N], id[N], marry[N], ans[N], pref[N][N];$/;"	v	typeref:typename:int[][]
m	code-library/Graph Theory/Steiner Tree Problem.cpp	/^int n, k, m;$/;"	v	typeref:typename:int
m	code-library/Math/Determinant of Sparse Matrix.cpp	/^  int n, m;$/;"	m	struct:Mat	typeref:typename:int	file:
m	code-library/Math/FWHT in Any Base.cpp	/^    int a[MXK][MXK], n, m;$/;"	m	struct:FWHT::Matrix	typeref:typename:int	file:
m	code-library/Math/Freivalds Algorithm.cpp	/^  int n, m;$/;"	m	struct:Mat	typeref:typename:int	file:
m	code-library/Math/Matrix Exponentiation.cpp	/^  int n, m;$/;"	m	struct:Mat	typeref:typename:int	file:
m	code-library/Math/Reeds Sloane Algorithm.cpp	/^  int m;$/;"	m	struct:LinearRecurrence	typeref:typename:int	file:
m	code-library/Math/Simplex Algorithm.cpp	/^  int m, n, solution_flag, minmax_flag, basis[MAXC], index[MAXV];$/;"	v	namespace:lp	typeref:typename:int
m	code-library/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^int n, m, tot, col[N], where[N], par[N];$/;"	v	typeref:typename:int
m	code-library/Miscellaneous/Schreier–Sims algorithm.cpp	/^  int n, m;$/;"	m	struct:Group	typeref:typename:int	file:
m	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^    u32 m;$/;"	m	struct:poly::fast_div	typeref:typename:u32	file:
m	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^    u64 m, s, x;$/;"	m	struct:poly::fast_div	typeref:typename:u64	file:
m	code-library/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^int m;$/;"	v	typeref:typename:int
m	code-library/Strings/Prefix Automaton.cpp	/^int n, m;$/;"	v	typeref:typename:int
m	code-library/Strings/String Hashing 2D.cpp	/^  int n, m;$/;"	m	struct:Hashing	typeref:typename:int	file:
m	code/Data Structures/MOs with DSU.cpp	/^int n, ed, m;$/;"	v	typeref:typename:int
m	code/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^  vector<ll> m, b;$/;"	m	struct:CHT	typeref:typename:vector<ll>	file:
m	code/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^  ll m, b;$/;"	m	struct:line	typeref:typename:ll	file:
m	code/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  ll m, c;$/;"	m	struct:Line	typeref:typename:ll	file:
m	code/Graph Theory/Dijkstra.cpp	/^int n, m;$/;"	v	typeref:typename:int
m	code/Graph Theory/Dynamic MST.cpp	/^int n, m, q;$/;"	v	typeref:typename:int
m	code/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^int n, m, bel[N * 4];$/;"	v	typeref:typename:int
m	code/Graph Theory/Maximum Density Subgraph.cpp	/^int s, t, n, m, u[N], v[N], deg[N];$/;"	v	typeref:typename:int
m	code/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^int n, m, U[M], V[M], id[N], par[N];$/;"	v	typeref:typename:int
m	code/Graph Theory/Stable Marriage Problem.cpp	/^int m[N][N], w[N][N], id[N], marry[N], ans[N], pref[N][N];$/;"	v	typeref:typename:int[][]
m	code/Graph Theory/Steiner Tree Problem.cpp	/^int n, k, m;$/;"	v	typeref:typename:int
m	code/Math/Determinant of Sparse Matrix.cpp	/^  int n, m;$/;"	m	struct:Mat	typeref:typename:int	file:
m	code/Math/FWHT in Any Base.cpp	/^    int a[MXK][MXK], n, m;$/;"	m	struct:FWHT::Matrix	typeref:typename:int	file:
m	code/Math/Freivalds Algorithm.cpp	/^  int n, m;$/;"	m	struct:Mat	typeref:typename:int	file:
m	code/Math/Matrix Exponentiation.cpp	/^  int n, m;$/;"	m	struct:Mat	typeref:typename:int	file:
m	code/Math/Reeds Sloane Algorithm.cpp	/^  int m;$/;"	m	struct:LinearRecurrence	typeref:typename:int	file:
m	code/Math/Simplex Algorithm.cpp	/^  int m, n, solution_flag, minmax_flag, basis[MAXC], index[MAXV];$/;"	v	namespace:lp	typeref:typename:int
m	code/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^int n, m, tot, col[N], where[N], par[N];$/;"	v	typeref:typename:int
m	code/Miscellaneous/Schreier–Sims algorithm.cpp	/^  int n, m;$/;"	m	struct:Group	typeref:typename:int	file:
m	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^    u32 m;$/;"	m	struct:poly::fast_div	typeref:typename:u32	file:
m	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^    u64 m, s, x;$/;"	m	struct:poly::fast_div	typeref:typename:u64	file:
m	code/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^int m;$/;"	v	typeref:typename:int
m	code/Strings/Prefix Automaton.cpp	/^int n, m;$/;"	v	typeref:typename:int
m	code/Strings/String Hashing 2D.cpp	/^  int n, m;$/;"	m	struct:Hashing	typeref:typename:int	file:
m	practice/usacoguide/gold/dsu/wormhole/main.cpp	/^int n, m;$/;"	v	typeref:typename:int
m32_1	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  using m32_1 = ntt::Mod<138412033, 5>;$/;"	t	namespace:ntt	typeref:typename:ntt::Mod<138412033,5>	file:
m32_1	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  using m32_1 = ntt::Mod<138412033, 5>;$/;"	t	namespace:ntt	typeref:typename:ntt::Mod<138412033,5>	file:
m32_2	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  using m32_2 = ntt::Mod<155189249, 6>;$/;"	t	namespace:ntt	typeref:typename:ntt::Mod<155189249,6>	file:
m32_2	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  using m32_2 = ntt::Mod<155189249, 6>;$/;"	t	namespace:ntt	typeref:typename:ntt::Mod<155189249,6>	file:
m32_3	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  using m32_3 = ntt::Mod<163577857, 23>; \/\/ <=  16579e4 (sub.D = 3)$/;"	t	namespace:ntt	typeref:typename:ntt::Mod<163577857,23>	file:
m32_3	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  using m32_3 = ntt::Mod<163577857, 23>; \/\/ <=  16579e4 (sub.D = 3)$/;"	t	namespace:ntt	typeref:typename:ntt::Mod<163577857,23>	file:
m64_1	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  using m64_1 = ntt::Mod<709143768229478401, 31>;$/;"	t	namespace:ntt	typeref:typename:ntt::Mod<709143768229478401,31>	file:
m64_1	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  using m64_1 = ntt::Mod<709143768229478401, 31>;$/;"	t	namespace:ntt	typeref:typename:ntt::Mod<709143768229478401,31>	file:
m64_2	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  using m64_2 = ntt::Mod<711416664922521601, 19>; \/\/ <= 712e15 (sub.D = 3)$/;"	t	namespace:ntt	typeref:typename:ntt::Mod<711416664922521601,19>	file:
m64_2	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  using m64_2 = ntt::Mod<711416664922521601, 19>; \/\/ <= 712e15 (sub.D = 3)$/;"	t	namespace:ntt	typeref:typename:ntt::Mod<711416664922521601,19>	file:
main	.compilingScripts/download_prob.py	/^def main():$/;"	f
main	code-library/Data Structures/Augmented DSU.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Data Structures/BIT 2D with Range Update and Range Query.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Data Structures/BIT with Range Update and Range Query.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/BIT.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/BST using STL.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Data Structures/Binarizing a Tree.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/Cartesian Tree.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/Centroid Decomposition.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Data Structures/DSU Partially Persistent.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/DSU on Tree.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/DSU with Rollbacks.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/DSU.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/Disjoint Sparse Table.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Data Structures/Dynamic Diameter Online.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/HLD.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/Implicit Treap.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Data Structures/Interval Set.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/KD Tree.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Data Structures/LCA.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/Link Cut Tree.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/MOs Algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/MOs Online.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Data Structures/MOs on tree.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Data Structures/MOs with DSU.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Data Structures/MOs with Update.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Data Structures/Monotonous Queue.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/Ordered Set.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Data Structures/Permutation Tree.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/Persistent Array.cpp	/^int32_t main(){$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/Persistent Meldable Heap.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/Persistent Queue.cpp	/^int32_t main(){$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/Persistent UnionFind.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/Queue Undo Trick.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/Reachability Tree.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/SQRT Tree.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/Segment Tree Beats.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/Segment Tree Lazy.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/Segment Tree Merging.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Data Structures/Segment Tree NonRecursive.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/Segment Tree Persistent.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/Segment Tree.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/Sparse Table 2D.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/Sparse Table.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/Static to Dynamic Trick.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Data Structures/Top Tree.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Data Structures/Treap persistent.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/Treap.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/Trie.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Data Structures/Wavelet Tree.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Dynamic Programming Optimizations/1D1D DP.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Dynamic Programming Optimizations/Bounded Knapsack.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Dynamic Programming Optimizations/Connected Component DP.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Dynamic Programming Optimizations/DP Over Divisors.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Dynamic Programming Optimizations/Digit DP.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Dynamic Programming Optimizations/Divide and Conquer Optimization.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Dynamic Programming Optimizations/Dynamic Submask Count.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Dynamic Programming Optimizations/Hirschbergs Algorithm.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Dynamic Programming Optimizations/Knuth Optimization.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Dynamic Programming Optimizations/Number of Subsequences Having Product at least K.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Dynamic Programming Optimizations/SOS convolutions.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Dynamic Programming Optimizations/Subset Sum in SQRT.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Dynamic Programming Optimizations/Subset Union of Bitsets.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Dynamic Programming Optimizations/XOR Equation.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Game Theory/Blue Red Hackenbush.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Game Theory/Green Hackenbush.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Game Theory/Matching Game On A Graph.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Geometry/All Pair Segment Intersection.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Geometry/Closest Pair of Points.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Geometry/Convec Hull Dynamic.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Geometry/Delaunay Triangulation.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Geometry/Geometry 2D.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Geometry/Geometry 3D.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Geometry/Half Plane Intersection.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Geometry/Maximum Area of Triangle, Given are Lengths.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Geometry/Onion Decomposition.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Geometry/Point Location.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Geometry/Voronoi Diagram.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/2 SAT.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Graph Theory/3 CYCLE and 4 CYCLE.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/3 SAT.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Articulation Bridges.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Articulation Points.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Bellman Ford.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Block Cut Tree.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Graph Theory/Blossom Algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Boruvka's Algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Chinese Postman Problem.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Graph Theory/Chordal Graph.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Chromatic Number.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Cycle Detection.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/DAG Reachability Dynamic.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Dijkstra on Segment Tree.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Dijkstra.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Dinics Algorithm.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Graph Theory/Directed MST.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Dominator Tree.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Graph Theory/Dynamic MST.cpp	/^int main(){$/;"	f	typeref:typename:int
main	code-library/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Edge Coloring Simple Graph.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Eppsteins Algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Euler Path Directed.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Euler Path Undirected.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Floyd Warshall.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Graph Theory/Gomory Hu Tree.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/HopCroft Karp Algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Hungarian Algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Inverse Graph.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Johnson's Algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Kirchoffs Theorem.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Krushkal's MST.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Kuhns Algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/L R Flow with Dinic.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/L R Flow with MCMF.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/LCA in O(1).cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/LCA.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Manhattan MST.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Maximum Clique.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Maximum Closure Problem.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Maximum Independant Set.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Min Cost Max Flow.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Graph Theory/Min Cut in a Planar Graph.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Graph Theory/Minimum Mean Weight Cycle.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Minimum Weight Cycle For Each Edge.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Minimum Weight Cycle For Each Vertex.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Number of Arborescence.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Number of DAG.cpp	/^int32_t main()$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Number of Different Cliques.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Graph Theory/Online Articulation Bridges.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Graph Theory/Path Intersection.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Path Union.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Prim's MST.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Graph Theory/Prufer Code.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Randomized Matching Unweighted.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Randomized Matching Weighted.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/SCC.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Graph Theory/SPFA.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/ST Numbering.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Stable Marriage Problem.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Steiner Tree Problem.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Graph Theory/Stoer Wagner Algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/System Of Difference Constraints.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Three Edge Connectivity.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Graph Theory/Tree Isomorphism.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Tree Orientation.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Tuttes Theorem.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Unique Min Cut.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Graph Theory/Virtual Tree.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/All Possible Perfect Matching XOR Values.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Basis Vector Reduced Row Echelon Form.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Basis Vector ft Weighted Linearly Independent Vectors.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Basis Vector.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Math/BerleKamp Massey.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Characteristic Polynomial Faster.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Determinant of Cyclic Matrix.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Math/Determinant of Permutant Matrix.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Math/Determinant of Product Matrix.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Determinant of Sparse Matrix.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Math/Determinant under Composite Modulo.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Determinant under Prime Modulo.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Determinant.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Math/FFT.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/FWHT in Any Base.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Math/FWHT in Ternary Base.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/FWHT.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Faulhaber Formula Fastest.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Finite Field Arithmetic Binary.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Freivalds Algorithm.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Math/Gaussian Elimination Modular.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Gaussian Elimination Modulo 2.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Gaussian Elimination.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Hafnian of a Matrix.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Integration (Romberg).cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Integration (Simpsons).cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Inverse of A Matrix modulo 2.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Inverse of A Matrix.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Lagrange Interpolation Brute.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Lagrange Interpolation.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Lagrange Multiplier.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Linear Recurrence Fastest.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Linear Recurrence With Polynomial Coefficients.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Math/Linear Recurrence.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Matrix Exponentiation.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Max Convolution between Convex Funtions.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/NTT Online.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/NTT With Any Prime MOD.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Math/NTT.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Permanent of a Matrix.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Polynomial Factorization.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Math/Polynomial Sum.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Polynomial with Binomial Coefficients.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Polynomial.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Reeds Sloane Algorithm.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Math/Simplex Algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Subset Sum Problem.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/The Slime Trick.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Thomas Algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Math/Vandermonde Matrix.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Miscellaneous/BigInt.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Miscellaneous/Bitset Custom.cpp	/^int32_t main()$/;"	f	typeref:typename:int32_t
main	code-library/Miscellaneous/Expression Parsing.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Miscellaneous/Fraction Binary Search.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Miscellaneous/Gray Code.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Miscellaneous/K-th Root of a Permutation.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Miscellaneous/MEX of all Subarrays.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Miscellaneous/Parallel Binary Search.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Miscellaneous/Schreier–Sims algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Miscellaneous/Subset Union of Bitsets.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Miscellaneous/XOR Equation Arbitrary Range.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Number Theory/Bell Number.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/CRT.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Combinatorics Basics.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Continued Fractions.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Dirichlet Convolution.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Discrete Log.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Discrete Root Faster.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Discrete Root.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Extended Euclid.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Factoradic Number System.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Fermats Theorem on Sum of Two Squares.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Number Theory/Fibonacci Number Faster.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Floor Sum of  Arithmetic Progressions.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Intersection of Arithmetic Progressions.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/K Divisors.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/LCM of Fibonacci Numbers.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Linear Congruence Equation.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Linear Diophantine Equation Three Variables with Nonnegative Solutions.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Linear Diophantine Equation with Nonnegative Solutions.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Linear Diophantine Equation with Two Variables.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Linear Diophantine With N Unknowns and Two Equations.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Linear Sieve for Multiplicative Functions.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Lucas Theorem.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Maximum Coprime Product.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Number Theory/Min_25 Sieve.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Mobius Function.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Multiplicative Order.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Number of Distinct Kth Powers Modulo n.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Number of Nonnegative Integer Solutions to ax+by <= c.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Number of ax%p in a Range.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Partition Function.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Pells Equation.py	/^def main():$/;"	f
main	code-library/Number Theory/Phi Field.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Phi Function.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Pisano Period.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Pollard Rho.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Power Tower.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Prime Counting Function.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Prime Factorization Fastest.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Number Theory/Prime Number System.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Primitive Root.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Rational Approximation.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Sieve upto 1e9.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Sieve.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Smallest Nonnegative Integer x s.t. l <= ax % p <= r.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Smallest Number Having Exactly K Divisors.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Sum of Arithmetic Progression Modular and Divided.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Number Theory/Sum of Floors.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Sum of The Number of Divisors in cbrt(n).cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/Tonelli Shanks Algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Number Theory/nCr Modulo Any Mod.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Strings/Aho Corasick Dynamic.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Strings/Aho Corasick.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Strings/All Substring Longest Common Subsequence.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Strings/Bit LCS.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Strings/Cyclic LCS.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Strings/De Bruijn Sequence.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Strings/KMP.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Strings/Manachers.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Strings/Number of Palindromes in Range.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Strings/Palindromic Tree Persistent.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Strings/Palindromic Tree.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Strings/Prefix Automaton.cpp	/^int32_t main()$/;"	f	typeref:typename:int32_t
main	code-library/Strings/String Hashing 2D.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Strings/String Hashing.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Strings/String Matching With FFT.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Strings/String Matching using Bitsets.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code-library/Strings/Suffix Array Isomorphic.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Strings/Suffix Array.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Strings/Suffix Automaton.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code-library/Strings/Z Algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Augmented DSU.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Data Structures/BIT 2D with Range Update and Range Query.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Data Structures/BIT with Range Update and Range Query.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/BIT.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/BST using STL.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Data Structures/Binarizing a Tree.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Cartesian Tree.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Data Structures/Centroid Decomposition Persistent.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Centroid Decomposition.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Data Structures/DSU Partially Persistent.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/DSU on Tree.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/DSU with Rollbacks.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/DSU.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Disjoint Sparse Table.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Dynamic Connectivity Problem.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Data Structures/Dynamic Diameter Online.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/HLD.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Implicit Treap.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Data Structures/Interval Set.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/KD Tree.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Data Structures/LCA.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Link Cut Tree.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/MOs Algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/MOs Online.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Data Structures/MOs on tree.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Data Structures/MOs with DSU.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Data Structures/MOs with Update.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Data Structures/Monotonous Queue.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Ordered Set.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Data Structures/Permutation Tree.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Persistent Array.cpp	/^int32_t main(){$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Persistent Meldable Heap.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Persistent Queue.cpp	/^int32_t main(){$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Persistent UnionFind.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Queue Undo Trick.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Reachability Tree.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/SQRT Tree.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Segment Tree Beats.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Segment Tree Lazy.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Segment Tree Merging.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Data Structures/Segment Tree NonRecursive.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Segment Tree Persistent.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Segment Tree.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Sparse Table 2D.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Sparse Table.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Static to Dynamic Trick.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Data Structures/Top Tree.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Data Structures/Treap persistent.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Treap.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Trie.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Data Structures/Wavelet Tree.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Dynamic Programming Optimizations/1D1D DP.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Dynamic Programming Optimizations/Bounded Knapsack.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Dynamic Programming Optimizations/Connected Component DP.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Dynamic Programming Optimizations/DP Over Divisors.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Dynamic Programming Optimizations/Digit DP.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Dynamic Programming Optimizations/Divide and Conquer Optimization.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Dynamic Programming Optimizations/Dynamic Submask Count.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Dynamic Programming Optimizations/Hirschbergs Algorithm.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Dynamic Programming Optimizations/Knuth Optimization.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Dynamic Programming Optimizations/Number of Subsequences Having Product at least K.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Dynamic Programming Optimizations/SOS convolutions.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Dynamic Programming Optimizations/Subset Sum in SQRT.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Dynamic Programming Optimizations/Subset Union of Bitsets.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Dynamic Programming Optimizations/XOR Equation.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Game Theory/Blue Red Hackenbush.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Game Theory/Green Hackenbush.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Game Theory/Matching Game On A Graph.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Geometry/All Pair Segment Intersection.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Geometry/Closest Pair of Points.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Geometry/Convec Hull Dynamic.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Geometry/Delaunay Triangulation.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Geometry/Geometry 2D.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Geometry/Geometry 3D.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Geometry/Half Plane Intersection Dynamic.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Geometry/Half Plane Intersection.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Geometry/Maximum Area of Triangle, Given are Lengths.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Geometry/Onion Decomposition.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Geometry/Point Location.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Geometry/Voronoi Diagram.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/2 SAT.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Graph Theory/3 CYCLE and 4 CYCLE.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/3 SAT.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Articulation Bridges.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Articulation Points.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Bellman Ford.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Block Cut Tree.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Graph Theory/Blossom Algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Boruvka's Algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Chinese Postman Problem.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Graph Theory/Chordal Graph.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Chromatic Number.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Chromatic Polynoimial.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Counting Labeled Graphs.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Cycle Detection.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/DAG Reachability Dynamic.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Dijkstra on Segment Tree.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Dijkstra.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Dinics Algorithm.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Graph Theory/Directed MST.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Dominator Tree.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Graph Theory/Dynamic MST.cpp	/^int main(){$/;"	f	typeref:typename:int
main	code/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Edge Coloring Simple Graph.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Eppsteins Algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Euler Path Directed.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Euler Path Undirected.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Floyd Warshall.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Graph Theory/Gomory Hu Tree.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Hafnian of a Matrix.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/HopCroft Karp Algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Hungarian Algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Inverse Graph.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Johnson's Algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Kirchoffs Theorem.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Krushkal's MST.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Kuhns Algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/L R Flow with Dinic.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/L R Flow with MCMF.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/LCA in O(1).cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/LCA.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Manhattan MST.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Maximum Clique.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Maximum Closure Problem.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Maximum Density Subgraph.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Maximum Independant Set.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Min Cost Max Flow.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Graph Theory/Min Cut in a Planar Graph.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Graph Theory/Minimum Mean Weight Cycle.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Minimum Weight Cycle For Each Edge.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Minimum Weight Cycle For Each Vertex.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Number of Arborescence.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Number of DAG.cpp	/^int32_t main()$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Number of Different Cliques.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Graph Theory/Online Articulation Bridges.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Graph Theory/Path Intersection.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Path Union.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Prim's MST.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Graph Theory/Prufer Code.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Randomized Matching Unweighted.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Randomized Matching Weighted.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/SCC.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Graph Theory/SPFA.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/ST Numbering.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Stable Marriage Problem.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Steiner Tree Problem.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Graph Theory/Stoer Wagner Algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/System Of Difference Constraints.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Three Edge Connectivity.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Graph Theory/Tree Isomorphism.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Tree Orientation.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Tuttes Theorem.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Unique Min Cut.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Graph Theory/Virtual Tree.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/All Possible Perfect Matching XOR Values.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Basis Vector Reduced Row Echelon Form.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Basis Vector ft Weighted Linearly Independent Vectors.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Basis Vector.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Math/BerleKamp Massey.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Characteristic Polynomial Faster.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Determinant of Cyclic Matrix.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Math/Determinant of Permutant Matrix.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Math/Determinant of Product Matrix.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Determinant of Sparse Matrix.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Math/Determinant under Composite Modulo.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Determinant under Prime Modulo.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Determinant.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Math/FFT.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/FWHT in Any Base.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Math/FWHT in Ternary Base.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/FWHT.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Faulhaber Formula Fastest.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Finite Field Arithmetic Binary.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Freivalds Algorithm.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Math/Gaussian Elimination Modular.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Gaussian Elimination Modulo 2.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Gaussian Elimination.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Math/Generating Function of a Linear Recurrence.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Hafnian of a Matrix.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Integration (Romberg).cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Integration (Simpsons).cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Inverse of A Matrix modulo 2.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Inverse of A Matrix.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Lagrange Interpolation Brute.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Lagrange Interpolation.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Lagrange Multiplier.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Linear Recurrence Fastest.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Linear Recurrence With Polynomial Coefficients.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Math/Linear Recurrence.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Matrix Exponentiation.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Max Convolution between Convex Funtions.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/NTT Online.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/NTT With Any Prime MOD.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Math/NTT.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Math/Number of Solutions of A Equation MITM.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Permanent of a Matrix.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Polynomial Factorization.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Math/Polynomial Sum.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Polynomial with Binomial Coefficients.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Polynomial.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Reeds Sloane Algorithm.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Math/Simplex Algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Subset Sum Problem.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/The Slime Trick.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Thomas Algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Math/Vandermonde Matrix.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Miscellaneous/BigInt.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Miscellaneous/Bitset Custom.cpp	/^int32_t main()$/;"	f	typeref:typename:int32_t
main	code/Miscellaneous/Expression Parsing.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Miscellaneous/Fraction Binary Search.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Miscellaneous/Gray Code.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Miscellaneous/K-th Root of a Permutation.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Miscellaneous/MEX of all Subarrays.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Miscellaneous/Parallel Binary Search.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Miscellaneous/Schreier–Sims algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Miscellaneous/Subset Union of Bitsets.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Miscellaneous/XOR Equation Arbitrary Range.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Number Theory/Bell Number.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/CRT.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Combinatorics Basics.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Continued Fractions.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Dirichlet Convolution.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Discrete Log.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Discrete Root Faster.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Discrete Root.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Extended Euclid.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Factoradic Number System.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Fermats Theorem on Sum of Two Squares.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Number Theory/Fibonacci Number Faster.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Floor Sum of  Arithmetic Progressions.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Intersection of Arithmetic Progressions.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/K Divisors.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/LCM of Fibonacci Numbers.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Linear Congruence Equation.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Linear Diophantine Equation Three Variables with Nonnegative Solutions.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Linear Diophantine Equation with Nonnegative Solutions.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Linear Diophantine Equation with Two Variables.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Linear Diophantine With N Unknowns and Two Equations.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Linear Sieve for Multiplicative Functions.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Lucas Theorem.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Maximum Coprime Product.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Number Theory/Min_25 Sieve.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Mobius Function.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Multiplicative Order.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Number of Distinct Kth Powers Modulo n.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Number of Nonnegative Integer Solutions to ax+by <= c.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Number of ax%p in a Range.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Partition Function.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Pells Equation.py	/^def main():$/;"	f
main	code/Number Theory/Phi Field.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Phi Function.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Pisano Period.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Pollard Rho.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Power Tower.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Prime Counting Function.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Prime Factorization Fastest.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Number Theory/Prime Number System.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Primitive Root.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Rational Approximation.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Sieve upto 1e9.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Sieve.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Smallest Nonnegative Integer x s.t. l <= ax % p <= r.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Smallest Number Having Exactly K Divisors.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Sum of Arithmetic Progression Modular and Divided.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Number Theory/Sum of Floors.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Sum of The Number of Divisors in cbrt(n).cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/Tonelli Shanks Algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Number Theory/nCr Modulo Any Mod.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Strings/Aho Corasick Dynamic.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Strings/Aho Corasick.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Strings/All Substring Longest Common Subsequence.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Strings/Bit LCS.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Strings/Cyclic LCS.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Strings/De Bruijn Sequence.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Strings/KMP.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Strings/Manachers.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Strings/Number of Palindromes in Range.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Strings/Palindromic Tree Persistent.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Strings/Palindromic Tree.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Strings/Prefix Automaton.cpp	/^int32_t main()$/;"	f	typeref:typename:int32_t
main	code/Strings/String Hashing 2D.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Strings/String Hashing.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Strings/String Matching With FFT.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Strings/String Matching using Bitsets.cpp	/^int main() {$/;"	f	typeref:typename:int
main	code/Strings/Suffix Array Isomorphic.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Strings/Suffix Array.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Strings/Suffix Automaton.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/Strings/Z Algorithm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	code/template.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/AtCoder/214/A/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/AtCoder/214/B/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/AtCoder/214/C/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/AtCoder/214/D/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/AtCoder/215/A/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/AtCoder/215/B/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/AtCoder/215/C/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/AtCoder/215/D/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/AtCoder/225/A.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/AtCoder/225/B.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/AtCoder/225/C.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/AtCoder/225/D.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/AtCoder/225/E.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/AtCoder/225/F.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/AtCoder/231/A.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/AtCoder/231/B.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/AtCoder/231/C.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/AtCoder/231/D.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/AtCoder/231/E.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/AtCoder/ABC211/A.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/AtCoder/ABC211/B.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/AtCoder/ABC211/C.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/AtCoder/ABC211/D.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/AtCoder/ABC211/E.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1552/1552A.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1552/1552B.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1552/1552C.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1552/1552D.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1552/1552E.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1552/1552F.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1552/1552G.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1552/1552H.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1552/1552I.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1560/A/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1560/B/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1560/C/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1560/D/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1560/D/test.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1560/E/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1560/F1/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1560/F1/main1.cpp	/^signed main()$/;"	f	typeref:typename:signed
main	contests/Codeforces/1560/F1/stress.cpp	/^int main(int argc, char* argv[]) {$/;"	f	typeref:typename:int
main	contests/Codeforces/1560/F1/test1.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1560/F1/test2.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1609/A.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1609/B.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1609/C.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1609/D.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1616/A/sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1616/B/sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1616/C/sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1616/C/soll.cpp	/^int main()$/;"	f	typeref:typename:int
main	contests/Codeforces/1616/D/new_sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1616/D/sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1622/A/sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1622/B/sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1622/C/sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1622/C_new/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1622/C_new/sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1622/upsolve/C/sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1623/A/sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1623/B/sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1623/C/sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/1623/new_C/sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/737/A.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/Codeforces/737/B.cpp	/^int main() {$/;"	f	typeref:typename:int
main	contests/Codeforces/737/C.cpp	/^int main(){$/;"	f	typeref:typename:int
main	contests/Codeforces/737/D.cpp	/^int main() {$/;"	f	typeref:typename:int
main	contests/Codeforces/737/E.cpp	/^int main()$/;"	f	typeref:typename:int
main	contests/LIT2021/B.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/LIT2021/C.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/LIT2021/D.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/USACO/dec_silver_2021/A/A.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/USACO/dec_silver_2021/A/AA.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/USACO/dec_silver_2021/A/AAA.cpp	/^signed main() {$/;"	f	typeref:typename:signed
main	contests/USACO/dec_silver_2021/A/A_safe.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/USACO/dec_silver_2021/A/A_sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/USACO/dec_silver_2021/A/a_save.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/USACO/dec_silver_2021/A/a_testing.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/USACO/dec_silver_2021/A/gen.cpp	/^int main(int argc, char* argv[]) {$/;"	f	typeref:typename:int
main	contests/USACO/dec_silver_2021/A/restart_A.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/USACO/dec_silver_2021/B/B.cpp	/^signed main() {$/;"	f	typeref:typename:signed
main	contests/USACO/dec_silver_2021/B/B_new.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/USACO/dec_silver_2021/B/brute.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/USACO/dec_silver_2021/B/gen.cpp	/^int main(int argc, char* argv[]) {$/;"	f	typeref:typename:int
main	contests/USACO/dec_silver_2021/C/C.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/USACO/dec_silver_2021/C/C_full.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/USACO/dec_silver_2021/C/C_new.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	contests/USACO/dec_silver_2021/C/gen.cpp	/^int main(int argc, char* argv[]) {$/;"	f	typeref:typename:int
main	practice/cf/DP/1051E1.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/DP/1061D.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/DP/1091D.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/DP/1461C.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/DP/altaray.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/DP/knap1.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/DP/knap2.cpp	/^int32_t main(){$/;"	f	typeref:typename:int32_t
main	practice/cf/DP/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/greedy/1487C.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/1700/1.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/1700/1472E.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/1700/1473D.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/1700/1476D.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/1700/1608C/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/1700/1618E.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/1700/1618E/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/1700/2.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/1700/3.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/1700/4.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/1700/5.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/1700/6.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/1700/7.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/1700/8.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/1700/brute.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/1700/stress.cpp	/^int main(int argc, char* argv[]) {$/;"	f	typeref:typename:int
main	practice/cf/random/1700/test.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/1700/test1.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/1700/test2.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/1700/test3.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/1700/testing.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/coloring/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/diane/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/i_hate_math_problems/1336B.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/i_hate_math_problems/1368D.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/i_hate_math_problems/1400B.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/i_hate_math_problems/1422C.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/i_hate_math_problems/1451D.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/i_hate_math_problems/1469D.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/i_hate_math_problems/testing.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/random/pink/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/stuff/dec 20 2021/1608C/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cf/upsolve/1557B.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/club/prob1/generator_prob1.cpp	/^int main(int argc, char* argv[]) {$/;"	f	typeref:typename:int
main	practice/club/prob1/solution_prob1.cpp	/^int main() {$/;"	f	typeref:typename:int
main	practice/club/prob2/generator_prob2.cpp	/^int main(int argc, char* argv[]) {$/;"	f	typeref:typename:int
main	practice/club/prob2/solution_prob2.cpp	/^int main(){$/;"	f	typeref:typename:int
main	practice/club/prob3/generator_prob3.cpp	/^int32_t main(int argc, char* argv[]) {$/;"	f	typeref:typename:int32_t
main	practice/club/prob3/solution_prob3.cpp	/^int32_t main(){$/;"	f	typeref:typename:int32_t
main	practice/club/prob3/test.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.4/medium/11507.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.4/medium/11956.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.4/medium/12157.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.4/medium/12643.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.4/medium/basicprogramming1.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.4/medium/battlesimulation.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.4/medium/bitsequalizer.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.4/medium/fastfood.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.4/medium/garage.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.4/medium/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.4/medium/poi.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.4/medium/shatteredcake.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.6/card/10388/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.6/card/10388/main2.cpp	/^int main()$/;"	f	typeref:typename:int
main	practice/cpbook/ch1/1.6/card/10646/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.6/card/11225/karte.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.6/card/11225/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.6/card/11225/test.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.6/card/11678/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.6/card/11678/test.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.6/card/12247/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.6/chess/00225/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.6/chess/00696/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.6/chess/10284/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.6/chess/bijele/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.6/chess/chess/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.6/chess/chess/realsol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.6/game/easier/10189/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.6/game/easier/11459/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.6/game/easier/trik/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.6/game/harder/11013/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.6/game/harder/battleship/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.6/game/harder/rockpaperscissors/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.6/reallife/medium/00161/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.6/reallife/medium/01091/ac.cpp	/^int main() {$/;"	f	typeref:typename:int
main	practice/cpbook/ch1/1.6/reallife/medium/01091/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.6/reallife/medium/01091/restartmain.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.6/reallife/medium/01091/stress.cpp	/^int main(int argc, char* argv[]) {$/;"	f	typeref:typename:int
main	practice/cpbook/ch1/1.6/reallife/medium/01091/test.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.6/reallife/medium/10528/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.6/reallife/medium/beatspread/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch1/1.6/reallife/medium/tenis/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch2/2.2/1D/11222/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch2/2.2/1D/12150/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch2/2.2/1D/13048/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch2/2.2/1D/13181/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch2/2.2/1D/pivot/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch2/2.2/2D/11581/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch3/DP/00787.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/cpbook/ch3/DP/10684.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/december2021/1560E/sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/december2021/1572A/new_sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/december2021/1572A/sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/december2021/1619D/sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/december2021/1619E/sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/december2021/1620C/sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/december2021/DP/LIS/sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/december2021/DP/counting_towers/sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/december2021/DP/rectangle_cutting/sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/december2021/DP/removal_game/sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/december2021/DP/teamwork/sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/december2021/stacks/advertisement/sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/december2021/stacks/balloons/sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/december2021/stacks/nsv/sol.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/SP/dining/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/SP/flightdiscount.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/SP/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/SP/pump.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/SP/shortestroutesii.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/SP/visitfj.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/SP/visitfj/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/bfs/bfsdfs.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/bfs/cownav.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/bfs/cownav/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/bfs/dfsbfs.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/bfs/graphgirth.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/bfs/graphgirth2.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/bfs/graphgirth2.cpp	/^signed main(){$/;"	f	typeref:typename:signed
main	practice/usacoguide/gold/bfs/lasers.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/bfs/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/bfs/mecho/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/bfs/mechonew/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/bfs/milkpails.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/bfs/monsters.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/bfs/piggyback.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/bfs/swap.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/bfs/swap/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/bfs/telephone.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/bfs/walls.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/divisibility/commondivisors.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/divisibility/dilucandkaeya.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/divisibility/oraclcm.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/divisibility/powerproducts.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/divisibility/test.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/dsu/closing/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/dsu/moocast/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/dsu/mootube/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/dsu/tractor/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/dsu/tractor/mountain.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/dsu/wormhole/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/introDP/711C.cpp	/^int main()$/;"	f	typeref:typename:int
main	practice/usacoguide/gold/introDP/arraydescription.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/introDP/cannonballs.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/introDP/countingtowers.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/introDP/editdistance.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/introDP/feast.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/introDP/flag.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/introDP/gridpaths.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/introDP/hoofpaperscissors.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/introDP/king2.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/introDP/knight.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/introDP/ladder.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/introDP/learningdp.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/introDP/longestpath.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/introDP/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/introDP/mooney.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/introDP/rabbit.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/introDP/rectanglecutting.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/introDP/slalom.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/introDP/time.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/modular/divisoranalysis.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/modular/exponentiation.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/modular/exponentiation2.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/modular/santasbot.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/gold/modular/test.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/silver/2P/everywhere.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/silver/binsearch/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/silver/binsearch/sabotage.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/silver/greedy/cielduel.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/silver/greedy/party.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/silver/greedy/test.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/silver/idk/lirs/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/silver/idk/maze/main.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/silver/orderedsets/arraydestruction.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
main	practice/usacoguide/silver/orderedsets/coveredpoints.cpp	/^int32_t main() {$/;"	f	typeref:typename:int32_t
mainClass	practice/cf/random/1700/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	s	object:languages.java
mainClass	practice/cf/random/1700/1618E/problem.json	/^{"name": "E. Singers' Tour", "group": "Codeforces - Codeforces Round #760 (Div. 3)", "url": "htt/;"	s	object:languages.java
mainClass	practice/cf/random/coloring/problem.json	/^{"name": "A. Dreamoon Likes Coloring", "group": "Codeforces - Codeforces Round #631 (Div. 1) - T/;"	s	object:languages.java
mainClass	practice/cf/random/diane/problem.json	/^{"name": "D. Diane", "group": "Codeforces - Codeforces Round #735 (Div. 2)", "url": "https:\/\/c/;"	s	object:languages.java
mainClass	practice/cf/random/pink/problem.json	/^{"name": "C. Pinkie Pie Eats Patty-cakes", "group": "Codeforces - Codeforces Round #662 (Div. 2)/;"	s	object:languages.java
mainClass	practice/cf/stuff/dec 20 2021/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	s	object:languages.java
mainClass	practice/usacoguide/gold/SP/dining/problem.json	/^{"name": "Problem 1. Fine Dining", "group": "USACO - USACO 2018 December Contest, Gold", "url": /;"	s	object:languages.java
mainClass	practice/usacoguide/gold/SP/visitfj/problem.json	/^{"name": "Problem 1. Why Did the Cow Cross the Road", "group": "USACO - USACO 2017 February Cont/;"	s	object:languages.java
mainClass	practice/usacoguide/gold/bfs/cownav/problem.json	/^{"name": "Problem 3. Cow Navigation", "group": "USACO - USACO 2017 January Contest, Gold", "url"/;"	s	object:languages.java
mainClass	practice/usacoguide/gold/bfs/swap/problem.json	/^{"name": "Swap Game", "group": "CSES - CSES Problem Set", "url": "https:\/\/cses.fi\/problemset\//;"	s	object:languages.java
mainClass	practice/usacoguide/gold/dsu/closing/problem.json	/^{"name": "Problem 2. Closing the Farm", "group": "USACO - USACO 2016 US Open Contest, Gold", "ur/;"	s	object:languages.java
mainClass	practice/usacoguide/gold/dsu/moocast/problem.json	/^{"name": "Problem 1. Moocast", "group": "USACO - USACO 2016 December Contest, Gold", "url": "htt/;"	s	object:languages.java
mainClass	practice/usacoguide/gold/dsu/mootube/problem.json	/^{"name": "Problem 1. MooTube", "group": "USACO - USACO 2018 January Contest, Gold", "url": "http/;"	s	object:languages.java
mainClass	practice/usacoguide/gold/dsu/tractor/problem.json	/^{"name": "Problem 2. Tractor", "group": "USACO - USACO 2013 February Contest, Silver", "url": "h/;"	s	object:languages.java
mainClass	practice/usacoguide/gold/dsu/wormhole/problem.json	/^{"name": "Problem 3. Wormhole Sort", "group": "USACO - USACO 2020 January Contest, Silver", "url/;"	s	object:languages.java
mainClass	practice/usacoguide/silver/idk/lirs/problem.json	/^{"name": "Problem 3. Liars and Truth Tellers", "group": "USACO - USACO 2013 January Contest, Bro/;"	s	object:languages.java
mainClass	practice/usacoguide/silver/idk/maze/problem.json	/^{"name": "Problem 1. Maze Tac Toe", "group": "USACO - USACO 2021 US Open, Silver", "url": "http:/;"	s	object:languages.java
make_edge	code-library/Geometry/Delaunay Triangulation.cpp	/^Q make_edge(PT orig,  PT dest) {$/;"	f	typeref:typename:Q
make_edge	code-library/Geometry/Voronoi Diagram.cpp	/^Q make_edge(P orig,  P dest) {$/;"	f	typeref:typename:Q
make_edge	code/Geometry/Delaunay Triangulation.cpp	/^Q make_edge(PT orig,  PT dest) {$/;"	f	typeref:typename:Q
make_edge	code/Geometry/Voronoi Diagram.cpp	/^Q make_edge(P orig,  P dest) {$/;"	f	typeref:typename:Q
make_prob	.compilingScripts/download_prob.py	/^def make_prob(data, name):$/;"	f
make_root	code-library/Data Structures/Link Cut Tree.cpp	/^  void make_root(int u) {$/;"	f	struct:LCT	typeref:typename:void	file:
make_root	code-library/Data Structures/Top Tree.cpp	/^  void make_root() {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
make_root	code-library/Graph Theory/Online Articulation Bridges.cpp	/^void make_root (int v) {$/;"	f	typeref:typename:void
make_root	code/Data Structures/Link Cut Tree.cpp	/^  void make_root(int u) {$/;"	f	struct:LCT	typeref:typename:void	file:
make_root	code/Data Structures/Top Tree.cpp	/^  void make_root() {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
make_root	code/Graph Theory/Online Articulation Bridges.cpp	/^void make_root (int v) {$/;"	f	typeref:typename:void
make_unit	code-library/Math/Determinant of Sparse Matrix.cpp	/^  inline void make_unit() {$/;"	f	struct:Mat	typeref:typename:void	file:
make_unit	code-library/Math/Freivalds Algorithm.cpp	/^  inline void make_unit() {$/;"	f	struct:Mat	typeref:typename:void	file:
make_unit	code-library/Math/Matrix Exponentiation.cpp	/^  inline void make_unit() {$/;"	f	struct:Mat	typeref:typename:void	file:
make_unit	code/Math/Determinant of Sparse Matrix.cpp	/^  inline void make_unit() {$/;"	f	struct:Mat	typeref:typename:void	file:
make_unit	code/Math/Freivalds Algorithm.cpp	/^  inline void make_unit() {$/;"	f	struct:Mat	typeref:typename:void	file:
make_unit	code/Math/Matrix Exponentiation.cpp	/^  inline void make_unit() {$/;"	f	struct:Mat	typeref:typename:void	file:
manachers	code-library/Strings/Number of Palindromes in Range.cpp	/^void manachers(string &s) {$/;"	f	typeref:typename:void
manachers	code/Strings/Number of Palindromes in Range.cpp	/^void manachers(string &s) {$/;"	f	typeref:typename:void
mapleader	.compilingScripts/init.vim	/^let mapleader=" "$/;"	v
mapleader	.config/nvim/init.vim	/^let mapleader=" "$/;"	v
mapleader	dotfiles/init.vim	/^let mapleader=" "$/;"	v
mapleader	dotfiles/macinit.vim	/^let mapleader=" "$/;"	v
mark	code-library/Geometry/Delaunay Triangulation.cpp	/^    bool mark; Q o, rot; PT p;$/;"	m	struct:Quad	typeref:typename:bool	file:
mark	code-library/Geometry/Voronoi Diagram.cpp	/^    bool mark; Q o, rot; P p;$/;"	m	struct:Quad	typeref:typename:bool	file:
mark	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  void mark(int x, int v) {$/;"	f	namespace:lct	typeref:typename:void
mark	code/Geometry/Delaunay Triangulation.cpp	/^    bool mark; Q o, rot; PT p;$/;"	m	struct:Quad	typeref:typename:bool	file:
mark	code/Geometry/Voronoi Diagram.cpp	/^    bool mark; Q o, rot; P p;$/;"	m	struct:Quad	typeref:typename:bool	file:
mark	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  void mark(int x, int v) {$/;"	f	namespace:lct	typeref:typename:void
marry	code-library/Graph Theory/Stable Marriage Problem.cpp	/^int m[N][N], w[N][N], id[N], marry[N], ans[N], pref[N][N];$/;"	v	typeref:typename:int[]
marry	code/Graph Theory/Stable Marriage Problem.cpp	/^int m[N][N], w[N][N], id[N], marry[N], ans[N], pref[N][N];$/;"	v	typeref:typename:int[]
mask	code-library/Math/Finite Field Arithmetic Binary.cpp	/^  const int B = 30, mask = (1 << B) - 1;$/;"	v	namespace:FFA	typeref:typename:const int
mask	code/Math/Finite Field Arithmetic Binary.cpp	/^  const int B = 30, mask = (1 << B) - 1;$/;"	v	namespace:FFA	typeref:typename:const int
mat	code-library/Graph Theory/Chinese Postman Problem.cpp	/^  int mat[N], stk[N], id[N], vis[N];$/;"	m	struct:RandomizedMatching	typeref:typename:int[]	file:
mat	code-library/Graph Theory/Randomized Matching Weighted.cpp	/^	int mat[N], stk[N], id[N], vis[N];$/;"	m	struct:RandomizedMatching	typeref:typename:int[]	file:
mat	code-library/Math/Finite Field Arithmetic Binary.cpp	/^string mat[N][N];$/;"	v	typeref:typename:string[][]
mat	code/Graph Theory/Chinese Postman Problem.cpp	/^  int mat[N], stk[N], id[N], vis[N];$/;"	m	struct:RandomizedMatching	typeref:typename:int[]	file:
mat	code/Graph Theory/Randomized Matching Weighted.cpp	/^	int mat[N], stk[N], id[N], vis[N];$/;"	m	struct:RandomizedMatching	typeref:typename:int[]	file:
mat	code/Math/Finite Field Arithmetic Binary.cpp	/^string mat[N][N];$/;"	v	typeref:typename:string[][]
match	code-library/Game Theory/Matching Game On A Graph.cpp	/^  int vis[N], par[N], orig[N], match[N], aux[N], t;$/;"	m	struct:Blossom	typeref:typename:int[]	file:
match	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  int n, n_x, match[N * 2], slack[N * 2], st[N * 2], pa[N * 2], flower_from[N * 2][N * 2], S[N */;"	m	struct:Blossom	typeref:typename:int[]	file:
match	code-library/Graph Theory/Blossom Algorithm.cpp	/^  int vis[N], par[N], orig[N], match[N], aux[N], t;$/;"	m	struct:Blossom	typeref:typename:int[]	file:
match	code-library/Graph Theory/Chinese Postman Problem.cpp	/^  int match[N];$/;"	m	struct:RandomizedMatching	typeref:typename:int[]	file:
match	code-library/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  vector<int> match(vector<int> lab) { \/\/ find perfect matching in MlogM$/;"	f	struct:EdgeColoring	typeref:typename:vector<int>	file:
match	code-library/Graph Theory/Randomized Matching Unweighted.cpp	/^  int n, match[N], vis[N], T = 0;$/;"	m	struct:RandomizedMatching	typeref:typename:int[]	file:
match	code-library/Graph Theory/Randomized Matching Weighted.cpp	/^	int match[N];$/;"	m	struct:RandomizedMatching	typeref:typename:int[]	file:
match	code/Game Theory/Matching Game On A Graph.cpp	/^  int vis[N], par[N], orig[N], match[N], aux[N], t;$/;"	m	struct:Blossom	typeref:typename:int[]	file:
match	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  int n, n_x, match[N * 2], slack[N * 2], st[N * 2], pa[N * 2], flower_from[N * 2][N * 2], S[N */;"	m	struct:Blossom	typeref:typename:int[]	file:
match	code/Graph Theory/Blossom Algorithm.cpp	/^  int vis[N], par[N], orig[N], match[N], aux[N], t;$/;"	m	struct:Blossom	typeref:typename:int[]	file:
match	code/Graph Theory/Chinese Postman Problem.cpp	/^  int match[N];$/;"	m	struct:RandomizedMatching	typeref:typename:int[]	file:
match	code/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  vector<int> match(vector<int> lab) { \/\/ find perfect matching in MlogM$/;"	f	struct:EdgeColoring	typeref:typename:vector<int>	file:
match	code/Graph Theory/Randomized Matching Unweighted.cpp	/^  int n, match[N], vis[N], T = 0;$/;"	m	struct:RandomizedMatching	typeref:typename:int[]	file:
match	code/Graph Theory/Randomized Matching Weighted.cpp	/^	int match[N];$/;"	m	struct:RandomizedMatching	typeref:typename:int[]	file:
matching	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  inline bool matching() {$/;"	f	struct:Blossom	typeref:typename:bool	file:
matching	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  inline bool matching() {$/;"	f	struct:Blossom	typeref:typename:bool	file:
maxSubarrayProduct	practice/cpbook/ch3/DP/00787.cpp	/^int maxSubarrayProduct(vector<int> arr, int n)$/;"	f	typeref:typename:int
max_anticlique	code-library/Graph Theory/Maximum Independant Set.cpp	/^int max_anticlique(int k) {$/;"	f	typeref:typename:int
max_anticlique	code/Graph Theory/Maximum Independant Set.cpp	/^int max_anticlique(int k) {$/;"	f	typeref:typename:int
max_c	code-library/Data Structures/Segment Tree Beats.cpp	/^  ll max_v[4 * N], smax_v[4 * N], max_c[4 * N];$/;"	m	struct:SGTBeats	typeref:typename:ll[]	file:
max_c	code/Data Structures/Segment Tree Beats.cpp	/^  ll max_v[4 * N], smax_v[4 * N], max_c[4 * N];$/;"	m	struct:SGTBeats	typeref:typename:ll[]	file:
max_clique	code-library/Graph Theory/Chordal Graph.cpp	/^int max_clique(int n, vector<int> &ord) {$/;"	f	typeref:typename:int
max_clique	code-library/Graph Theory/Maximum Clique.cpp	/^int max_clique (int n) {$/;"	f	typeref:typename:int
max_clique	code/Graph Theory/Chordal Graph.cpp	/^int max_clique(int n, vector<int> &ord) {$/;"	f	typeref:typename:int
max_clique	code/Graph Theory/Maximum Clique.cpp	/^int max_clique (int n) {$/;"	f	typeref:typename:int
max_flow	code-library/Graph Theory/Dinics Algorithm.cpp	/^  long long max_flow(int _s, int _t) {$/;"	f	struct:Dinic	typeref:typename:long long	file:
max_flow	code-library/Graph Theory/L R Flow with Dinic.cpp	/^  int max_flow(int _s, int _t) { \/\/-1 means flow is not feasible$/;"	f	struct:LR_Flow	typeref:typename:int	file:
max_flow	code-library/Graph Theory/L R Flow with Dinic.cpp	/^  long long max_flow(int _s, int _t) {$/;"	f	struct:Dinic	typeref:typename:long long	file:
max_flow	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  long long max_flow(int _s, int _t) {$/;"	f	struct:Dinic	typeref:typename:long long	file:
max_flow	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^  double max_flow(int _s, int _t) {$/;"	f	struct:Dinic	typeref:typename:double	file:
max_flow	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  flow_t max_flow() {$/;"	f	struct:mcSFlow	typeref:typename:flow_t	file:
max_flow	code-library/Graph Theory/Unique Min Cut.cpp	/^  long long max_flow(int _s, int _t) {$/;"	f	struct:Dinic	typeref:typename:long long	file:
max_flow	code/Graph Theory/Dinics Algorithm.cpp	/^  long long max_flow(int _s, int _t) {$/;"	f	struct:Dinic	typeref:typename:long long	file:
max_flow	code/Graph Theory/L R Flow with Dinic.cpp	/^  int max_flow(int _s, int _t) { \/\/-1 means flow is not feasible$/;"	f	struct:LR_Flow	typeref:typename:int	file:
max_flow	code/Graph Theory/L R Flow with Dinic.cpp	/^  long long max_flow(int _s, int _t) {$/;"	f	struct:Dinic	typeref:typename:long long	file:
max_flow	code/Graph Theory/Maximum Closure Problem.cpp	/^  long long max_flow(int _s, int _t) {$/;"	f	struct:Dinic	typeref:typename:long long	file:
max_flow	code/Graph Theory/Maximum Density Subgraph.cpp	/^  double max_flow(int _s, int _t) {$/;"	f	struct:Dinic	typeref:typename:double	file:
max_flow	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  flow_t max_flow() {$/;"	f	struct:mcSFlow	typeref:typename:flow_t	file:
max_flow	code/Graph Theory/Unique Min Cut.cpp	/^  long long max_flow(int _s, int _t) {$/;"	f	struct:Dinic	typeref:typename:long long	file:
max_v	code-library/Data Structures/Segment Tree Beats.cpp	/^  ll max_v[4 * N], smax_v[4 * N], max_c[4 * N];$/;"	m	struct:SGTBeats	typeref:typename:ll[]	file:
max_v	code/Data Structures/Segment Tree Beats.cpp	/^  ll max_v[4 * N], smax_v[4 * N], max_c[4 * N];$/;"	m	struct:SGTBeats	typeref:typename:ll[]	file:
max_xor	code-library/Math/Basis Vector Reduced Row Echelon Form.cpp	/^  int max_xor(int ans = 0) {$/;"	f	struct:Basis	typeref:typename:int	file:
max_xor	code/Math/Basis Vector Reduced Row Echelon Form.cpp	/^  int max_xor(int ans = 0) {$/;"	f	struct:Basis	typeref:typename:int	file:
max_xor2	code-library/Math/Basis Vector Reduced Row Echelon Form.cpp	/^  int max_xor2(int x = 0) {$/;"	f	struct:Basis	typeref:typename:int	file:
max_xor2	code/Math/Basis Vector Reduced Row Echelon Form.cpp	/^  int max_xor2(int x = 0) {$/;"	f	struct:Basis	typeref:typename:int	file:
maximum_circle_cover	code-library/Geometry/Geometry 2D.cpp	/^double maximum_circle_cover(vector<PT> p, double r, circle &c) {$/;"	f	typeref:typename:double
maximum_circle_cover	code/Geometry/Geometry 2D.cpp	/^double maximum_circle_cover(vector<PT> p, double r, circle &c) {$/;"	f	typeref:typename:double
maximum_dist_from_polygon_to_polygon	code-library/Geometry/Geometry 2D.cpp	/^double maximum_dist_from_polygon_to_polygon(vector<PT> &u, vector<PT> &v){ \/\/O(n)$/;"	f	typeref:typename:double
maximum_dist_from_polygon_to_polygon	code/Geometry/Geometry 2D.cpp	/^double maximum_dist_from_polygon_to_polygon(vector<PT> &u, vector<PT> &v){ \/\/O(n)$/;"	f	typeref:typename:double
maximum_dot_product	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    double maximum_dot_product(Angle c) { \/\/ answer \/ (D * D)$/;"	f	struct:HalfPlaneSet	typeref:typename:double	file:
maximum_dot_product	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    double maximum_dot_product(Angle c) { \/\/ answer \/ (D * D)$/;"	f	struct:HalfPlaneSet	typeref:typename:double	file:
maximum_inscribed_circle	code-library/Geometry/Geometry 2D.cpp	/^double maximum_inscribed_circle(vector<PT> p) {$/;"	f	typeref:typename:double
maximum_inscribed_circle	code/Geometry/Geometry 2D.cpp	/^double maximum_inscribed_circle(vector<PT> p) {$/;"	f	typeref:typename:double
maximum_matching	code-library/Game Theory/Matching Game On A Graph.cpp	/^  int maximum_matching() {$/;"	f	struct:Blossom	typeref:typename:int	file:
maximum_matching	code-library/Graph Theory/Blossom Algorithm.cpp	/^  int maximum_matching() {$/;"	f	struct:Blossom	typeref:typename:int	file:
maximum_matching	code-library/Graph Theory/Chinese Postman Problem.cpp	/^  long long maximum_matching() {$/;"	f	struct:RandomizedMatching	typeref:typename:long long	file:
maximum_matching	code-library/Graph Theory/HopCroft Karp Algorithm.cpp	/^  int maximum_matching() {$/;"	f	struct:HopcroftKarp	typeref:typename:int	file:
maximum_matching	code-library/Graph Theory/Hungarian Algorithm.cpp	/^  long long maximum_matching() {$/;"	f	struct:Hungarian	typeref:typename:long long	file:
maximum_matching	code-library/Graph Theory/Kuhns Algorithm.cpp	/^  int maximum_matching() {$/;"	f	struct:Kuhn	typeref:typename:int	file:
maximum_matching	code-library/Graph Theory/Randomized Matching Unweighted.cpp	/^  int maximum_matching() {$/;"	f	struct:RandomizedMatching	typeref:typename:int	file:
maximum_matching	code-library/Graph Theory/Randomized Matching Weighted.cpp	/^	long long maximum_matching() {$/;"	f	struct:RandomizedMatching	typeref:typename:long long	file:
maximum_matching	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  int maximum_matching() {$/;"	f	struct:Kuhn	typeref:typename:int	file:
maximum_matching	code/Game Theory/Matching Game On A Graph.cpp	/^  int maximum_matching() {$/;"	f	struct:Blossom	typeref:typename:int	file:
maximum_matching	code/Graph Theory/Blossom Algorithm.cpp	/^  int maximum_matching() {$/;"	f	struct:Blossom	typeref:typename:int	file:
maximum_matching	code/Graph Theory/Chinese Postman Problem.cpp	/^  long long maximum_matching() {$/;"	f	struct:RandomizedMatching	typeref:typename:long long	file:
maximum_matching	code/Graph Theory/HopCroft Karp Algorithm.cpp	/^  int maximum_matching() {$/;"	f	struct:HopcroftKarp	typeref:typename:int	file:
maximum_matching	code/Graph Theory/Hungarian Algorithm.cpp	/^  long long maximum_matching() {$/;"	f	struct:Hungarian	typeref:typename:long long	file:
maximum_matching	code/Graph Theory/Kuhns Algorithm.cpp	/^  int maximum_matching() {$/;"	f	struct:Kuhn	typeref:typename:int	file:
maximum_matching	code/Graph Theory/Randomized Matching Unweighted.cpp	/^  int maximum_matching() {$/;"	f	struct:RandomizedMatching	typeref:typename:int	file:
maximum_matching	code/Graph Theory/Randomized Matching Weighted.cpp	/^	long long maximum_matching() {$/;"	f	struct:RandomizedMatching	typeref:typename:long long	file:
maximum_matching	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  int maximum_matching() {$/;"	f	struct:Kuhn	typeref:typename:int	file:
maxn	practice/cpbook/ch1/1.6/reallife/medium/01091/ac.cpp	/^#define maxn /;"	d	file:
maxxor	code-library/Math/Basis Vector.cpp	/^  int maxxor(int x = 0) {$/;"	f	struct:Basis	typeref:typename:int	file:
maxxor	code/Math/Basis Vector.cpp	/^  int maxxor(int x = 0) {$/;"	f	struct:Basis	typeref:typename:int	file:
mcSFlow	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  mcSFlow(int _N, int _S, int _T): eps(0), N(_N), S(_S), T(_T), G(_N) {}$/;"	f	struct:mcSFlow	file:
mcSFlow	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^struct mcSFlow {$/;"	s	file:
mcSFlow	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  mcSFlow(int _N, int _S, int _T): eps(0), N(_N), S(_S), T(_T), G(_N) {}$/;"	f	struct:mcSFlow	file:
mcSFlow	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^struct mcSFlow {$/;"	s	file:
mecho_dist	practice/usacoguide/gold/bfs/mechonew/main.cpp	/^int mecho_dist[mxN][mxN];$/;"	v	typeref:typename:int[][]
meld	code-library/Data Structures/Persistent Meldable Heap.cpp	/^  heap meld(heap b) {$/;"	f	struct:heap	typeref:typename:heap	file:
meld	code-library/Data Structures/Persistent Meldable Heap.cpp	/^  node* meld(node* a, node* b) {$/;"	f	struct:heap	typeref:typename:node *	file:
meld	code-library/Graph Theory/DAG Reachability Dynamic.cpp	/^  void meld(int root, int sub, int u, int v) {$/;"	f	struct:Italiano	typeref:typename:void	file:
meld	code-library/Graph Theory/Eppsteins Algorithm.cpp	/^  heap meld(heap b) {$/;"	f	struct:heap	typeref:typename:heap	file:
meld	code-library/Graph Theory/Eppsteins Algorithm.cpp	/^  node* meld(node* a, node* b) {$/;"	f	struct:heap	typeref:typename:node *	file:
meld	code/Data Structures/Persistent Meldable Heap.cpp	/^  heap meld(heap b) {$/;"	f	struct:heap	typeref:typename:heap	file:
meld	code/Data Structures/Persistent Meldable Heap.cpp	/^  node* meld(node* a, node* b) {$/;"	f	struct:heap	typeref:typename:node *	file:
meld	code/Graph Theory/DAG Reachability Dynamic.cpp	/^  void meld(int root, int sub, int u, int v) {$/;"	f	struct:Italiano	typeref:typename:void	file:
meld	code/Graph Theory/Eppsteins Algorithm.cpp	/^  heap meld(heap b) {$/;"	f	struct:heap	typeref:typename:heap	file:
meld	code/Graph Theory/Eppsteins Algorithm.cpp	/^  node* meld(node* a, node* b) {$/;"	f	struct:heap	typeref:typename:node *	file:
meld_path_end	code-library/Data Structures/Top Tree.cpp	/^  void meld_path_end() {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
meld_path_end	code/Data Structures/Top Tree.cpp	/^  void meld_path_end() {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
memoryLimit	practice/cf/random/1700/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	n
memoryLimit	practice/cf/random/1700/1618E/problem.json	/^{"name": "E. Singers' Tour", "group": "Codeforces - Codeforces Round #760 (Div. 3)", "url": "htt/;"	n
memoryLimit	practice/cf/random/coloring/problem.json	/^{"name": "A. Dreamoon Likes Coloring", "group": "Codeforces - Codeforces Round #631 (Div. 1) - T/;"	n
memoryLimit	practice/cf/random/diane/problem.json	/^{"name": "D. Diane", "group": "Codeforces - Codeforces Round #735 (Div. 2)", "url": "https:\/\/c/;"	n
memoryLimit	practice/cf/random/pink/problem.json	/^{"name": "C. Pinkie Pie Eats Patty-cakes", "group": "Codeforces - Codeforces Round #662 (Div. 2)/;"	n
memoryLimit	practice/cf/stuff/dec 20 2021/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	n
memoryLimit	practice/usacoguide/gold/SP/dining/problem.json	/^{"name": "Problem 1. Fine Dining", "group": "USACO - USACO 2018 December Contest, Gold", "url": /;"	n
memoryLimit	practice/usacoguide/gold/SP/visitfj/problem.json	/^{"name": "Problem 1. Why Did the Cow Cross the Road", "group": "USACO - USACO 2017 February Cont/;"	n
memoryLimit	practice/usacoguide/gold/bfs/cownav/problem.json	/^{"name": "Problem 3. Cow Navigation", "group": "USACO - USACO 2017 January Contest, Gold", "url"/;"	n
memoryLimit	practice/usacoguide/gold/bfs/swap/problem.json	/^{"name": "Swap Game", "group": "CSES - CSES Problem Set", "url": "https:\/\/cses.fi\/problemset\//;"	n
memoryLimit	practice/usacoguide/gold/dsu/closing/problem.json	/^{"name": "Problem 2. Closing the Farm", "group": "USACO - USACO 2016 US Open Contest, Gold", "ur/;"	n
memoryLimit	practice/usacoguide/gold/dsu/moocast/problem.json	/^{"name": "Problem 1. Moocast", "group": "USACO - USACO 2016 December Contest, Gold", "url": "htt/;"	n
memoryLimit	practice/usacoguide/gold/dsu/mootube/problem.json	/^{"name": "Problem 1. MooTube", "group": "USACO - USACO 2018 January Contest, Gold", "url": "http/;"	n
memoryLimit	practice/usacoguide/gold/dsu/tractor/problem.json	/^{"name": "Problem 2. Tractor", "group": "USACO - USACO 2013 February Contest, Silver", "url": "h/;"	n
memoryLimit	practice/usacoguide/gold/dsu/wormhole/problem.json	/^{"name": "Problem 3. Wormhole Sort", "group": "USACO - USACO 2020 January Contest, Silver", "url/;"	n
memoryLimit	practice/usacoguide/silver/idk/lirs/problem.json	/^{"name": "Problem 3. Liars and Truth Tellers", "group": "USACO - USACO 2013 January Contest, Bro/;"	n
memoryLimit	practice/usacoguide/silver/idk/maze/problem.json	/^{"name": "Problem 1. Maze Tac Toe", "group": "USACO - USACO 2021 US Open, Silver", "url": "http:/;"	n
merge	code-library/Data Structures/Augmented DSU.cpp	/^void merge(int a, int b, int d) {$/;"	f	typeref:typename:void
merge	code-library/Data Structures/DSU Partially Persistent.cpp	/^  bool merge(int u, int v) {$/;"	f	struct:DSU	typeref:typename:bool	file:
merge	code-library/Data Structures/DSU with Rollbacks.cpp	/^  bool merge(int u, int v) {$/;"	f	struct:DSU	typeref:typename:bool	file:
merge	code-library/Data Structures/DSU.cpp	/^  int merge(int i, int j) {$/;"	f	struct:DSU	typeref:typename:int	file:
merge	code-library/Data Structures/Implicit Treap.cpp	/^  void merge(pnode &t, pnode l, pnode r) {$/;"	f	struct:treap	typeref:typename:void	file:
merge	code-library/Data Structures/Persistent UnionFind.cpp	/^  int merge(int r, int u, int v) { \/\/ returns the updated root$/;"	f	struct:PersistentDSU	typeref:typename:int	file:
merge	code-library/Data Structures/Queue Undo Trick.cpp	/^  bool merge(int u, int v) {$/;"	f	struct:DSU	typeref:typename:bool	file:
merge	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  node* merge(node *l, node *r) {$/;"	f	struct:treap	typeref:typename:node *	file:
merge	code-library/Data Structures/Segment Tree Merging.cpp	/^  int merge(int a, int b) {$/;"	f	struct:STM	typeref:typename:int	file:
merge	code-library/Data Structures/Segment Tree Merging.cpp	/^void merge(int a, int b) {$/;"	f	typeref:typename:void
merge	code-library/Data Structures/Treap persistent.cpp	/^node* merge(node *l, node *r) {$/;"	f	namespace:PersistentTreap	typeref:typename:node *
merge	code-library/Data Structures/Treap.cpp	/^  node* merge(node *l, node *r) {$/;"	f	struct:treap	typeref:typename:node *	file:
merge	code-library/Data Structures/Venice Technique.cpp	/^  void merge(PQ &&x) {$/;"	f	struct:PQ	typeref:typename:void	file:
merge	code-library/Graph Theory/Boruvka's Algorithm.cpp	/^  int merge(int i, int j) {$/;"	f	struct:dsu	typeref:typename:int	file:
merge	code-library/Graph Theory/Directed MST.cpp	/^  void merge(PQ &&x) {$/;"	f	struct:PQ	typeref:typename:void	file:
merge	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  int merge(int i, int j) {$/;"	f	struct:dsu	typeref:typename:int	file:
merge	code-library/Graph Theory/Kirchoffs Theorem.cpp	/^  int merge(int i, int j) {$/;"	f	struct:dsu	typeref:typename:int	file:
merge	code-library/Graph Theory/Krushkal's MST.cpp	/^  int merge(int i, int j) {$/;"	f	struct:dsu	typeref:typename:int	file:
merge	code-library/Graph Theory/Manhattan MST.cpp	/^  void merge(int u, int v) { p[find(u)] = find(v); }$/;"	f	struct:DSU	typeref:typename:void	file:
merge	code-library/Graph Theory/Path Union.cpp	/^pair<int, int> merge(pair<int, int> x, pair<int, int> y) {$/;"	f	typeref:typename:pair<int,int>
merge	code/Data Structures/Augmented DSU.cpp	/^void merge(int a, int b, int d) {$/;"	f	typeref:typename:void
merge	code/Data Structures/DSU Partially Persistent.cpp	/^  bool merge(int u, int v) {$/;"	f	struct:DSU	typeref:typename:bool	file:
merge	code/Data Structures/DSU with Rollbacks.cpp	/^  bool merge(int u, int v) {$/;"	f	struct:DSU	typeref:typename:bool	file:
merge	code/Data Structures/DSU.cpp	/^  int merge(int i, int j) {$/;"	f	struct:DSU	typeref:typename:int	file:
merge	code/Data Structures/Implicit Treap.cpp	/^  void merge(pnode &t, pnode l, pnode r) {$/;"	f	struct:treap	typeref:typename:void	file:
merge	code/Data Structures/Persistent UnionFind.cpp	/^  int merge(int r, int u, int v) { \/\/ returns the updated root$/;"	f	struct:PersistentDSU	typeref:typename:int	file:
merge	code/Data Structures/Queue Undo Trick.cpp	/^  bool merge(int u, int v) {$/;"	f	struct:DSU	typeref:typename:bool	file:
merge	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  node* merge(node *l, node *r) {$/;"	f	struct:treap	typeref:typename:node *	file:
merge	code/Data Structures/Segment Tree Merging.cpp	/^  int merge(int a, int b) {$/;"	f	struct:STM	typeref:typename:int	file:
merge	code/Data Structures/Segment Tree Merging.cpp	/^void merge(int a, int b) {$/;"	f	typeref:typename:void
merge	code/Data Structures/Treap persistent.cpp	/^node* merge(node *l, node *r) {$/;"	f	namespace:PersistentTreap	typeref:typename:node *
merge	code/Data Structures/Treap.cpp	/^  node* merge(node *l, node *r) {$/;"	f	struct:treap	typeref:typename:node *	file:
merge	code/Data Structures/Venice Technique.cpp	/^  void merge(PQ &&x) {$/;"	f	struct:PQ	typeref:typename:void	file:
merge	code/Graph Theory/Boruvka's Algorithm.cpp	/^  int merge(int i, int j) {$/;"	f	struct:dsu	typeref:typename:int	file:
merge	code/Graph Theory/Directed MST.cpp	/^  void merge(PQ &&x) {$/;"	f	struct:PQ	typeref:typename:void	file:
merge	code/Graph Theory/Gomory Hu Tree.cpp	/^  int merge(int i, int j) {$/;"	f	struct:dsu	typeref:typename:int	file:
merge	code/Graph Theory/Kirchoffs Theorem.cpp	/^  int merge(int i, int j) {$/;"	f	struct:dsu	typeref:typename:int	file:
merge	code/Graph Theory/Krushkal's MST.cpp	/^  int merge(int i, int j) {$/;"	f	struct:dsu	typeref:typename:int	file:
merge	code/Graph Theory/Manhattan MST.cpp	/^  void merge(int u, int v) { p[find(u)] = find(v); }$/;"	f	struct:DSU	typeref:typename:void	file:
merge	code/Graph Theory/Path Union.cpp	/^pair<int, int> merge(pair<int, int> x, pair<int, int> y) {$/;"	f	typeref:typename:pair<int,int>
merge_path	code-library/Graph Theory/Online Articulation Bridges.cpp	/^void merge_path (int a, int b) {$/;"	f	typeref:typename:void
merge_path	code/Graph Theory/Online Articulation Bridges.cpp	/^void merge_path (int a, int b) {$/;"	f	typeref:typename:void
merge_treap	code-library/Data Structures/Treap.cpp	/^  node* merge_treap(node *l, node *r) {$/;"	f	struct:treap	typeref:typename:node *	file:
merge_treap	code/Data Structures/Treap.cpp	/^  node* merge_treap(node *l, node *r) {$/;"	f	struct:treap	typeref:typename:node *	file:
mexp	code/modint.hpp	/^    friend Mint mexp(Mint a, long long e) {$/;"	f	typeref:typename:Mint
mexp	practice/december2021/DP/counting_towers/sol.cpp	/^    friend Modular mexp(Modular a, long long e) {$/;"	f	typeref:typename:Modular	file:
mi	practice/cf/random/1700/6.cpp	/^	mi() { v = 0; }$/;"	f	struct:mi	file:
mi	practice/cf/random/1700/6.cpp	/^	mi(long long _v) : v(_v % MOD) { v += (v < 0) * MOD; }$/;"	f	struct:mi	file:
mi	practice/cf/random/1700/6.cpp	/^struct mi {$/;"	s	file:
mi	practice/cf/random/i_hate_math_problems/1422C.cpp	/^	mi():v(0) {}$/;"	f	struct:mi	file:
mi	practice/cf/random/i_hate_math_problems/1422C.cpp	/^	mi(ll _v):v(int(_v%MOD)) { v += (v<0)*MOD; }$/;"	f	struct:mi	file:
mi	practice/cf/random/i_hate_math_problems/1422C.cpp	/^struct mi { \/\/ WARNING: needs some adjustment to work with FFT$/;"	s	file:
mi	practice/usacoguide/gold/introDP/arraydescription.cpp	/^	mi():v(0) {}$/;"	f	struct:mi	file:
mi	practice/usacoguide/gold/introDP/arraydescription.cpp	/^	mi(ll _v):v(int(_v%MOD)) { v += (v<0)*MOD; }$/;"	f	struct:mi	file:
mi	practice/usacoguide/gold/introDP/arraydescription.cpp	/^struct mi { \/\/ WARNING: needs some adjustment to work with FFT$/;"	s	file:
mid	code-library/Dynamic Programming Optimizations/Knuth Optimization.cpp	/^int a[N], mid[N][N];$/;"	v	typeref:typename:int[][]
mid	code-library/Miscellaneous/Parallel Binary Search.cpp	/^vector<int> mid[N];$/;"	v	typeref:typename:vector<int>[]
mid	code/Dynamic Programming Optimizations/Knuth Optimization.cpp	/^int a[N], mid[N][N];$/;"	v	typeref:typename:int[][]
mid	code/Miscellaneous/Parallel Binary Search.cpp	/^vector<int> mid[N];$/;"	v	typeref:typename:vector<int>[]
middle_product	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly middle_product(const poly& g) const {$/;"	f	class:poly	typeref:typename:poly	file:
middle_product	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly middle_product(const poly& g) const {$/;"	f	class:poly	typeref:typename:poly	file:
mii	contests/Codeforces/737/D.cpp	/^#define mii /;"	d	file:
mii	contests/Codeforces/737/E.cpp	/^#define mii /;"	d	file:
miller_rabin	code-library/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^  inline bool miller_rabin(ll n) {$/;"	f	namespace:PollardRho	typeref:typename:bool
miller_rabin	code-library/Number Theory/Pisano Period.cpp	/^  inline bool miller_rabin(ll n) {$/;"	f	namespace:PollardRho	typeref:typename:bool
miller_rabin	code-library/Number Theory/Pollard Rho.cpp	/^  inline bool miller_rabin(ll n) {$/;"	f	namespace:PollardRho	typeref:typename:bool
miller_rabin	code/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^  inline bool miller_rabin(ll n) {$/;"	f	namespace:PollardRho	typeref:typename:bool
miller_rabin	code/Number Theory/Pisano Period.cpp	/^  inline bool miller_rabin(ll n) {$/;"	f	namespace:PollardRho	typeref:typename:bool
miller_rabin	code/Number Theory/Pollard Rho.cpp	/^  inline bool miller_rabin(ll n) {$/;"	f	namespace:PollardRho	typeref:typename:bool
minCostMaxFlow	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  pair<flow_t, cost_t> minCostMaxFlow() {$/;"	f	struct:mcSFlow	typeref:typename:pair<flow_t,cost_t>	file:
minCostMaxFlow	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  pair<flow_t, cost_t> minCostMaxFlow() {$/;"	f	struct:mcSFlow	typeref:typename:pair<flow_t,cost_t>	file:
min_c	code-library/Data Structures/Segment Tree Beats.cpp	/^  ll min_v[4 * N], smin_v[4 * N], min_c[4 * N];$/;"	m	struct:SGTBeats	typeref:typename:ll[]	file:
min_c	code/Data Structures/Segment Tree Beats.cpp	/^  ll min_v[4 * N], smin_v[4 * N], min_c[4 * N];$/;"	m	struct:SGTBeats	typeref:typename:ll[]	file:
min_flow	code-library/Graph Theory/L R Flow with Dinic.cpp	/^  int min_flow(int _s, int _t) { \/\/-1 means flow is not feasible$/;"	f	struct:LR_Flow	typeref:typename:int	file:
min_flow	code/Graph Theory/L R Flow with Dinic.cpp	/^  int min_flow(int _s, int _t) { \/\/-1 means flow is not feasible$/;"	f	struct:LR_Flow	typeref:typename:int	file:
min_v	code-library/Data Structures/Segment Tree Beats.cpp	/^  ll min_v[4 * N], smin_v[4 * N], min_c[4 * N];$/;"	m	struct:SGTBeats	typeref:typename:ll[]	file:
min_v	code/Data Structures/Segment Tree Beats.cpp	/^  ll min_v[4 * N], smin_v[4 * N], min_c[4 * N];$/;"	m	struct:SGTBeats	typeref:typename:ll[]	file:
minimumChanges	contests/Codeforces/1616/C/soll.cpp	/^int minimumChanges(vector<int> arr, int n, int d)$/;"	f	typeref:typename:int
minimum_enclosing_circle	code-library/Geometry/Geometry 2D.cpp	/^circle minimum_enclosing_circle(vector<PT> &p) {$/;"	f	typeref:typename:circle
minimum_enclosing_circle	code/Geometry/Geometry 2D.cpp	/^circle minimum_enclosing_circle(vector<PT> &p) {$/;"	f	typeref:typename:circle
minimum_enclosing_rectangle	code-library/Geometry/Geometry 2D.cpp	/^double minimum_enclosing_rectangle(vector<PT> &p) {$/;"	f	typeref:typename:double
minimum_enclosing_rectangle	code/Geometry/Geometry 2D.cpp	/^double minimum_enclosing_rectangle(vector<PT> &p) {$/;"	f	typeref:typename:double
minimum_partition	code-library/Strings/Palindromic Tree.cpp	/^  vector<array<int, 2>> minimum_partition() { \/\/(even, odd), 1 indexed$/;"	f	struct:PalindromicTree	typeref:typename:vector<array<int,2>>	file:
minimum_partition	code/Strings/Palindromic Tree.cpp	/^  vector<array<int, 2>> minimum_partition() { \/\/(even, odd), 1 indexed$/;"	f	struct:PalindromicTree	typeref:typename:vector<array<int,2>>	file:
minkowski_sum	code-library/Geometry/Geometry 2D.cpp	/^vector<PT> minkowski_sum(vector<PT> &a, vector<PT> &b) {$/;"	f	typeref:typename:vector<PT>
minkowski_sum	code/Geometry/Geometry 2D.cpp	/^vector<PT> minkowski_sum(vector<PT> &a, vector<PT> &b) {$/;"	f	typeref:typename:vector<PT>
minmax_flag	code-library/Math/Simplex Algorithm.cpp	/^  int m, n, solution_flag, minmax_flag, basis[MAXC], index[MAXV];$/;"	v	namespace:lp	typeref:typename:int
minmax_flag	code/Math/Simplex Algorithm.cpp	/^  int m, n, solution_flag, minmax_flag, basis[MAXC], index[MAXV];$/;"	v	namespace:lp	typeref:typename:int
mint	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Graph Theory/Number of Arborescence.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Graph Theory/Number of DAG.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Graph Theory/Tree Isomorphism.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Math/BerleKamp Massey.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Math/Characteristic Polynomial Faster.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Math/Determinant of Sparse Matrix.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Math/FWHT in Ternary Base.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Math/Faulhaber Formula Fastest.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Math/Hafnian of a Matrix.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Math/Lagrange Interpolation Brute.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Math/Lagrange Interpolation.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Math/Linear Recurrence.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Math/Polynomial Sum.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Math/Polynomial.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Math/Subset Sum Problem.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Math/The Slime Trick.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Math/Thomas Algorithm.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Math/Vandermonde Matrix.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Number Theory/Bell Number.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Number Theory/Combinatorics Basics.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Number Theory/Dirichlet Convolution.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Number Theory/Lucas Theorem.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Number Theory/Min_25 Sieve.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Number Theory/Partition Function.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Number Theory/Phi Field.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Graph Theory/Chromatic Polynoimial.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Graph Theory/Counting Labeled Graphs.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Graph Theory/Hafnian of a Matrix.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Graph Theory/Number of Arborescence.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Graph Theory/Number of DAG.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Graph Theory/Tree Isomorphism.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Math/BerleKamp Massey.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Math/Characteristic Polynomial Faster.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Math/Determinant of Sparse Matrix.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Math/FWHT in Ternary Base.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Math/Faulhaber Formula Fastest.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Math/Generating Function of a Linear Recurrence.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Math/Hafnian of a Matrix.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Math/Lagrange Interpolation Brute.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Math/Lagrange Interpolation.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Math/Linear Recurrence.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Math/Number of Solutions of A Equation MITM.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Math/Polynomial Sum.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Math/Polynomial.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Math/Subset Sum Problem.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Math/The Slime Trick.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Math/Thomas Algorithm.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Math/Vandermonde Matrix.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Number Theory/Bell Number.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Number Theory/Combinatorics Basics.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Number Theory/Dirichlet Convolution.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Number Theory/Lucas Theorem.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Number Theory/Min_25 Sieve.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Number Theory/Partition Function.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Number Theory/Phi Field.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
mint	practice/cf/random/i_hate_math_problems/testing.cpp	/^using mint = modint<mod>;$/;"	t	typeref:typename:modint<mod>	file:
minxor	code-library/Graph Theory/Boruvka's Algorithm.cpp	/^int minxor(int x) {$/;"	f	typeref:typename:int
minxor	code-library/Math/Basis Vector.cpp	/^  int minxor(int x = 0) {$/;"	f	struct:Basis	typeref:typename:int	file:
minxor	code/Graph Theory/Boruvka's Algorithm.cpp	/^int minxor(int x) {$/;"	f	typeref:typename:int
minxor	code/Math/Basis Vector.cpp	/^  int minxor(int x = 0) {$/;"	f	struct:Basis	typeref:typename:int	file:
mit	practice/usacoguide/gold/introDP/711C.cpp	/^typedef map<int,int>::iterator mit;$/;"	t	typeref:typename:map<int,int>::iterator	file:
mn	code-library/Data Structures/Implicit Treap.cpp	/^    int val, sz, prior, lazy, sum, mx, mn, repl;$/;"	m	struct:treap::node	typeref:typename:int	file:
mn	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  int pos, key, mn, mx;$/;"	m	struct:node	typeref:typename:int	file:
mn	code/Data Structures/Implicit Treap.cpp	/^    int val, sz, prior, lazy, sum, mx, mn, repl;$/;"	m	struct:treap::node	typeref:typename:int	file:
mn	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  int pos, key, mn, mx;$/;"	m	struct:node	typeref:typename:int	file:
mn_deg	code-library/Graph Theory/Maximum Independant Set.cpp	/^int mn_deg, comp_size;$/;"	v	typeref:typename:int
mn_deg	code/Graph Theory/Maximum Independant Set.cpp	/^int mn_deg, comp_size;$/;"	v	typeref:typename:int
mob	code-library/Number Theory/Mobius Function.cpp	/^int mob[N];$/;"	v	typeref:typename:int[]
mob	code/Number Theory/Mobius Function.cpp	/^int mob[N];$/;"	v	typeref:typename:int[]
mobius	code-library/Number Theory/Mobius Function.cpp	/^void mobius() {$/;"	f	typeref:typename:void
mobius	code/Number Theory/Mobius Function.cpp	/^void mobius() {$/;"	f	typeref:typename:void
mobius_transform	code-library/Dynamic Programming Optimizations/SOS convolutions.cpp	/^vector<int> mobius_transform(vector<int> f) {$/;"	f	namespace:SOS	typeref:typename:vector<int>
mobius_transform	code/Dynamic Programming Optimizations/SOS convolutions.cpp	/^vector<int> mobius_transform(vector<int> f) {$/;"	f	namespace:SOS	typeref:typename:vector<int>
mod	code-library/Data Structures/Cartesian Tree.cpp	/^const int N = 1e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Data Structures/Disjoint Sparse Table.cpp	/^int mod = 1e9 + 7;$/;"	v	typeref:typename:int
mod	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^const int N = 1e5 + 9, mod = 1e9 + 9;$/;"	v	typeref:typename:const int
mod	code-library/Data Structures/Implicit Treap.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Data Structures/Interval Set.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^const int N = 1e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^const int N = 1010, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Dynamic Programming Optimizations/Connected Component DP.cpp	/^const int N = 105, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Dynamic Programming Optimizations/DP Over Divisors.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Dynamic Programming Optimizations/Digit DP.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Dynamic Programming Optimizations/Number of Subsequences Having Product at least K.cpp	/^const int N = 1010, mod = 1e9 + 7, SQ = sqrt(mod) + 1;$/;"	v	typeref:typename:const int
mod	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Dynamic Programming Optimizations/SOS convolutions.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code-library/Dynamic Programming Optimizations/XOR Equation.cpp	/^const int N = 55, mod = 1000000003;$/;"	v	typeref:typename:const int
mod	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^const int N = 303, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Graph Theory/Dijkstra.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code-library/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^const int mod = 998244353;$/;"	v	typeref:typename:const int
mod	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code-library/Graph Theory/Kirchoffs Theorem.cpp	/^const int N = 205, mod = 1000210433;$/;"	v	typeref:typename:const int
mod	code-library/Graph Theory/Krushkal's MST.cpp	/^const int N = 3e5 + 9, mod = 1e9;$/;"	v	typeref:typename:const int
mod	code-library/Graph Theory/Number of Arborescence.cpp	/^const int N = 1e3 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Graph Theory/Number of DAG.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code-library/Graph Theory/Tree Isomorphism.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 97;$/;"	v	typeref:typename:const int
mod	code-library/Math/BerleKamp Massey.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Math/Characteristic Polynomial Faster.cpp	/^const int N = 505, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code-library/Math/Determinant of Product Matrix.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Math/Determinant of Sparse Matrix.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code-library/Math/Determinant under Prime Modulo.cpp	/^const int N = 105, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code-library/Math/FWHT in Any Base.cpp	/^const int N = 1e5 + 9, mod = 330301441;$/;"	v	typeref:typename:const int
mod	code-library/Math/FWHT in Ternary Base.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Math/FWHT.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Math/Faulhaber Formula Fastest.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Math/Freivalds Algorithm.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Math/Gaussian Elimination Modular.cpp	/^const int N = 105, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^const int N = 3e3 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code-library/Math/Hafnian of a Matrix.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code-library/Math/Inverse of A Matrix.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Math/Lagrange Interpolation Brute.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^const int N = 1e6 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Math/Lagrange Interpolation.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Math/Linear Recurrence Fastest.cpp	/^const int N = 3e5 + 9, mod = 104857601;$/;"	v	typeref:typename:const int
mod	code-library/Math/Linear Recurrence.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Math/Matrix Exponentiation.cpp	/^const int mod = 998244353;$/;"	v	typeref:typename:const int
mod	code-library/Math/NTT Online.cpp	/^const int N = 1e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Math/NTT With Any Prime MOD.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code-library/Math/NTT.cpp	/^const int mod = 998244353;$/;"	v	typeref:typename:const int
mod	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Math/Polynomial Sum.cpp	/^const int N = 1e7 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code-library/Math/Polynomial with Binomial Coefficients.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code-library/Math/Polynomial.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code-library/Math/Reeds Sloane Algorithm.cpp	/^  ll mod;$/;"	m	struct:LinearRecurrence	typeref:typename:ll	file:
mod	code-library/Math/Simplex Algorithm.cpp	/^const int mod=1e9+7;$/;"	v	typeref:typename:const int
mod	code-library/Math/Subset Sum Problem.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code-library/Math/The Slime Trick.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code-library/Math/Thomas Algorithm.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code-library/Math/Vandermonde Matrix.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Miscellaneous/XOR Equation Arbitrary Range.cpp	/^const int N = 55, mod = 1000000003;$/;"	v	typeref:typename:const int
mod	code-library/Number Theory/Bell Number.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Number Theory/Combinatorics Basics.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Number Theory/Dirichlet Convolution.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^const int N = 25, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Number Theory/LCM of Fibonacci Numbers.cpp	/^const int N = 3e5 + 9, mod= 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Number Theory/Lucas Theorem.cpp	/^const int N = 1e6 + 3, mod = 1e6 + 3;$/;"	v	typeref:typename:const int
mod	code-library/Number Theory/Min_25 Sieve.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^const int N = 1e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Number Theory/Partition Function.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Number Theory/Phi Field.cpp	/^const int mod = 998244353;$/;"	v	typeref:typename:const int
mod	code-library/Number Theory/Pisano Period.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^const int N = 1e5 + 9, B = 330, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Number Theory/Prime Factorization Fastest.cpp	/^  static uint64_t mod, inv, r2;$/;"	m	struct:Mint	typeref:typename:uint64_t	file:
mod	code-library/Number Theory/Prime Factorization Fastest.cpp	/^uint64_t Mint::mod, Mint::inv, Mint::r2;$/;"	m	class:Mint	typeref:typename:uint64_t
mod	code-library/Number Theory/Prime Number System.cpp	/^const int N = 1e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Number Theory/Smallest Nonnegative Integer x s.t. l <= ax % p <= r.cpp	/^const int N = 1e9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Number Theory/Smallest Number Having Exactly K Divisors.cpp	/^const int N = 1e6 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^const int mod = 998244353;$/;"	v	typeref:typename:const int
mod	code-library/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^const int mod = 998244353;$/;"	v	typeref:typename:const int
mod	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^const int mod = 998244353;$/;"	v	typeref:typename:const int
mod	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^const int N = 25, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^const int N = 2e5 + 9, mod = 924844033;$/;"	v	typeref:typename:const int
mod	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static R mod;$/;"	m	class:poly	typeref:typename:R	file:
mod	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^R poly::mod;$/;"	m	class:poly	typeref:typename:R
mod	code-library/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^const int mod = 998244353;$/;"	v	typeref:typename:const int
mod	code-library/Strings/Prefix Automaton.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code-library/Strings/String Hashing 2D.cpp	/^  static const int PX = 3731,  PY = 2999, mod = 998244353;$/;"	m	struct:Hashing	typeref:typename:const int	file:
mod	code-library/Strings/String Matching With FFT.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Data Structures/Cartesian Tree.cpp	/^const int N = 1e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Data Structures/Disjoint Sparse Table.cpp	/^int mod = 1e9 + 7;$/;"	v	typeref:typename:int
mod	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^const int N = 1e5 + 9, mod = 1e9 + 9;$/;"	v	typeref:typename:const int
mod	code/Data Structures/Implicit Treap.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Data Structures/Interval Set.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^const int N = 1e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^const int N = 1010, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Dynamic Programming Optimizations/Connected Component DP.cpp	/^const int N = 105, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Dynamic Programming Optimizations/DP Over Divisors.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Dynamic Programming Optimizations/Digit DP.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Dynamic Programming Optimizations/Number of Subsequences Having Product at least K.cpp	/^const int N = 1010, mod = 1e9 + 7, SQ = sqrt(mod) + 1;$/;"	v	typeref:typename:const int
mod	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Dynamic Programming Optimizations/SOS convolutions.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code/Dynamic Programming Optimizations/XOR Equation.cpp	/^const int N = 55, mod = 1000000003;$/;"	v	typeref:typename:const int
mod	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^const int N = 303, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Graph Theory/Chromatic Polynoimial.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code/Graph Theory/Counting Labeled Graphs.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Graph Theory/Dijkstra.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^const int mod = 998244353;$/;"	v	typeref:typename:const int
mod	code/Graph Theory/Hafnian of a Matrix.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code/Graph Theory/Kirchoffs Theorem.cpp	/^const int N = 205, mod = 1000210433;$/;"	v	typeref:typename:const int
mod	code/Graph Theory/Krushkal's MST.cpp	/^const int N = 3e5 + 9, mod = 1e9;$/;"	v	typeref:typename:const int
mod	code/Graph Theory/Number of Arborescence.cpp	/^const int N = 1e3 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Graph Theory/Number of DAG.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code/Graph Theory/Tree Isomorphism.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 97;$/;"	v	typeref:typename:const int
mod	code/Math/BerleKamp Massey.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Math/Characteristic Polynomial Faster.cpp	/^const int N = 505, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code/Math/Determinant of Product Matrix.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Math/Determinant of Sparse Matrix.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code/Math/Determinant under Prime Modulo.cpp	/^const int N = 105, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code/Math/FWHT in Any Base.cpp	/^const int N = 1e5 + 9, mod = 330301441;$/;"	v	typeref:typename:const int
mod	code/Math/FWHT in Ternary Base.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Math/FWHT.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Math/Faulhaber Formula Fastest.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Math/Freivalds Algorithm.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Math/Gaussian Elimination Modular.cpp	/^const int N = 105, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Math/Generating Function of a Linear Recurrence.cpp	/^const int N = 3e3 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code/Math/Hafnian of a Matrix.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code/Math/Inverse of A Matrix.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Math/Lagrange Interpolation Brute.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^const int N = 1e6 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Math/Lagrange Interpolation.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Math/Linear Recurrence Fastest.cpp	/^const int N = 3e5 + 9, mod = 104857601;$/;"	v	typeref:typename:const int
mod	code/Math/Linear Recurrence.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Math/Matrix Exponentiation.cpp	/^const int mod = 998244353;$/;"	v	typeref:typename:const int
mod	code/Math/NTT Online.cpp	/^const int N = 1e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Math/NTT With Any Prime MOD.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code/Math/NTT.cpp	/^const int mod = 998244353;$/;"	v	typeref:typename:const int
mod	code/Math/Number of Solutions of A Equation MITM.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Math/Polynomial Sum.cpp	/^const int N = 1e7 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code/Math/Polynomial with Binomial Coefficients.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code/Math/Polynomial.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code/Math/Reeds Sloane Algorithm.cpp	/^  ll mod;$/;"	m	struct:LinearRecurrence	typeref:typename:ll	file:
mod	code/Math/Simplex Algorithm.cpp	/^const int mod=1e9+7;$/;"	v	typeref:typename:const int
mod	code/Math/Subset Sum Problem.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code/Math/The Slime Trick.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code/Math/Thomas Algorithm.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code/Math/Vandermonde Matrix.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Miscellaneous/XOR Equation Arbitrary Range.cpp	/^const int N = 55, mod = 1000000003;$/;"	v	typeref:typename:const int
mod	code/Number Theory/Bell Number.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Number Theory/Combinatorics Basics.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Number Theory/Dirichlet Convolution.cpp	/^const int N = 3e5 + 9, mod = 998244353;$/;"	v	typeref:typename:const int
mod	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^const int N = 25, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Number Theory/LCM of Fibonacci Numbers.cpp	/^const int N = 3e5 + 9, mod= 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Number Theory/Lucas Theorem.cpp	/^const int N = 1e6 + 3, mod = 1e6 + 3;$/;"	v	typeref:typename:const int
mod	code/Number Theory/Min_25 Sieve.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^const int N = 1e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Number Theory/Partition Function.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Number Theory/Phi Field.cpp	/^const int mod = 998244353;$/;"	v	typeref:typename:const int
mod	code/Number Theory/Pisano Period.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^const int N = 1e5 + 9, B = 330, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Number Theory/Prime Factorization Fastest.cpp	/^  static uint64_t mod, inv, r2;$/;"	m	struct:Mint	typeref:typename:uint64_t	file:
mod	code/Number Theory/Prime Factorization Fastest.cpp	/^uint64_t Mint::mod, Mint::inv, Mint::r2;$/;"	m	class:Mint	typeref:typename:uint64_t
mod	code/Number Theory/Prime Number System.cpp	/^const int N = 1e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Number Theory/Smallest Nonnegative Integer x s.t. l <= ax % p <= r.cpp	/^const int N = 1e9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Number Theory/Smallest Number Having Exactly K Divisors.cpp	/^const int N = 1e6 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^const int mod = 998244353;$/;"	v	typeref:typename:const int
mod	code/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^const int mod = 998244353;$/;"	v	typeref:typename:const int
mod	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^const int N = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^const int mod = 998244353;$/;"	v	typeref:typename:const int
mod	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^const int N = 25, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^const int N = 2e5 + 9, mod = 924844033;$/;"	v	typeref:typename:const int
mod	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static R mod;$/;"	m	class:poly	typeref:typename:R	file:
mod	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^R poly::mod;$/;"	m	class:poly	typeref:typename:R
mod	code/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^const int mod = 998244353;$/;"	v	typeref:typename:const int
mod	code/Strings/Prefix Automaton.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	code/Strings/String Hashing 2D.cpp	/^  static const int PX = 3731,  PY = 2999, mod = 998244353;$/;"	m	struct:Hashing	typeref:typename:const int	file:
mod	code/Strings/String Matching With FFT.cpp	/^const int mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	contests/Codeforces/737/D.cpp	/^lli mod=1e9+9;$/;"	v	typeref:typename:lli
mod	contests/Codeforces/737/E.cpp	/^lli mod=1e9+9;$/;"	v	typeref:typename:lli
mod	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^const int mxN = 5e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod	practice/cf/random/i_hate_math_problems/testing.cpp	/^const int mxN = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mod_count	code-library/Number Theory/Number of ax%p in a Range.cpp	/^ll mod_count(ll a, ll m, ll c, ll n) {$/;"	f	typeref:typename:ll
mod_count	code/Number Theory/Number of ax%p in a Range.cpp	/^ll mod_count(ll a, ll m, ll c, ll n) {$/;"	f	typeref:typename:ll
mod_count_range	code-library/Number Theory/Number of ax%p in a Range.cpp	/^ll mod_count_range(ll a, ll m, ll clo, ll chi, ll nlo, ll nhi) {$/;"	f	typeref:typename:ll
mod_count_range	code/Number Theory/Number of ax%p in a Range.cpp	/^ll mod_count_range(ll a, ll m, ll clo, ll chi, ll nlo, ll nhi) {$/;"	f	typeref:typename:ll
mod_inv	code-library/Math/Linear Recurrence With Polynomial Coefficients.cpp	/^int mod_inv(int a, int mod) {$/;"	f	typeref:typename:int
mod_inv	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static R mod_inv(R a) {$/;"	f	class:poly	typeref:typename:R	file:
mod_inv	code/Math/Linear Recurrence With Polynomial Coefficients.cpp	/^int mod_inv(int a, int mod) {$/;"	f	typeref:typename:int
mod_inv	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static R mod_inv(R a) {$/;"	f	class:poly	typeref:typename:R	file:
mod_pow	practice/usacoguide/gold/modular/exponentiation.cpp	/^int64_t mod_pow(int64_t a, int64_t b) {$/;"	f	typeref:typename:int64_t
mod_sum	code-library/Number Theory/Floor Sum of  Arithmetic Progressions.cpp	/^ll mod_sum(ll a, ll d, ll m, ll n) {$/;"	f	typeref:typename:ll
mod_sum	code-library/Number Theory/Sum of Arithmetic Progression Modular and Divided.cpp	/^long long mod_sum(long long a, long long d, long long m, long long n) {$/;"	f	typeref:typename:long long
mod_sum	code/Number Theory/Floor Sum of  Arithmetic Progressions.cpp	/^ll mod_sum(ll a, ll d, ll m, ll n) {$/;"	f	typeref:typename:ll
mod_sum	code/Number Theory/Sum of Arithmetic Progression Modular and Divided.cpp	/^long long mod_sum(long long a, long long d, long long m, long long n) {$/;"	f	typeref:typename:long long
mod_xk	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly mod_xk(int k) const { return {a.begin(), a.begin() + min(k, size())}; } \/\/modulo by x^k$/;"	f	struct:poly	typeref:typename:poly	file:
mod_xk	code-library/Math/Polynomial.cpp	/^  poly mod_xk(int k) const { return {a.begin(), a.begin() + min(k, size())}; } \/\/modulo by x^k$/;"	f	struct:poly	typeref:typename:poly	file:
mod_xk	code-library/Math/Subset Sum Problem.cpp	/^  poly mod_xk(int k) const { return {a.begin(), a.begin() + min(k, size())}; } \/\/modulo by x^k$/;"	f	struct:poly	typeref:typename:poly	file:
mod_xk	code-library/Number Theory/Bell Number.cpp	/^    poly mod_xk(int k) const { return {a.begin(), a.begin() + min(k, size())}; } \/\/modulo by x/;"	f	struct:poly	typeref:typename:poly	file:
mod_xk	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly mod_xk(int k) const { return {a.begin(), a.begin() + min(k, size())}; } \/\/modulo by x/;"	f	struct:poly	typeref:typename:poly	file:
mod_xk	code/Math/Faulhaber Formula Fastest.cpp	/^  poly mod_xk(int k) const { return {a.begin(), a.begin() + min(k, size())}; } \/\/modulo by x^k$/;"	f	struct:poly	typeref:typename:poly	file:
mod_xk	code/Math/Polynomial.cpp	/^  poly mod_xk(int k) const { return {a.begin(), a.begin() + min(k, size())}; } \/\/modulo by x^k$/;"	f	struct:poly	typeref:typename:poly	file:
mod_xk	code/Math/Subset Sum Problem.cpp	/^  poly mod_xk(int k) const { return {a.begin(), a.begin() + min(k, size())}; } \/\/modulo by x^k$/;"	f	struct:poly	typeref:typename:poly	file:
mod_xk	code/Number Theory/Bell Number.cpp	/^    poly mod_xk(int k) const { return {a.begin(), a.begin() + min(k, size())}; } \/\/modulo by x/;"	f	struct:poly	typeref:typename:poly	file:
mod_xk	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly mod_xk(int k) const { return {a.begin(), a.begin() + min(k, size())}; } \/\/modulo by x/;"	f	struct:poly	typeref:typename:poly	file:
modifies	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^pair<int, int> modifies[N * 2];$/;"	v	typeref:typename:pair<int,int>[]
modifies	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^pair<int, int> modifies[N * 2];$/;"	v	typeref:typename:pair<int,int>[]
modify	code-library/Graph Theory/Manhattan MST.cpp	/^void modify(int x, int w, int id) {$/;"	f	typeref:typename:void
modify	code/Graph Theory/Manhattan MST.cpp	/^void modify(int x, int w, int id) {$/;"	f	typeref:typename:void
modint	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^    modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Graph Theory/Number of Arborescence.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Graph Theory/Number of Arborescence.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Graph Theory/Number of DAG.cpp	/^    modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Graph Theory/Number of DAG.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Graph Theory/Tree Isomorphism.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Graph Theory/Tree Isomorphism.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Math/BerleKamp Massey.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Math/BerleKamp Massey.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Math/Characteristic Polynomial Faster.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Math/Characteristic Polynomial Faster.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Math/Determinant of Sparse Matrix.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Math/Determinant of Sparse Matrix.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Math/FWHT in Ternary Base.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Math/FWHT in Ternary Base.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Math/Faulhaber Formula Fastest.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Math/Faulhaber Formula Fastest.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^    modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Math/Hafnian of a Matrix.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Math/Hafnian of a Matrix.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Math/Lagrange Interpolation Brute.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Math/Lagrange Interpolation Brute.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Math/Lagrange Interpolation.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Math/Lagrange Interpolation.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Math/Linear Recurrence.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Math/Linear Recurrence.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Math/Polynomial Sum.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Math/Polynomial Sum.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Math/Polynomial.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Math/Polynomial.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Math/Subset Sum Problem.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Math/Subset Sum Problem.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Math/The Slime Trick.cpp	/^    modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Math/The Slime Trick.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Math/Thomas Algorithm.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Math/Thomas Algorithm.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Math/Vandermonde Matrix.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Math/Vandermonde Matrix.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Number Theory/Bell Number.cpp	/^    modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Number Theory/Bell Number.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Number Theory/Combinatorics Basics.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Number Theory/Combinatorics Basics.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Number Theory/Dirichlet Convolution.cpp	/^    modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Number Theory/Dirichlet Convolution.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Number Theory/Lucas Theorem.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Number Theory/Lucas Theorem.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Number Theory/Min_25 Sieve.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Number Theory/Min_25 Sieve.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Number Theory/Partition Function.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Number Theory/Partition Function.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Number Theory/Phi Field.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Number Theory/Phi Field.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^struct modint {$/;"	s	file:
modint	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^struct modint {$/;"	s	file:
modint	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^struct modint {$/;"	s	file:
modint	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^struct modint {$/;"	s	file:
modint	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^struct modint {$/;"	s	file:
modint	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^struct modint {$/;"	s	file:
modint	code/Graph Theory/Chromatic Polynoimial.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Graph Theory/Chromatic Polynoimial.cpp	/^struct modint {$/;"	s	file:
modint	code/Graph Theory/Counting Labeled Graphs.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Graph Theory/Counting Labeled Graphs.cpp	/^struct modint {$/;"	s	file:
modint	code/Graph Theory/Hafnian of a Matrix.cpp	/^    modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Graph Theory/Hafnian of a Matrix.cpp	/^struct modint {$/;"	s	file:
modint	code/Graph Theory/Number of Arborescence.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Graph Theory/Number of Arborescence.cpp	/^struct modint {$/;"	s	file:
modint	code/Graph Theory/Number of DAG.cpp	/^    modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Graph Theory/Number of DAG.cpp	/^struct modint {$/;"	s	file:
modint	code/Graph Theory/Tree Isomorphism.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Graph Theory/Tree Isomorphism.cpp	/^struct modint {$/;"	s	file:
modint	code/Math/BerleKamp Massey.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Math/BerleKamp Massey.cpp	/^struct modint {$/;"	s	file:
modint	code/Math/Characteristic Polynomial Faster.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Math/Characteristic Polynomial Faster.cpp	/^struct modint {$/;"	s	file:
modint	code/Math/Determinant of Sparse Matrix.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Math/Determinant of Sparse Matrix.cpp	/^struct modint {$/;"	s	file:
modint	code/Math/FWHT in Ternary Base.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Math/FWHT in Ternary Base.cpp	/^struct modint {$/;"	s	file:
modint	code/Math/Faulhaber Formula Fastest.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Math/Faulhaber Formula Fastest.cpp	/^struct modint {$/;"	s	file:
modint	code/Math/Generating Function of a Linear Recurrence.cpp	/^    modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Math/Generating Function of a Linear Recurrence.cpp	/^struct modint {$/;"	s	file:
modint	code/Math/Hafnian of a Matrix.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Math/Hafnian of a Matrix.cpp	/^struct modint {$/;"	s	file:
modint	code/Math/Lagrange Interpolation Brute.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Math/Lagrange Interpolation Brute.cpp	/^struct modint {$/;"	s	file:
modint	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^struct modint {$/;"	s	file:
modint	code/Math/Lagrange Interpolation.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Math/Lagrange Interpolation.cpp	/^struct modint {$/;"	s	file:
modint	code/Math/Linear Recurrence.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Math/Linear Recurrence.cpp	/^struct modint {$/;"	s	file:
modint	code/Math/Number of Solutions of A Equation MITM.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Math/Number of Solutions of A Equation MITM.cpp	/^struct modint {$/;"	s	file:
modint	code/Math/Polynomial Sum.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Math/Polynomial Sum.cpp	/^struct modint {$/;"	s	file:
modint	code/Math/Polynomial.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Math/Polynomial.cpp	/^struct modint {$/;"	s	file:
modint	code/Math/Subset Sum Problem.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Math/Subset Sum Problem.cpp	/^struct modint {$/;"	s	file:
modint	code/Math/The Slime Trick.cpp	/^    modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Math/The Slime Trick.cpp	/^struct modint {$/;"	s	file:
modint	code/Math/Thomas Algorithm.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Math/Thomas Algorithm.cpp	/^struct modint {$/;"	s	file:
modint	code/Math/Vandermonde Matrix.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Math/Vandermonde Matrix.cpp	/^struct modint {$/;"	s	file:
modint	code/Number Theory/Bell Number.cpp	/^    modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Number Theory/Bell Number.cpp	/^struct modint {$/;"	s	file:
modint	code/Number Theory/Combinatorics Basics.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Number Theory/Combinatorics Basics.cpp	/^struct modint {$/;"	s	file:
modint	code/Number Theory/Dirichlet Convolution.cpp	/^    modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Number Theory/Dirichlet Convolution.cpp	/^struct modint {$/;"	s	file:
modint	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^struct modint {$/;"	s	file:
modint	code/Number Theory/Lucas Theorem.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Number Theory/Lucas Theorem.cpp	/^struct modint {$/;"	s	file:
modint	code/Number Theory/Min_25 Sieve.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Number Theory/Min_25 Sieve.cpp	/^struct modint {$/;"	s	file:
modint	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^struct modint {$/;"	s	file:
modint	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^struct modint {$/;"	s	file:
modint	code/Number Theory/Partition Function.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Number Theory/Partition Function.cpp	/^struct modint {$/;"	s	file:
modint	code/Number Theory/Phi Field.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Number Theory/Phi Field.cpp	/^struct modint {$/;"	s	file:
modint	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^struct modint {$/;"	s	file:
modint	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^struct modint {$/;"	s	file:
modint	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^struct modint {$/;"	s	file:
modint	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^struct modint {$/;"	s	file:
modint	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^struct modint {$/;"	s	file:
modint	practice/cf/random/i_hate_math_problems/testing.cpp	/^  modint(int32_t value_) : value(value_) {}$/;"	f	struct:modint	file:
modint	practice/cf/random/i_hate_math_problems/testing.cpp	/^struct modint {$/;"	s	file:
mods	practice/cf/random/1700/test2.cpp	/^vector<int> mods[5];$/;"	v	typeref:typename:vector<int>[5]
modulus	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static word_t modulus() { return mod; }$/;"	f	class:ntt::Mod	typeref:typename:word_t	file:
modulus	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static word_t modulus() { return mod; }$/;"	f	class:ntt::Mod	typeref:typename:word_t	file:
monotonous_queue	code-library/Data Structures/Monotonous Queue.cpp	/^struct monotonous_queue { \/\/max, stores strictly decreasing sequence of the current queue$/;"	s	file:
monotonous_queue	code/Data Structures/Monotonous Queue.cpp	/^struct monotonous_queue { \/\/max, stores strictly decreasing sequence of the current queue$/;"	s	file:
mov	practice/cpbook/ch1/1.6/chess/00225/main.cpp	/^int king, queen, mov;$/;"	v	typeref:typename:int
mov_pos	practice/cpbook/ch1/1.6/chess/00225/main.cpp	/^pair<int, int> queen_pos, king_pos, mov_pos;$/;"	v	typeref:typename:pair<int,int>
move_forward	practice/usacoguide/gold/bfs/cownav.cpp	/^Point move_forward(Point cur) {$/;"	f	typeref:typename:Point
mp	code-library/Data Structures/MOs Online.cpp	/^map <int, int> mp;$/;"	v	typeref:typename:map<int,int>
mp	code-library/Data Structures/MOs with Update.cpp	/^map <int, int> mp;$/;"	v	typeref:typename:map<int,int>
mp	code-library/Graph Theory/Euler Path Directed.cpp	/^map<string, int> mp;$/;"	v	typeref:typename:map<string,int>
mp	code-library/Graph Theory/Kirchoffs Theorem.cpp	/^gp_hash_table<int, int> mp;$/;"	v	typeref:typename:gp_hash_table<int,int>
mp	code-library/Math/Finite Field Arithmetic Binary.cpp	/^int mp[40];$/;"	v	typeref:typename:int[40]
mp	code-library/Number Theory/Dirichlet Convolution.cpp	/^  gp_hash_table<long long, mint> mp;$/;"	v	namespace:Dirichlet	typeref:typename:gp_hash_table<long long,mint>
mp	code-library/Number Theory/Power Tower.cpp	/^map<ll, ll> mp;$/;"	v	typeref:typename:map<ll,ll>
mp	code-library/Number Theory/Prime Number System.cpp	/^  map<int, int> mp;$/;"	m	struct:base	typeref:typename:map<int,int>	file:
mp	code/Data Structures/MOs Online.cpp	/^map <int, int> mp;$/;"	v	typeref:typename:map<int,int>
mp	code/Data Structures/MOs with Update.cpp	/^map <int, int> mp;$/;"	v	typeref:typename:map<int,int>
mp	code/Graph Theory/Euler Path Directed.cpp	/^map<string, int> mp;$/;"	v	typeref:typename:map<string,int>
mp	code/Graph Theory/Kirchoffs Theorem.cpp	/^gp_hash_table<int, int> mp;$/;"	v	typeref:typename:gp_hash_table<int,int>
mp	code/Math/Finite Field Arithmetic Binary.cpp	/^int mp[40];$/;"	v	typeref:typename:int[40]
mp	code/Number Theory/Dirichlet Convolution.cpp	/^  gp_hash_table<long long, mint> mp;$/;"	v	namespace:Dirichlet	typeref:typename:gp_hash_table<long long,mint>
mp	code/Number Theory/Power Tower.cpp	/^map<ll, ll> mp;$/;"	v	typeref:typename:map<ll,ll>
mp	code/Number Theory/Prime Number System.cpp	/^  map<int, int> mp;$/;"	m	struct:base	typeref:typename:map<int,int>	file:
mp	contests/Codeforces/737/C.cpp	/^#define mp /;"	d	file:
mp	practice/usacoguide/gold/divisibility/commondivisors.cpp	/^int mp[int(1e6 + 5)];$/;"	v	typeref:typename:int[]
mp	practice/usacoguide/gold/introDP/711C.cpp	/^#define mp /;"	d	file:
msk	code-library/Dynamic Programming Optimizations/Subset Union of Bitsets.cpp	/^int x[N], y[N], c[N], dp[1 << 20], msk[N], ans[N];$/;"	v	typeref:typename:int[]
msk	code-library/Miscellaneous/Subset Union of Bitsets.cpp	/^int x[N], y[N], c[N], dp[1 << 20], msk[N], ans[N];$/;"	v	typeref:typename:int[]
msk	code/Dynamic Programming Optimizations/Subset Union of Bitsets.cpp	/^int x[N], y[N], c[N], dp[1 << 20], msk[N], ans[N];$/;"	v	typeref:typename:int[]
msk	code/Miscellaneous/Subset Union of Bitsets.cpp	/^int x[N], y[N], c[N], dp[1 << 20], msk[N], ans[N];$/;"	v	typeref:typename:int[]
mu	code-library/Math/Polynomial Factorization.cpp	/^int mu[MAXN];$/;"	v	typeref:typename:int[]
mu	code/Math/Polynomial Factorization.cpp	/^int mu[MAXN];$/;"	v	typeref:typename:int[]
mul	code-library/Math/Finite Field Arithmetic Binary.cpp	/^  inline int mul(int a, int b) {$/;"	f	namespace:FFA	typeref:typename:int
mul	code-library/Math/Polynomial Factorization.cpp	/^void mul(vi &a, int e) {$/;"	f	typeref:typename:void
mul	code-library/Number Theory/Mobius Function.cpp	/^int mul[N];$/;"	v	typeref:typename:int[]
mul	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly mul(const poly& g) const {$/;"	f	class:poly	typeref:typename:poly	file:
mul	code/Math/Finite Field Arithmetic Binary.cpp	/^  inline int mul(int a, int b) {$/;"	f	namespace:FFA	typeref:typename:int
mul	code/Math/Polynomial Factorization.cpp	/^void mul(vi &a, int e) {$/;"	f	typeref:typename:void
mul	code/Number Theory/Mobius Function.cpp	/^int mul[N];$/;"	v	typeref:typename:int[]
mul	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly mul(const poly& g) const {$/;"	f	class:poly	typeref:typename:poly	file:
mul	practice/usacoguide/gold/modular/santasbot.cpp	/^ll mul(int a, int b, int c, int d) {$/;"	f	typeref:typename:ll
mul	practice/usacoguide/gold/modular/test.cpp	/^ll mul(int a, int b, int c, int d) {$/;"	f	typeref:typename:ll
mul2	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static void mul2(const poly& f, const poly& g, bool cyclic=false) {$/;"	f	class:poly	typeref:typename:void	file:
mul2	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static void mul2(const poly& f, const poly& g, bool cyclic=false) {$/;"	f	class:poly	typeref:typename:void	file:
mul_back	code-library/Dynamic Programming Optimizations/Number of Subsequences Having Product at least K.cpp	/^int mul_back(int i, int p) {$/;"	f	typeref:typename:int
mul_back	code/Dynamic Programming Optimizations/Number of Subsequences Having Product at least K.cpp	/^int mul_back(int i, int p) {$/;"	f	typeref:typename:int
mul_basecase	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly mul_basecase(const poly& g) const {$/;"	f	class:poly	typeref:typename:poly	file:
mul_basecase	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly mul_basecase(const poly& g) const {$/;"	f	class:poly	typeref:typename:poly	file:
mul_crt	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static poly mul_crt(int beg, int end) {$/;"	f	class:poly	typeref:typename:poly	file:
mul_crt	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static poly mul_crt(int beg, int end) {$/;"	f	class:poly	typeref:typename:poly	file:
mul_fft	code-library/Miscellaneous/BigInt.cpp	/^  BigInt mul_fft(const BigInt& v) const {$/;"	f	struct:BigInt	typeref:typename:BigInt	file:
mul_fft	code/Miscellaneous/BigInt.cpp	/^  BigInt mul_fft(const BigInt& v) const {$/;"	f	struct:BigInt	typeref:typename:BigInt	file:
mul_front	code-library/Dynamic Programming Optimizations/Number of Subsequences Having Product at least K.cpp	/^int mul_front(int i, int p) {$/;"	f	typeref:typename:int
mul_front	code/Dynamic Programming Optimizations/Number of Subsequences Having Product at least K.cpp	/^int mul_front(int i, int p) {$/;"	f	typeref:typename:int
mul_inv	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static constexpr word_t mul_inv(word_t n, int e=6, word_t x=1) {$/;"	f	class:ntt::Mod	typeref:typename:word_t	file:
mul_inv	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static constexpr word_t mul_inv(word_t n, int e=6, word_t x=1) {$/;"	f	class:ntt::Mod	typeref:typename:word_t	file:
mul_mod	code-library/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^  inline ll mul_mod(ll x, ll y, ll m) {$/;"	f	namespace:PollardRho	typeref:typename:ll
mul_mod	code-library/Number Theory/Pisano Period.cpp	/^  inline ll mul_mod(ll x, ll y, ll m) {$/;"	f	namespace:PollardRho	typeref:typename:ll
mul_mod	code-library/Number Theory/Pollard Rho.cpp	/^  inline ll mul_mod(ll x, ll y, ll m) {$/;"	f	namespace:PollardRho	typeref:typename:ll
mul_mod	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static R mul_mod(R a, R b) { return R64(a) * b % fast_mod; }$/;"	f	class:poly	typeref:typename:R	file:
mul_mod	code/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^  inline ll mul_mod(ll x, ll y, ll m) {$/;"	f	namespace:PollardRho	typeref:typename:ll
mul_mod	code/Number Theory/Pisano Period.cpp	/^  inline ll mul_mod(ll x, ll y, ll m) {$/;"	f	namespace:PollardRho	typeref:typename:ll
mul_mod	code/Number Theory/Pollard Rho.cpp	/^  inline ll mul_mod(ll x, ll y, ll m) {$/;"	f	namespace:PollardRho	typeref:typename:ll
mul_mod	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static R mul_mod(R a, R b) { return R64(a) * b % fast_mod; }$/;"	f	class:poly	typeref:typename:R	file:
mul_simple	code-library/Miscellaneous/BigInt.cpp	/^  BigInt mul_simple(const BigInt &v) const {$/;"	f	struct:BigInt	typeref:typename:BigInt	file:
mul_simple	code/Miscellaneous/BigInt.cpp	/^  BigInt mul_simple(const BigInt &v) const {$/;"	f	struct:BigInt	typeref:typename:BigInt	file:
mul_xk	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly mul_xk(int k) const { \/\/ multiply by x^k$/;"	f	struct:poly	typeref:typename:poly	file:
mul_xk	code-library/Math/Polynomial.cpp	/^  poly mul_xk(int k) const { \/\/ multiply by x^k$/;"	f	struct:poly	typeref:typename:poly	file:
mul_xk	code-library/Math/Subset Sum Problem.cpp	/^  poly mul_xk(int k) const { \/\/ multiply by x^k$/;"	f	struct:poly	typeref:typename:poly	file:
mul_xk	code-library/Number Theory/Bell Number.cpp	/^    poly mul_xk(int k) const { \/\/ multiply by x^k$/;"	f	struct:poly	typeref:typename:poly	file:
mul_xk	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly mul_xk(int k) const { \/\/ multiply by x^k$/;"	f	struct:poly	typeref:typename:poly	file:
mul_xk	code/Math/Faulhaber Formula Fastest.cpp	/^  poly mul_xk(int k) const { \/\/ multiply by x^k$/;"	f	struct:poly	typeref:typename:poly	file:
mul_xk	code/Math/Polynomial.cpp	/^  poly mul_xk(int k) const { \/\/ multiply by x^k$/;"	f	struct:poly	typeref:typename:poly	file:
mul_xk	code/Math/Subset Sum Problem.cpp	/^  poly mul_xk(int k) const { \/\/ multiply by x^k$/;"	f	struct:poly	typeref:typename:poly	file:
mul_xk	code/Number Theory/Bell Number.cpp	/^    poly mul_xk(int k) const { \/\/ multiply by x^k$/;"	f	struct:poly	typeref:typename:poly	file:
mul_xk	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly mul_xk(int k) const { \/\/ multiply by x^k$/;"	f	struct:poly	typeref:typename:poly	file:
mult	code-library/Number Theory/Fermats Theorem on Sum of Two Squares.cpp	/^    inline num_t mult(num_t a, num_t b, num_t p) {$/;"	f	namespace:FermatRepresent	typeref:typename:num_t
mult	code/Number Theory/Fermats Theorem on Sum of Two Squares.cpp	/^    inline num_t mult(num_t a, num_t b, num_t p) {$/;"	f	namespace:FermatRepresent	typeref:typename:num_t
multiplicative_order	code-library/Number Theory/Multiplicative Order.cpp	/^ll multiplicative_order(ll a, ll mod) {$/;"	f	typeref:typename:ll
multiplicative_order	code/Number Theory/Multiplicative Order.cpp	/^ll multiplicative_order(ll a, ll mod) {$/;"	f	typeref:typename:ll
multiplicity	code-library/Number Theory/nCr Modulo Any Mod.cpp	/^ll multiplicity(ll n, int p) {$/;"	f	typeref:typename:ll
multiplicity	code/Number Theory/nCr Modulo Any Mod.cpp	/^ll multiplicity(ll n, int p) {$/;"	f	typeref:typename:ll
multiply	code-library/Data Structures/Centroid Decomposition.cpp	/^vector<long long> multiply(vector<int> &a, vector<int> &b) {$/;"	f	typeref:typename:vector<long long>
multiply	code-library/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^vector<long long> multiply(vector<int> &a, vector<int> &b) {$/;"	f	typeref:typename:vector<long long>
multiply	code-library/Math/FFT.cpp	/^vector<long long> multiply(vector<int> &a, vector<int> &b) {$/;"	f	typeref:typename:vector<long long>
multiply	code-library/Math/FWHT in Any Base.cpp	/^  vector<int> multiply(vector<int> a, vector<int> b, int k) {$/;"	f	namespace:FWHT	typeref:typename:vector<int>
multiply	code-library/Math/FWHT in Ternary Base.cpp	/^  vector<int> multiply(int n, vector<int> &a, vector<int> &b) {$/;"	f	struct:FWHT	typeref:typename:vector<int>	file:
multiply	code-library/Math/FWHT.cpp	/^ vector<int> multiply(int n, vector<int> A, vector<int> B, int flag = XOR) {$/;"	f	struct:FWHT	typeref:typename:vector<int>	file:
multiply	code-library/Math/Faulhaber Formula Fastest.cpp	/^vector<int> multiply(vector<int> &a, vector<int> &b, int eq = 0) {$/;"	f	typeref:typename:vector<int>
multiply	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^vector<int> multiply(vector<int> &a, vector<int> &b, int eq = 0) {$/;"	f	typeref:typename:vector<int>
multiply	code-library/Math/Linear Recurrence Fastest.cpp	/^vector<int> multiply(vector<int> &a, vector<int> &b, int eq = 0) {$/;"	f	typeref:typename:vector<int>
multiply	code-library/Math/Max Convolution between Convex Funtions.cpp	/^vector<int> multiply(vector<int> a, vector<int> b) {$/;"	f	typeref:typename:vector<int>
multiply	code-library/Math/NTT Online.cpp	/^vector<int> multiply(vector<int> &a, vector<int> &b, int eq = 0) {$/;"	f	typeref:typename:vector<int>
multiply	code-library/Math/NTT With Any Prime MOD.cpp	/^vector<int> multiply(vector<int> &a, vector<int> &b, int eq = 0) {$/;"	f	typeref:typename:vector<int>
multiply	code-library/Math/NTT.cpp	/^vector<int> multiply(vector<int> &f, vector<int> &g) {$/;"	f	typeref:typename:vector<int>
multiply	code-library/Math/Polynomial with Binomial Coefficients.cpp	/^vector<int> multiply(vector<int> &a, vector<int> &b, int eq = 0) {$/;"	f	typeref:typename:vector<int>
multiply	code-library/Math/Polynomial.cpp	/^vector<int> multiply(vector<int> &a, vector<int> &b, int eq = 0) {$/;"	f	typeref:typename:vector<int>
multiply	code-library/Math/Subset Sum Problem.cpp	/^vector<int> multiply(vector<int> &a, vector<int> &b, int eq = 0) {$/;"	f	typeref:typename:vector<int>
multiply	code-library/Math/Vandermonde Matrix.cpp	/^vector<mint> multiply(vector<mint> a, vector<mint> b) {$/;"	f	typeref:typename:vector<mint>
multiply	code-library/Number Theory/Bell Number.cpp	/^vector<int> multiply(vector<int> &a, vector<int> &b, int eq = 0) {$/;"	f	typeref:typename:vector<int>
multiply	code-library/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^vector<int> multiply(vector<int> &f, vector<int> &g) {$/;"	f	typeref:typename:vector<int>
multiply	code-library/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^vector<int> multiply(vector<int> &f, vector<int> &g) {$/;"	f	typeref:typename:vector<int>
multiply	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^vector<int> multiply(vector<int> &a, vector<int> &b, int eq = 0) {$/;"	f	typeref:typename:vector<int>
multiply	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^vector<int> multiply(vector<int> &f, vector<int> &g) {$/;"	f	typeref:typename:vector<int>
multiply	code-library/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^vector<int> multiply(vector<int> &a, vector<int> &b, int eq = 0) {$/;"	f	typeref:typename:vector<int>
multiply	code-library/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^vector<int> multiply(vector<int> &f, vector<int> &g) {$/;"	f	typeref:typename:vector<int>
multiply	code-library/Strings/String Matching With FFT.cpp	/^vector<int> multiply(vector<int> &a, vector<int> &b) {$/;"	f	typeref:typename:vector<int>
multiply	code/Data Structures/Centroid Decomposition.cpp	/^vector<long long> multiply(vector<int> &a, vector<int> &b) {$/;"	f	typeref:typename:vector<long long>
multiply	code/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^vector<long long> multiply(vector<int> &a, vector<int> &b) {$/;"	f	typeref:typename:vector<long long>
multiply	code/Math/FFT.cpp	/^vector<long long> multiply(vector<int> &a, vector<int> &b) {$/;"	f	typeref:typename:vector<long long>
multiply	code/Math/FWHT in Any Base.cpp	/^  vector<int> multiply(vector<int> a, vector<int> b, int k) {$/;"	f	namespace:FWHT	typeref:typename:vector<int>
multiply	code/Math/FWHT in Ternary Base.cpp	/^  vector<int> multiply(int n, vector<int> &a, vector<int> &b) {$/;"	f	struct:FWHT	typeref:typename:vector<int>	file:
multiply	code/Math/FWHT.cpp	/^ vector<int> multiply(int n, vector<int> A, vector<int> B, int flag = XOR) {$/;"	f	struct:FWHT	typeref:typename:vector<int>	file:
multiply	code/Math/Faulhaber Formula Fastest.cpp	/^vector<int> multiply(vector<int> &a, vector<int> &b, int eq = 0) {$/;"	f	typeref:typename:vector<int>
multiply	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^vector<int> multiply(vector<int> &a, vector<int> &b, int eq = 0) {$/;"	f	typeref:typename:vector<int>
multiply	code/Math/Linear Recurrence Fastest.cpp	/^vector<int> multiply(vector<int> &a, vector<int> &b, int eq = 0) {$/;"	f	typeref:typename:vector<int>
multiply	code/Math/Max Convolution between Convex Funtions.cpp	/^vector<int> multiply(vector<int> a, vector<int> b) {$/;"	f	typeref:typename:vector<int>
multiply	code/Math/NTT Online.cpp	/^vector<int> multiply(vector<int> &a, vector<int> &b, int eq = 0) {$/;"	f	typeref:typename:vector<int>
multiply	code/Math/NTT With Any Prime MOD.cpp	/^vector<int> multiply(vector<int> &a, vector<int> &b, int eq = 0) {$/;"	f	typeref:typename:vector<int>
multiply	code/Math/NTT.cpp	/^vector<int> multiply(vector<int> &f, vector<int> &g) {$/;"	f	typeref:typename:vector<int>
multiply	code/Math/Polynomial with Binomial Coefficients.cpp	/^vector<int> multiply(vector<int> &a, vector<int> &b, int eq = 0) {$/;"	f	typeref:typename:vector<int>
multiply	code/Math/Polynomial.cpp	/^vector<int> multiply(vector<int> &a, vector<int> &b, int eq = 0) {$/;"	f	typeref:typename:vector<int>
multiply	code/Math/Subset Sum Problem.cpp	/^vector<int> multiply(vector<int> &a, vector<int> &b, int eq = 0) {$/;"	f	typeref:typename:vector<int>
multiply	code/Math/Vandermonde Matrix.cpp	/^vector<mint> multiply(vector<mint> a, vector<mint> b) {$/;"	f	typeref:typename:vector<mint>
multiply	code/Number Theory/Bell Number.cpp	/^vector<int> multiply(vector<int> &a, vector<int> &b, int eq = 0) {$/;"	f	typeref:typename:vector<int>
multiply	code/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^vector<int> multiply(vector<int> &f, vector<int> &g) {$/;"	f	typeref:typename:vector<int>
multiply	code/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^vector<int> multiply(vector<int> &f, vector<int> &g) {$/;"	f	typeref:typename:vector<int>
multiply	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^vector<int> multiply(vector<int> &a, vector<int> &b, int eq = 0) {$/;"	f	typeref:typename:vector<int>
multiply	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^vector<int> multiply(vector<int> &f, vector<int> &g) {$/;"	f	typeref:typename:vector<int>
multiply	code/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^vector<int> multiply(vector<int> &a, vector<int> &b, int eq = 0) {$/;"	f	typeref:typename:vector<int>
multiply	code/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^vector<int> multiply(vector<int> &f, vector<int> &g) {$/;"	f	typeref:typename:vector<int>
multiply	code/Strings/String Matching With FFT.cpp	/^vector<int> multiply(vector<int> &a, vector<int> &b) {$/;"	f	typeref:typename:vector<int>
multiply_fft	code-library/Miscellaneous/BigInt.cpp	/^  void multiply_fft(const vector<int> &a, const vector<int> &b, vector<int> &res) const {$/;"	f	struct:BigInt	typeref:typename:void	file:
multiply_fft	code/Miscellaneous/BigInt.cpp	/^  void multiply_fft(const vector<int> &a, const vector<int> &b, vector<int> &res) const {$/;"	f	struct:BigInt	typeref:typename:void	file:
multiply_mint	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^vector<mint> multiply_mint(vector<mint> &a, vector<mint> &b) {$/;"	f	typeref:typename:vector<mint>
multiply_mint	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^vector<mint> multiply_mint(vector<mint> &a, vector<mint> &b) {$/;"	f	typeref:typename:vector<mint>
mulx	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly mulx(mint x) { \/\/component-wise multiplication with x^k$/;"	f	struct:poly	typeref:typename:poly	file:
mulx	code-library/Math/Polynomial.cpp	/^  poly mulx(mint x) { \/\/component-wise multiplication with x^k$/;"	f	struct:poly	typeref:typename:poly	file:
mulx	code/Math/Faulhaber Formula Fastest.cpp	/^  poly mulx(mint x) { \/\/component-wise multiplication with x^k$/;"	f	struct:poly	typeref:typename:poly	file:
mulx	code/Math/Polynomial.cpp	/^  poly mulx(mint x) { \/\/component-wise multiplication with x^k$/;"	f	struct:poly	typeref:typename:poly	file:
mulx_sq	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly mulx_sq(mint x) { \/\/component-wise multiplication with x^{k^2}$/;"	f	struct:poly	typeref:typename:poly	file:
mulx_sq	code-library/Math/Polynomial.cpp	/^  poly mulx_sq(mint x) { \/\/component-wise multiplication with x^{k^2}$/;"	f	struct:poly	typeref:typename:poly	file:
mulx_sq	code/Math/Faulhaber Formula Fastest.cpp	/^  poly mulx_sq(mint x) { \/\/component-wise multiplication with x^{k^2}$/;"	f	struct:poly	typeref:typename:poly	file:
mulx_sq	code/Math/Polynomial.cpp	/^  poly mulx_sq(mint x) { \/\/component-wise multiplication with x^{k^2}$/;"	f	struct:poly	typeref:typename:poly	file:
mx	code-library/Data Structures/Implicit Treap.cpp	/^    int val, sz, prior, lazy, sum, mx, mn, repl;$/;"	m	struct:treap::node	typeref:typename:int	file:
mx	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  int pos, key, mn, mx;$/;"	m	struct:node	typeref:typename:int	file:
mx	code/Data Structures/Implicit Treap.cpp	/^    int val, sz, prior, lazy, sum, mx, mn, repl;$/;"	m	struct:treap::node	typeref:typename:int	file:
mx	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  int pos, key, mn, mx;$/;"	m	struct:node	typeref:typename:int	file:
mxN	contests/AtCoder/231/D.cpp	/^const int mxN = 1e5 + 5;$/;"	v	typeref:typename:const int
mxN	contests/AtCoder/ABC211/D.cpp	/^const int mxN = 2e5 + 5, MOD = 1e9 + 7;$/;"	v	typeref:typename:const int
mxN	contests/Codeforces/1609/C.cpp	/^const int mxN = 1e7, mxNN = 1e7 + 5;$/;"	v	typeref:typename:const int
mxN	contests/Codeforces/1609/D.cpp	/^const int mxN = 1e7, mxNN = 1e7 + 5;$/;"	v	typeref:typename:const int
mxN	contests/LIT2021/C.cpp	/^const int mxN = 55;$/;"	v	typeref:typename:const int
mxN	contests/USACO/dec_silver_2021/C/C.cpp	/^const int mxN = 3e7 + 5;$/;"	v	typeref:typename:const int
mxN	practice/cf/DP/knap1.cpp	/^const int mxN = 105, mxW = 1e5 + 5;$/;"	v	typeref:typename:const int
mxN	practice/cf/random/1700/test1.cpp	/^const int mxN = 2e5 + 5;$/;"	v	typeref:typename:const int
mxN	practice/cf/random/1700/test2.cpp	/^const int mxN = 25;$/;"	v	typeref:typename:const int
mxN	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^const int mxN = 5e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mxN	practice/cf/random/i_hate_math_problems/testing.cpp	/^const int mxN = 3e5 + 9, mod = 1e9 + 7;$/;"	v	typeref:typename:const int
mxN	practice/club/prob3/solution_prob3.cpp	/^const int mxN = 505;$/;"	v	typeref:typename:const int
mxN	practice/cpbook/ch1/1.4/medium/11956.cpp	/^const int mxN = 105;$/;"	v	typeref:typename:const int
mxN	practice/cpbook/ch1/1.4/medium/garage.cpp	/^const int mxN = 2005;$/;"	v	typeref:typename:const int
mxN	practice/cpbook/ch1/1.4/medium/poi.cpp	/^const int mxN = 2005;$/;"	v	typeref:typename:const int
mxN	practice/cpbook/ch1/1.6/game/easier/10189/main.cpp	/^const int mxN = 105;$/;"	v	typeref:typename:const int
mxN	practice/cpbook/ch1/1.6/game/harder/rockpaperscissors/main.cpp	/^const int mxN = 101;$/;"	v	typeref:typename:const int
mxN	practice/cpbook/ch2/2.2/1D/11222/main.cpp	/^const int mxN = 1e4 + 5;$/;"	v	typeref:typename:const int
mxN	practice/cpbook/ch2/2.2/2D/11581/main.cpp	/^const int mxN = 3;$/;"	v	typeref:typename:const int
mxN	practice/december2021/DP/counting_towers/sol.cpp	/^const int mxN = 1e6 + 5;$/;"	v	typeref:typename:const int
mxN	practice/december2021/DP/rectangle_cutting/sol.cpp	/^const int mxN = 505;$/;"	v	typeref:typename:const int
mxN	practice/december2021/DP/removal_game/sol.cpp	/^const int mxN = 5005;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/gold/SP/flightdiscount.cpp	/^const int mxN = 1e5 + 5;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/gold/SP/shortestroutesii.cpp	/^const int mxN = 505;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/gold/bfs/cownav.cpp	/^const int mxN = 25;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/gold/bfs/graphgirth.cpp	/^const int mxN = 2505;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/gold/bfs/mecho/main.cpp	/^const int mxN = 805;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/gold/bfs/mechonew/main.cpp	/^const int mxN = 805;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/gold/bfs/monsters.cpp	/^const int mxN = 1005;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/gold/bfs/piggyback.cpp	/^const int mxN = 40005;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/gold/dsu/closing/main.cpp	/^const int mxN = 2e5 + 5;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/gold/dsu/tractor/main.cpp	/^const int mxN = 505;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/gold/dsu/tractor/mountain.cpp	/^const int mxN = 1e3 + 5;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/gold/dsu/wormhole/main.cpp	/^const int mxN = 1e5 + 5;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/gold/introDP/arraydescription.cpp	/^const int mxN = 1e5 + 5;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/gold/introDP/cannonballs.cpp	/^const int mxN = 3e5 + 5;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/gold/introDP/editdistance.cpp	/^const int mxN = 5005;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/gold/introDP/flag.cpp	/^const int mxN = 1005;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/gold/introDP/gridpaths.cpp	/^const int mxN = 1005, MOD = 1e9 + 7;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/gold/introDP/hoofpaperscissors.cpp	/^const int mxN = 1e5 + 5;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/gold/introDP/king2.cpp	/^const int mxN = 9;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/gold/introDP/knight.cpp	/^const int mxN = 55;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/gold/introDP/ladder.cpp	/^const int mxN = 105;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/gold/introDP/longestpath.cpp	/^const int mxN = 1e4 + 5;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/gold/introDP/mooney.cpp	/^const int mxN = 1001;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/gold/introDP/rabbit.cpp	/^const int mxN = 1005;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/gold/introDP/slalom.cpp	/^const int mxN = 105;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/gold/introDP/time.cpp	/^const int mxN = 1005;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/silver/idk/maze/main.cpp	/^const int mxN = 50;$/;"	v	typeref:typename:const int
mxN	practice/usacoguide/silver/orderedsets/coveredpoints.cpp	/^const int mxN = 4e5 + 5;$/;"	v	typeref:typename:const int
mxNN	contests/Codeforces/1609/C.cpp	/^const int mxN = 1e7, mxNN = 1e7 + 5;$/;"	v	typeref:typename:const int
mxNN	contests/Codeforces/1609/D.cpp	/^const int mxN = 1e7, mxNN = 1e7 + 5;$/;"	v	typeref:typename:const int
mxW	practice/cf/DP/knap1.cpp	/^const int mxN = 105, mxW = 1e5 + 5;$/;"	v	typeref:typename:const int
mxid	code-library/Graph Theory/Dinics Algorithm.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
mxid	code-library/Graph Theory/L R Flow with Dinic.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
mxid	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  int n, s, t, mxid;$/;"	m	struct:MCMF	typeref:typename:int	file:
mxid	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
mxid	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
mxid	code-library/Graph Theory/Min Cost Max Flow.cpp	/^  int n, s, t, mxid;$/;"	m	struct:MCMF	typeref:typename:int	file:
mxid	code-library/Graph Theory/Unique Min Cut.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
mxid	code/Graph Theory/Dinics Algorithm.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
mxid	code/Graph Theory/L R Flow with Dinic.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
mxid	code/Graph Theory/L R Flow with MCMF.cpp	/^  int n, s, t, mxid;$/;"	m	struct:MCMF	typeref:typename:int	file:
mxid	code/Graph Theory/Maximum Closure Problem.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
mxid	code/Graph Theory/Maximum Density Subgraph.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
mxid	code/Graph Theory/Min Cost Max Flow.cpp	/^  int n, s, t, mxid;$/;"	m	struct:MCMF	typeref:typename:int	file:
mxid	code/Graph Theory/Unique Min Cut.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
n	code-library/Data Structures/BIT.cpp	/^  int n; vector<T> t;$/;"	m	struct:BIT	typeref:typename:int	file:
n	code-library/Data Structures/Cartesian Tree.cpp	/^int n, tot, st[N], l[N], r[N], vis[N];$/;"	v	typeref:typename:int
n	code-library/Data Structures/Disjoint Sparse Table.cpp	/^  int k, n;$/;"	m	struct:DST	typeref:typename:int	file:
n	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int n;$/;"	v	typeref:typename:int
n	code-library/Data Structures/HLD.cpp	/^int n;$/;"	v	typeref:typename:int
n	code-library/Data Structures/KD Tree.cpp	/^int tests, n;$/;"	v	typeref:typename:int
n	code-library/Data Structures/MOs with DSU.cpp	/^int n, ed, m;$/;"	v	typeref:typename:int
n	code-library/Data Structures/Persistent Array.cpp	/^  int n = 1;$/;"	m	struct:PersistentArray	typeref:typename:int	file:
n	code-library/Data Structures/Persistent Queue.cpp	/^  int n = 1;$/;"	m	struct:PersistentArray	typeref:typename:int	file:
n	code-library/Data Structures/Persistent UnionFind.cpp	/^  int n = 1;$/;"	m	struct:PersistentArray	typeref:typename:int	file:
n	code-library/Data Structures/Reachability Tree.cpp	/^  int n, par[2 * N], sp[LG + 1][2 * N], val[2 * N], rid[2 * N];$/;"	m	struct:RT	typeref:typename:int	file:
n	code-library/Data Structures/SQRT Tree.cpp	/^  int n, llg, indexSz;$/;"	m	struct:SqrtTree	typeref:typename:int	file:
n	code-library/Data Structures/Segment Tree Beats.cpp	/^  int n, n0;$/;"	m	struct:SGTBeats	typeref:typename:int	file:
n	code-library/Data Structures/Segment Tree Merging.cpp	/^int n, q, a[N];$/;"	v	typeref:typename:int
n	code-library/Data Structures/Segment Tree NonRecursive.cpp	/^int n, a[N];$/;"	v	typeref:typename:int
n	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^int n;$/;"	v	typeref:typename:int
n	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^int n, T;$/;"	v	typeref:typename:int
n	code-library/Dynamic Programming Optimizations/1D1D DP.cpp	/^int n, s, t[N], f[N];$/;"	v	typeref:typename:int
n	code-library/Dynamic Programming Optimizations/Connected Component DP.cpp	/^int n, k, a[N], dp[N][N][1005][3];$/;"	v	typeref:typename:int
n	code-library/Dynamic Programming Optimizations/Knuth Optimization.cpp	/^int n, k;$/;"	v	typeref:typename:int
n	code-library/Game Theory/Green Hackenbush.cpp	/^int n, T, low[N], dis[N];$/;"	v	typeref:typename:int
n	code-library/Game Theory/Matching Game On A Graph.cpp	/^  int n;$/;"	m	struct:Blossom	typeref:typename:int	file:
n	code-library/Geometry/Geometry 2D.cpp	/^    int n;$/;"	m	struct:CircleUnion	typeref:typename:int	file:
n	code-library/Geometry/Geometry 3D.cpp	/^    int n; \/\/ initial vertex number$/;"	m	struct:CH3D	typeref:typename:int	file:
n	code-library/Geometry/Geometry 3D.cpp	/^    p3 n; double d; \/\/ (n | p) = d$/;"	m	struct:plane	typeref:typename:p3	file:
n	code-library/Graph Theory/2 SAT.cpp	/^  int n;  \/\/ total size combining +, -. must be even.$/;"	m	struct:twosat	typeref:typename:int	file:
n	code-library/Graph Theory/3 SAT.cpp	/^  int n;$/;"	m	struct:SAT_GOD	typeref:typename:int	file:
n	code-library/Graph Theory/Articulation Bridges.cpp	/^  int n, k;$/;"	m	struct:TECC	typeref:typename:int	file:
n	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  int n, n_x, match[N * 2], slack[N * 2], st[N * 2], pa[N * 2], flower_from[N * 2][N * 2], S[N */;"	m	struct:Blossom	typeref:typename:int	file:
n	code-library/Graph Theory/Blossom Algorithm.cpp	/^  int n;$/;"	m	struct:Blossom	typeref:typename:int	file:
n	code-library/Graph Theory/Chinese Postman Problem.cpp	/^  int n, top;$/;"	m	struct:RandomizedMatching	typeref:typename:int	file:
n	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^  int n;$/;"	m	struct:ChromaticPolynomial	typeref:typename:int	file:
n	code-library/Graph Theory/DAG Reachability Dynamic.cpp	/^  int n;$/;"	m	struct:Italiano	typeref:typename:int	file:
n	code-library/Graph Theory/Dijkstra.cpp	/^int n, m;$/;"	v	typeref:typename:int
n	code-library/Graph Theory/Dinics Algorithm.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
n	code-library/Graph Theory/Dynamic MST.cpp	/^int n, m, q;$/;"	v	typeref:typename:int
n	code-library/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  int n;$/;"	m	struct:EdgeColoring	typeref:typename:int	file:
n	code-library/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^int n, m, bel[N * 4];$/;"	v	typeref:typename:int
n	code-library/Graph Theory/HopCroft Karp Algorithm.cpp	/^  int n;$/;"	m	struct:HopcroftKarp	typeref:typename:int	file:
n	code-library/Graph Theory/Hungarian Algorithm.cpp	/^  int start, finish, n;$/;"	m	struct:Hungarian	typeref:typename:int	file:
n	code-library/Graph Theory/Inverse Graph.cpp	/^int par[N], col[N], vis[N], ty[N], n;$/;"	v	typeref:typename:int
n	code-library/Graph Theory/Kuhns Algorithm.cpp	/^  int n;$/;"	m	struct:Kuhn	typeref:typename:int	file:
n	code-library/Graph Theory/L R Flow with Dinic.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
n	code-library/Graph Theory/L R Flow with Dinic.cpp	/^  int n, s, t;$/;"	m	struct:LR_Flow	typeref:typename:int	file:
n	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  int n, s, t, mxid;$/;"	m	struct:MCMF	typeref:typename:int	file:
n	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  int n, s, t;$/;"	m	struct:LR_Flow	typeref:typename:int	file:
n	code-library/Graph Theory/Manhattan MST.cpp	/^int n;$/;"	v	typeref:typename:int
n	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
n	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  int n;$/;"	m	struct:MaximumClosure	typeref:typename:int	file:
n	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
n	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^int s, t, n, m, u[N], v[N], deg[N];$/;"	v	typeref:typename:int
n	code-library/Graph Theory/Maximum Independant Set.cpp	/^int g[N][N], n;$/;"	v	typeref:typename:int
n	code-library/Graph Theory/Min Cost Max Flow.cpp	/^  int n, s, t, mxid;$/;"	m	struct:MCMF	typeref:typename:int	file:
n	code-library/Graph Theory/Min Cut in a Planar Graph.cpp	/^int n, s, t, a[N];$/;"	v	typeref:typename:int
n	code-library/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^int n, m, U[M], V[M], id[N], par[N];$/;"	v	typeref:typename:int
n	code-library/Graph Theory/Online Articulation Bridges.cpp	/^int n, bridges, par[N], bl[N], comp[N], sz[N];$/;"	v	typeref:typename:int
n	code-library/Graph Theory/Prufer Code.cpp	/^int n;$/;"	v	typeref:typename:int
n	code-library/Graph Theory/Randomized Matching Unweighted.cpp	/^  int n, match[N], vis[N], T = 0;$/;"	m	struct:RandomizedMatching	typeref:typename:int	file:
n	code-library/Graph Theory/Randomized Matching Weighted.cpp	/^	int n, top;$/;"	m	struct:RandomizedMatching	typeref:typename:int	file:
n	code-library/Graph Theory/Steiner Tree Problem.cpp	/^int n, k, m;$/;"	v	typeref:typename:int
n	code-library/Graph Theory/Stoer Wagner Algorithm.cpp	/^  int n;$/;"	m	struct:StoerWagner	typeref:typename:int	file:
n	code-library/Graph Theory/Tree Isomorphism.cpp	/^  int n;$/;"	m	struct:Tree	typeref:typename:int	file:
n	code-library/Graph Theory/Unique Min Cut.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
n	code-library/Math/All Possible Perfect Matching XOR Values.cpp	/^int a[N][N], p[N], n, vis[N];$/;"	v	typeref:typename:int
n	code-library/Math/Determinant of Sparse Matrix.cpp	/^  int n, m;$/;"	m	struct:Mat	typeref:typename:int	file:
n	code-library/Math/FWHT in Any Base.cpp	/^    int a[MXK][MXK], n, m;$/;"	m	struct:FWHT::Matrix	typeref:typename:int	file:
n	code-library/Math/Faulhaber Formula Fastest.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:int	file:
n	code-library/Math/Freivalds Algorithm.cpp	/^  int n, m;$/;"	m	struct:Mat	typeref:typename:int	file:
n	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:int	file:
n	code-library/Math/Matrix Exponentiation.cpp	/^  int n, m;$/;"	m	struct:Mat	typeref:typename:int	file:
n	code-library/Math/Permanent of a Matrix.cpp	/^int n, a[N][N];$/;"	v	typeref:typename:int
n	code-library/Math/Polynomial Sum.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:int	file:
n	code-library/Math/Simplex Algorithm.cpp	/^  int m, n, solution_flag, minmax_flag, basis[MAXC], index[MAXV];$/;"	v	namespace:lp	typeref:typename:int
n	code-library/Math/Simplex Algorithm.cpp	/^ll n,k,a[N],dis[N][N];$/;"	v	typeref:typename:ll
n	code-library/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^int n, m, tot, col[N], where[N], par[N];$/;"	v	typeref:typename:int
n	code-library/Miscellaneous/Schreier–Sims algorithm.cpp	/^  int n, m;$/;"	m	struct:Group	typeref:typename:int	file:
n	code-library/Number Theory/Combinatorics Basics.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:int	file:
n	code-library/Number Theory/Linear Diophantine Equation with Nonnegative Solutions.cpp	/^  int n, x;$/;"	m	struct:LDE	typeref:typename:int	file:
n	code-library/Number Theory/Lucas Theorem.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:int	file:
n	code-library/Number Theory/Min_25 Sieve.cpp	/^ll n;$/;"	v	typeref:typename:ll
n	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:int	file:
n	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:int	file:
n	code-library/Number Theory/Prime Factorization Fastest.cpp	/^  uint64_t n;$/;"	m	struct:Mint	typeref:typename:uint64_t	file:
n	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:int	file:
n	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  int n;$/;"	m	struct:Kuhn	typeref:typename:int	file:
n	code-library/Strings/Prefix Automaton.cpp	/^int n, m;$/;"	v	typeref:typename:int
n	code-library/Strings/String Hashing 2D.cpp	/^  int n, m;$/;"	m	struct:Hashing	typeref:typename:int	file:
n	code-library/Strings/String Hashing.cpp	/^  int n;$/;"	m	struct:Hashing	typeref:typename:int	file:
n	code-library/Strings/Suffix Array Isomorphic.cpp	/^  int n;$/;"	m	struct:IsomorphicSuffixArray	typeref:typename:int	file:
n	code-library/Strings/Suffix Array Isomorphic.cpp	/^  int n;$/;"	m	struct:SuffixArray	typeref:typename:int	file:
n	code-library/Strings/Suffix Array.cpp	/^  int n;$/;"	m	struct:SuffixArray	typeref:typename:int	file:
n	code/Data Structures/BIT.cpp	/^  int n; vector<T> t;$/;"	m	struct:BIT	typeref:typename:int	file:
n	code/Data Structures/Cartesian Tree.cpp	/^int n, tot, st[N], l[N], r[N], vis[N];$/;"	v	typeref:typename:int
n	code/Data Structures/Disjoint Sparse Table.cpp	/^  int k, n;$/;"	m	struct:DST	typeref:typename:int	file:
n	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int n;$/;"	v	typeref:typename:int
n	code/Data Structures/HLD.cpp	/^int n;$/;"	v	typeref:typename:int
n	code/Data Structures/KD Tree.cpp	/^int tests, n;$/;"	v	typeref:typename:int
n	code/Data Structures/MOs with DSU.cpp	/^int n, ed, m;$/;"	v	typeref:typename:int
n	code/Data Structures/Persistent Array.cpp	/^  int n = 1;$/;"	m	struct:PersistentArray	typeref:typename:int	file:
n	code/Data Structures/Persistent Queue.cpp	/^  int n = 1;$/;"	m	struct:PersistentArray	typeref:typename:int	file:
n	code/Data Structures/Persistent UnionFind.cpp	/^  int n = 1;$/;"	m	struct:PersistentArray	typeref:typename:int	file:
n	code/Data Structures/Reachability Tree.cpp	/^  int n, par[2 * N], sp[LG + 1][2 * N], val[2 * N], rid[2 * N];$/;"	m	struct:RT	typeref:typename:int	file:
n	code/Data Structures/SQRT Tree.cpp	/^  int n, llg, indexSz;$/;"	m	struct:SqrtTree	typeref:typename:int	file:
n	code/Data Structures/Segment Tree Beats.cpp	/^  int n, n0;$/;"	m	struct:SGTBeats	typeref:typename:int	file:
n	code/Data Structures/Segment Tree Merging.cpp	/^int n, q, a[N];$/;"	v	typeref:typename:int
n	code/Data Structures/Segment Tree NonRecursive.cpp	/^int n, a[N];$/;"	v	typeref:typename:int
n	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^int n;$/;"	v	typeref:typename:int
n	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^int n, T;$/;"	v	typeref:typename:int
n	code/Dynamic Programming Optimizations/1D1D DP.cpp	/^int n, s, t[N], f[N];$/;"	v	typeref:typename:int
n	code/Dynamic Programming Optimizations/Connected Component DP.cpp	/^int n, k, a[N], dp[N][N][1005][3];$/;"	v	typeref:typename:int
n	code/Dynamic Programming Optimizations/Knuth Optimization.cpp	/^int n, k;$/;"	v	typeref:typename:int
n	code/Game Theory/Green Hackenbush.cpp	/^int n, T, low[N], dis[N];$/;"	v	typeref:typename:int
n	code/Game Theory/Matching Game On A Graph.cpp	/^  int n;$/;"	m	struct:Blossom	typeref:typename:int	file:
n	code/Geometry/Geometry 2D.cpp	/^    int n;$/;"	m	struct:CircleUnion	typeref:typename:int	file:
n	code/Geometry/Geometry 3D.cpp	/^    int n; \/\/ initial vertex number$/;"	m	struct:CH3D	typeref:typename:int	file:
n	code/Geometry/Geometry 3D.cpp	/^    p3 n; double d; \/\/ (n | p) = d$/;"	m	struct:plane	typeref:typename:p3	file:
n	code/Graph Theory/2 SAT.cpp	/^  int n;  \/\/ total size combining +, -. must be even.$/;"	m	struct:twosat	typeref:typename:int	file:
n	code/Graph Theory/3 SAT.cpp	/^  int n;$/;"	m	struct:SAT_GOD	typeref:typename:int	file:
n	code/Graph Theory/Articulation Bridges.cpp	/^  int n, k;$/;"	m	struct:TECC	typeref:typename:int	file:
n	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  int n, n_x, match[N * 2], slack[N * 2], st[N * 2], pa[N * 2], flower_from[N * 2][N * 2], S[N */;"	m	struct:Blossom	typeref:typename:int	file:
n	code/Graph Theory/Blossom Algorithm.cpp	/^  int n;$/;"	m	struct:Blossom	typeref:typename:int	file:
n	code/Graph Theory/Chinese Postman Problem.cpp	/^  int n, top;$/;"	m	struct:RandomizedMatching	typeref:typename:int	file:
n	code/Graph Theory/Chromatic Polynoimial.cpp	/^  int n;$/;"	m	struct:ChromaticPolynomial	typeref:typename:int	file:
n	code/Graph Theory/DAG Reachability Dynamic.cpp	/^  int n;$/;"	m	struct:Italiano	typeref:typename:int	file:
n	code/Graph Theory/Dijkstra.cpp	/^int n, m;$/;"	v	typeref:typename:int
n	code/Graph Theory/Dinics Algorithm.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
n	code/Graph Theory/Dynamic MST.cpp	/^int n, m, q;$/;"	v	typeref:typename:int
n	code/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  int n;$/;"	m	struct:EdgeColoring	typeref:typename:int	file:
n	code/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^int n, m, bel[N * 4];$/;"	v	typeref:typename:int
n	code/Graph Theory/HopCroft Karp Algorithm.cpp	/^  int n;$/;"	m	struct:HopcroftKarp	typeref:typename:int	file:
n	code/Graph Theory/Hungarian Algorithm.cpp	/^  int start, finish, n;$/;"	m	struct:Hungarian	typeref:typename:int	file:
n	code/Graph Theory/Inverse Graph.cpp	/^int par[N], col[N], vis[N], ty[N], n;$/;"	v	typeref:typename:int
n	code/Graph Theory/Kuhns Algorithm.cpp	/^  int n;$/;"	m	struct:Kuhn	typeref:typename:int	file:
n	code/Graph Theory/L R Flow with Dinic.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
n	code/Graph Theory/L R Flow with Dinic.cpp	/^  int n, s, t;$/;"	m	struct:LR_Flow	typeref:typename:int	file:
n	code/Graph Theory/L R Flow with MCMF.cpp	/^  int n, s, t, mxid;$/;"	m	struct:MCMF	typeref:typename:int	file:
n	code/Graph Theory/L R Flow with MCMF.cpp	/^  int n, s, t;$/;"	m	struct:LR_Flow	typeref:typename:int	file:
n	code/Graph Theory/Manhattan MST.cpp	/^int n;$/;"	v	typeref:typename:int
n	code/Graph Theory/Maximum Closure Problem.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
n	code/Graph Theory/Maximum Closure Problem.cpp	/^  int n;$/;"	m	struct:MaximumClosure	typeref:typename:int	file:
n	code/Graph Theory/Maximum Density Subgraph.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
n	code/Graph Theory/Maximum Density Subgraph.cpp	/^int s, t, n, m, u[N], v[N], deg[N];$/;"	v	typeref:typename:int
n	code/Graph Theory/Maximum Independant Set.cpp	/^int g[N][N], n;$/;"	v	typeref:typename:int
n	code/Graph Theory/Min Cost Max Flow.cpp	/^  int n, s, t, mxid;$/;"	m	struct:MCMF	typeref:typename:int	file:
n	code/Graph Theory/Min Cut in a Planar Graph.cpp	/^int n, s, t, a[N];$/;"	v	typeref:typename:int
n	code/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^int n, m, U[M], V[M], id[N], par[N];$/;"	v	typeref:typename:int
n	code/Graph Theory/Online Articulation Bridges.cpp	/^int n, bridges, par[N], bl[N], comp[N], sz[N];$/;"	v	typeref:typename:int
n	code/Graph Theory/Prufer Code.cpp	/^int n;$/;"	v	typeref:typename:int
n	code/Graph Theory/Randomized Matching Unweighted.cpp	/^  int n, match[N], vis[N], T = 0;$/;"	m	struct:RandomizedMatching	typeref:typename:int	file:
n	code/Graph Theory/Randomized Matching Weighted.cpp	/^	int n, top;$/;"	m	struct:RandomizedMatching	typeref:typename:int	file:
n	code/Graph Theory/Steiner Tree Problem.cpp	/^int n, k, m;$/;"	v	typeref:typename:int
n	code/Graph Theory/Stoer Wagner Algorithm.cpp	/^  int n;$/;"	m	struct:StoerWagner	typeref:typename:int	file:
n	code/Graph Theory/Tree Isomorphism.cpp	/^  int n;$/;"	m	struct:Tree	typeref:typename:int	file:
n	code/Graph Theory/Unique Min Cut.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
n	code/Math/All Possible Perfect Matching XOR Values.cpp	/^int a[N][N], p[N], n, vis[N];$/;"	v	typeref:typename:int
n	code/Math/Determinant of Sparse Matrix.cpp	/^  int n, m;$/;"	m	struct:Mat	typeref:typename:int	file:
n	code/Math/FWHT in Any Base.cpp	/^    int a[MXK][MXK], n, m;$/;"	m	struct:FWHT::Matrix	typeref:typename:int	file:
n	code/Math/Faulhaber Formula Fastest.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:int	file:
n	code/Math/Freivalds Algorithm.cpp	/^  int n, m;$/;"	m	struct:Mat	typeref:typename:int	file:
n	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:int	file:
n	code/Math/Matrix Exponentiation.cpp	/^  int n, m;$/;"	m	struct:Mat	typeref:typename:int	file:
n	code/Math/Permanent of a Matrix.cpp	/^int n, a[N][N];$/;"	v	typeref:typename:int
n	code/Math/Polynomial Sum.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:int	file:
n	code/Math/Simplex Algorithm.cpp	/^  int m, n, solution_flag, minmax_flag, basis[MAXC], index[MAXV];$/;"	v	namespace:lp	typeref:typename:int
n	code/Math/Simplex Algorithm.cpp	/^ll n,k,a[N],dis[N][N];$/;"	v	typeref:typename:ll
n	code/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^int n, m, tot, col[N], where[N], par[N];$/;"	v	typeref:typename:int
n	code/Miscellaneous/Schreier–Sims algorithm.cpp	/^  int n, m;$/;"	m	struct:Group	typeref:typename:int	file:
n	code/Number Theory/Combinatorics Basics.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:int	file:
n	code/Number Theory/Linear Diophantine Equation with Nonnegative Solutions.cpp	/^  int n, x;$/;"	m	struct:LDE	typeref:typename:int	file:
n	code/Number Theory/Lucas Theorem.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:int	file:
n	code/Number Theory/Min_25 Sieve.cpp	/^ll n;$/;"	v	typeref:typename:ll
n	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:int	file:
n	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:int	file:
n	code/Number Theory/Prime Factorization Fastest.cpp	/^  uint64_t n;$/;"	m	struct:Mint	typeref:typename:uint64_t	file:
n	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:Combi	typeref:typename:int	file:
n	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  int n;$/;"	m	struct:Kuhn	typeref:typename:int	file:
n	code/Strings/Prefix Automaton.cpp	/^int n, m;$/;"	v	typeref:typename:int
n	code/Strings/String Hashing 2D.cpp	/^  int n, m;$/;"	m	struct:Hashing	typeref:typename:int	file:
n	code/Strings/String Hashing.cpp	/^  int n;$/;"	m	struct:Hashing	typeref:typename:int	file:
n	code/Strings/Suffix Array Isomorphic.cpp	/^  int n;$/;"	m	struct:IsomorphicSuffixArray	typeref:typename:int	file:
n	code/Strings/Suffix Array Isomorphic.cpp	/^  int n;$/;"	m	struct:SuffixArray	typeref:typename:int	file:
n	code/Strings/Suffix Array.cpp	/^  int n;$/;"	m	struct:SuffixArray	typeref:typename:int	file:
n	contests/Codeforces/1560/F1/main1.cpp	/^int t, n, k;$/;"	v	typeref:typename:int
n	practice/cf/DP/knap2.cpp	/^int n;$/;"	v	typeref:typename:int
n	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:int	file:
n	practice/cf/random/i_hate_math_problems/testing.cpp	/^  int n; vector<mint> facts, finvs, invs;$/;"	m	struct:combi	typeref:typename:int	file:
n	practice/cpbook/ch1/1.6/reallife/medium/01091/ac.cpp	/^int n, a[maxn], b[maxn];$/;"	v	typeref:typename:int
n	practice/usacoguide/gold/dsu/moocast/main.cpp	/^int n;$/;"	v	typeref:typename:int
n	practice/usacoguide/gold/dsu/wormhole/main.cpp	/^int n, m;$/;"	v	typeref:typename:int
n0	code-library/Data Structures/Segment Tree Beats.cpp	/^  int n, n0;$/;"	m	struct:SGTBeats	typeref:typename:int	file:
n0	code/Data Structures/Segment Tree Beats.cpp	/^  int n, n0;$/;"	m	struct:SGTBeats	typeref:typename:int	file:
nCr	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^  mint nCr(int n, int k) {$/;"	f	struct:ChromaticPolynomial	typeref:typename:mint	file:
nCr	code/Graph Theory/Chromatic Polynoimial.cpp	/^  mint nCr(int n, int k) {$/;"	f	struct:ChromaticPolynomial	typeref:typename:mint	file:
n_l	practice/cf/random/1700/testing.cpp	/^#define n_l /;"	d	file:
n_x	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  int n, n_x, match[N * 2], slack[N * 2], st[N * 2], pa[N * 2], flower_from[N * 2][N * 2], S[N */;"	m	struct:Blossom	typeref:typename:int	file:
n_x	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  int n, n_x, match[N * 2], slack[N * 2], st[N * 2], pa[N * 2], flower_from[N * 2][N * 2], S[N */;"	m	struct:Blossom	typeref:typename:int	file:
name	practice/cf/random/1700/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	s
name	practice/cf/random/1700/1618E/problem.json	/^{"name": "E. Singers' Tour", "group": "Codeforces - Codeforces Round #760 (Div. 3)", "url": "htt/;"	s
name	practice/cf/random/coloring/problem.json	/^{"name": "A. Dreamoon Likes Coloring", "group": "Codeforces - Codeforces Round #631 (Div. 1) - T/;"	s
name	practice/cf/random/diane/problem.json	/^{"name": "D. Diane", "group": "Codeforces - Codeforces Round #735 (Div. 2)", "url": "https:\/\/c/;"	s
name	practice/cf/random/pink/problem.json	/^{"name": "C. Pinkie Pie Eats Patty-cakes", "group": "Codeforces - Codeforces Round #662 (Div. 2)/;"	s
name	practice/cf/stuff/dec 20 2021/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	s
name	practice/usacoguide/gold/SP/dining/problem.json	/^{"name": "Problem 1. Fine Dining", "group": "USACO - USACO 2018 December Contest, Gold", "url": /;"	s
name	practice/usacoguide/gold/SP/visitfj/problem.json	/^{"name": "Problem 1. Why Did the Cow Cross the Road", "group": "USACO - USACO 2017 February Cont/;"	s
name	practice/usacoguide/gold/bfs/cownav/problem.json	/^{"name": "Problem 3. Cow Navigation", "group": "USACO - USACO 2017 January Contest, Gold", "url"/;"	s
name	practice/usacoguide/gold/bfs/swap/problem.json	/^{"name": "Swap Game", "group": "CSES - CSES Problem Set", "url": "https:\/\/cses.fi\/problemset\//;"	s
name	practice/usacoguide/gold/dsu/closing/problem.json	/^{"name": "Problem 2. Closing the Farm", "group": "USACO - USACO 2016 US Open Contest, Gold", "ur/;"	s
name	practice/usacoguide/gold/dsu/moocast/problem.json	/^{"name": "Problem 1. Moocast", "group": "USACO - USACO 2016 December Contest, Gold", "url": "htt/;"	s
name	practice/usacoguide/gold/dsu/mootube/problem.json	/^{"name": "Problem 1. MooTube", "group": "USACO - USACO 2018 January Contest, Gold", "url": "http/;"	s
name	practice/usacoguide/gold/dsu/tractor/problem.json	/^{"name": "Problem 2. Tractor", "group": "USACO - USACO 2013 February Contest, Silver", "url": "h/;"	s
name	practice/usacoguide/gold/dsu/wormhole/problem.json	/^{"name": "Problem 3. Wormhole Sort", "group": "USACO - USACO 2020 January Contest, Silver", "url/;"	s
name	practice/usacoguide/silver/idk/lirs/problem.json	/^{"name": "Problem 3. Liars and Truth Tellers", "group": "USACO - USACO 2013 January Contest, Bro/;"	s
name	practice/usacoguide/silver/idk/maze/problem.json	/^{"name": "Problem 1. Maze Tac Toe", "group": "USACO - USACO 2021 US Open, Silver", "url": "http:/;"	s
ncr	code-library/Math/Faulhaber Formula Fastest.cpp	/^  inline mint ncr(int n, int k) { return facts[n] * finvs[k] * finvs[n-k]; }$/;"	f	struct:combi	typeref:typename:mint	file:
ncr	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline mint ncr(int n, int k) { return facts[n] * finvs[k] * finvs[n-k]; }$/;"	f	struct:combi	typeref:typename:mint	file:
ncr	code-library/Math/NTT Online.cpp	/^int ncr(int n,int r) {$/;"	f	typeref:typename:int
ncr	code-library/Math/NTT.cpp	/^int ncr(int n, int r) {$/;"	f	typeref:typename:int
ncr	code-library/Math/Polynomial Sum.cpp	/^  inline mint ncr(int n, int k) { return n < k ? 0 : facts[n] * finvs[k] * finvs[n-k]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
ncr	code-library/Number Theory/Combinatorics Basics.cpp	/^  inline mint ncr(int n, int k) { return n < k or k < 0 ? 0 : facts[n] * finvs[k] * finvs[n-k]; /;"	f	struct:combi	typeref:typename:mint	file:
ncr	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^ll ncr[N][N], d[N][N]; \/\/ N > k1 + k2$/;"	v	typeref:typename:ll[][]
ncr	code-library/Number Theory/Lucas Theorem.cpp	/^  inline mint ncr(int n, int k) { return n < k or k < 0 ? 0 : facts[n] * finvs[k] * finvs[n-k]; /;"	f	struct:combi	typeref:typename:mint	file:
ncr	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline mint ncr(int n, int k) { return n < k ? 0 : facts[n] * finvs[k] * finvs[n-k]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
ncr	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline mint ncr(int n, int k) { return n < k ? 0 : facts[n] * finvs[k] * finvs[n-k]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
ncr	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  inline mint ncr(int n, int k) { return n < k ? 0 : facts[n] * finvs[k] * finvs[n-k]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
ncr	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^long long ncr[N][N], d[N][N]; \/\/ N > k1 + k2$/;"	v	typeref:typename:long long[][]
ncr	code-library/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^int ncr(int n, int k) {$/;"	f	typeref:typename:int
ncr	code-library/Number Theory/nCr Modulo Any Mod.cpp	/^int ncr(ll n, ll r, int m) {$/;"	f	typeref:typename:int
ncr	code-library/Number Theory/nCr Modulo Any Mod.cpp	/^int ncr(ll n, ll r, int p, int k) {$/;"	f	typeref:typename:int
ncr	code/Math/Faulhaber Formula Fastest.cpp	/^  inline mint ncr(int n, int k) { return facts[n] * finvs[k] * finvs[n-k]; }$/;"	f	struct:combi	typeref:typename:mint	file:
ncr	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline mint ncr(int n, int k) { return facts[n] * finvs[k] * finvs[n-k]; }$/;"	f	struct:combi	typeref:typename:mint	file:
ncr	code/Math/NTT Online.cpp	/^int ncr(int n,int r) {$/;"	f	typeref:typename:int
ncr	code/Math/NTT.cpp	/^int ncr(int n, int r) {$/;"	f	typeref:typename:int
ncr	code/Math/Polynomial Sum.cpp	/^  inline mint ncr(int n, int k) { return n < k ? 0 : facts[n] * finvs[k] * finvs[n-k]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
ncr	code/Number Theory/Combinatorics Basics.cpp	/^  inline mint ncr(int n, int k) { return n < k or k < 0 ? 0 : facts[n] * finvs[k] * finvs[n-k]; /;"	f	struct:combi	typeref:typename:mint	file:
ncr	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^ll ncr[N][N], d[N][N]; \/\/ N > k1 + k2$/;"	v	typeref:typename:ll[][]
ncr	code/Number Theory/Lucas Theorem.cpp	/^  inline mint ncr(int n, int k) { return n < k or k < 0 ? 0 : facts[n] * finvs[k] * finvs[n-k]; /;"	f	struct:combi	typeref:typename:mint	file:
ncr	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline mint ncr(int n, int k) { return n < k ? 0 : facts[n] * finvs[k] * finvs[n-k]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
ncr	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline mint ncr(int n, int k) { return n < k ? 0 : facts[n] * finvs[k] * finvs[n-k]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
ncr	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  inline mint ncr(int n, int k) { return n < k ? 0 : facts[n] * finvs[k] * finvs[n-k]; }$/;"	f	struct:Combi	typeref:typename:mint	file:
ncr	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^long long ncr[N][N], d[N][N]; \/\/ N > k1 + k2$/;"	v	typeref:typename:long long[][]
ncr	code/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^int ncr(int n, int k) {$/;"	f	typeref:typename:int
ncr	code/Number Theory/nCr Modulo Any Mod.cpp	/^int ncr(ll n, ll r, int m) {$/;"	f	typeref:typename:int
ncr	code/Number Theory/nCr Modulo Any Mod.cpp	/^int ncr(ll n, ll r, int p, int k) {$/;"	f	typeref:typename:int
ncr	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^  inline mint ncr(int n, int k) { return n < k or k < 0 ? 0 : facts[n] * finvs[k] * finvs[n-k]; /;"	f	struct:combi	typeref:typename:mint	file:
ncr	practice/cf/random/i_hate_math_problems/testing.cpp	/^  inline mint ncr(int n, int k) { return n < k or k < 0 ? 0 : facts[n] * finvs[k] * finvs[n-k]; /;"	f	struct:combi	typeref:typename:mint	file:
nearest_neighbor	code-library/Data Structures/KD Tree.cpp	/^void nearest_neighbor(node_ptr node, point q, long long &ans) {$/;"	f	typeref:typename:void
nearest_neighbor	code/Data Structures/KD Tree.cpp	/^void nearest_neighbor(node_ptr node, point q, long long &ans) {$/;"	f	typeref:typename:void
neg	code-library/Graph Theory/3 SAT.cpp	/^  vector<int> occ, pos, neg;$/;"	m	struct:SAT_GOD	typeref:typename:vector<int>	file:
neg	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  bool neg;$/;"	m	struct:MCMF	typeref:typename:bool	file:
neg	code-library/Graph Theory/Min Cost Max Flow.cpp	/^  bool neg;$/;"	m	struct:MCMF	typeref:typename:bool	file:
neg	code/Graph Theory/3 SAT.cpp	/^  vector<int> occ, pos, neg;$/;"	m	struct:SAT_GOD	typeref:typename:vector<int>	file:
neg	code/Graph Theory/L R Flow with MCMF.cpp	/^  bool neg;$/;"	m	struct:MCMF	typeref:typename:bool	file:
neg	code/Graph Theory/Min Cost Max Flow.cpp	/^  bool neg;$/;"	m	struct:MCMF	typeref:typename:bool	file:
new_node	code-library/Data Structures/Segment Tree Merging.cpp	/^  inline int new_node() {$/;"	f	struct:STM	typeref:typename:int	file:
new_node	code/Data Structures/Segment Tree Merging.cpp	/^  inline int new_node() {$/;"	f	struct:STM	typeref:typename:int	file:
next	code-library/Geometry/Delaunay Triangulation.cpp	/^    Q next() { return r() -> prev();}$/;"	f	struct:Quad	typeref:typename:Q	file:
next	code-library/Geometry/Voronoi Diagram.cpp	/^    Q next() { return r() -> prev();}$/;"	f	struct:Quad	typeref:typename:Q	file:
next	code-library/Strings/Aho Corasick.cpp	/^  vector <vector <int>> next;$/;"	m	struct:AC	typeref:typename:vector<vector<int>>	file:
next	code/Geometry/Delaunay Triangulation.cpp	/^    Q next() { return r() -> prev();}$/;"	f	struct:Quad	typeref:typename:Q	file:
next	code/Geometry/Voronoi Diagram.cpp	/^    Q next() { return r() -> prev();}$/;"	f	struct:Quad	typeref:typename:Q	file:
next	code/Strings/Aho Corasick.cpp	/^  vector <vector <int>> next;$/;"	m	struct:AC	typeref:typename:vector<vector<int>>	file:
nl	code-library/Data Structures/Disjoint Sparse Table.cpp	/^#define nl /;"	d	file:
nl	code-library/Data Structures/Implicit Treap.cpp	/^#define nl /;"	d	file:
nl	code-library/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^#define nl /;"	d	file:
nl	code-library/Dynamic Programming Optimizations/DP Over Divisors.cpp	/^#define nl /;"	d	file:
nl	code-library/Dynamic Programming Optimizations/Digit DP.cpp	/^#define nl /;"	d	file:
nl	code-library/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^#define nl /;"	d	file:
nl	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^#define nl /;"	d	file:
nl	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^#define nl /;"	d	file:
nl	code-library/Strings/Prefix Automaton.cpp	/^#define nl /;"	d	file:
nl	code/Data Structures/Disjoint Sparse Table.cpp	/^#define nl /;"	d	file:
nl	code/Data Structures/Implicit Treap.cpp	/^#define nl /;"	d	file:
nl	code/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^#define nl /;"	d	file:
nl	code/Dynamic Programming Optimizations/DP Over Divisors.cpp	/^#define nl /;"	d	file:
nl	code/Dynamic Programming Optimizations/Digit DP.cpp	/^#define nl /;"	d	file:
nl	code/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^#define nl /;"	d	file:
nl	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^#define nl /;"	d	file:
nl	code/Graph Theory/Counting Labeled Graphs.cpp	/^#define nl /;"	d	file:
nl	code/Strings/Prefix Automaton.cpp	/^#define nl /;"	d	file:
node	code-library/Data Structures/Binarizing a Tree.cpp	/^struct node {$/;"	s	file:
node	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^struct node {$/;"	s	file:
node	code-library/Data Structures/Dynamic Diameter Online.cpp	/^struct node {$/;"	s	file:
node	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    struct node$/;"	s	struct:PST	file:
node	code-library/Data Structures/Implicit Treap.cpp	/^    node() {$/;"	f	struct:treap::node	file:
node	code-library/Data Structures/Implicit Treap.cpp	/^    node(int _val) {$/;"	f	struct:treap::node	file:
node	code-library/Data Structures/Implicit Treap.cpp	/^  struct node {$/;"	s	struct:treap	file:
node	code-library/Data Structures/Link Cut Tree.cpp	/^  node() {}$/;"	f	struct:node	file:
node	code-library/Data Structures/Link Cut Tree.cpp	/^  node(int x) {$/;"	f	struct:node	file:
node	code-library/Data Structures/Link Cut Tree.cpp	/^struct node {$/;"	s	file:
node	code-library/Data Structures/Persistent Array.cpp	/^  struct node {$/;"	s	struct:PersistentArray	file:
node	code-library/Data Structures/Persistent Meldable Heap.cpp	/^    node(T val, int from, int to): sz(1), val(val), from(from), to(to) {}$/;"	f	struct:heap::node	file:
node	code-library/Data Structures/Persistent Meldable Heap.cpp	/^  struct node{$/;"	s	struct:heap	file:
node	code-library/Data Structures/Persistent Queue.cpp	/^  struct node {$/;"	s	struct:PersistentArray	file:
node	code-library/Data Structures/Persistent UnionFind.cpp	/^  struct node {$/;"	s	struct:PersistentArray	file:
node	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  node(int position, long long value) {$/;"	f	struct:node	file:
node	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^struct node {$/;"	s	file:
node	code-library/Data Structures/Segment Tree Merging.cpp	/^  struct node {$/;"	s	struct:STM	file:
node	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^  struct node {$/;"	s	struct:PST	file:
node	code-library/Data Structures/Segment Tree Persistent.cpp	/^  struct node {$/;"	s	struct:PST	file:
node	code-library/Data Structures/Treap persistent.cpp	/^  node() {}$/;"	f	struct:node	file:
node	code-library/Data Structures/Treap persistent.cpp	/^  node(int id) {$/;"	f	struct:node	file:
node	code-library/Data Structures/Treap persistent.cpp	/^struct node {$/;"	s	file:
node	code-library/Data Structures/Treap.cpp	/^  node(int id) {$/;"	f	struct:node	file:
node	code-library/Data Structures/Treap.cpp	/^struct node {$/;"	s	file:
node	code-library/Data Structures/Trie.cpp	/^    node() {$/;"	f	struct:Trie::node	file:
node	code-library/Data Structures/Trie.cpp	/^  struct node {$/;"	s	struct:Trie	file:
node	code-library/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  node(Line line) : line(line) {}$/;"	f	struct:node	file:
node	code-library/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^struct node {$/;"	s	file:
node	code-library/Geometry/Onion Decomposition.cpp	/^    struct node {$/;"	s	struct:LeftHull	file:
node	code-library/Graph Theory/Eppsteins Algorithm.cpp	/^    node(T val, int from, int to): sz(1), val(val), from(from), to(to) {}$/;"	f	struct:heap::node	file:
node	code-library/Graph Theory/Eppsteins Algorithm.cpp	/^  struct node{$/;"	s	struct:heap	file:
node	code-library/Graph Theory/Manhattan MST.cpp	/^struct node {$/;"	s	file:
node	code-library/Strings/Aho Corasick.cpp	/^  int node() {$/;"	f	struct:AC	typeref:typename:int	file:
node	code-library/Strings/Palindromic Tree Persistent.cpp	/^    node() {$/;"	f	struct:PalindromicTree::node	file:
node	code-library/Strings/Palindromic Tree Persistent.cpp	/^  struct node {$/;"	s	struct:PalindromicTree	file:
node	code-library/Strings/Palindromic Tree.cpp	/^  struct node {$/;"	s	struct:PalindromicTree	file:
node	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^struct node {$/;"	s	file:
node	code-library/Strings/Suffix Automaton.cpp	/^    struct node {$/;"	s	struct:SuffixAutomaton	file:
node	code/Data Structures/Binarizing a Tree.cpp	/^struct node {$/;"	s	file:
node	code/Data Structures/Centroid Decomposition Persistent.cpp	/^struct node {$/;"	s	file:
node	code/Data Structures/Dynamic Diameter Online.cpp	/^struct node {$/;"	s	file:
node	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    struct node$/;"	s	struct:PST	file:
node	code/Data Structures/Implicit Treap.cpp	/^    node() {$/;"	f	struct:treap::node	file:
node	code/Data Structures/Implicit Treap.cpp	/^    node(int _val) {$/;"	f	struct:treap::node	file:
node	code/Data Structures/Implicit Treap.cpp	/^  struct node {$/;"	s	struct:treap	file:
node	code/Data Structures/Link Cut Tree.cpp	/^  node() {}$/;"	f	struct:node	file:
node	code/Data Structures/Link Cut Tree.cpp	/^  node(int x) {$/;"	f	struct:node	file:
node	code/Data Structures/Link Cut Tree.cpp	/^struct node {$/;"	s	file:
node	code/Data Structures/Persistent Array.cpp	/^  struct node {$/;"	s	struct:PersistentArray	file:
node	code/Data Structures/Persistent Meldable Heap.cpp	/^    node(T val, int from, int to): sz(1), val(val), from(from), to(to) {}$/;"	f	struct:heap::node	file:
node	code/Data Structures/Persistent Meldable Heap.cpp	/^  struct node{$/;"	s	struct:heap	file:
node	code/Data Structures/Persistent Queue.cpp	/^  struct node {$/;"	s	struct:PersistentArray	file:
node	code/Data Structures/Persistent UnionFind.cpp	/^  struct node {$/;"	s	struct:PersistentArray	file:
node	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  node(int position, long long value) {$/;"	f	struct:node	file:
node	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^struct node {$/;"	s	file:
node	code/Data Structures/Segment Tree Merging.cpp	/^  struct node {$/;"	s	struct:STM	file:
node	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^  struct node {$/;"	s	struct:PST	file:
node	code/Data Structures/Segment Tree Persistent.cpp	/^  struct node {$/;"	s	struct:PST	file:
node	code/Data Structures/Treap persistent.cpp	/^  node() {}$/;"	f	struct:node	file:
node	code/Data Structures/Treap persistent.cpp	/^  node(int id) {$/;"	f	struct:node	file:
node	code/Data Structures/Treap persistent.cpp	/^struct node {$/;"	s	file:
node	code/Data Structures/Treap.cpp	/^  node(int id) {$/;"	f	struct:node	file:
node	code/Data Structures/Treap.cpp	/^struct node {$/;"	s	file:
node	code/Data Structures/Trie.cpp	/^    node() {$/;"	f	struct:Trie::node	file:
node	code/Data Structures/Trie.cpp	/^  struct node {$/;"	s	struct:Trie	file:
node	code/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  node(Line line) : line(line) {}$/;"	f	struct:node	file:
node	code/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^struct node {$/;"	s	file:
node	code/Geometry/Onion Decomposition.cpp	/^    struct node {$/;"	s	struct:LeftHull	file:
node	code/Graph Theory/Eppsteins Algorithm.cpp	/^    node(T val, int from, int to): sz(1), val(val), from(from), to(to) {}$/;"	f	struct:heap::node	file:
node	code/Graph Theory/Eppsteins Algorithm.cpp	/^  struct node{$/;"	s	struct:heap	file:
node	code/Graph Theory/Manhattan MST.cpp	/^struct node {$/;"	s	file:
node	code/Strings/Aho Corasick.cpp	/^  int node() {$/;"	f	struct:AC	typeref:typename:int	file:
node	code/Strings/Palindromic Tree Persistent.cpp	/^    node() {$/;"	f	struct:PalindromicTree::node	file:
node	code/Strings/Palindromic Tree Persistent.cpp	/^  struct node {$/;"	s	struct:PalindromicTree	file:
node	code/Strings/Palindromic Tree.cpp	/^  struct node {$/;"	s	struct:PalindromicTree	file:
node	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^struct node {$/;"	s	file:
node	code/Strings/Suffix Automaton.cpp	/^    struct node {$/;"	s	struct:SuffixAutomaton	file:
node_ptr	code-library/Data Structures/KD Tree.cpp	/^typedef kd_node* node_ptr;$/;"	t	typeref:typename:kd_node *	file:
node_ptr	code/Data Structures/KD Tree.cpp	/^typedef kd_node* node_ptr;$/;"	t	typeref:typename:kd_node *	file:
node_t	code-library/Data Structures/Persistent Trie.cpp	/^  node_t() : time(0) {$/;"	f	struct:node_t	file:
node_t	code-library/Data Structures/Persistent Trie.cpp	/^struct node_t {$/;"	s	file:
node_t	code/Data Structures/Persistent Trie.cpp	/^  node_t() : time(0) {$/;"	f	struct:node_t	file:
node_t	code/Data Structures/Persistent Trie.cpp	/^struct node_t {$/;"	s	file:
nodes	code-library/Geometry/Onion Decomposition.cpp	/^    vector<node> nodes;$/;"	m	struct:LeftHull	typeref:typename:vector<node>	file:
nodes	code-library/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  vector<int> nodes;$/;"	m	struct:Euler	typeref:typename:vector<int>	file:
nodes	code/Geometry/Onion Decomposition.cpp	/^    vector<node> nodes;$/;"	m	struct:LeftHull	typeref:typename:vector<node>	file:
nodes	code/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  vector<int> nodes;$/;"	m	struct:Euler	typeref:typename:vector<int>	file:
norm	code-library/Geometry/All Pair Segment Intersection.cpp	/^    double norm() {$/;"	f	struct:PT	typeref:typename:double	file:
norm	code-library/Geometry/Geometry 2D.cpp	/^    double norm() { return sqrt(x * x + y * y); }$/;"	f	struct:PT	typeref:typename:double	file:
norm	code-library/Geometry/Geometry 3D.cpp	/^    double norm() { return sqrt(x * x + y * y); }$/;"	f	struct:PT	typeref:typename:double	file:
norm	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    double norm() { return sqrt(x * x + y * y); }$/;"	f	struct:PT	typeref:typename:double	file:
norm	code-library/Geometry/Half Plane Intersection.cpp	/^    double norm() { return sqrt(x * x + y * y); }$/;"	f	struct:PT	typeref:typename:double	file:
norm	code-library/Geometry/Voronoi Diagram.cpp	/^    double norm() { return sqrt(x * x + y * y); }$/;"	f	struct:PT	typeref:typename:double	file:
norm	code/Geometry/All Pair Segment Intersection.cpp	/^    double norm() {$/;"	f	struct:PT	typeref:typename:double	file:
norm	code/Geometry/Geometry 2D.cpp	/^    double norm() { return sqrt(x * x + y * y); }$/;"	f	struct:PT	typeref:typename:double	file:
norm	code/Geometry/Geometry 3D.cpp	/^    double norm() { return sqrt(x * x + y * y); }$/;"	f	struct:PT	typeref:typename:double	file:
norm	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    double norm() { return sqrt(x * x + y * y); }$/;"	f	struct:PT	typeref:typename:double	file:
norm	code/Geometry/Half Plane Intersection.cpp	/^    double norm() { return sqrt(x * x + y * y); }$/;"	f	struct:PT	typeref:typename:double	file:
norm	code/Geometry/Voronoi Diagram.cpp	/^    double norm() { return sqrt(x * x + y * y); }$/;"	f	struct:PT	typeref:typename:double	file:
norm2	code-library/Geometry/All Pair Segment Intersection.cpp	/^    double norm2() {$/;"	f	struct:PT	typeref:typename:double	file:
norm2	code-library/Geometry/Delaunay Triangulation.cpp	/^    double norm2() { return x * x + y * y; }$/;"	f	struct:dPT	typeref:typename:double	file:
norm2	code-library/Geometry/Delaunay Triangulation.cpp	/^    long long norm2() { return x * x + y * y; }$/;"	f	struct:PT	typeref:typename:long long	file:
norm2	code-library/Geometry/Geometry 2D.cpp	/^    double norm2() { return x * x + y * y; }$/;"	f	struct:PT	typeref:typename:double	file:
norm2	code-library/Geometry/Geometry 3D.cpp	/^    double norm2() { return x * x + y * y; }$/;"	f	struct:PT	typeref:typename:double	file:
norm2	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    double norm2() { return x * x + y * y; }$/;"	f	struct:PT	typeref:typename:double	file:
norm2	code-library/Geometry/Half Plane Intersection.cpp	/^    double norm2() { return x * x + y * y; }$/;"	f	struct:PT	typeref:typename:double	file:
norm2	code-library/Geometry/Voronoi Diagram.cpp	/^    double norm2() { return x * x + y * y; }$/;"	f	struct:PT	typeref:typename:double	file:
norm2	code-library/Geometry/Voronoi Diagram.cpp	/^    long long norm2() { return x * x + y * y; }$/;"	f	struct:P	typeref:typename:long long	file:
norm2	code/Geometry/All Pair Segment Intersection.cpp	/^    double norm2() {$/;"	f	struct:PT	typeref:typename:double	file:
norm2	code/Geometry/Delaunay Triangulation.cpp	/^    double norm2() { return x * x + y * y; }$/;"	f	struct:dPT	typeref:typename:double	file:
norm2	code/Geometry/Delaunay Triangulation.cpp	/^    long long norm2() { return x * x + y * y; }$/;"	f	struct:PT	typeref:typename:long long	file:
norm2	code/Geometry/Geometry 2D.cpp	/^    double norm2() { return x * x + y * y; }$/;"	f	struct:PT	typeref:typename:double	file:
norm2	code/Geometry/Geometry 3D.cpp	/^    double norm2() { return x * x + y * y; }$/;"	f	struct:PT	typeref:typename:double	file:
norm2	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    double norm2() { return x * x + y * y; }$/;"	f	struct:PT	typeref:typename:double	file:
norm2	code/Geometry/Half Plane Intersection.cpp	/^    double norm2() { return x * x + y * y; }$/;"	f	struct:PT	typeref:typename:double	file:
norm2	code/Geometry/Voronoi Diagram.cpp	/^    double norm2() { return x * x + y * y; }$/;"	f	struct:PT	typeref:typename:double	file:
norm2	code/Geometry/Voronoi Diagram.cpp	/^    long long norm2() { return x * x + y * y; }$/;"	f	struct:P	typeref:typename:long long	file:
normalize	code-library/Math/Faulhaber Formula Fastest.cpp	/^  inline void normalize() {$/;"	f	struct:poly	typeref:typename:void	file:
normalize	code-library/Math/Polynomial.cpp	/^  inline void normalize() {$/;"	f	struct:poly	typeref:typename:void	file:
normalize	code-library/Math/Subset Sum Problem.cpp	/^  inline void normalize() {$/;"	f	struct:poly	typeref:typename:void	file:
normalize	code-library/Number Theory/Bell Number.cpp	/^    inline void normalize() {$/;"	f	struct:poly	typeref:typename:void	file:
normalize	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline void normalize() {$/;"	f	struct:poly	typeref:typename:void	file:
normalize	code/Math/Faulhaber Formula Fastest.cpp	/^  inline void normalize() {$/;"	f	struct:poly	typeref:typename:void	file:
normalize	code/Math/Polynomial.cpp	/^  inline void normalize() {$/;"	f	struct:poly	typeref:typename:void	file:
normalize	code/Math/Subset Sum Problem.cpp	/^  inline void normalize() {$/;"	f	struct:poly	typeref:typename:void	file:
normalize	code/Number Theory/Bell Number.cpp	/^    inline void normalize() {$/;"	f	struct:poly	typeref:typename:void	file:
normalize	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline void normalize() {$/;"	f	struct:poly	typeref:typename:void	file:
ntt	code-library/Math/NTT.cpp	/^void ntt(vector<int> &a, int typ) {$/;"	f	typeref:typename:void
ntt	code-library/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^void ntt(vector<int> &a, int typ) {$/;"	f	typeref:typename:void
ntt	code-library/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^void ntt(vector<int> &a, int typ) {$/;"	f	typeref:typename:void
ntt	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^void ntt(vector<int> &a, int typ) {$/;"	f	typeref:typename:void
ntt	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^namespace ntt {$/;"	n	file:
ntt	code-library/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^void ntt(vector<int> &a, int typ) {$/;"	f	typeref:typename:void
ntt	code/Math/NTT.cpp	/^void ntt(vector<int> &a, int typ) {$/;"	f	typeref:typename:void
ntt	code/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^void ntt(vector<int> &a, int typ) {$/;"	f	typeref:typename:void
ntt	code/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^void ntt(vector<int> &a, int typ) {$/;"	f	typeref:typename:void
ntt	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^void ntt(vector<int> &a, int typ) {$/;"	f	typeref:typename:void
ntt	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^namespace ntt {$/;"	n	file:
ntt	code/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^void ntt(vector<int> &a, int typ) {$/;"	f	typeref:typename:void
ntt_dit4	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^void ntt_dit4(mod_t* A, int n, int sign, mod_t* roots) {$/;"	f	namespace:ntt	typeref:typename:void
ntt_dit4	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^void ntt_dit4(mod_t* A, int n, int sign, mod_t* roots) {$/;"	f	namespace:ntt	typeref:typename:void
ntt_threshold	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static const int ntt_threshold = 900; \/\/ deg(f * g)$/;"	m	class:poly	typeref:typename:const int	file:
ntt_threshold	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static const int ntt_threshold = 900; \/\/ deg(f * g)$/;"	m	class:poly	typeref:typename:const int	file:
num	code-library/Geometry/Geometry 3D.cpp	/^    int num; \/\/ convex hull surface triangle number$/;"	m	struct:CH3D	typeref:typename:int	file:
num	code/Geometry/Geometry 3D.cpp	/^    int num; \/\/ convex hull surface triangle number$/;"	m	struct:CH3D	typeref:typename:int	file:
number_of_polygons	code-library/Geometry/Geometry 3D.cpp	/^    int number_of_polygons() {  \/\/ number of surface polygons$/;"	f	struct:CH3D	typeref:typename:int	file:
number_of_polygons	code/Geometry/Geometry 3D.cpp	/^    int number_of_polygons() {  \/\/ number of surface polygons$/;"	f	struct:CH3D	typeref:typename:int	file:
number_of_triangles	code-library/Geometry/Geometry 3D.cpp	/^    int number_of_triangles() { \/\/ number of surface triangles$/;"	f	struct:CH3D	typeref:typename:int	file:
number_of_triangles	code/Geometry/Geometry 3D.cpp	/^    int number_of_triangles() { \/\/ number of surface triangles$/;"	f	struct:CH3D	typeref:typename:int	file:
nw	code-library/Miscellaneous/Bitset Custom.cpp	/^Bitset<N> bs[101], nw, t;$/;"	v	typeref:typename:Bitset<N>
nw	code/Miscellaneous/Bitset Custom.cpp	/^Bitset<N> bs[101], nw, t;$/;"	v	typeref:typename:Bitset<N>
nxt	code-library/Data Structures/MOs Online.cpp	/^int nxt = 0;$/;"	v	typeref:typename:int
nxt	code-library/Data Structures/MOs with Update.cpp	/^int nxt = 0;$/;"	v	typeref:typename:int
nxt	code-library/Data Structures/Trie.cpp	/^    node* nxt[2];$/;"	m	struct:Trie::node	typeref:typename:node * [2]	file:
nxt	code-library/Geometry/Point Location.cpp	/^        edge* nxt = nullptr;$/;"	m	struct:DCEL::edge	typeref:typename:edge *	file:
nxt	code-library/Graph Theory/Three Edge Connectivity.cpp	/^  vector<int> nxt;$/;"	m	struct:Components	typeref:typename:vector<int>	file:
nxt	code-library/Strings/Palindromic Tree Persistent.cpp	/^    int nxt[A], len, st, en, link, cnt, oc, smart_link[A];$/;"	m	struct:PalindromicTree::node	typeref:typename:int[]	file:
nxt	code-library/Strings/Palindromic Tree.cpp	/^    int nxt[26], len, st, en, link, diff, slink, cnt, oc;$/;"	m	struct:PalindromicTree::node	typeref:typename:int[26]	file:
nxt	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  map<char, int> nxt;$/;"	m	struct:node	typeref:typename:map<char,int>	file:
nxt	code-library/Strings/Suffix Automaton.cpp	/^        map<char, int> nxt;$/;"	m	struct:SuffixAutomaton::node	typeref:typename:map<char,int>	file:
nxt	code/Data Structures/MOs Online.cpp	/^int nxt = 0;$/;"	v	typeref:typename:int
nxt	code/Data Structures/MOs with Update.cpp	/^int nxt = 0;$/;"	v	typeref:typename:int
nxt	code/Data Structures/Trie.cpp	/^    node* nxt[2];$/;"	m	struct:Trie::node	typeref:typename:node * [2]	file:
nxt	code/Geometry/Point Location.cpp	/^        edge* nxt = nullptr;$/;"	m	struct:DCEL::edge	typeref:typename:edge *	file:
nxt	code/Graph Theory/Three Edge Connectivity.cpp	/^  vector<int> nxt;$/;"	m	struct:Components	typeref:typename:vector<int>	file:
nxt	code/Strings/Palindromic Tree Persistent.cpp	/^    int nxt[A], len, st, en, link, cnt, oc, smart_link[A];$/;"	m	struct:PalindromicTree::node	typeref:typename:int[]	file:
nxt	code/Strings/Palindromic Tree.cpp	/^    int nxt[26], len, st, en, link, diff, slink, cnt, oc;$/;"	m	struct:PalindromicTree::node	typeref:typename:int[26]	file:
nxt	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  map<char, int> nxt;$/;"	m	struct:node	typeref:typename:map<char,int>	file:
nxt	code/Strings/Suffix Automaton.cpp	/^        map<char, int> nxt;$/;"	m	struct:SuffixAutomaton::node	typeref:typename:map<char,int>	file:
o	code-library/Geometry/Delaunay Triangulation.cpp	/^    bool mark; Q o, rot; PT p;$/;"	m	struct:Quad	typeref:typename:Q	file:
o	code-library/Geometry/Geometry 3D.cpp	/^    p3 d, o; \/\/ p = o + k * d$/;"	m	struct:line3d	typeref:typename:p3	file:
o	code-library/Geometry/Geometry 3D.cpp	/^    p3 o, dx, dy, dz;$/;"	m	struct:coords	typeref:typename:p3	file:
o	code-library/Geometry/Voronoi Diagram.cpp	/^    bool mark; Q o, rot; P p;$/;"	m	struct:Quad	typeref:typename:Q	file:
o	code-library/Miscellaneous/Bitset Custom.cpp	/^unsigned long long o[64][64], z[64][64];$/;"	v	typeref:typename:unsigned long long[64][64]
o	code/Geometry/Delaunay Triangulation.cpp	/^    bool mark; Q o, rot; PT p;$/;"	m	struct:Quad	typeref:typename:Q	file:
o	code/Geometry/Geometry 3D.cpp	/^    p3 d, o; \/\/ p = o + k * d$/;"	m	struct:line3d	typeref:typename:p3	file:
o	code/Geometry/Geometry 3D.cpp	/^    p3 o, dx, dy, dz;$/;"	m	struct:coords	typeref:typename:p3	file:
o	code/Geometry/Voronoi Diagram.cpp	/^    bool mark; Q o, rot; P p;$/;"	m	struct:Quad	typeref:typename:Q	file:
o	code/Miscellaneous/Bitset Custom.cpp	/^unsigned long long o[64][64], z[64][64];$/;"	v	typeref:typename:unsigned long long[64][64]
o_map	code-library/Data Structures/Ordered Set.cpp	/^template <typename T, typename R> using o_map = tree<T, R, less<T>, rb_tree_tag, tree_order_stat/;"	t	typeref:typename:tree<T,R,less<T>,rb_tree_tag,tree_order_statistics_node_update>	file:
o_map	code/Data Structures/Ordered Set.cpp	/^template <typename T, typename R> using o_map = tree<T, R, less<T>, rb_tree_tag, tree_order_stat/;"	t	typeref:typename:tree<T,R,less<T>,rb_tree_tag,tree_order_statistics_node_update>	file:
o_set	code-library/Data Structures/Ordered Set.cpp	/^template <typename T> using o_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statisti/;"	t	typeref:typename:tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>	file:
o_set	code-library/Number Theory/Factoradic Number System.cpp	/^template <typename T> using o_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statisti/;"	t	typeref:typename:tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>	file:
o_set	code/Data Structures/Ordered Set.cpp	/^template <typename T> using o_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statisti/;"	t	typeref:typename:tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>	file:
o_set	code/Number Theory/Factoradic Number System.cpp	/^template <typename T> using o_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statisti/;"	t	typeref:typename:tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>	file:
obj	code-library/Math/Simplex Algorithm.cpp	/^long double obj[N],cons[N];$/;"	v	typeref:typename:long double[]
obj	code/Math/Simplex Algorithm.cpp	/^long double obj[N],cons[N];$/;"	v	typeref:typename:long double[]
oc	code-library/Strings/Palindromic Tree Persistent.cpp	/^    int nxt[A], len, st, en, link, cnt, oc, smart_link[A];$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
oc	code-library/Strings/Palindromic Tree.cpp	/^    int nxt[26], len, st, en, link, diff, slink, cnt, oc;$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
oc	code-library/Strings/String Matching using Bitsets.cpp	/^bitset<N>bs[26], oc;$/;"	v	typeref:typename:bitset<N>
oc	code/Strings/Palindromic Tree Persistent.cpp	/^    int nxt[A], len, st, en, link, cnt, oc, smart_link[A];$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
oc	code/Strings/Palindromic Tree.cpp	/^    int nxt[26], len, st, en, link, diff, slink, cnt, oc;$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
oc	code/Strings/String Matching using Bitsets.cpp	/^bitset<N>bs[26], oc;$/;"	v	typeref:typename:bitset<N>
occ	code-library/Graph Theory/3 SAT.cpp	/^  vector<int> occ, pos, neg;$/;"	m	struct:SAT_GOD	typeref:typename:vector<int>	file:
occ	code/Graph Theory/3 SAT.cpp	/^  vector<int> occ, pos, neg;$/;"	m	struct:SAT_GOD	typeref:typename:vector<int>	file:
odd	code-library/Strings/Number of Palindromes in Range.cpp	/^int odd(int l, int r) {$/;"	f	typeref:typename:int
odd	code/Strings/Number of Palindromes in Range.cpp	/^int odd(int l, int r) {$/;"	f	typeref:typename:int
oddl	code-library/Strings/Number of Palindromes in Range.cpp	/^wavelet_tree oddl, oddr;$/;"	v	typeref:typename:wavelet_tree
oddl	code/Strings/Number of Palindromes in Range.cpp	/^wavelet_tree oddl, oddr;$/;"	v	typeref:typename:wavelet_tree
oddr	code-library/Strings/Number of Palindromes in Range.cpp	/^wavelet_tree oddl, oddr;$/;"	v	typeref:typename:wavelet_tree
oddr	code/Strings/Number of Palindromes in Range.cpp	/^wavelet_tree oddl, oddr;$/;"	v	typeref:typename:wavelet_tree
ok	code-library/Geometry/Geometry 3D.cpp	/^        bool ok;  \/\/ whether the face belongs to the face on the final convex hull$/;"	m	struct:CH3D::face	typeref:typename:bool	file:
ok	code-library/Graph Theory/2 SAT.cpp	/^  bool ok() {$/;"	f	struct:twosat	typeref:typename:bool	file:
ok	code-library/Graph Theory/3 SAT.cpp	/^  bool ok() {$/;"	f	struct:SAT_GOD	typeref:typename:bool	file:
ok	code-library/Graph Theory/Minimum Mean Weight Cycle.cpp	/^bool ok(int n, double x) {$/;"	f	typeref:typename:bool
ok	code-library/Math/BerleKamp Massey.cpp	/^int prime[] = {2, 3, 5, 7, 11, 13, 17, 19}, ok[20];$/;"	v	typeref:typename:int[20]
ok	code-library/Math/Simplex Algorithm.cpp	/^bool ok[N][N];$/;"	v	typeref:typename:bool[][]
ok	code/Geometry/Geometry 3D.cpp	/^        bool ok;  \/\/ whether the face belongs to the face on the final convex hull$/;"	m	struct:CH3D::face	typeref:typename:bool	file:
ok	code/Graph Theory/2 SAT.cpp	/^  bool ok() {$/;"	f	struct:twosat	typeref:typename:bool	file:
ok	code/Graph Theory/3 SAT.cpp	/^  bool ok() {$/;"	f	struct:SAT_GOD	typeref:typename:bool	file:
ok	code/Graph Theory/Minimum Mean Weight Cycle.cpp	/^bool ok(int n, double x) {$/;"	f	typeref:typename:bool
ok	code/Math/BerleKamp Massey.cpp	/^int prime[] = {2, 3, 5, 7, 11, 13, 17, 19}, ok[20];$/;"	v	typeref:typename:int[20]
ok	code/Math/Simplex Algorithm.cpp	/^bool ok[N][N];$/;"	v	typeref:typename:bool[][]
old	code-library/Data Structures/MOs with Update.cpp	/^  int pos, old, cur;$/;"	m	struct:upd	typeref:typename:int	file:
old	code/Data Structures/MOs with Update.cpp	/^  int pos, old, cur;$/;"	m	struct:upd	typeref:typename:int	file:
omega	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static Mod omega() { return Mod(prim_root).pow((mod - 1) >> level); }$/;"	f	class:ntt::Mod	typeref:typename:Mod	file:
omega	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static Mod omega() { return Mod(prim_root).pow((mod - 1) >> level); }$/;"	f	class:ntt::Mod	typeref:typename:Mod	file:
onLayer	code-library/Data Structures/SQRT Tree.cpp	/^  vector<int> clz, layers, onLayer;$/;"	m	struct:SqrtTree	typeref:typename:vector<int>	file:
onLayer	code/Data Structures/SQRT Tree.cpp	/^  vector<int> clz, layers, onLayer;$/;"	m	struct:SqrtTree	typeref:typename:vector<int>	file:
on_attach	init.lua	/^local on_attach = function(_, bufnr)$/;"	f
on_found_edge	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  inline bool on_found_edge(const edge &e) {$/;"	f	struct:Blossom	typeref:typename:bool	file:
on_found_edge	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  inline bool on_found_edge(const edge &e) {$/;"	f	struct:Blossom	typeref:typename:bool	file:
one_it	practice/usacoguide/gold/bfs/monsters.cpp	/^bool one_it = 0, possible = 0;$/;"	v	typeref:typename:bool
ook	practice/usacoguide/gold/introDP/711C.cpp	/^#define ook /;"	d	file:
op	code-library/Data Structures/DSU with Rollbacks.cpp	/^  vector<array<int, 3>> op;$/;"	m	struct:DSU	typeref:typename:vector<array<int,3>>	file:
op	code-library/Data Structures/Queue Undo Trick.cpp	/^  vector<array<int, 3>> op;$/;"	m	struct:DSU	typeref:typename:vector<array<int,3>>	file:
op	code-library/Data Structures/SQRT Tree.cpp	/^SqrtTreeItem op(const SqrtTreeItem &a, const SqrtTreeItem &b) {$/;"	f	typeref:typename:SqrtTreeItem
op	code/Data Structures/DSU with Rollbacks.cpp	/^  vector<array<int, 3>> op;$/;"	m	struct:DSU	typeref:typename:vector<array<int,3>>	file:
op	code/Data Structures/Queue Undo Trick.cpp	/^  vector<array<int, 3>> op;$/;"	m	struct:DSU	typeref:typename:vector<array<int,3>>	file:
op	code/Data Structures/SQRT Tree.cpp	/^SqrtTreeItem op(const SqrtTreeItem &a, const SqrtTreeItem &b) {$/;"	f	typeref:typename:SqrtTreeItem
operation	code-library/Data Structures/Implicit Treap.cpp	/^  void operation(pnode &t) {$/;"	f	struct:treap	typeref:typename:void	file:
operation	code/Data Structures/Implicit Treap.cpp	/^  void operation(pnode &t) {$/;"	f	struct:treap	typeref:typename:void	file:
operator !=	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Data Structures/KD Tree.cpp	/^  bool operator !=(const point &a) const {$/;"	f	struct:point	typeref:typename:bool	file:
operator !=	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Geometry/All Pair Segment Intersection.cpp	/^    bool operator != (PT a) const {$/;"	f	struct:PT	typeref:typename:bool	file:
operator !=	code-library/Geometry/Geometry 2D.cpp	/^    bool operator != (PT a) const { return !(*this == a); }$/;"	f	struct:PT	typeref:typename:bool	file:
operator !=	code-library/Geometry/Geometry 3D.cpp	/^    bool operator != (PT a) const { return !(*this == a); }$/;"	f	struct:PT	typeref:typename:bool	file:
operator !=	code-library/Geometry/Geometry 3D.cpp	/^    bool operator != (p3 a) const { return !(*this == a); }$/;"	f	struct:p3	typeref:typename:bool	file:
operator !=	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    bool operator != (PT a) const { return !(*this == a); }$/;"	f	struct:PT	typeref:typename:bool	file:
operator !=	code-library/Geometry/Half Plane Intersection.cpp	/^    bool operator != (PT a) const { return !(*this == a); }$/;"	f	struct:PT	typeref:typename:bool	file:
operator !=	code-library/Geometry/Voronoi Diagram.cpp	/^    bool operator != (PT a) const { return !(*this == a); }$/;"	f	struct:PT	typeref:typename:bool	file:
operator !=	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^    inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Graph Theory/Number of Arborescence.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Graph Theory/Number of DAG.cpp	/^    inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Graph Theory/Tree Isomorphism.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Math/BerleKamp Massey.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Math/Characteristic Polynomial Faster.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Math/Determinant of Sparse Matrix.cpp	/^  inline bool operator != (const Mat& b) { return a != b.a; }$/;"	f	struct:Mat	typeref:typename:bool	file:
operator !=	code-library/Math/Determinant of Sparse Matrix.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Math/FWHT in Ternary Base.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Math/Faulhaber Formula Fastest.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Math/Freivalds Algorithm.cpp	/^  inline bool operator != (const Mat& b) { return a != b.a; }$/;"	f	struct:Mat	typeref:typename:bool	file:
operator !=	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^    inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Math/Hafnian of a Matrix.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Math/Lagrange Interpolation Brute.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Math/Lagrange Interpolation.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Math/Linear Recurrence.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Math/Matrix Exponentiation.cpp	/^  inline bool operator != (const Mat& b) { return a != b.a; }$/;"	f	struct:Mat	typeref:typename:bool	file:
operator !=	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Math/Polynomial Sum.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Math/Polynomial.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Math/Subset Sum Problem.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Math/The Slime Trick.cpp	/^    inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Math/Thomas Algorithm.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Math/Vandermonde Matrix.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Miscellaneous/BigInt.cpp	/^  bool operator!=(const BigInt &v) const {$/;"	f	struct:BigInt	typeref:typename:bool	file:
operator !=	code-library/Number Theory/Bell Number.cpp	/^    inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Number Theory/Combinatorics Basics.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Number Theory/Dirichlet Convolution.cpp	/^    inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Number Theory/Lucas Theorem.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Number Theory/Min_25 Sieve.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Number Theory/Partition Function.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Number Theory/Phi Field.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Data Structures/KD Tree.cpp	/^  bool operator !=(const point &a) const {$/;"	f	struct:point	typeref:typename:bool	file:
operator !=	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Geometry/All Pair Segment Intersection.cpp	/^    bool operator != (PT a) const {$/;"	f	struct:PT	typeref:typename:bool	file:
operator !=	code/Geometry/Geometry 2D.cpp	/^    bool operator != (PT a) const { return !(*this == a); }$/;"	f	struct:PT	typeref:typename:bool	file:
operator !=	code/Geometry/Geometry 3D.cpp	/^    bool operator != (PT a) const { return !(*this == a); }$/;"	f	struct:PT	typeref:typename:bool	file:
operator !=	code/Geometry/Geometry 3D.cpp	/^    bool operator != (p3 a) const { return !(*this == a); }$/;"	f	struct:p3	typeref:typename:bool	file:
operator !=	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    bool operator != (PT a) const { return !(*this == a); }$/;"	f	struct:PT	typeref:typename:bool	file:
operator !=	code/Geometry/Half Plane Intersection.cpp	/^    bool operator != (PT a) const { return !(*this == a); }$/;"	f	struct:PT	typeref:typename:bool	file:
operator !=	code/Geometry/Voronoi Diagram.cpp	/^    bool operator != (PT a) const { return !(*this == a); }$/;"	f	struct:PT	typeref:typename:bool	file:
operator !=	code/Graph Theory/Chromatic Polynoimial.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Graph Theory/Counting Labeled Graphs.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Graph Theory/Hafnian of a Matrix.cpp	/^    inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Graph Theory/Number of Arborescence.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Graph Theory/Number of DAG.cpp	/^    inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Graph Theory/Tree Isomorphism.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Math/BerleKamp Massey.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Math/Characteristic Polynomial Faster.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Math/Determinant of Sparse Matrix.cpp	/^  inline bool operator != (const Mat& b) { return a != b.a; }$/;"	f	struct:Mat	typeref:typename:bool	file:
operator !=	code/Math/Determinant of Sparse Matrix.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Math/FWHT in Ternary Base.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Math/Faulhaber Formula Fastest.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Math/Freivalds Algorithm.cpp	/^  inline bool operator != (const Mat& b) { return a != b.a; }$/;"	f	struct:Mat	typeref:typename:bool	file:
operator !=	code/Math/Generating Function of a Linear Recurrence.cpp	/^    inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Math/Hafnian of a Matrix.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Math/Lagrange Interpolation Brute.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Math/Lagrange Interpolation.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Math/Linear Recurrence.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Math/Matrix Exponentiation.cpp	/^  inline bool operator != (const Mat& b) { return a != b.a; }$/;"	f	struct:Mat	typeref:typename:bool	file:
operator !=	code/Math/Number of Solutions of A Equation MITM.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Math/Polynomial Sum.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Math/Polynomial.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Math/Subset Sum Problem.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Math/The Slime Trick.cpp	/^    inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Math/Thomas Algorithm.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Math/Vandermonde Matrix.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Miscellaneous/BigInt.cpp	/^  bool operator!=(const BigInt &v) const {$/;"	f	struct:BigInt	typeref:typename:bool	file:
operator !=	code/Number Theory/Bell Number.cpp	/^    inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Number Theory/Combinatorics Basics.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Number Theory/Dirichlet Convolution.cpp	/^    inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Number Theory/Lucas Theorem.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Number Theory/Min_25 Sieve.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Number Theory/Partition Function.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Number Theory/Phi Field.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	code/modint.hpp	/^    friend bool operator!=(Mint const& a, Mint const& b) {return a.value != b.value;}$/;"	f	typeref:typename:bool
operator !=	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	practice/cf/random/i_hate_math_problems/testing.cpp	/^  inline bool operator != (modint<MOD> other) const { return value != other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator !=	practice/december2021/DP/counting_towers/sol.cpp	/^    friend bool operator!=(Modular const& a, Modular const& b) {return a.value != b.value;}$/;"	f	typeref:typename:bool	file:
operator %	code-library/Math/Determinant of Cyclic Matrix.cpp	/^Poly operator%(Poly a, const Poly &b) {$/;"	f	typeref:typename:Poly
operator %	code-library/Math/Determinant of Permutant Matrix.cpp	/^Poly operator%(Poly a, const Poly &b) {$/;"	f	typeref:typename:Poly
operator %	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly operator % (const poly &t) const {return divmod(t).second;}$/;"	f	struct:poly	typeref:typename:poly	file:
operator %	code-library/Math/Polynomial.cpp	/^  poly operator % (const poly &t) const {return divmod(t).second;}$/;"	f	struct:poly	typeref:typename:poly	file:
operator %	code-library/Miscellaneous/BigInt.cpp	/^  BigInt operator%(const BigInt &v) const {$/;"	f	struct:BigInt	typeref:typename:BigInt	file:
operator %	code-library/Miscellaneous/BigInt.cpp	/^  ll operator%(ll v) const {$/;"	f	struct:BigInt	typeref:typename:ll	file:
operator %	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^    friend u32 operator % (u64 n, fast_div d) { return n % d.m; }$/;"	f	class:poly	typeref:typename:u32	file:
operator %	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^    friend u64 operator % (u64 n, fast_div d) { return n - n \/ d * d.m; }$/;"	f	class:poly	typeref:typename:u64	file:
operator %	code/Math/Determinant of Cyclic Matrix.cpp	/^Poly operator%(Poly a, const Poly &b) {$/;"	f	typeref:typename:Poly
operator %	code/Math/Determinant of Permutant Matrix.cpp	/^Poly operator%(Poly a, const Poly &b) {$/;"	f	typeref:typename:Poly
operator %	code/Math/Faulhaber Formula Fastest.cpp	/^  poly operator % (const poly &t) const {return divmod(t).second;}$/;"	f	struct:poly	typeref:typename:poly	file:
operator %	code/Math/Polynomial.cpp	/^  poly operator % (const poly &t) const {return divmod(t).second;}$/;"	f	struct:poly	typeref:typename:poly	file:
operator %	code/Miscellaneous/BigInt.cpp	/^  BigInt operator%(const BigInt &v) const {$/;"	f	struct:BigInt	typeref:typename:BigInt	file:
operator %	code/Miscellaneous/BigInt.cpp	/^  ll operator%(ll v) const {$/;"	f	struct:BigInt	typeref:typename:ll	file:
operator %	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^    friend u32 operator % (u64 n, fast_div d) { return n % d.m; }$/;"	f	class:poly	typeref:typename:u32	file:
operator %	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^    friend u64 operator % (u64 n, fast_div d) { return n - n \/ d * d.m; }$/;"	f	class:poly	typeref:typename:u64	file:
operator %=	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly& operator %= (const poly &t) {return *this = divmod(t).second;}$/;"	f	struct:poly	typeref:typename:poly &	file:
operator %=	code-library/Math/Polynomial.cpp	/^  poly& operator %= (const poly &t) {return *this = divmod(t).second;}$/;"	f	struct:poly	typeref:typename:poly &	file:
operator %=	code/Math/Faulhaber Formula Fastest.cpp	/^  poly& operator %= (const poly &t) {return *this = divmod(t).second;}$/;"	f	struct:poly	typeref:typename:poly &	file:
operator %=	code/Math/Polynomial.cpp	/^  poly& operator %= (const poly &t) {return *this = divmod(t).second;}$/;"	f	struct:poly	typeref:typename:poly &	file:
operator &	code-library/Miscellaneous/Bitset Custom.cpp	/^    inline Bitset operator & (const Bitset &x) const {$/;"	f	struct:Bitset	typeref:typename:Bitset	file:
operator &	code/Miscellaneous/Bitset Custom.cpp	/^    inline Bitset operator & (const Bitset &x) const {$/;"	f	struct:Bitset	typeref:typename:Bitset	file:
operator ()	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^  size_t operator()(const pair<int, int>&x)const {$/;"	f	struct:HASH	typeref:typename:size_t	file:
operator ()	code/Data Structures/Dynamic Connectivity Problem.cpp	/^  size_t operator()(const pair<int, int>&x)const {$/;"	f	struct:HASH	typeref:typename:size_t	file:
operator () 	code-library/Data Structures/KD Tree.cpp	/^  bool operator () (const point &a, const point &b) const {$/;"	f	struct:cmp_points	typeref:typename:bool	file:
operator () 	code/Data Structures/KD Tree.cpp	/^  bool operator () (const point &a, const point &b) const {$/;"	f	struct:cmp_points	typeref:typename:bool	file:
operator *	code-library/Data Structures/Centroid Decomposition.cpp	/^  const base operator * (const base &c) const {$/;"	f	struct:base	typeref:typename:const base	file:
operator *	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value */;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Geometry/All Pair Segment Intersection.cpp	/^    PT operator * (const double a) const {$/;"	f	struct:PT	typeref:typename:PT	file:
operator *	code-library/Geometry/All Pair Segment Intersection.cpp	/^    friend PT operator * (const double &a, const PT &b) {$/;"	f	typeref:typename:PT	file:
operator *	code-library/Geometry/Delaunay Triangulation.cpp	/^    dPT operator * (const double a) const { return dPT(x * a, y * a); }$/;"	f	struct:dPT	typeref:typename:dPT	file:
operator *	code-library/Geometry/Geometry 2D.cpp	/^    PT operator * (const double a) const { return PT(x * a, y * a); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator *	code-library/Geometry/Geometry 2D.cpp	/^    friend PT operator * (const double &a, const PT &b) { return PT(a * b.x, a * b.y); }$/;"	f	typeref:typename:PT	file:
operator *	code-library/Geometry/Geometry 3D.cpp	/^    PT operator * (const double a) const { return PT(x * a, y * a); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator *	code-library/Geometry/Geometry 3D.cpp	/^    friend PT operator * (const double &a, const PT &b) { return PT(a * b.x, a * b.y); }$/;"	f	typeref:typename:PT	file:
operator *	code-library/Geometry/Geometry 3D.cpp	/^    friend p3 operator * (const double &a, const p3 &b) { return p3(a * b.x, a * b.y, a * b.z); /;"	f	typeref:typename:p3	file:
operator *	code-library/Geometry/Geometry 3D.cpp	/^    p3 operator * (const double a) const { return p3(x * a, y * a, z * a); }$/;"	f	struct:p3	typeref:typename:p3	file:
operator *	code-library/Geometry/Geometry 3D.cpp	/^p3 operator * (p3 v, p3 w) { \/\/cross product$/;"	f	typeref:typename:p3
operator *	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    PT operator * (const double a) const { return PT(x * a, y * a); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator *	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    friend PT operator * (const double &a, const PT &b) { return PT(a * b.x, a * b.y); }$/;"	f	typeref:typename:PT	file:
operator *	code-library/Geometry/Half Plane Intersection.cpp	/^    PT operator * (const double a) const { return PT(x * a, y * a); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator *	code-library/Geometry/Half Plane Intersection.cpp	/^    friend PT operator * (const double &a, const PT &b) { return PT(a * b.x, a * b.y); }$/;"	f	typeref:typename:PT	file:
operator *	code-library/Geometry/Voronoi Diagram.cpp	/^    PT operator * (const double a) const { return PT(x * a, y * a); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator *	code-library/Geometry/Voronoi Diagram.cpp	/^    friend PT operator * (const double &a, const PT &b) { return PT(a * b.x, a * b.y); }$/;"	f	typeref:typename:PT	file:
operator *	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^    inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value */;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Graph Theory/Number of Arborescence.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Graph Theory/Number of Arborescence.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Graph Theory/Number of Arborescence.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Graph Theory/Number of DAG.cpp	/^    inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value */;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Graph Theory/Number of DAG.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Graph Theory/Number of DAG.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^  const base operator * (const base &c) const {$/;"	f	struct:base	typeref:typename:const base	file:
operator *	code-library/Graph Theory/Tree Isomorphism.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Graph Theory/Tree Isomorphism.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Graph Theory/Tree Isomorphism.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/BerleKamp Massey.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Math/BerleKamp Massey.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/BerleKamp Massey.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Characteristic Polynomial Faster.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Math/Characteristic Polynomial Faster.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Characteristic Polynomial Faster.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Determinant of Sparse Matrix.cpp	/^  inline Mat operator * (const Mat &b) {$/;"	f	struct:Mat	typeref:typename:Mat	file:
operator *	code-library/Math/Determinant of Sparse Matrix.cpp	/^  inline Mat operator * (int k) {$/;"	f	struct:Mat	typeref:typename:Mat	file:
operator *	code-library/Math/Determinant of Sparse Matrix.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Math/Determinant of Sparse Matrix.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Determinant of Sparse Matrix.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/FFT.cpp	/^  const base operator * (const base &c) const$/;"	f	struct:base	typeref:typename:const base	file:
operator *	code-library/Math/FWHT in Any Base.cpp	/^  Matrix operator * (Matrix& p, Matrix& q) {$/;"	f	namespace:FWHT	typeref:typename:Matrix
operator *	code-library/Math/FWHT in Ternary Base.cpp	/^  cmplx operator*(cmplx x) {$/;"	f	struct:cmplx	typeref:typename:cmplx	file:
operator *	code-library/Math/FWHT in Ternary Base.cpp	/^  cmplx operator*(int k) { return cmplx(a * k, b * k); }$/;"	f	struct:cmplx	typeref:typename:cmplx	file:
operator *	code-library/Math/FWHT in Ternary Base.cpp	/^  cmplx operator*(mint k) { return cmplx(a * k, b * k); }$/;"	f	struct:cmplx	typeref:typename:cmplx	file:
operator *	code-library/Math/FWHT in Ternary Base.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Math/FWHT in Ternary Base.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/FWHT in Ternary Base.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Faulhaber Formula Fastest.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly operator * (const mint& x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator *	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly operator * (const poly& b) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator *	code-library/Math/Faulhaber Formula Fastest.cpp	/^inline base operator * (base a, base b) { return base(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b/;"	f	typeref:typename:base
operator *	code-library/Math/Faulhaber Formula Fastest.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Faulhaber Formula Fastest.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Freivalds Algorithm.cpp	/^  inline Mat operator * (const Mat &b) {$/;"	f	struct:Mat	typeref:typename:Mat	file:
operator *	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^    inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value */;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Hafnian of a Matrix.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Math/Hafnian of a Matrix.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Hafnian of a Matrix.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Lagrange Interpolation Brute.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Math/Lagrange Interpolation Brute.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Lagrange Interpolation Brute.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^inline base operator * (base a, base b) { return base(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b/;"	f	typeref:typename:base
operator *	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Lagrange Interpolation.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Math/Lagrange Interpolation.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Lagrange Interpolation.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Linear Recurrence Fastest.cpp	/^inline base operator * (base a, base b) { return base(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b/;"	f	typeref:typename:base
operator *	code-library/Math/Linear Recurrence.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Math/Linear Recurrence.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Linear Recurrence.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Matrix Exponentiation.cpp	/^  inline Mat operator * (const Mat &b) {$/;"	f	struct:Mat	typeref:typename:Mat	file:
operator *	code-library/Math/NTT Online.cpp	/^inline base operator * (base a, base b) { return base(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b/;"	f	typeref:typename:base
operator *	code-library/Math/NTT With Any Prime MOD.cpp	/^inline base operator * (base a, base b) { return base(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b/;"	f	typeref:typename:base
operator *	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^poly operator * (poly a, poly b) {$/;"	f	typeref:typename:poly
operator *	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Polynomial Sum.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Math/Polynomial Sum.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Polynomial Sum.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Polynomial with Binomial Coefficients.cpp	/^inline base operator * (base a, base b) { return base(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b/;"	f	typeref:typename:base
operator *	code-library/Math/Polynomial.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Math/Polynomial.cpp	/^  poly operator * (const mint& x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator *	code-library/Math/Polynomial.cpp	/^  poly operator * (const poly& b) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator *	code-library/Math/Polynomial.cpp	/^inline base operator * (base a, base b) { return base(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b/;"	f	typeref:typename:base
operator *	code-library/Math/Polynomial.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Polynomial.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Subset Sum Problem.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Math/Subset Sum Problem.cpp	/^  poly operator * (const mint& x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator *	code-library/Math/Subset Sum Problem.cpp	/^  poly operator * (const poly& b) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator *	code-library/Math/Subset Sum Problem.cpp	/^inline base operator * (base a, base b) { return base(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b/;"	f	typeref:typename:base
operator *	code-library/Math/Subset Sum Problem.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Subset Sum Problem.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/The Slime Trick.cpp	/^    inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value */;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Math/The Slime Trick.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/The Slime Trick.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Thomas Algorithm.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Math/Thomas Algorithm.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Thomas Algorithm.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Vandermonde Matrix.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Math/Vandermonde Matrix.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Math/Vandermonde Matrix.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Miscellaneous/BigInt.cpp	/^  BigInt operator*(const BigInt &v) const {$/;"	f	struct:BigInt	typeref:typename:BigInt	file:
operator *	code-library/Miscellaneous/BigInt.cpp	/^  BigInt operator*(int v) const {$/;"	f	struct:BigInt	typeref:typename:BigInt	file:
operator *	code-library/Miscellaneous/BigInt.cpp	/^  cplx operator*(const cplx &c) const {$/;"	f	struct:cplx	typeref:typename:cplx	file:
operator *	code-library/Miscellaneous/BigInt.cpp	/^  template<class U> cplx operator*(const U &c) const {$/;"	f	struct:cplx	typeref:typename:cplx	file:
operator *	code-library/Miscellaneous/Schreier–Sims algorithm.cpp	/^vector<int> operator * (vector<int>& a, vector<int>& b ){$/;"	f	typeref:typename:vector<int>
operator *	code-library/Number Theory/Bell Number.cpp	/^    inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value */;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Number Theory/Bell Number.cpp	/^    poly operator * (const mint& x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator *	code-library/Number Theory/Bell Number.cpp	/^    poly operator * (const poly& b) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator *	code-library/Number Theory/Bell Number.cpp	/^inline base operator * (base a, base b) { return base(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b/;"	f	typeref:typename:base
operator *	code-library/Number Theory/Bell Number.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Bell Number.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Combinatorics Basics.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Number Theory/Combinatorics Basics.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Combinatorics Basics.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Dirichlet Convolution.cpp	/^    inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value */;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Number Theory/Dirichlet Convolution.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Dirichlet Convolution.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Lucas Theorem.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Number Theory/Lucas Theorem.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Lucas Theorem.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Min_25 Sieve.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Number Theory/Min_25 Sieve.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Min_25 Sieve.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^poly operator * (poly a, poly b) {$/;"	f	typeref:typename:poly
operator *	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Partition Function.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Number Theory/Partition Function.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Partition Function.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Phi Field.cpp	/^  field operator * (const field &oth) const {$/;"	f	struct:field	typeref:typename:field	file:
operator *	code-library/Number Theory/Phi Field.cpp	/^  field operator * (const mint &oth) const {$/;"	f	struct:field	typeref:typename:field	file:
operator *	code-library/Number Theory/Phi Field.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Number Theory/Phi Field.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Phi Field.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Prime Factorization Fastest.cpp	/^  Mint& operator* (const Mint &x) const { return Mint(*this) *= x; }$/;"	f	struct:Mint	typeref:typename:Mint &	file:
operator *	code-library/Number Theory/Prime Number System.cpp	/^  base operator * (base p) {$/;"	f	struct:base	typeref:typename:base	file:
operator *	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value */;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly operator * (const mint& x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator *	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly operator * (const poly& b) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator *	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^inline base operator * (base a, base b) { return base(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b/;"	f	typeref:typename:base
operator *	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value */;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code-library/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^inline base operator * (base a, base b) { return base(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b/;"	f	typeref:typename:base
operator *	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  Mod operator * (Mod rhs) const { return Mod(*this) *= rhs; }$/;"	f	class:ntt::Mod	typeref:typename:Mod	file:
operator *	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly operator * (const poly& rhs) const { return this->mul(rhs); }$/;"	f	class:poly	typeref:typename:poly	file:
operator *	code-library/Strings/String Matching With FFT.cpp	/^  const base operator * (const base &c) const {$/;"	f	struct:base	typeref:typename:const base	file:
operator *	code/Data Structures/Centroid Decomposition.cpp	/^  const base operator * (const base &c) const {$/;"	f	struct:base	typeref:typename:const base	file:
operator *	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value */;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Geometry/All Pair Segment Intersection.cpp	/^    PT operator * (const double a) const {$/;"	f	struct:PT	typeref:typename:PT	file:
operator *	code/Geometry/All Pair Segment Intersection.cpp	/^    friend PT operator * (const double &a, const PT &b) {$/;"	f	typeref:typename:PT	file:
operator *	code/Geometry/Delaunay Triangulation.cpp	/^    dPT operator * (const double a) const { return dPT(x * a, y * a); }$/;"	f	struct:dPT	typeref:typename:dPT	file:
operator *	code/Geometry/Geometry 2D.cpp	/^    PT operator * (const double a) const { return PT(x * a, y * a); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator *	code/Geometry/Geometry 2D.cpp	/^    friend PT operator * (const double &a, const PT &b) { return PT(a * b.x, a * b.y); }$/;"	f	typeref:typename:PT	file:
operator *	code/Geometry/Geometry 3D.cpp	/^    PT operator * (const double a) const { return PT(x * a, y * a); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator *	code/Geometry/Geometry 3D.cpp	/^    friend PT operator * (const double &a, const PT &b) { return PT(a * b.x, a * b.y); }$/;"	f	typeref:typename:PT	file:
operator *	code/Geometry/Geometry 3D.cpp	/^    friend p3 operator * (const double &a, const p3 &b) { return p3(a * b.x, a * b.y, a * b.z); /;"	f	typeref:typename:p3	file:
operator *	code/Geometry/Geometry 3D.cpp	/^    p3 operator * (const double a) const { return p3(x * a, y * a, z * a); }$/;"	f	struct:p3	typeref:typename:p3	file:
operator *	code/Geometry/Geometry 3D.cpp	/^p3 operator * (p3 v, p3 w) { \/\/cross product$/;"	f	typeref:typename:p3
operator *	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    PT operator * (const double a) const { return PT(x * a, y * a); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator *	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    friend PT operator * (const double &a, const PT &b) { return PT(a * b.x, a * b.y); }$/;"	f	typeref:typename:PT	file:
operator *	code/Geometry/Half Plane Intersection.cpp	/^    PT operator * (const double a) const { return PT(x * a, y * a); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator *	code/Geometry/Half Plane Intersection.cpp	/^    friend PT operator * (const double &a, const PT &b) { return PT(a * b.x, a * b.y); }$/;"	f	typeref:typename:PT	file:
operator *	code/Geometry/Voronoi Diagram.cpp	/^    PT operator * (const double a) const { return PT(x * a, y * a); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator *	code/Geometry/Voronoi Diagram.cpp	/^    friend PT operator * (const double &a, const PT &b) { return PT(a * b.x, a * b.y); }$/;"	f	typeref:typename:PT	file:
operator *	code/Graph Theory/Chromatic Polynoimial.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Graph Theory/Chromatic Polynoimial.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Graph Theory/Chromatic Polynoimial.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Graph Theory/Counting Labeled Graphs.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Graph Theory/Counting Labeled Graphs.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Graph Theory/Counting Labeled Graphs.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Graph Theory/Hafnian of a Matrix.cpp	/^    inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value */;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Graph Theory/Hafnian of a Matrix.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Graph Theory/Hafnian of a Matrix.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Graph Theory/Number of Arborescence.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Graph Theory/Number of Arborescence.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Graph Theory/Number of Arborescence.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Graph Theory/Number of DAG.cpp	/^    inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value */;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Graph Theory/Number of DAG.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Graph Theory/Number of DAG.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^  const base operator * (const base &c) const {$/;"	f	struct:base	typeref:typename:const base	file:
operator *	code/Graph Theory/Tree Isomorphism.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Graph Theory/Tree Isomorphism.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Graph Theory/Tree Isomorphism.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/BerleKamp Massey.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Math/BerleKamp Massey.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/BerleKamp Massey.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Characteristic Polynomial Faster.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Math/Characteristic Polynomial Faster.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Characteristic Polynomial Faster.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Determinant of Sparse Matrix.cpp	/^  inline Mat operator * (const Mat &b) {$/;"	f	struct:Mat	typeref:typename:Mat	file:
operator *	code/Math/Determinant of Sparse Matrix.cpp	/^  inline Mat operator * (int k) {$/;"	f	struct:Mat	typeref:typename:Mat	file:
operator *	code/Math/Determinant of Sparse Matrix.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Math/Determinant of Sparse Matrix.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Determinant of Sparse Matrix.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/FFT.cpp	/^  const base operator * (const base &c) const$/;"	f	struct:base	typeref:typename:const base	file:
operator *	code/Math/FWHT in Any Base.cpp	/^  Matrix operator * (Matrix& p, Matrix& q) {$/;"	f	namespace:FWHT	typeref:typename:Matrix
operator *	code/Math/FWHT in Ternary Base.cpp	/^  cmplx operator*(cmplx x) {$/;"	f	struct:cmplx	typeref:typename:cmplx	file:
operator *	code/Math/FWHT in Ternary Base.cpp	/^  cmplx operator*(int k) { return cmplx(a * k, b * k); }$/;"	f	struct:cmplx	typeref:typename:cmplx	file:
operator *	code/Math/FWHT in Ternary Base.cpp	/^  cmplx operator*(mint k) { return cmplx(a * k, b * k); }$/;"	f	struct:cmplx	typeref:typename:cmplx	file:
operator *	code/Math/FWHT in Ternary Base.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Math/FWHT in Ternary Base.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/FWHT in Ternary Base.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Faulhaber Formula Fastest.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Math/Faulhaber Formula Fastest.cpp	/^  poly operator * (const mint& x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator *	code/Math/Faulhaber Formula Fastest.cpp	/^  poly operator * (const poly& b) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator *	code/Math/Faulhaber Formula Fastest.cpp	/^inline base operator * (base a, base b) { return base(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b/;"	f	typeref:typename:base
operator *	code/Math/Faulhaber Formula Fastest.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Faulhaber Formula Fastest.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Freivalds Algorithm.cpp	/^  inline Mat operator * (const Mat &b) {$/;"	f	struct:Mat	typeref:typename:Mat	file:
operator *	code/Math/Generating Function of a Linear Recurrence.cpp	/^    inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value */;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Math/Generating Function of a Linear Recurrence.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Generating Function of a Linear Recurrence.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Hafnian of a Matrix.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Math/Hafnian of a Matrix.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Hafnian of a Matrix.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Lagrange Interpolation Brute.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Math/Lagrange Interpolation Brute.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Lagrange Interpolation Brute.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^inline base operator * (base a, base b) { return base(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b/;"	f	typeref:typename:base
operator *	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Lagrange Interpolation.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Math/Lagrange Interpolation.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Lagrange Interpolation.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Linear Recurrence Fastest.cpp	/^inline base operator * (base a, base b) { return base(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b/;"	f	typeref:typename:base
operator *	code/Math/Linear Recurrence.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Math/Linear Recurrence.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Linear Recurrence.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Matrix Exponentiation.cpp	/^  inline Mat operator * (const Mat &b) {$/;"	f	struct:Mat	typeref:typename:Mat	file:
operator *	code/Math/NTT Online.cpp	/^inline base operator * (base a, base b) { return base(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b/;"	f	typeref:typename:base
operator *	code/Math/NTT With Any Prime MOD.cpp	/^inline base operator * (base a, base b) { return base(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b/;"	f	typeref:typename:base
operator *	code/Math/Number of Solutions of A Equation MITM.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Math/Number of Solutions of A Equation MITM.cpp	/^poly operator * (poly a, poly b) {$/;"	f	typeref:typename:poly
operator *	code/Math/Number of Solutions of A Equation MITM.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Number of Solutions of A Equation MITM.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Polynomial Sum.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Math/Polynomial Sum.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Polynomial Sum.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Polynomial with Binomial Coefficients.cpp	/^inline base operator * (base a, base b) { return base(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b/;"	f	typeref:typename:base
operator *	code/Math/Polynomial.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Math/Polynomial.cpp	/^  poly operator * (const mint& x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator *	code/Math/Polynomial.cpp	/^  poly operator * (const poly& b) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator *	code/Math/Polynomial.cpp	/^inline base operator * (base a, base b) { return base(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b/;"	f	typeref:typename:base
operator *	code/Math/Polynomial.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Polynomial.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Subset Sum Problem.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Math/Subset Sum Problem.cpp	/^  poly operator * (const mint& x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator *	code/Math/Subset Sum Problem.cpp	/^  poly operator * (const poly& b) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator *	code/Math/Subset Sum Problem.cpp	/^inline base operator * (base a, base b) { return base(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b/;"	f	typeref:typename:base
operator *	code/Math/Subset Sum Problem.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Subset Sum Problem.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/The Slime Trick.cpp	/^    inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value */;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Math/The Slime Trick.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/The Slime Trick.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Thomas Algorithm.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Math/Thomas Algorithm.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Thomas Algorithm.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Vandermonde Matrix.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Math/Vandermonde Matrix.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Math/Vandermonde Matrix.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Miscellaneous/BigInt.cpp	/^  BigInt operator*(const BigInt &v) const {$/;"	f	struct:BigInt	typeref:typename:BigInt	file:
operator *	code/Miscellaneous/BigInt.cpp	/^  BigInt operator*(int v) const {$/;"	f	struct:BigInt	typeref:typename:BigInt	file:
operator *	code/Miscellaneous/BigInt.cpp	/^  cplx operator*(const cplx &c) const {$/;"	f	struct:cplx	typeref:typename:cplx	file:
operator *	code/Miscellaneous/BigInt.cpp	/^  template<class U> cplx operator*(const U &c) const {$/;"	f	struct:cplx	typeref:typename:cplx	file:
operator *	code/Miscellaneous/Schreier–Sims algorithm.cpp	/^vector<int> operator * (vector<int>& a, vector<int>& b ){$/;"	f	typeref:typename:vector<int>
operator *	code/Number Theory/Bell Number.cpp	/^    inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value */;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Number Theory/Bell Number.cpp	/^    poly operator * (const mint& x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator *	code/Number Theory/Bell Number.cpp	/^    poly operator * (const poly& b) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator *	code/Number Theory/Bell Number.cpp	/^inline base operator * (base a, base b) { return base(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b/;"	f	typeref:typename:base
operator *	code/Number Theory/Bell Number.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Bell Number.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Combinatorics Basics.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Number Theory/Combinatorics Basics.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Combinatorics Basics.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Dirichlet Convolution.cpp	/^    inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value */;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Number Theory/Dirichlet Convolution.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Dirichlet Convolution.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Lucas Theorem.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Number Theory/Lucas Theorem.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Lucas Theorem.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Min_25 Sieve.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Number Theory/Min_25 Sieve.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Min_25 Sieve.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^poly operator * (poly a, poly b) {$/;"	f	typeref:typename:poly
operator *	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Partition Function.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Number Theory/Partition Function.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Partition Function.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Phi Field.cpp	/^  field operator * (const field &oth) const {$/;"	f	struct:field	typeref:typename:field	file:
operator *	code/Number Theory/Phi Field.cpp	/^  field operator * (const mint &oth) const {$/;"	f	struct:field	typeref:typename:field	file:
operator *	code/Number Theory/Phi Field.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Number Theory/Phi Field.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Phi Field.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Prime Factorization Fastest.cpp	/^  Mint& operator* (const Mint &x) const { return Mint(*this) *= x; }$/;"	f	struct:Mint	typeref:typename:Mint &	file:
operator *	code/Number Theory/Prime Number System.cpp	/^  base operator * (base p) {$/;"	f	struct:base	typeref:typename:base	file:
operator *	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value */;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly operator * (const mint& x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator *	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly operator * (const poly& b) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator *	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^inline base operator * (base a, base b) { return base(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b/;"	f	typeref:typename:base
operator *	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value */;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	code/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^inline base operator * (base a, base b) { return base(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b/;"	f	typeref:typename:base
operator *	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  Mod operator * (Mod rhs) const { return Mod(*this) *= rhs; }$/;"	f	class:ntt::Mod	typeref:typename:Mod	file:
operator *	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly operator * (const poly& rhs) const { return this->mul(rhs); }$/;"	f	class:poly	typeref:typename:poly	file:
operator *	code/Strings/String Matching With FFT.cpp	/^  const base operator * (const base &c) const {$/;"	f	struct:base	typeref:typename:const base	file:
operator *	code/modint.hpp	/^    friend Mint operator*(Mint a, Mint const b) { return a *= b; }$/;"	f	typeref:typename:Mint
operator *	practice/cf/random/1700/6.cpp	/^mi operator*(mi a, mi b) { return mi((long long) a.v * b.v); }$/;"	f	typeref:typename:mi
operator *	practice/cf/random/i_hate_math_problems/1422C.cpp	/^mi operator*(mi a, mi b) { return mi((ll)a.v*b.v); }$/;"	f	typeref:typename:mi
operator *	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	practice/cf/random/i_hate_math_problems/testing.cpp	/^  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * o/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator *	practice/cf/random/i_hate_math_problems/testing.cpp	/^template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	practice/cf/random/i_hate_math_problems/testing.cpp	/^template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD/;"	f	typeref:typename:modint<MOD>
operator *	practice/december2021/DP/counting_towers/sol.cpp	/^    friend Modular operator*(Modular a, Modular const b) { return a *= b; }$/;"	f	typeref:typename:Modular	file:
operator *	practice/usacoguide/gold/introDP/arraydescription.cpp	/^mi operator*(mi a, mi b) { return mi((ll)a.v*b.v); }$/;"	f	typeref:typename:mi
operator *=	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * /;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^    inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * /;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Graph Theory/Number of Arborescence.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Graph Theory/Number of DAG.cpp	/^    inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * /;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Graph Theory/Tree Isomorphism.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Math/BerleKamp Massey.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Math/Characteristic Polynomial Faster.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Math/Determinant of Sparse Matrix.cpp	/^  inline Mat& operator *= (const Mat& b) { return *this = (*this) * b; }$/;"	f	struct:Mat	typeref:typename:Mat &	file:
operator *=	code-library/Math/Determinant of Sparse Matrix.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Math/FWHT in Ternary Base.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Math/Faulhaber Formula Fastest.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly& operator *= (const mint &x) { return *this = (*this) * x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator *=	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly& operator *= (const poly &x) { return *this = (*this) * x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator *=	code-library/Math/Freivalds Algorithm.cpp	/^  inline Mat& operator *= (const Mat& b) { return *this = (*this) * b; }$/;"	f	struct:Mat	typeref:typename:Mat &	file:
operator *=	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^    inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * /;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Math/Hafnian of a Matrix.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Math/Lagrange Interpolation Brute.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Math/Lagrange Interpolation.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Math/Linear Recurrence.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Math/Matrix Exponentiation.cpp	/^  inline Mat& operator *= (const Mat& b) { return *this = (*this) * b; }$/;"	f	struct:Mat	typeref:typename:Mat &	file:
operator *=	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Math/Polynomial Sum.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Math/Polynomial.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Math/Polynomial.cpp	/^  poly& operator *= (const mint &x) { return *this = (*this) * x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator *=	code-library/Math/Polynomial.cpp	/^  poly& operator *= (const poly &x) { return *this = (*this) * x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator *=	code-library/Math/Subset Sum Problem.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Math/Subset Sum Problem.cpp	/^  poly& operator *= (const mint &x) { return *this = (*this) * x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator *=	code-library/Math/Subset Sum Problem.cpp	/^  poly& operator *= (const poly &x) { return *this = (*this) * x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator *=	code-library/Math/The Slime Trick.cpp	/^    inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * /;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Math/Thomas Algorithm.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Math/Vandermonde Matrix.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Miscellaneous/BigInt.cpp	/^  cplx& operator*=(const cplx &c) {$/;"	f	struct:cplx	typeref:typename:cplx &	file:
operator *=	code-library/Miscellaneous/BigInt.cpp	/^  void operator*=(const BigInt &v) {$/;"	f	struct:BigInt	typeref:typename:void	file:
operator *=	code-library/Miscellaneous/BigInt.cpp	/^  void operator*=(int v) {$/;"	f	struct:BigInt	typeref:typename:void	file:
operator *=	code-library/Number Theory/Bell Number.cpp	/^    inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * /;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Number Theory/Bell Number.cpp	/^    poly& operator *= (const mint &x) { return *this = (*this) * x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator *=	code-library/Number Theory/Bell Number.cpp	/^    poly& operator *= (const poly &x) { return *this = (*this) * x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator *=	code-library/Number Theory/Combinatorics Basics.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Number Theory/Dirichlet Convolution.cpp	/^    inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * /;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Number Theory/Lucas Theorem.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Number Theory/Min_25 Sieve.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Number Theory/Partition Function.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Number Theory/Phi Field.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Number Theory/Prime Factorization Fastest.cpp	/^  Mint& operator*= (const Mint &x) { n = reduce(__uint128_t(n) * x.n); return *this; }$/;"	f	struct:Mint	typeref:typename:Mint &	file:
operator *=	code-library/Number Theory/Prime Number System.cpp	/^  base& operator *= (base p) {$/;"	f	struct:base	typeref:typename:base &	file:
operator *=	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * /;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly& operator *= (const mint &x) { return *this = (*this) * x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator *=	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly& operator *= (const poly &x) { return *this = (*this) * x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator *=	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * /;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  Mod& operator *= (Mod rhs) { this->x = reduce(dword_t(this->x) * rhs.x); return *this; }$/;"	f	class:ntt::Mod	typeref:typename:Mod &	file:
operator *=	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly& operator *= (const poly& rhs) { return *this = *this * rhs; }$/;"	f	class:poly	typeref:typename:poly &	file:
operator *=	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * /;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Graph Theory/Chromatic Polynoimial.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Graph Theory/Counting Labeled Graphs.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Graph Theory/Hafnian of a Matrix.cpp	/^    inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * /;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Graph Theory/Number of Arborescence.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Graph Theory/Number of DAG.cpp	/^    inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * /;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Graph Theory/Tree Isomorphism.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Math/BerleKamp Massey.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Math/Characteristic Polynomial Faster.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Math/Determinant of Sparse Matrix.cpp	/^  inline Mat& operator *= (const Mat& b) { return *this = (*this) * b; }$/;"	f	struct:Mat	typeref:typename:Mat &	file:
operator *=	code/Math/Determinant of Sparse Matrix.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Math/FWHT in Ternary Base.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Math/Faulhaber Formula Fastest.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Math/Faulhaber Formula Fastest.cpp	/^  poly& operator *= (const mint &x) { return *this = (*this) * x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator *=	code/Math/Faulhaber Formula Fastest.cpp	/^  poly& operator *= (const poly &x) { return *this = (*this) * x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator *=	code/Math/Freivalds Algorithm.cpp	/^  inline Mat& operator *= (const Mat& b) { return *this = (*this) * b; }$/;"	f	struct:Mat	typeref:typename:Mat &	file:
operator *=	code/Math/Generating Function of a Linear Recurrence.cpp	/^    inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * /;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Math/Hafnian of a Matrix.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Math/Lagrange Interpolation Brute.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Math/Lagrange Interpolation.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Math/Linear Recurrence.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Math/Matrix Exponentiation.cpp	/^  inline Mat& operator *= (const Mat& b) { return *this = (*this) * b; }$/;"	f	struct:Mat	typeref:typename:Mat &	file:
operator *=	code/Math/Number of Solutions of A Equation MITM.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Math/Polynomial Sum.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Math/Polynomial.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Math/Polynomial.cpp	/^  poly& operator *= (const mint &x) { return *this = (*this) * x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator *=	code/Math/Polynomial.cpp	/^  poly& operator *= (const poly &x) { return *this = (*this) * x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator *=	code/Math/Subset Sum Problem.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Math/Subset Sum Problem.cpp	/^  poly& operator *= (const mint &x) { return *this = (*this) * x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator *=	code/Math/Subset Sum Problem.cpp	/^  poly& operator *= (const poly &x) { return *this = (*this) * x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator *=	code/Math/The Slime Trick.cpp	/^    inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * /;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Math/Thomas Algorithm.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Math/Vandermonde Matrix.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Miscellaneous/BigInt.cpp	/^  cplx& operator*=(const cplx &c) {$/;"	f	struct:cplx	typeref:typename:cplx &	file:
operator *=	code/Miscellaneous/BigInt.cpp	/^  void operator*=(const BigInt &v) {$/;"	f	struct:BigInt	typeref:typename:void	file:
operator *=	code/Miscellaneous/BigInt.cpp	/^  void operator*=(int v) {$/;"	f	struct:BigInt	typeref:typename:void	file:
operator *=	code/Number Theory/Bell Number.cpp	/^    inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * /;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Number Theory/Bell Number.cpp	/^    poly& operator *= (const mint &x) { return *this = (*this) * x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator *=	code/Number Theory/Bell Number.cpp	/^    poly& operator *= (const poly &x) { return *this = (*this) * x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator *=	code/Number Theory/Combinatorics Basics.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Number Theory/Dirichlet Convolution.cpp	/^    inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * /;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Number Theory/Lucas Theorem.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Number Theory/Min_25 Sieve.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Number Theory/Partition Function.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Number Theory/Phi Field.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Number Theory/Prime Factorization Fastest.cpp	/^  Mint& operator*= (const Mint &x) { n = reduce(__uint128_t(n) * x.n); return *this; }$/;"	f	struct:Mint	typeref:typename:Mint &	file:
operator *=	code/Number Theory/Prime Number System.cpp	/^  base& operator *= (base p) {$/;"	f	struct:base	typeref:typename:base &	file:
operator *=	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * /;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly& operator *= (const mint &x) { return *this = (*this) * x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator *=	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly& operator *= (const poly &x) { return *this = (*this) * x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator *=	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * /;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  Mod& operator *= (Mod rhs) { this->x = reduce(dword_t(this->x) * rhs.x); return *this; }$/;"	f	class:ntt::Mod	typeref:typename:Mod &	file:
operator *=	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly& operator *= (const poly& rhs) { return *this = *this * rhs; }$/;"	f	class:poly	typeref:typename:poly &	file:
operator *=	code/modint.hpp	/^    Mint& operator*=(Mint const& b) {value = (long long)value * b.value % MOD;return *this;}$/;"	f	struct:Mint	typeref:typename:Mint &
operator *=	practice/cf/random/1700/6.cpp	/^mi& operator*=(mi& a, mi b) { return a = a * b; }$/;"	f	typeref:typename:mi &
operator *=	practice/cf/random/i_hate_math_problems/1422C.cpp	/^mi& operator*=(mi& a, mi b) { return a = a*b; }$/;"	f	typeref:typename:mi &
operator *=	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	practice/cf/random/i_hate_math_problems/testing.cpp	/^  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * ot/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator *=	practice/december2021/DP/counting_towers/sol.cpp	/^    Modular& operator*=(Modular const& b) {value = (long long)value * b.value % MOD;return *this/;"	f	struct:Modular	typeref:typename:Modular &	file:
operator *=	practice/usacoguide/gold/introDP/arraydescription.cpp	/^mi& operator*=(mi& a, mi b) { return a = a*b; }$/;"	f	typeref:typename:mi &
operator +	code-library/Data Structures/Centroid Decomposition.cpp	/^  const base operator + (const base &c) const {$/;"	f	struct:base	typeref:typename:const base	file:
operator +	code-library/Data Structures/Dynamic Diameter Online.cpp	/^    node operator + (const node &oth) const {$/;"	f	struct:node	typeref:typename:node	file:
operator +	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^    const Int operator + (const Int &b) const {$/;"	f	struct:ST::Int	typeref:typename:const Int	file:
operator +	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Geometry/All Pair Segment Intersection.cpp	/^    PT operator + (const PT &a) const {$/;"	f	struct:PT	typeref:typename:PT	file:
operator +	code-library/Geometry/Delaunay Triangulation.cpp	/^    PT operator + (const PT &a) const { return PT(x + a.x, y + a.y); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator +	code-library/Geometry/Delaunay Triangulation.cpp	/^    dPT operator + (const dPT &a) const { return dPT(x + a.x, y + a.y); }$/;"	f	struct:dPT	typeref:typename:dPT	file:
operator +	code-library/Geometry/Geometry 2D.cpp	/^    PT operator + (const PT &a) const { return PT(x + a.x, y + a.y); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator +	code-library/Geometry/Geometry 3D.cpp	/^    PT operator + (const PT &a) const { return PT(x + a.x, y + a.y); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator +	code-library/Geometry/Geometry 3D.cpp	/^    p3 operator + (const p3 &a) const { return p3(x + a.x, y + a.y, z + a.z); }$/;"	f	struct:p3	typeref:typename:p3	file:
operator +	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    PT operator + (const PT &a) const { return PT(x + a.x, y + a.y); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator +	code-library/Geometry/Half Plane Intersection.cpp	/^    PT operator + (const PT &a) const { return PT(x + a.x, y + a.y); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator +	code-library/Geometry/Voronoi Diagram.cpp	/^    P operator + (const P &a) const { return P(x + a.x, y + a.y); }$/;"	f	struct:P	typeref:typename:P	file:
operator +	code-library/Geometry/Voronoi Diagram.cpp	/^    PT operator + (const PT &a) const { return PT(x + a.x, y + a.y); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator +	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^    inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Graph Theory/Number of Arborescence.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Graph Theory/Number of DAG.cpp	/^    inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^  const base operator + (const base &c) const {$/;"	f	struct:base	typeref:typename:const base	file:
operator +	code-library/Graph Theory/Tree Isomorphism.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Math/BerleKamp Massey.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Math/Characteristic Polynomial Faster.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Math/Determinant of Sparse Matrix.cpp	/^  inline Mat operator + (const Mat &b) {$/;"	f	struct:Mat	typeref:typename:Mat	file:
operator +	code-library/Math/Determinant of Sparse Matrix.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Math/FFT.cpp	/^  const base operator + (const base &c) const$/;"	f	struct:base	typeref:typename:const base	file:
operator +	code-library/Math/FWHT in Ternary Base.cpp	/^  cmplx operator+(cmplx x) { return cmplx(a + x.a, b + x.b); }$/;"	f	struct:cmplx	typeref:typename:cmplx	file:
operator +	code-library/Math/FWHT in Ternary Base.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Math/Faulhaber Formula Fastest.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly operator + (const poly &x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator +	code-library/Math/Faulhaber Formula Fastest.cpp	/^inline base operator + (base a, base b) { return base(a.x + b.x, a.y + b.y); }$/;"	f	typeref:typename:base
operator +	code-library/Math/Freivalds Algorithm.cpp	/^  inline Mat operator + (const Mat &b) {$/;"	f	struct:Mat	typeref:typename:Mat	file:
operator +	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^    inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Math/Hafnian of a Matrix.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Math/Lagrange Interpolation Brute.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^inline base operator + (base a, base b) { return base(a.x + b.x, a.y + b.y); }$/;"	f	typeref:typename:base
operator +	code-library/Math/Lagrange Interpolation.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Math/Linear Recurrence Fastest.cpp	/^inline base operator + (base a, base b) { return base(a.x + b.x, a.y + b.y); }$/;"	f	typeref:typename:base
operator +	code-library/Math/Linear Recurrence.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Math/Matrix Exponentiation.cpp	/^  inline Mat operator + (const Mat &b) {$/;"	f	struct:Mat	typeref:typename:Mat	file:
operator +	code-library/Math/NTT Online.cpp	/^inline base operator + (base a, base b) { return base(a.x + b.x, a.y + b.y); }$/;"	f	typeref:typename:base
operator +	code-library/Math/NTT With Any Prime MOD.cpp	/^inline base operator + (base a, base b) { return base(a.x + b.x, a.y + b.y); }$/;"	f	typeref:typename:base
operator +	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^poly operator + (poly a, poly b) {$/;"	f	typeref:typename:poly
operator +	code-library/Math/Polynomial Sum.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Math/Polynomial with Binomial Coefficients.cpp	/^inline base operator + (base a, base b) { return base(a.x + b.x, a.y + b.y); }$/;"	f	typeref:typename:base
operator +	code-library/Math/Polynomial.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Math/Polynomial.cpp	/^  poly operator + (const poly &x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator +	code-library/Math/Polynomial.cpp	/^inline base operator + (base a, base b) { return base(a.x + b.x, a.y + b.y); }$/;"	f	typeref:typename:base
operator +	code-library/Math/Subset Sum Problem.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Math/Subset Sum Problem.cpp	/^  poly operator + (const poly &x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator +	code-library/Math/Subset Sum Problem.cpp	/^inline base operator + (base a, base b) { return base(a.x + b.x, a.y + b.y); }$/;"	f	typeref:typename:base
operator +	code-library/Math/The Slime Trick.cpp	/^    inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Math/Thomas Algorithm.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Math/Vandermonde Matrix.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Miscellaneous/BigInt.cpp	/^  BigInt >::type friend operator + (L&& l, R&& r) {$/;"	f	file:
operator +	code-library/Miscellaneous/BigInt.cpp	/^  cplx operator+(const cplx &c) const {$/;"	f	struct:cplx	typeref:typename:cplx	file:
operator +	code-library/Number Theory/Bell Number.cpp	/^    inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Number Theory/Bell Number.cpp	/^  poly operator + (const poly &x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator +	code-library/Number Theory/Bell Number.cpp	/^inline base operator + (base a, base b) { return base(a.x + b.x, a.y + b.y); }$/;"	f	typeref:typename:base
operator +	code-library/Number Theory/Combinatorics Basics.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Number Theory/Dirichlet Convolution.cpp	/^    inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Number Theory/Lucas Theorem.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Number Theory/Min_25 Sieve.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^poly operator + (poly a, poly b) {$/;"	f	typeref:typename:poly
operator +	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Number Theory/Partition Function.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Number Theory/Phi Field.cpp	/^  field operator + (const field &oth) const {$/;"	f	struct:field	typeref:typename:field	file:
operator +	code-library/Number Theory/Phi Field.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Number Theory/Prime Factorization Fastest.cpp	/^  Mint& operator+ (const Mint &x) const { return Mint(*this) += x; }$/;"	f	struct:Mint	typeref:typename:Mint &	file:
operator +	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  poly operator + (const poly &x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator +	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^inline base operator + (base a, base b) { return base(a.x + b.x, a.y + b.y); }$/;"	f	typeref:typename:base
operator +	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code-library/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^inline base operator + (base a, base b) { return base(a.x + b.x, a.y + b.y); }$/;"	f	typeref:typename:base
operator +	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  Mod operator + (Mod rhs) const { return Mod(*this) += rhs; }$/;"	f	class:ntt::Mod	typeref:typename:Mod	file:
operator +	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly operator + (const poly& rhs) const { return poly(*this) += rhs; }$/;"	f	class:poly	typeref:typename:poly	file:
operator +	code-library/Strings/String Matching With FFT.cpp	/^  const base operator + (const base &c) const {$/;"	f	struct:base	typeref:typename:const base	file:
operator +	code/Data Structures/Centroid Decomposition.cpp	/^  const base operator + (const base &c) const {$/;"	f	struct:base	typeref:typename:const base	file:
operator +	code/Data Structures/Dynamic Diameter Online.cpp	/^    node operator + (const node &oth) const {$/;"	f	struct:node	typeref:typename:node	file:
operator +	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^    const Int operator + (const Int &b) const {$/;"	f	struct:ST::Int	typeref:typename:const Int	file:
operator +	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Geometry/All Pair Segment Intersection.cpp	/^    PT operator + (const PT &a) const {$/;"	f	struct:PT	typeref:typename:PT	file:
operator +	code/Geometry/Delaunay Triangulation.cpp	/^    PT operator + (const PT &a) const { return PT(x + a.x, y + a.y); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator +	code/Geometry/Delaunay Triangulation.cpp	/^    dPT operator + (const dPT &a) const { return dPT(x + a.x, y + a.y); }$/;"	f	struct:dPT	typeref:typename:dPT	file:
operator +	code/Geometry/Geometry 2D.cpp	/^    PT operator + (const PT &a) const { return PT(x + a.x, y + a.y); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator +	code/Geometry/Geometry 3D.cpp	/^    PT operator + (const PT &a) const { return PT(x + a.x, y + a.y); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator +	code/Geometry/Geometry 3D.cpp	/^    p3 operator + (const p3 &a) const { return p3(x + a.x, y + a.y, z + a.z); }$/;"	f	struct:p3	typeref:typename:p3	file:
operator +	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    PT operator + (const PT &a) const { return PT(x + a.x, y + a.y); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator +	code/Geometry/Half Plane Intersection.cpp	/^    PT operator + (const PT &a) const { return PT(x + a.x, y + a.y); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator +	code/Geometry/Voronoi Diagram.cpp	/^    P operator + (const P &a) const { return P(x + a.x, y + a.y); }$/;"	f	struct:P	typeref:typename:P	file:
operator +	code/Geometry/Voronoi Diagram.cpp	/^    PT operator + (const PT &a) const { return PT(x + a.x, y + a.y); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator +	code/Graph Theory/Chromatic Polynoimial.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Graph Theory/Counting Labeled Graphs.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Graph Theory/Hafnian of a Matrix.cpp	/^    inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Graph Theory/Number of Arborescence.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Graph Theory/Number of DAG.cpp	/^    inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^  const base operator + (const base &c) const {$/;"	f	struct:base	typeref:typename:const base	file:
operator +	code/Graph Theory/Tree Isomorphism.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Math/BerleKamp Massey.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Math/Characteristic Polynomial Faster.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Math/Determinant of Sparse Matrix.cpp	/^  inline Mat operator + (const Mat &b) {$/;"	f	struct:Mat	typeref:typename:Mat	file:
operator +	code/Math/Determinant of Sparse Matrix.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Math/FFT.cpp	/^  const base operator + (const base &c) const$/;"	f	struct:base	typeref:typename:const base	file:
operator +	code/Math/FWHT in Ternary Base.cpp	/^  cmplx operator+(cmplx x) { return cmplx(a + x.a, b + x.b); }$/;"	f	struct:cmplx	typeref:typename:cmplx	file:
operator +	code/Math/FWHT in Ternary Base.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Math/Faulhaber Formula Fastest.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Math/Faulhaber Formula Fastest.cpp	/^  poly operator + (const poly &x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator +	code/Math/Faulhaber Formula Fastest.cpp	/^inline base operator + (base a, base b) { return base(a.x + b.x, a.y + b.y); }$/;"	f	typeref:typename:base
operator +	code/Math/Freivalds Algorithm.cpp	/^  inline Mat operator + (const Mat &b) {$/;"	f	struct:Mat	typeref:typename:Mat	file:
operator +	code/Math/Generating Function of a Linear Recurrence.cpp	/^    inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Math/Hafnian of a Matrix.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Math/Lagrange Interpolation Brute.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^inline base operator + (base a, base b) { return base(a.x + b.x, a.y + b.y); }$/;"	f	typeref:typename:base
operator +	code/Math/Lagrange Interpolation.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Math/Linear Recurrence Fastest.cpp	/^inline base operator + (base a, base b) { return base(a.x + b.x, a.y + b.y); }$/;"	f	typeref:typename:base
operator +	code/Math/Linear Recurrence.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Math/Matrix Exponentiation.cpp	/^  inline Mat operator + (const Mat &b) {$/;"	f	struct:Mat	typeref:typename:Mat	file:
operator +	code/Math/NTT Online.cpp	/^inline base operator + (base a, base b) { return base(a.x + b.x, a.y + b.y); }$/;"	f	typeref:typename:base
operator +	code/Math/NTT With Any Prime MOD.cpp	/^inline base operator + (base a, base b) { return base(a.x + b.x, a.y + b.y); }$/;"	f	typeref:typename:base
operator +	code/Math/Number of Solutions of A Equation MITM.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Math/Number of Solutions of A Equation MITM.cpp	/^poly operator + (poly a, poly b) {$/;"	f	typeref:typename:poly
operator +	code/Math/Polynomial Sum.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Math/Polynomial with Binomial Coefficients.cpp	/^inline base operator + (base a, base b) { return base(a.x + b.x, a.y + b.y); }$/;"	f	typeref:typename:base
operator +	code/Math/Polynomial.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Math/Polynomial.cpp	/^  poly operator + (const poly &x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator +	code/Math/Polynomial.cpp	/^inline base operator + (base a, base b) { return base(a.x + b.x, a.y + b.y); }$/;"	f	typeref:typename:base
operator +	code/Math/Subset Sum Problem.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Math/Subset Sum Problem.cpp	/^  poly operator + (const poly &x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator +	code/Math/Subset Sum Problem.cpp	/^inline base operator + (base a, base b) { return base(a.x + b.x, a.y + b.y); }$/;"	f	typeref:typename:base
operator +	code/Math/The Slime Trick.cpp	/^    inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Math/Thomas Algorithm.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Math/Vandermonde Matrix.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Miscellaneous/BigInt.cpp	/^  BigInt >::type friend operator + (L&& l, R&& r) {$/;"	f	file:
operator +	code/Miscellaneous/BigInt.cpp	/^  cplx operator+(const cplx &c) const {$/;"	f	struct:cplx	typeref:typename:cplx	file:
operator +	code/Number Theory/Bell Number.cpp	/^    inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Number Theory/Bell Number.cpp	/^  poly operator + (const poly &x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator +	code/Number Theory/Bell Number.cpp	/^inline base operator + (base a, base b) { return base(a.x + b.x, a.y + b.y); }$/;"	f	typeref:typename:base
operator +	code/Number Theory/Combinatorics Basics.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Number Theory/Dirichlet Convolution.cpp	/^    inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Number Theory/Lucas Theorem.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Number Theory/Min_25 Sieve.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^poly operator + (poly a, poly b) {$/;"	f	typeref:typename:poly
operator +	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Number Theory/Partition Function.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Number Theory/Phi Field.cpp	/^  field operator + (const field &oth) const {$/;"	f	struct:field	typeref:typename:field	file:
operator +	code/Number Theory/Phi Field.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Number Theory/Prime Factorization Fastest.cpp	/^  Mint& operator+ (const Mint &x) const { return Mint(*this) += x; }$/;"	f	struct:Mint	typeref:typename:Mint &	file:
operator +	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  poly operator + (const poly &x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator +	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^inline base operator + (base a, base b) { return base(a.x + b.x, a.y + b.y); }$/;"	f	typeref:typename:base
operator +	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	code/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^inline base operator + (base a, base b) { return base(a.x + b.x, a.y + b.y); }$/;"	f	typeref:typename:base
operator +	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  Mod operator + (Mod rhs) const { return Mod(*this) += rhs; }$/;"	f	class:ntt::Mod	typeref:typename:Mod	file:
operator +	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly operator + (const poly& rhs) const { return poly(*this) += rhs; }$/;"	f	class:poly	typeref:typename:poly	file:
operator +	code/Strings/String Matching With FFT.cpp	/^  const base operator + (const base &c) const {$/;"	f	struct:base	typeref:typename:const base	file:
operator +	code/modint.hpp	/^    friend Mint operator+(Mint a, Mint const b) { return a += b; }$/;"	f	typeref:typename:Mint
operator +	practice/cf/random/1700/6.cpp	/^mi operator+(mi a, mi b) { return a += b; }$/;"	f	typeref:typename:mi
operator +	practice/cf/random/i_hate_math_problems/1422C.cpp	/^mi operator+(mi a, mi b) { return a += b; }$/;"	f	typeref:typename:mi
operator +	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	practice/cf/random/i_hate_math_problems/testing.cpp	/^  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator +	practice/december2021/DP/counting_towers/sol.cpp	/^    friend Modular operator+(Modular a, Modular const b) { return a += b; }$/;"	f	typeref:typename:Modular	file:
operator +	practice/usacoguide/gold/introDP/arraydescription.cpp	/^mi operator+(mi a, mi b) { return a += b; }$/;"	f	typeref:typename:mi
operator +=	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Game Theory/Blue Red Hackenbush.cpp	/^  inline void operator +=(surreal x) {$/;"	f	struct:surreal	typeref:typename:void	file:
operator +=	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^    inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Graph Theory/Number of Arborescence.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Graph Theory/Number of DAG.cpp	/^    inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Graph Theory/Tree Isomorphism.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Math/BerleKamp Massey.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Math/Characteristic Polynomial Faster.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Math/Determinant of Sparse Matrix.cpp	/^  inline Mat& operator += (const Mat& b) { return *this = (*this) + b; }$/;"	f	struct:Mat	typeref:typename:Mat &	file:
operator +=	code-library/Math/Determinant of Sparse Matrix.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Math/FWHT in Ternary Base.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Math/Faulhaber Formula Fastest.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly& operator += (const poly &x) { return *this = (*this) + x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator +=	code-library/Math/Freivalds Algorithm.cpp	/^  inline Mat& operator += (const Mat& b) { return *this = (*this) + b; }$/;"	f	struct:Mat	typeref:typename:Mat &	file:
operator +=	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^    inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Math/Hafnian of a Matrix.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Math/Lagrange Interpolation Brute.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Math/Lagrange Interpolation.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Math/Linear Recurrence.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Math/Matrix Exponentiation.cpp	/^  inline Mat& operator += (const Mat& b) { return *this = (*this) + b; }$/;"	f	struct:Mat	typeref:typename:Mat &	file:
operator +=	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Math/Polynomial Sum.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Math/Polynomial.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Math/Polynomial.cpp	/^  poly& operator += (const poly &x) { return *this = (*this) + x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator +=	code-library/Math/Subset Sum Problem.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Math/Subset Sum Problem.cpp	/^  poly& operator += (const poly &x) { return *this = (*this) + x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator +=	code-library/Math/The Slime Trick.cpp	/^    inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Math/Thomas Algorithm.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Math/Vandermonde Matrix.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Miscellaneous/BigInt.cpp	/^  BigInt operator+=(const BigInt& v) {$/;"	f	struct:BigInt	typeref:typename:BigInt	file:
operator +=	code-library/Number Theory/Bell Number.cpp	/^    inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Number Theory/Bell Number.cpp	/^    poly& operator += (const poly &x) { return *this = (*this) + x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator +=	code-library/Number Theory/Combinatorics Basics.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Number Theory/Dirichlet Convolution.cpp	/^    inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Number Theory/Lucas Theorem.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Number Theory/Min_25 Sieve.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Number Theory/Partition Function.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Number Theory/Phi Field.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Number Theory/Prime Factorization Fastest.cpp	/^  Mint& operator+= (const Mint &x) { n += x.n - mod; if(int64_t(n) < 0) n += mod; return *this; /;"	f	struct:Mint	typeref:typename:Mint &	file:
operator +=	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly& operator += (const poly &x) { return *this = (*this) + x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator +=	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  Mod& operator += (Mod rhs) { this->x += rhs.x; return *this; }$/;"	f	class:ntt::Mod	typeref:typename:Mod &	file:
operator +=	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly& operator += (const poly& rhs) {$/;"	f	class:poly	typeref:typename:poly &	file:
operator +=	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Game Theory/Blue Red Hackenbush.cpp	/^  inline void operator +=(surreal x) {$/;"	f	struct:surreal	typeref:typename:void	file:
operator +=	code/Graph Theory/Chromatic Polynoimial.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Graph Theory/Counting Labeled Graphs.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Graph Theory/Hafnian of a Matrix.cpp	/^    inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Graph Theory/Number of Arborescence.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Graph Theory/Number of DAG.cpp	/^    inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Graph Theory/Tree Isomorphism.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Math/BerleKamp Massey.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Math/Characteristic Polynomial Faster.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Math/Determinant of Sparse Matrix.cpp	/^  inline Mat& operator += (const Mat& b) { return *this = (*this) + b; }$/;"	f	struct:Mat	typeref:typename:Mat &	file:
operator +=	code/Math/Determinant of Sparse Matrix.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Math/FWHT in Ternary Base.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Math/Faulhaber Formula Fastest.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Math/Faulhaber Formula Fastest.cpp	/^  poly& operator += (const poly &x) { return *this = (*this) + x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator +=	code/Math/Freivalds Algorithm.cpp	/^  inline Mat& operator += (const Mat& b) { return *this = (*this) + b; }$/;"	f	struct:Mat	typeref:typename:Mat &	file:
operator +=	code/Math/Generating Function of a Linear Recurrence.cpp	/^    inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Math/Hafnian of a Matrix.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Math/Lagrange Interpolation Brute.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Math/Lagrange Interpolation.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Math/Linear Recurrence.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Math/Matrix Exponentiation.cpp	/^  inline Mat& operator += (const Mat& b) { return *this = (*this) + b; }$/;"	f	struct:Mat	typeref:typename:Mat &	file:
operator +=	code/Math/Number of Solutions of A Equation MITM.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Math/Polynomial Sum.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Math/Polynomial.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Math/Polynomial.cpp	/^  poly& operator += (const poly &x) { return *this = (*this) + x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator +=	code/Math/Subset Sum Problem.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Math/Subset Sum Problem.cpp	/^  poly& operator += (const poly &x) { return *this = (*this) + x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator +=	code/Math/The Slime Trick.cpp	/^    inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Math/Thomas Algorithm.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Math/Vandermonde Matrix.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Miscellaneous/BigInt.cpp	/^  BigInt operator+=(const BigInt& v) {$/;"	f	struct:BigInt	typeref:typename:BigInt	file:
operator +=	code/Number Theory/Bell Number.cpp	/^    inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Number Theory/Bell Number.cpp	/^    poly& operator += (const poly &x) { return *this = (*this) + x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator +=	code/Number Theory/Combinatorics Basics.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Number Theory/Dirichlet Convolution.cpp	/^    inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Number Theory/Lucas Theorem.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Number Theory/Min_25 Sieve.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Number Theory/Partition Function.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Number Theory/Phi Field.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Number Theory/Prime Factorization Fastest.cpp	/^  Mint& operator+= (const Mint &x) { n += x.n - mod; if(int64_t(n) < 0) n += mod; return *this; /;"	f	struct:Mint	typeref:typename:Mint &	file:
operator +=	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly& operator += (const poly &x) { return *this = (*this) + x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator +=	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  Mod& operator += (Mod rhs) { this->x += rhs.x; return *this; }$/;"	f	class:ntt::Mod	typeref:typename:Mod &	file:
operator +=	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly& operator += (const poly& rhs) {$/;"	f	class:poly	typeref:typename:poly &	file:
operator +=	code/modint.hpp	/^    Mint& operator+=(Mint const& b) {value += b.value; if (value >= MOD) value -= MOD; return *t/;"	f	struct:Mint	typeref:typename:Mint &
operator +=	practice/cf/random/1700/6.cpp	/^mi& operator+=(mi& a, mi b) { $/;"	f	typeref:typename:mi &
operator +=	practice/cf/random/i_hate_math_problems/1422C.cpp	/^mi& operator+=(mi& a, mi b) { $/;"	f	typeref:typename:mi &
operator +=	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	practice/cf/random/i_hate_math_problems/testing.cpp	/^  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator +=	practice/december2021/DP/counting_towers/sol.cpp	/^    Modular& operator+=(Modular const& b) {value += b.value; if (value >= MOD) value -= MOD; ret/;"	f	struct:Modular	typeref:typename:Modular &	file:
operator +=	practice/usacoguide/gold/introDP/arraydescription.cpp	/^mi& operator+=(mi& a, mi b) { $/;"	f	typeref:typename:mi &
operator -	code-library/Data Structures/Centroid Decomposition.cpp	/^  const base operator - (const base &c) const {$/;"	f	struct:base	typeref:typename:const base	file:
operator -	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Geometry/All Pair Segment Intersection.cpp	/^    PT operator - (const PT &a) const {$/;"	f	struct:PT	typeref:typename:PT	file:
operator -	code-library/Geometry/Convec Hull Dynamic.cpp	/^    PT operator - (const PT& rhs) const {$/;"	f	struct:PT	typeref:typename:PT	file:
operator -	code-library/Geometry/Delaunay Triangulation.cpp	/^    PT operator - (const PT &a) const { return PT(x - a.x, y - a.y); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator -	code-library/Geometry/Delaunay Triangulation.cpp	/^    dPT operator - (const dPT &a) const { return dPT(x - a.x, y - a.y); }$/;"	f	struct:dPT	typeref:typename:dPT	file:
operator -	code-library/Geometry/Geometry 2D.cpp	/^    PT operator - (const PT &a) const { return PT(x - a.x, y - a.y); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator -	code-library/Geometry/Geometry 3D.cpp	/^    PT operator - (const PT &a) const { return PT(x - a.x, y - a.y); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator -	code-library/Geometry/Geometry 3D.cpp	/^    p3 operator - (const p3 &a) const { return p3(x - a.x, y - a.y, z - a.z); }$/;"	f	struct:p3	typeref:typename:p3	file:
operator -	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    Angle operator - (Angle a) const { return {x - a.x, y - a.y}; }$/;"	f	struct:Angle	typeref:typename:Angle	file:
operator -	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    PT operator - (const PT &a) const { return PT(x - a.x, y - a.y); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator -	code-library/Geometry/Half Plane Intersection.cpp	/^    PT operator - (const PT &a) const { return PT(x - a.x, y - a.y); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator -	code-library/Geometry/Onion Decomposition.cpp	/^    PT operator - () const { return {-x, -y}; }$/;"	f	struct:PT	typeref:typename:PT	file:
operator -	code-library/Geometry/Onion Decomposition.cpp	/^    PT operator - (PT p) const { return {x - p.x, y- p.y}; }$/;"	f	struct:PT	typeref:typename:PT	file:
operator -	code-library/Geometry/Point Location.cpp	/^    PT operator-(const PT& a) const { return PT(x - a.x, y - a.y); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator -	code-library/Geometry/Voronoi Diagram.cpp	/^    P operator - (const P &a) const { return P(x - a.x, y - a.y); }$/;"	f	struct:P	typeref:typename:P	file:
operator -	code-library/Geometry/Voronoi Diagram.cpp	/^    PT operator - (const PT &a) const { return PT(x - a.x, y - a.y); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator -	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^    inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^    inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Graph Theory/Number of Arborescence.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Graph Theory/Number of Arborescence.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Graph Theory/Number of DAG.cpp	/^    inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Graph Theory/Number of DAG.cpp	/^    inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^  const base operator - (const base &c) const {$/;"	f	struct:base	typeref:typename:const base	file:
operator -	code-library/Graph Theory/Tree Isomorphism.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Graph Theory/Tree Isomorphism.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/BerleKamp Massey.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/BerleKamp Massey.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Characteristic Polynomial Faster.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Characteristic Polynomial Faster.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Determinant of Sparse Matrix.cpp	/^  inline Mat operator - (const Mat &b) {$/;"	f	struct:Mat	typeref:typename:Mat	file:
operator -	code-library/Math/Determinant of Sparse Matrix.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Determinant of Sparse Matrix.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/FFT.cpp	/^  const base operator - (const base &c) const$/;"	f	struct:base	typeref:typename:const base	file:
operator -	code-library/Math/FWHT in Ternary Base.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/FWHT in Ternary Base.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Faulhaber Formula Fastest.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Faulhaber Formula Fastest.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly operator - (const poly &x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator -	code-library/Math/Faulhaber Formula Fastest.cpp	/^inline base operator - (base a, base b) { return base(a.x - b.x, a.y - b.y); }$/;"	f	typeref:typename:base
operator -	code-library/Math/Freivalds Algorithm.cpp	/^  inline Mat operator - (const Mat &b) {$/;"	f	struct:Mat	typeref:typename:Mat	file:
operator -	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^    inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^    inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Hafnian of a Matrix.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Hafnian of a Matrix.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Lagrange Interpolation Brute.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Lagrange Interpolation Brute.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^inline base operator - (base a, base b) { return base(a.x - b.x, a.y - b.y); }$/;"	f	typeref:typename:base
operator -	code-library/Math/Lagrange Interpolation.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Lagrange Interpolation.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Linear Recurrence Fastest.cpp	/^inline base operator - (base a, base b) { return base(a.x - b.x, a.y - b.y); }$/;"	f	typeref:typename:base
operator -	code-library/Math/Linear Recurrence.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Linear Recurrence.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Matrix Exponentiation.cpp	/^  inline Mat operator - (const Mat &b) {$/;"	f	struct:Mat	typeref:typename:Mat	file:
operator -	code-library/Math/NTT Online.cpp	/^inline base operator - (base a, base b) { return base(a.x - b.x, a.y - b.y); }$/;"	f	typeref:typename:base
operator -	code-library/Math/NTT With Any Prime MOD.cpp	/^inline base operator - (base a, base b) { return base(a.x - b.x, a.y - b.y); }$/;"	f	typeref:typename:base
operator -	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^poly operator - (poly a, poly b) {$/;"	f	typeref:typename:poly
operator -	code-library/Math/Polynomial Sum.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Polynomial Sum.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Polynomial with Binomial Coefficients.cpp	/^inline base operator - (base a, base b) { return base(a.x - b.x, a.y - b.y); }$/;"	f	typeref:typename:base
operator -	code-library/Math/Polynomial.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Polynomial.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Polynomial.cpp	/^  poly operator - (const poly &x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator -	code-library/Math/Polynomial.cpp	/^inline base operator - (base a, base b) { return base(a.x - b.x, a.y - b.y); }$/;"	f	typeref:typename:base
operator -	code-library/Math/Subset Sum Problem.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Subset Sum Problem.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Subset Sum Problem.cpp	/^  poly operator - (const poly &x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator -	code-library/Math/Subset Sum Problem.cpp	/^inline base operator - (base a, base b) { return base(a.x - b.x, a.y - b.y); }$/;"	f	typeref:typename:base
operator -	code-library/Math/The Slime Trick.cpp	/^    inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/The Slime Trick.cpp	/^    inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Thomas Algorithm.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Thomas Algorithm.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Vandermonde Matrix.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Math/Vandermonde Matrix.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Miscellaneous/BigInt.cpp	/^  BigInt >::type friend operator - (L&& l, R&& r) {$/;"	f	typeref:typename:enable_if<is_convertible<L,BigInt>::value && is_convertible<R,BigInt>::value,BigInt>::type 	file:
operator -	code-library/Miscellaneous/BigInt.cpp	/^  BigInt operator-() const {$/;"	f	struct:BigInt	typeref:typename:BigInt	file:
operator -	code-library/Miscellaneous/BigInt.cpp	/^  cplx operator-(const cplx &c) const {$/;"	f	struct:cplx	typeref:typename:cplx	file:
operator -	code-library/Number Theory/Bell Number.cpp	/^    inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Bell Number.cpp	/^    inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Bell Number.cpp	/^    poly operator - (const poly &x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator -	code-library/Number Theory/Bell Number.cpp	/^inline base operator - (base a, base b) { return base(a.x - b.x, a.y - b.y); }$/;"	f	typeref:typename:base
operator -	code-library/Number Theory/Combinatorics Basics.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Combinatorics Basics.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Dirichlet Convolution.cpp	/^    inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Dirichlet Convolution.cpp	/^    inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Lucas Theorem.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Lucas Theorem.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Min_25 Sieve.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Min_25 Sieve.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^poly operator - (poly a, poly b) {$/;"	f	typeref:typename:poly
operator -	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Partition Function.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Partition Function.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Phi Field.cpp	/^  field operator - (const field &oth) const {$/;"	f	struct:field	typeref:typename:field	file:
operator -	code-library/Number Theory/Phi Field.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Phi Field.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly operator - (const poly &x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator -	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^inline base operator - (base a, base b) { return base(a.x - b.x, a.y - b.y); }$/;"	f	typeref:typename:base
operator -	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code-library/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^inline base operator - (base a, base b) { return base(a.x - b.x, a.y - b.y); }$/;"	f	typeref:typename:base
operator -	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  Mod operator - (Mod rhs) const { return Mod(*this) -= rhs; }$/;"	f	class:ntt::Mod	typeref:typename:Mod	file:
operator -	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly operator - () {$/;"	f	class:poly	typeref:typename:poly	file:
operator -	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly operator - (const poly& rhs) const { return poly(*this) -= rhs; }$/;"	f	class:poly	typeref:typename:poly	file:
operator -	code-library/Strings/String Matching With FFT.cpp	/^  const base operator - (const base &c) const {$/;"	f	struct:base	typeref:typename:const base	file:
operator -	code/Data Structures/Centroid Decomposition.cpp	/^  const base operator - (const base &c) const {$/;"	f	struct:base	typeref:typename:const base	file:
operator -	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Geometry/All Pair Segment Intersection.cpp	/^    PT operator - (const PT &a) const {$/;"	f	struct:PT	typeref:typename:PT	file:
operator -	code/Geometry/Convec Hull Dynamic.cpp	/^    PT operator - (const PT& rhs) const {$/;"	f	struct:PT	typeref:typename:PT	file:
operator -	code/Geometry/Delaunay Triangulation.cpp	/^    PT operator - (const PT &a) const { return PT(x - a.x, y - a.y); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator -	code/Geometry/Delaunay Triangulation.cpp	/^    dPT operator - (const dPT &a) const { return dPT(x - a.x, y - a.y); }$/;"	f	struct:dPT	typeref:typename:dPT	file:
operator -	code/Geometry/Geometry 2D.cpp	/^    PT operator - (const PT &a) const { return PT(x - a.x, y - a.y); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator -	code/Geometry/Geometry 3D.cpp	/^    PT operator - (const PT &a) const { return PT(x - a.x, y - a.y); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator -	code/Geometry/Geometry 3D.cpp	/^    p3 operator - (const p3 &a) const { return p3(x - a.x, y - a.y, z - a.z); }$/;"	f	struct:p3	typeref:typename:p3	file:
operator -	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    Angle operator - (Angle a) const { return {x - a.x, y - a.y}; }$/;"	f	struct:Angle	typeref:typename:Angle	file:
operator -	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    PT operator - (const PT &a) const { return PT(x - a.x, y - a.y); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator -	code/Geometry/Half Plane Intersection.cpp	/^    PT operator - (const PT &a) const { return PT(x - a.x, y - a.y); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator -	code/Geometry/Onion Decomposition.cpp	/^    PT operator - () const { return {-x, -y}; }$/;"	f	struct:PT	typeref:typename:PT	file:
operator -	code/Geometry/Onion Decomposition.cpp	/^    PT operator - (PT p) const { return {x - p.x, y- p.y}; }$/;"	f	struct:PT	typeref:typename:PT	file:
operator -	code/Geometry/Point Location.cpp	/^    PT operator-(const PT& a) const { return PT(x - a.x, y - a.y); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator -	code/Geometry/Voronoi Diagram.cpp	/^    P operator - (const P &a) const { return P(x - a.x, y - a.y); }$/;"	f	struct:P	typeref:typename:P	file:
operator -	code/Geometry/Voronoi Diagram.cpp	/^    PT operator - (const PT &a) const { return PT(x - a.x, y - a.y); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator -	code/Graph Theory/Chromatic Polynoimial.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Graph Theory/Chromatic Polynoimial.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Graph Theory/Counting Labeled Graphs.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Graph Theory/Counting Labeled Graphs.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Graph Theory/Hafnian of a Matrix.cpp	/^    inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Graph Theory/Hafnian of a Matrix.cpp	/^    inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Graph Theory/Number of Arborescence.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Graph Theory/Number of Arborescence.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Graph Theory/Number of DAG.cpp	/^    inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Graph Theory/Number of DAG.cpp	/^    inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^  const base operator - (const base &c) const {$/;"	f	struct:base	typeref:typename:const base	file:
operator -	code/Graph Theory/Tree Isomorphism.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Graph Theory/Tree Isomorphism.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/BerleKamp Massey.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/BerleKamp Massey.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Characteristic Polynomial Faster.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Characteristic Polynomial Faster.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Determinant of Sparse Matrix.cpp	/^  inline Mat operator - (const Mat &b) {$/;"	f	struct:Mat	typeref:typename:Mat	file:
operator -	code/Math/Determinant of Sparse Matrix.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Determinant of Sparse Matrix.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/FFT.cpp	/^  const base operator - (const base &c) const$/;"	f	struct:base	typeref:typename:const base	file:
operator -	code/Math/FWHT in Ternary Base.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/FWHT in Ternary Base.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Faulhaber Formula Fastest.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Faulhaber Formula Fastest.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Faulhaber Formula Fastest.cpp	/^  poly operator - (const poly &x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator -	code/Math/Faulhaber Formula Fastest.cpp	/^inline base operator - (base a, base b) { return base(a.x - b.x, a.y - b.y); }$/;"	f	typeref:typename:base
operator -	code/Math/Freivalds Algorithm.cpp	/^  inline Mat operator - (const Mat &b) {$/;"	f	struct:Mat	typeref:typename:Mat	file:
operator -	code/Math/Generating Function of a Linear Recurrence.cpp	/^    inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Generating Function of a Linear Recurrence.cpp	/^    inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Hafnian of a Matrix.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Hafnian of a Matrix.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Lagrange Interpolation Brute.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Lagrange Interpolation Brute.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^inline base operator - (base a, base b) { return base(a.x - b.x, a.y - b.y); }$/;"	f	typeref:typename:base
operator -	code/Math/Lagrange Interpolation.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Lagrange Interpolation.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Linear Recurrence Fastest.cpp	/^inline base operator - (base a, base b) { return base(a.x - b.x, a.y - b.y); }$/;"	f	typeref:typename:base
operator -	code/Math/Linear Recurrence.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Linear Recurrence.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Matrix Exponentiation.cpp	/^  inline Mat operator - (const Mat &b) {$/;"	f	struct:Mat	typeref:typename:Mat	file:
operator -	code/Math/NTT Online.cpp	/^inline base operator - (base a, base b) { return base(a.x - b.x, a.y - b.y); }$/;"	f	typeref:typename:base
operator -	code/Math/NTT With Any Prime MOD.cpp	/^inline base operator - (base a, base b) { return base(a.x - b.x, a.y - b.y); }$/;"	f	typeref:typename:base
operator -	code/Math/Number of Solutions of A Equation MITM.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Number of Solutions of A Equation MITM.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Number of Solutions of A Equation MITM.cpp	/^poly operator - (poly a, poly b) {$/;"	f	typeref:typename:poly
operator -	code/Math/Polynomial Sum.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Polynomial Sum.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Polynomial with Binomial Coefficients.cpp	/^inline base operator - (base a, base b) { return base(a.x - b.x, a.y - b.y); }$/;"	f	typeref:typename:base
operator -	code/Math/Polynomial.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Polynomial.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Polynomial.cpp	/^  poly operator - (const poly &x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator -	code/Math/Polynomial.cpp	/^inline base operator - (base a, base b) { return base(a.x - b.x, a.y - b.y); }$/;"	f	typeref:typename:base
operator -	code/Math/Subset Sum Problem.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Subset Sum Problem.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Subset Sum Problem.cpp	/^  poly operator - (const poly &x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator -	code/Math/Subset Sum Problem.cpp	/^inline base operator - (base a, base b) { return base(a.x - b.x, a.y - b.y); }$/;"	f	typeref:typename:base
operator -	code/Math/The Slime Trick.cpp	/^    inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/The Slime Trick.cpp	/^    inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Thomas Algorithm.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Thomas Algorithm.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Vandermonde Matrix.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Math/Vandermonde Matrix.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Miscellaneous/BigInt.cpp	/^  BigInt >::type friend operator - (L&& l, R&& r) {$/;"	f	typeref:typename:enable_if<is_convertible<L,BigInt>::value && is_convertible<R,BigInt>::value,BigInt>::type 	file:
operator -	code/Miscellaneous/BigInt.cpp	/^  BigInt operator-() const {$/;"	f	struct:BigInt	typeref:typename:BigInt	file:
operator -	code/Miscellaneous/BigInt.cpp	/^  cplx operator-(const cplx &c) const {$/;"	f	struct:cplx	typeref:typename:cplx	file:
operator -	code/Number Theory/Bell Number.cpp	/^    inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Bell Number.cpp	/^    inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Bell Number.cpp	/^    poly operator - (const poly &x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator -	code/Number Theory/Bell Number.cpp	/^inline base operator - (base a, base b) { return base(a.x - b.x, a.y - b.y); }$/;"	f	typeref:typename:base
operator -	code/Number Theory/Combinatorics Basics.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Combinatorics Basics.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Dirichlet Convolution.cpp	/^    inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Dirichlet Convolution.cpp	/^    inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Lucas Theorem.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Lucas Theorem.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Min_25 Sieve.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Min_25 Sieve.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^poly operator - (poly a, poly b) {$/;"	f	typeref:typename:poly
operator -	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Partition Function.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Partition Function.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Phi Field.cpp	/^  field operator - (const field &oth) const {$/;"	f	struct:field	typeref:typename:field	file:
operator -	code/Number Theory/Phi Field.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Phi Field.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly operator - (const poly &x) const {$/;"	f	struct:poly	typeref:typename:poly	file:
operator -	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^inline base operator - (base a, base b) { return base(a.x - b.x, a.y - b.y); }$/;"	f	typeref:typename:base
operator -	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.va/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	code/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^inline base operator - (base a, base b) { return base(a.x - b.x, a.y - b.y); }$/;"	f	typeref:typename:base
operator -	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  Mod operator - (Mod rhs) const { return Mod(*this) -= rhs; }$/;"	f	class:ntt::Mod	typeref:typename:Mod	file:
operator -	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly operator - () {$/;"	f	class:poly	typeref:typename:poly	file:
operator -	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly operator - (const poly& rhs) const { return poly(*this) -= rhs; }$/;"	f	class:poly	typeref:typename:poly	file:
operator -	code/Strings/String Matching With FFT.cpp	/^  const base operator - (const base &c) const {$/;"	f	struct:base	typeref:typename:const base	file:
operator -	code/modint.hpp	/^    friend Mint operator-(Mint a, Mint const b) { return a -= b; }$/;"	f	typeref:typename:Mint
operator -	code/modint.hpp	/^    friend Mint operator-(Mint const a) { return 0 - a; }$/;"	f	typeref:typename:Mint
operator -	practice/cf/random/1700/6.cpp	/^mi operator-(mi a, mi b) { return a -= b; }$/;"	f	typeref:typename:mi
operator -	practice/cf/random/i_hate_math_problems/1422C.cpp	/^mi operator-(mi a, mi b) { return a -= b; }$/;"	f	typeref:typename:mi
operator -	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	practice/cf/random/i_hate_math_problems/testing.cpp	/^  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : /;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	practice/cf/random/i_hate_math_problems/testing.cpp	/^  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.valu/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator -	practice/december2021/DP/counting_towers/sol.cpp	/^    friend Modular operator-(Modular a, Modular const b) { return a -= b; }$/;"	f	typeref:typename:Modular	file:
operator -	practice/december2021/DP/counting_towers/sol.cpp	/^    friend Modular operator-(Modular const a) { return 0 - a; }$/;"	f	typeref:typename:Modular	file:
operator -	practice/usacoguide/gold/introDP/arraydescription.cpp	/^mi operator-(mi a, mi b) { return a -= b; }$/;"	f	typeref:typename:mi
operator -=	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^    inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Graph Theory/Number of Arborescence.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Graph Theory/Number of DAG.cpp	/^    inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Graph Theory/Tree Isomorphism.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Math/BerleKamp Massey.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Math/Characteristic Polynomial Faster.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Math/Determinant of Sparse Matrix.cpp	/^  inline Mat& operator -= (const Mat& b) { return *this = (*this) - b; }$/;"	f	struct:Mat	typeref:typename:Mat &	file:
operator -=	code-library/Math/Determinant of Sparse Matrix.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Math/FWHT in Ternary Base.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Math/Faulhaber Formula Fastest.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly& operator -= (const poly &x) { return *this = (*this) - x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator -=	code-library/Math/Freivalds Algorithm.cpp	/^  inline Mat& operator -= (const Mat& b) { return *this = (*this) - b; }$/;"	f	struct:Mat	typeref:typename:Mat &	file:
operator -=	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^    inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Math/Hafnian of a Matrix.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Math/Lagrange Interpolation Brute.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Math/Lagrange Interpolation.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Math/Linear Recurrence.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Math/Matrix Exponentiation.cpp	/^  inline Mat& operator -= (const Mat& b) { return *this = (*this) - b; }$/;"	f	struct:Mat	typeref:typename:Mat &	file:
operator -=	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Math/Polynomial Sum.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Math/Polynomial.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Math/Polynomial.cpp	/^  poly& operator -= (const poly &x) { return *this = (*this) - x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator -=	code-library/Math/Subset Sum Problem.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Math/Subset Sum Problem.cpp	/^  poly& operator -= (const poly &x) { return *this = (*this) - x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator -=	code-library/Math/The Slime Trick.cpp	/^    inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Math/Thomas Algorithm.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Math/Vandermonde Matrix.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Miscellaneous/BigInt.cpp	/^  BigInt operator-=(const BigInt& v) {$/;"	f	struct:BigInt	typeref:typename:BigInt	file:
operator -=	code-library/Number Theory/Bell Number.cpp	/^    inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Number Theory/Bell Number.cpp	/^    poly& operator -= (const poly &x) { return *this = (*this) - x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator -=	code-library/Number Theory/Combinatorics Basics.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Number Theory/Dirichlet Convolution.cpp	/^    inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Number Theory/Lucas Theorem.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Number Theory/Min_25 Sieve.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Number Theory/Partition Function.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Number Theory/Phi Field.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly& operator -= (const poly &x) { return *this = (*this) - x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator -=	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  Mod& operator -= (Mod rhs) { this->x += 3 * mod - rhs.x; return *this; }$/;"	f	class:ntt::Mod	typeref:typename:Mod &	file:
operator -=	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly& operator -= (const poly& rhs) {$/;"	f	class:poly	typeref:typename:poly &	file:
operator -=	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Graph Theory/Chromatic Polynoimial.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Graph Theory/Counting Labeled Graphs.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Graph Theory/Hafnian of a Matrix.cpp	/^    inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Graph Theory/Number of Arborescence.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Graph Theory/Number of DAG.cpp	/^    inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Graph Theory/Tree Isomorphism.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Math/BerleKamp Massey.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Math/Characteristic Polynomial Faster.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Math/Determinant of Sparse Matrix.cpp	/^  inline Mat& operator -= (const Mat& b) { return *this = (*this) - b; }$/;"	f	struct:Mat	typeref:typename:Mat &	file:
operator -=	code/Math/Determinant of Sparse Matrix.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Math/FWHT in Ternary Base.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Math/Faulhaber Formula Fastest.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Math/Faulhaber Formula Fastest.cpp	/^  poly& operator -= (const poly &x) { return *this = (*this) - x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator -=	code/Math/Freivalds Algorithm.cpp	/^  inline Mat& operator -= (const Mat& b) { return *this = (*this) - b; }$/;"	f	struct:Mat	typeref:typename:Mat &	file:
operator -=	code/Math/Generating Function of a Linear Recurrence.cpp	/^    inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Math/Hafnian of a Matrix.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Math/Lagrange Interpolation Brute.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Math/Lagrange Interpolation.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Math/Linear Recurrence.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Math/Matrix Exponentiation.cpp	/^  inline Mat& operator -= (const Mat& b) { return *this = (*this) - b; }$/;"	f	struct:Mat	typeref:typename:Mat &	file:
operator -=	code/Math/Number of Solutions of A Equation MITM.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Math/Polynomial Sum.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Math/Polynomial.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Math/Polynomial.cpp	/^  poly& operator -= (const poly &x) { return *this = (*this) - x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator -=	code/Math/Subset Sum Problem.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Math/Subset Sum Problem.cpp	/^  poly& operator -= (const poly &x) { return *this = (*this) - x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator -=	code/Math/The Slime Trick.cpp	/^    inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Math/Thomas Algorithm.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Math/Vandermonde Matrix.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Miscellaneous/BigInt.cpp	/^  BigInt operator-=(const BigInt& v) {$/;"	f	struct:BigInt	typeref:typename:BigInt	file:
operator -=	code/Number Theory/Bell Number.cpp	/^    inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Number Theory/Bell Number.cpp	/^    poly& operator -= (const poly &x) { return *this = (*this) - x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator -=	code/Number Theory/Combinatorics Basics.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Number Theory/Dirichlet Convolution.cpp	/^    inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Number Theory/Lucas Theorem.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Number Theory/Min_25 Sieve.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Number Theory/Partition Function.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Number Theory/Phi Field.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly& operator -= (const poly &x) { return *this = (*this) - x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator -=	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this-/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  Mod& operator -= (Mod rhs) { this->x += 3 * mod - rhs.x; return *this; }$/;"	f	class:ntt::Mod	typeref:typename:Mod &	file:
operator -=	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly& operator -= (const poly& rhs) {$/;"	f	class:poly	typeref:typename:poly &	file:
operator -=	code/modint.hpp	/^    Mint& operator-=(Mint const& b) {value -= b.value; if (value < 0) value += MOD;return *this;/;"	f	struct:Mint	typeref:typename:Mint &
operator -=	practice/cf/random/1700/6.cpp	/^mi& operator-=(mi& a, mi b) { $/;"	f	typeref:typename:mi &
operator -=	practice/cf/random/i_hate_math_problems/1422C.cpp	/^mi& operator-=(mi& a, mi b) { $/;"	f	typeref:typename:mi &
operator -=	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	practice/cf/random/i_hate_math_problems/testing.cpp	/^  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->v/;"	f	struct:modint	typeref:typename:modint<MOD> &	file:
operator -=	practice/december2021/DP/counting_towers/sol.cpp	/^    Modular& operator-=(Modular const& b) {value -= b.value; if (value < 0) value += MOD;return /;"	f	struct:Modular	typeref:typename:Modular &	file:
operator -=	practice/usacoguide/gold/introDP/arraydescription.cpp	/^mi& operator-=(mi& a, mi b) { $/;"	f	typeref:typename:mi &
operator /	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Geometry/All Pair Segment Intersection.cpp	/^    PT operator \/ (const double a) const {$/;"	f	struct:PT	typeref:typename:PT	file:
operator /	code-library/Geometry/Geometry 2D.cpp	/^    PT operator \/ (const double a) const { return PT(x \/ a, y \/ a); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator /	code-library/Geometry/Geometry 3D.cpp	/^    PT operator \/ (const double a) const { return PT(x \/ a, y \/ a); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator /	code-library/Geometry/Geometry 3D.cpp	/^    p3 operator \/ (const double a) const { return p3(x \/ a, y \/ a, z \/ a); }$/;"	f	struct:p3	typeref:typename:p3	file:
operator /	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    PT operator \/ (const double a) const { return PT(x \/ a, y \/ a); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator /	code-library/Geometry/Half Plane Intersection.cpp	/^    PT operator \/ (const double a) const { return PT(x \/ a, y \/ a); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator /	code-library/Geometry/Voronoi Diagram.cpp	/^    PT operator \/ (const double a) const { return PT(x \/ a, y \/ a); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator /	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^    inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Graph Theory/Number of Arborescence.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Graph Theory/Number of DAG.cpp	/^    inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Graph Theory/Tree Isomorphism.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Math/BerleKamp Massey.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Math/Characteristic Polynomial Faster.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Math/Determinant of Sparse Matrix.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Math/FWHT in Ternary Base.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Math/Faulhaber Formula Fastest.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly operator \/ (const mint &x) const{ return (*this) * x.inv(); }$/;"	f	struct:poly	typeref:typename:poly	file:
operator /	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly operator \/ (const poly &t) const {return divmod(t).first;}$/;"	f	struct:poly	typeref:typename:poly	file:
operator /	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^    inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Math/Hafnian of a Matrix.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Math/Lagrange Interpolation Brute.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Math/Lagrange Interpolation.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Math/Linear Recurrence.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Math/Polynomial Sum.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Math/Polynomial.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Math/Polynomial.cpp	/^  poly operator \/ (const mint &x) const{ return (*this) * x.inv(); }$/;"	f	struct:poly	typeref:typename:poly	file:
operator /	code-library/Math/Polynomial.cpp	/^  poly operator \/ (const poly &t) const {return divmod(t).first;}$/;"	f	struct:poly	typeref:typename:poly	file:
operator /	code-library/Math/Subset Sum Problem.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Math/Subset Sum Problem.cpp	/^  poly operator \/ (const mint &x) const{ return (*this) * x.inv(); }$/;"	f	struct:poly	typeref:typename:poly	file:
operator /	code-library/Math/The Slime Trick.cpp	/^    inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Math/Thomas Algorithm.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Math/Vandermonde Matrix.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Miscellaneous/BigInt.cpp	/^  BigInt operator\/(const BigInt &v) const {$/;"	f	struct:BigInt	typeref:typename:BigInt	file:
operator /	code-library/Miscellaneous/BigInt.cpp	/^  BigInt operator\/(int v) const {$/;"	f	struct:BigInt	typeref:typename:BigInt	file:
operator /	code-library/Miscellaneous/BigInt.cpp	/^  template<class U> cplx operator\/(const U &c) const {$/;"	f	struct:cplx	typeref:typename:cplx	file:
operator /	code-library/Number Theory/Bell Number.cpp	/^    inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Number Theory/Bell Number.cpp	/^    poly operator \/ (const mint &x) const{ return (*this) * x.inv(); }$/;"	f	struct:poly	typeref:typename:poly	file:
operator /	code-library/Number Theory/Combinatorics Basics.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Number Theory/Dirichlet Convolution.cpp	/^    inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Number Theory/Lucas Theorem.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Number Theory/Min_25 Sieve.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Number Theory/Partition Function.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Number Theory/Phi Field.cpp	/^  field operator \/ (const mint &oth) const {$/;"	f	struct:field	typeref:typename:field	file:
operator /	code-library/Number Theory/Phi Field.cpp	/^  field operator \/ (field oth) {$/;"	f	struct:field	typeref:typename:field	file:
operator /	code-library/Number Theory/Phi Field.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Number Theory/Prime Number System.cpp	/^  base operator \/ (base p) {$/;"	f	struct:base	typeref:typename:base	file:
operator /	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly operator \/ (const mint &x) const{ return (*this) * x.inv(); }$/;"	f	struct:poly	typeref:typename:poly	file:
operator /	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^    friend u64 operator \/ (u64 n, fast_div d) { return u128(n) * d.x >> d.s; }$/;"	f	class:poly	typeref:typename:u64	file:
operator /	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Geometry/All Pair Segment Intersection.cpp	/^    PT operator \/ (const double a) const {$/;"	f	struct:PT	typeref:typename:PT	file:
operator /	code/Geometry/Geometry 2D.cpp	/^    PT operator \/ (const double a) const { return PT(x \/ a, y \/ a); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator /	code/Geometry/Geometry 3D.cpp	/^    PT operator \/ (const double a) const { return PT(x \/ a, y \/ a); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator /	code/Geometry/Geometry 3D.cpp	/^    p3 operator \/ (const double a) const { return p3(x \/ a, y \/ a, z \/ a); }$/;"	f	struct:p3	typeref:typename:p3	file:
operator /	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    PT operator \/ (const double a) const { return PT(x \/ a, y \/ a); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator /	code/Geometry/Half Plane Intersection.cpp	/^    PT operator \/ (const double a) const { return PT(x \/ a, y \/ a); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator /	code/Geometry/Voronoi Diagram.cpp	/^    PT operator \/ (const double a) const { return PT(x \/ a, y \/ a); }$/;"	f	struct:PT	typeref:typename:PT	file:
operator /	code/Graph Theory/Chromatic Polynoimial.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Graph Theory/Counting Labeled Graphs.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Graph Theory/Hafnian of a Matrix.cpp	/^    inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Graph Theory/Number of Arborescence.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Graph Theory/Number of DAG.cpp	/^    inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Graph Theory/Tree Isomorphism.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Math/BerleKamp Massey.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Math/Characteristic Polynomial Faster.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Math/Determinant of Sparse Matrix.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Math/FWHT in Ternary Base.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Math/Faulhaber Formula Fastest.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Math/Faulhaber Formula Fastest.cpp	/^  poly operator \/ (const mint &x) const{ return (*this) * x.inv(); }$/;"	f	struct:poly	typeref:typename:poly	file:
operator /	code/Math/Faulhaber Formula Fastest.cpp	/^  poly operator \/ (const poly &t) const {return divmod(t).first;}$/;"	f	struct:poly	typeref:typename:poly	file:
operator /	code/Math/Generating Function of a Linear Recurrence.cpp	/^    inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Math/Hafnian of a Matrix.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Math/Lagrange Interpolation Brute.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Math/Lagrange Interpolation.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Math/Linear Recurrence.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Math/Number of Solutions of A Equation MITM.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Math/Polynomial Sum.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Math/Polynomial.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Math/Polynomial.cpp	/^  poly operator \/ (const mint &x) const{ return (*this) * x.inv(); }$/;"	f	struct:poly	typeref:typename:poly	file:
operator /	code/Math/Polynomial.cpp	/^  poly operator \/ (const poly &t) const {return divmod(t).first;}$/;"	f	struct:poly	typeref:typename:poly	file:
operator /	code/Math/Subset Sum Problem.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Math/Subset Sum Problem.cpp	/^  poly operator \/ (const mint &x) const{ return (*this) * x.inv(); }$/;"	f	struct:poly	typeref:typename:poly	file:
operator /	code/Math/The Slime Trick.cpp	/^    inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Math/Thomas Algorithm.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Math/Vandermonde Matrix.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Miscellaneous/BigInt.cpp	/^  BigInt operator\/(const BigInt &v) const {$/;"	f	struct:BigInt	typeref:typename:BigInt	file:
operator /	code/Miscellaneous/BigInt.cpp	/^  BigInt operator\/(int v) const {$/;"	f	struct:BigInt	typeref:typename:BigInt	file:
operator /	code/Miscellaneous/BigInt.cpp	/^  template<class U> cplx operator\/(const U &c) const {$/;"	f	struct:cplx	typeref:typename:cplx	file:
operator /	code/Number Theory/Bell Number.cpp	/^    inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Number Theory/Bell Number.cpp	/^    poly operator \/ (const mint &x) const{ return (*this) * x.inv(); }$/;"	f	struct:poly	typeref:typename:poly	file:
operator /	code/Number Theory/Combinatorics Basics.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Number Theory/Dirichlet Convolution.cpp	/^    inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Number Theory/Lucas Theorem.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Number Theory/Min_25 Sieve.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Number Theory/Partition Function.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Number Theory/Phi Field.cpp	/^  field operator \/ (const mint &oth) const {$/;"	f	struct:field	typeref:typename:field	file:
operator /	code/Number Theory/Phi Field.cpp	/^  field operator \/ (field oth) {$/;"	f	struct:field	typeref:typename:field	file:
operator /	code/Number Theory/Phi Field.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Number Theory/Prime Number System.cpp	/^  base operator \/ (base p) {$/;"	f	struct:base	typeref:typename:base	file:
operator /	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly operator \/ (const mint &x) const{ return (*this) * x.inv(); }$/;"	f	struct:poly	typeref:typename:poly	file:
operator /	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^    friend u64 operator \/ (u64 n, fast_div d) { return u128(n) * d.x >> d.s; }$/;"	f	class:poly	typeref:typename:u64	file:
operator /	code/modint.hpp	/^    friend Mint operator\/(Mint a, Mint const b) { return a \/= b; }$/;"	f	typeref:typename:Mint
operator /	practice/cf/random/1700/6.cpp	/^mi operator\/(mi a, mi b) { return a * inv(b); }$/;"	f	typeref:typename:mi
operator /	practice/cf/random/i_hate_math_problems/1422C.cpp	/^mi operator\/(mi a, mi b) { return a*inv(b); }$/;"	f	typeref:typename:mi
operator /	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	practice/cf/random/i_hate_math_problems/testing.cpp	/^  inline modint<MOD> operator \/  (modint<MOD> other) const { return *this *  other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /	practice/december2021/DP/counting_towers/sol.cpp	/^    friend Modular operator\/(Modular a, Modular const b) { return a \/= b; }$/;"	f	typeref:typename:Modular	file:
operator /	practice/usacoguide/gold/introDP/arraydescription.cpp	/^mi operator\/(mi a, mi b) { return a*inv(b); }$/;"	f	typeref:typename:mi
operator /=	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^    inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Graph Theory/Number of Arborescence.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Graph Theory/Number of DAG.cpp	/^    inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Graph Theory/Tree Isomorphism.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Math/BerleKamp Massey.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Math/Characteristic Polynomial Faster.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Math/Determinant of Sparse Matrix.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Math/FWHT in Ternary Base.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Math/Faulhaber Formula Fastest.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly& operator \/= (const mint &x) { return *this = (*this) \/ x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator /=	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly& operator \/= (const poly &t) {return *this = divmod(t).first;}$/;"	f	struct:poly	typeref:typename:poly &	file:
operator /=	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^    inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Math/Hafnian of a Matrix.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Math/Lagrange Interpolation Brute.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Math/Lagrange Interpolation.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Math/Linear Recurrence.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Math/Polynomial Sum.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Math/Polynomial.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Math/Polynomial.cpp	/^  poly& operator \/= (const mint &x) { return *this = (*this) \/ x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator /=	code-library/Math/Polynomial.cpp	/^  poly& operator \/= (const poly &t) {return *this = divmod(t).first;}$/;"	f	struct:poly	typeref:typename:poly &	file:
operator /=	code-library/Math/Subset Sum Problem.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Math/Subset Sum Problem.cpp	/^  poly& operator \/= (const mint &x) { return *this = (*this) \/ x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator /=	code-library/Math/The Slime Trick.cpp	/^    inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Math/Thomas Algorithm.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Math/Vandermonde Matrix.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Miscellaneous/BigInt.cpp	/^  template<class U> void operator\/=(const U &c) {$/;"	f	struct:cplx	typeref:typename:void	file:
operator /=	code-library/Miscellaneous/BigInt.cpp	/^  void operator\/=(const BigInt &v) {$/;"	f	struct:BigInt	typeref:typename:void	file:
operator /=	code-library/Miscellaneous/BigInt.cpp	/^  void operator\/=(int v) {$/;"	f	struct:BigInt	typeref:typename:void	file:
operator /=	code-library/Number Theory/Bell Number.cpp	/^    inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Number Theory/Bell Number.cpp	/^    poly& operator \/= (const mint &x) { return *this = (*this) \/ x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator /=	code-library/Number Theory/Combinatorics Basics.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Number Theory/Dirichlet Convolution.cpp	/^    inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Number Theory/Lucas Theorem.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Number Theory/Min_25 Sieve.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Number Theory/Partition Function.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Number Theory/Phi Field.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Number Theory/Prime Number System.cpp	/^  base& operator \/= (base p) {$/;"	f	struct:base	typeref:typename:base &	file:
operator /=	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly& operator \/= (const mint &x) { return *this = (*this) \/ x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator /=	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Graph Theory/Chromatic Polynoimial.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Graph Theory/Counting Labeled Graphs.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Graph Theory/Hafnian of a Matrix.cpp	/^    inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Graph Theory/Number of Arborescence.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Graph Theory/Number of DAG.cpp	/^    inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Graph Theory/Tree Isomorphism.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Math/BerleKamp Massey.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Math/Characteristic Polynomial Faster.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Math/Determinant of Sparse Matrix.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Math/FWHT in Ternary Base.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Math/Faulhaber Formula Fastest.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Math/Faulhaber Formula Fastest.cpp	/^  poly& operator \/= (const mint &x) { return *this = (*this) \/ x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator /=	code/Math/Faulhaber Formula Fastest.cpp	/^  poly& operator \/= (const poly &t) {return *this = divmod(t).first;}$/;"	f	struct:poly	typeref:typename:poly &	file:
operator /=	code/Math/Generating Function of a Linear Recurrence.cpp	/^    inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Math/Hafnian of a Matrix.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Math/Lagrange Interpolation Brute.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Math/Lagrange Interpolation.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Math/Linear Recurrence.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Math/Number of Solutions of A Equation MITM.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Math/Polynomial Sum.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Math/Polynomial.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Math/Polynomial.cpp	/^  poly& operator \/= (const mint &x) { return *this = (*this) \/ x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator /=	code/Math/Polynomial.cpp	/^  poly& operator \/= (const poly &t) {return *this = divmod(t).first;}$/;"	f	struct:poly	typeref:typename:poly &	file:
operator /=	code/Math/Subset Sum Problem.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Math/Subset Sum Problem.cpp	/^  poly& operator \/= (const mint &x) { return *this = (*this) \/ x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator /=	code/Math/The Slime Trick.cpp	/^    inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Math/Thomas Algorithm.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Math/Vandermonde Matrix.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Miscellaneous/BigInt.cpp	/^  template<class U> void operator\/=(const U &c) {$/;"	f	struct:cplx	typeref:typename:void	file:
operator /=	code/Miscellaneous/BigInt.cpp	/^  void operator\/=(const BigInt &v) {$/;"	f	struct:BigInt	typeref:typename:void	file:
operator /=	code/Miscellaneous/BigInt.cpp	/^  void operator\/=(int v) {$/;"	f	struct:BigInt	typeref:typename:void	file:
operator /=	code/Number Theory/Bell Number.cpp	/^    inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Number Theory/Bell Number.cpp	/^    poly& operator \/= (const mint &x) { return *this = (*this) \/ x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator /=	code/Number Theory/Combinatorics Basics.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Number Theory/Dirichlet Convolution.cpp	/^    inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Number Theory/Lucas Theorem.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Number Theory/Min_25 Sieve.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Number Theory/Partition Function.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Number Theory/Phi Field.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Number Theory/Prime Number System.cpp	/^  base& operator \/= (base p) {$/;"	f	struct:base	typeref:typename:base &	file:
operator /=	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly& operator \/= (const mint &x) { return *this = (*this) \/ x; }$/;"	f	struct:poly	typeref:typename:poly &	file:
operator /=	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	code/modint.hpp	/^    Mint& operator\/=(Mint const& b) { return *this *= inverse(b); }$/;"	f	struct:Mint	typeref:typename:Mint &
operator /=	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	practice/cf/random/i_hate_math_problems/testing.cpp	/^  inline modint<MOD> operator \/= (modint<MOD> other)       { return *this *= other.inv(); }$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
operator /=	practice/december2021/DP/counting_towers/sol.cpp	/^    Modular& operator\/=(Modular const& b) { return *this *= inverse(b); }$/;"	f	struct:Modular	typeref:typename:Modular &	file:
operator <	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Data Structures/MOs Algorithm.cpp	/^  bool operator < (const query &x) const {$/;"	f	struct:query	typeref:typename:bool	file:
operator <	code-library/Data Structures/MOs on tree.cpp	/^  bool operator < (const query &x) const {$/;"	f	struct:query	typeref:typename:bool	file:
operator <	code-library/Data Structures/MOs with Update.cpp	/^  bool operator < (const query &x) const {$/;"	f	struct:query	typeref:typename:bool	file:
operator <	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^  bool operator < (const line& rhs) const {$/;"	f	struct:line	typeref:typename:bool	file:
operator <	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Geometry/All Pair Segment Intersection.cpp	/^    bool operator < (PT a) const {$/;"	f	struct:PT	typeref:typename:bool	file:
operator <	code-library/Geometry/All Pair Segment Intersection.cpp	/^    bool operator < (const event& e) const {$/;"	f	struct:event	typeref:typename:bool	file:
operator <	code-library/Geometry/All Pair Segment Intersection.cpp	/^bool operator < (const seg& a, const seg& b) {$/;"	f	typeref:typename:bool
operator <	code-library/Geometry/Delaunay Triangulation.cpp	/^    bool operator < (PT a) const { return sign(a.x - x) == 0 ? y < a.y : x < a.x; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator <	code-library/Geometry/Geometry 2D.cpp	/^    bool operator < (PT a) const { return sign(a.x - x) == 0 ? y < a.y : x < a.x; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator <	code-library/Geometry/Geometry 2D.cpp	/^    int operator < (const HP& rhs) const {$/;"	f	struct:HP	typeref:typename:int	file:
operator <	code-library/Geometry/Geometry 3D.cpp	/^    bool operator < (PT a) const { return sign(a.x - x) == 0 ? y < a.y : x < a.x; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator <	code-library/Geometry/Geometry 3D.cpp	/^bool operator < (p3 p, p3 q) {$/;"	f	typeref:typename:bool
operator <	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    bool operator < (PT a) const { return sign(a.x - x) == 0 ? y < a.y : x < a.x; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator <	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^bool operator < (Angle a, Angle b) {$/;"	f	typeref:typename:bool
operator <	code-library/Geometry/Half Plane Intersection.cpp	/^    bool operator < (PT a) const { return sign(a.x - x) == 0 ? y < a.y : x < a.x; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator <	code-library/Geometry/Half Plane Intersection.cpp	/^    int operator < (const HP& rhs) const {$/;"	f	struct:HP	typeref:typename:int	file:
operator <	code-library/Geometry/Onion Decomposition.cpp	/^    bool operator < (PT p) const { if (y != p.y) return y < p.y; return x < p.x; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator <	code-library/Geometry/Point Location.cpp	/^    bool operator < (const Event& event) const {$/;"	f	struct:Event	typeref:typename:bool	file:
operator <	code-library/Geometry/Voronoi Diagram.cpp	/^    bool operator < (P a) const { return sgn(a.x - x) == 0 ? y < a.y : x < a.x; }$/;"	f	struct:P	typeref:typename:bool	file:
operator <	code-library/Geometry/Voronoi Diagram.cpp	/^    bool operator < (PT a) const { return sign(a.x - x) == 0 ? y < a.y : x < a.x; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator <	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^    inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Graph Theory/Manhattan MST.cpp	/^  bool operator < (const PT &p) const {$/;"	f	struct:PT	typeref:typename:bool	file:
operator <	code-library/Graph Theory/Manhattan MST.cpp	/^  bool operator < (const edge &p) const { return w < p.w; }$/;"	f	struct:edge	typeref:typename:bool	file:
operator <	code-library/Graph Theory/Number of Arborescence.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Graph Theory/Tree Isomorphism.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Math/BerleKamp Massey.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Math/Characteristic Polynomial Faster.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Math/Determinant of Sparse Matrix.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Math/Faulhaber Formula Fastest.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^    inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Math/Hafnian of a Matrix.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Math/Lagrange Interpolation Brute.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Math/Lagrange Interpolation.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Math/Linear Recurrence.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Math/Polynomial Sum.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Math/Polynomial.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Math/Subset Sum Problem.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Math/The Slime Trick.cpp	/^    inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Math/Thomas Algorithm.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Math/Vandermonde Matrix.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Miscellaneous/BigInt.cpp	/^  bool operator<(const BigInt &v) const {$/;"	f	struct:BigInt	typeref:typename:bool	file:
operator <	code-library/Miscellaneous/Bitset Custom.cpp	/^    inline bool operator < (const Bitset &x) const {$/;"	f	struct:Bitset	typeref:typename:bool	file:
operator <	code-library/Number Theory/Bell Number.cpp	/^    inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Number Theory/Combinatorics Basics.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Number Theory/Dirichlet Convolution.cpp	/^    inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Number Theory/Lucas Theorem.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Number Theory/Min_25 Sieve.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Number Theory/Partition Function.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Number Theory/Phi Field.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  bool operator < (const query &x) const {$/;"	f	struct:query	typeref:typename:bool	file:
operator <	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Data Structures/MOs Algorithm.cpp	/^  bool operator < (const query &x) const {$/;"	f	struct:query	typeref:typename:bool	file:
operator <	code/Data Structures/MOs on tree.cpp	/^  bool operator < (const query &x) const {$/;"	f	struct:query	typeref:typename:bool	file:
operator <	code/Data Structures/MOs with Update.cpp	/^  bool operator < (const query &x) const {$/;"	f	struct:query	typeref:typename:bool	file:
operator <	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^  bool operator < (const line& rhs) const {$/;"	f	struct:line	typeref:typename:bool	file:
operator <	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Geometry/All Pair Segment Intersection.cpp	/^    bool operator < (PT a) const {$/;"	f	struct:PT	typeref:typename:bool	file:
operator <	code/Geometry/All Pair Segment Intersection.cpp	/^    bool operator < (const event& e) const {$/;"	f	struct:event	typeref:typename:bool	file:
operator <	code/Geometry/All Pair Segment Intersection.cpp	/^bool operator < (const seg& a, const seg& b) {$/;"	f	typeref:typename:bool
operator <	code/Geometry/Delaunay Triangulation.cpp	/^    bool operator < (PT a) const { return sign(a.x - x) == 0 ? y < a.y : x < a.x; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator <	code/Geometry/Geometry 2D.cpp	/^    bool operator < (PT a) const { return sign(a.x - x) == 0 ? y < a.y : x < a.x; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator <	code/Geometry/Geometry 2D.cpp	/^    int operator < (const HP& rhs) const {$/;"	f	struct:HP	typeref:typename:int	file:
operator <	code/Geometry/Geometry 3D.cpp	/^    bool operator < (PT a) const { return sign(a.x - x) == 0 ? y < a.y : x < a.x; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator <	code/Geometry/Geometry 3D.cpp	/^bool operator < (p3 p, p3 q) {$/;"	f	typeref:typename:bool
operator <	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    bool operator < (PT a) const { return sign(a.x - x) == 0 ? y < a.y : x < a.x; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator <	code/Geometry/Half Plane Intersection Dynamic.cpp	/^bool operator < (Angle a, Angle b) {$/;"	f	typeref:typename:bool
operator <	code/Geometry/Half Plane Intersection.cpp	/^    bool operator < (PT a) const { return sign(a.x - x) == 0 ? y < a.y : x < a.x; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator <	code/Geometry/Half Plane Intersection.cpp	/^    int operator < (const HP& rhs) const {$/;"	f	struct:HP	typeref:typename:int	file:
operator <	code/Geometry/Onion Decomposition.cpp	/^    bool operator < (PT p) const { if (y != p.y) return y < p.y; return x < p.x; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator <	code/Geometry/Point Location.cpp	/^    bool operator < (const Event& event) const {$/;"	f	struct:Event	typeref:typename:bool	file:
operator <	code/Geometry/Voronoi Diagram.cpp	/^    bool operator < (P a) const { return sgn(a.x - x) == 0 ? y < a.y : x < a.x; }$/;"	f	struct:P	typeref:typename:bool	file:
operator <	code/Geometry/Voronoi Diagram.cpp	/^    bool operator < (PT a) const { return sign(a.x - x) == 0 ? y < a.y : x < a.x; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator <	code/Graph Theory/Hafnian of a Matrix.cpp	/^    inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Graph Theory/Manhattan MST.cpp	/^  bool operator < (const PT &p) const {$/;"	f	struct:PT	typeref:typename:bool	file:
operator <	code/Graph Theory/Manhattan MST.cpp	/^  bool operator < (const edge &p) const { return w < p.w; }$/;"	f	struct:edge	typeref:typename:bool	file:
operator <	code/Graph Theory/Number of Arborescence.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Graph Theory/Tree Isomorphism.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Math/BerleKamp Massey.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Math/Characteristic Polynomial Faster.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Math/Determinant of Sparse Matrix.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Math/Faulhaber Formula Fastest.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Math/Generating Function of a Linear Recurrence.cpp	/^    inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Math/Hafnian of a Matrix.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Math/Lagrange Interpolation Brute.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Math/Lagrange Interpolation.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Math/Linear Recurrence.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Math/Number of Solutions of A Equation MITM.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Math/Polynomial Sum.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Math/Polynomial.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Math/Subset Sum Problem.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Math/The Slime Trick.cpp	/^    inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Math/Thomas Algorithm.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Math/Vandermonde Matrix.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Miscellaneous/BigInt.cpp	/^  bool operator<(const BigInt &v) const {$/;"	f	struct:BigInt	typeref:typename:bool	file:
operator <	code/Miscellaneous/Bitset Custom.cpp	/^    inline bool operator < (const Bitset &x) const {$/;"	f	struct:Bitset	typeref:typename:bool	file:
operator <	code/Number Theory/Bell Number.cpp	/^    inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Number Theory/Combinatorics Basics.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Number Theory/Dirichlet Convolution.cpp	/^    inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Number Theory/Lucas Theorem.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Number Theory/Min_25 Sieve.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Number Theory/Partition Function.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Number Theory/Phi Field.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  bool operator < (const query &x) const {$/;"	f	struct:query	typeref:typename:bool	file:
operator <	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <	practice/cf/random/i_hate_math_problems/testing.cpp	/^  inline bool operator < (modint<MOD> other) const { return value < other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator <<	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Graph Theory/Number of Arborescence.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Graph Theory/Number of DAG.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Graph Theory/Tree Isomorphism.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Math/BerleKamp Massey.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Math/Characteristic Polynomial Faster.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Math/Determinant of Sparse Matrix.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Math/FWHT in Ternary Base.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Math/Faulhaber Formula Fastest.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Math/Hafnian of a Matrix.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Math/Lagrange Interpolation Brute.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Math/Lagrange Interpolation.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Math/Linear Recurrence.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Math/Polynomial Factorization.cpp	/^std::ostream& operator << (std::ostream& o, const vi& v) {$/;"	f	typeref:typename:std::ostream &
operator <<	code-library/Math/Polynomial Sum.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Math/Polynomial.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Math/Subset Sum Problem.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Math/The Slime Trick.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Math/Thomas Algorithm.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Math/Vandermonde Matrix.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Miscellaneous/BigInt.cpp	/^  friend ostream& operator<<(ostream &out, const BigInt &v) {$/;"	f	typeref:typename:ostream &	file:
operator <<	code-library/Miscellaneous/Bitset Custom.cpp	/^    inline Bitset operator << (const int k) const {$/;"	f	struct:Bitset	typeref:typename:Bitset	file:
operator <<	code-library/Number Theory/Bell Number.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Number Theory/Combinatorics Basics.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Number Theory/Dirichlet Convolution.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Number Theory/Lucas Theorem.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Number Theory/Min_25 Sieve.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Number Theory/Partition Function.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Number Theory/Phi Field.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  friend ostream& operator << (ostream& os, const Mod& m) { return os << m.get(); }$/;"	f	namespace:ntt	typeref:typename:ostream &	file:
operator <<	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Graph Theory/Chromatic Polynoimial.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Graph Theory/Counting Labeled Graphs.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Graph Theory/Hafnian of a Matrix.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Graph Theory/Number of Arborescence.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Graph Theory/Number of DAG.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Graph Theory/Tree Isomorphism.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Math/BerleKamp Massey.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Math/Characteristic Polynomial Faster.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Math/Determinant of Sparse Matrix.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Math/FWHT in Ternary Base.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Math/Faulhaber Formula Fastest.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Math/Generating Function of a Linear Recurrence.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Math/Hafnian of a Matrix.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Math/Lagrange Interpolation Brute.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Math/Lagrange Interpolation.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Math/Linear Recurrence.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Math/Number of Solutions of A Equation MITM.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Math/Polynomial Factorization.cpp	/^std::ostream& operator << (std::ostream& o, const vi& v) {$/;"	f	typeref:typename:std::ostream &
operator <<	code/Math/Polynomial Sum.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Math/Polynomial.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Math/Subset Sum Problem.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Math/The Slime Trick.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Math/Thomas Algorithm.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Math/Vandermonde Matrix.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Miscellaneous/BigInt.cpp	/^  friend ostream& operator<<(ostream &out, const BigInt &v) {$/;"	f	typeref:typename:ostream &	file:
operator <<	code/Miscellaneous/Bitset Custom.cpp	/^    inline Bitset operator << (const int k) const {$/;"	f	struct:Bitset	typeref:typename:Bitset	file:
operator <<	code/Number Theory/Bell Number.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Number Theory/Combinatorics Basics.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Number Theory/Dirichlet Convolution.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Number Theory/Lucas Theorem.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Number Theory/Min_25 Sieve.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Number Theory/Partition Function.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Number Theory/Phi Field.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  friend ostream& operator << (ostream& os, const Mod& m) { return os << m.get(); }$/;"	f	namespace:ntt	typeref:typename:ostream &	file:
operator <<	code/modint.hpp	/^    friend std::ostream& operator<<(std::ostream& os, Mint const& a) {return os << a.value;}$/;"	f	typeref:typename:std::ostream &
operator <<	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	practice/cf/random/i_hate_math_problems/testing.cpp	/^template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.va/;"	f	typeref:typename:ostream &
operator <<	practice/december2021/DP/counting_towers/sol.cpp	/^    friend std::ostream& operator<<(std::ostream& os, Modular const& a) {return os << a.value;}$/;"	f	typeref:typename:std::ostream &	file:
operator <=	code-library/Miscellaneous/BigInt.cpp	/^  bool operator<=(const BigInt &v) const {$/;"	f	struct:BigInt	typeref:typename:bool	file:
operator <=	code/Miscellaneous/BigInt.cpp	/^  bool operator<=(const BigInt &v) const {$/;"	f	struct:BigInt	typeref:typename:bool	file:
operator =	code-library/Miscellaneous/BigInt.cpp	/^  BigInt& operator = (BigInt other) {$/;"	f	struct:BigInt	typeref:typename:BigInt &	file:
operator =	code-library/Miscellaneous/BigInt.cpp	/^  BigInt& operator = (ll v) {$/;"	f	struct:BigInt	typeref:typename:BigInt &	file:
operator =	code/Miscellaneous/BigInt.cpp	/^  BigInt& operator = (BigInt other) {$/;"	f	struct:BigInt	typeref:typename:BigInt &	file:
operator =	code/Miscellaneous/BigInt.cpp	/^  BigInt& operator = (ll v) {$/;"	f	struct:BigInt	typeref:typename:BigInt &	file:
operator ==	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Geometry/All Pair Segment Intersection.cpp	/^    bool operator == (PT a) const {$/;"	f	struct:PT	typeref:typename:bool	file:
operator ==	code-library/Geometry/Delaunay Triangulation.cpp	/^    bool operator == (PT a) const { return sign(a.x - x) == 0 && sign(a.y - y) == 0; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator ==	code-library/Geometry/Geometry 2D.cpp	/^    bool operator == (PT a) const { return sign(a.x - x) == 0 && sign(a.y - y) == 0; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator ==	code-library/Geometry/Geometry 2D.cpp	/^    bool operator == (circle v) { return p == v.p && sign(r - v.r) == 0; }$/;"	f	struct:circle	typeref:typename:bool	file:
operator ==	code-library/Geometry/Geometry 3D.cpp	/^    bool operator == (PT a) const { return sign(a.x - x) == 0 && sign(a.y - y) == 0; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator ==	code-library/Geometry/Geometry 3D.cpp	/^    bool operator == (p3 a) const { return sign(a.x - x) == 0 && sign(a.y - y) == 0 && sign(a.z /;"	f	struct:p3	typeref:typename:bool	file:
operator ==	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    bool operator == (PT a) const { return sign(a.x - x) == 0 && sign(a.y - y) == 0; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator ==	code-library/Geometry/Half Plane Intersection.cpp	/^    bool operator == (PT a) const { return sign(a.x - x) == 0 && sign(a.y - y) == 0; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator ==	code-library/Geometry/Onion Decomposition.cpp	/^    bool operator == (PT p) const { return x == p.x && y == p.y; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator ==	code-library/Geometry/Point Location.cpp	/^    bool operator == (const PT& a) const { return a.x == x && a.y == y; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator ==	code-library/Geometry/Voronoi Diagram.cpp	/^    bool operator == (P a) const { return sgn(a.x - x) == 0 && sgn(a.y - y) == 0; }$/;"	f	struct:P	typeref:typename:bool	file:
operator ==	code-library/Geometry/Voronoi Diagram.cpp	/^    bool operator == (PT a) const { return sign(a.x - x) == 0 && sign(a.y - y) == 0; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator ==	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^    inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Graph Theory/Number of Arborescence.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Graph Theory/Number of DAG.cpp	/^    inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Graph Theory/Tree Isomorphism.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Math/BerleKamp Massey.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Math/Characteristic Polynomial Faster.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Math/Determinant of Sparse Matrix.cpp	/^  inline bool operator == (const Mat& b) { return a == b.a; }$/;"	f	struct:Mat	typeref:typename:bool	file:
operator ==	code-library/Math/Determinant of Sparse Matrix.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Math/FWHT in Ternary Base.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Math/Faulhaber Formula Fastest.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Math/Freivalds Algorithm.cpp	/^  inline bool operator == (const Mat& b) { return a == b.a; }$/;"	f	struct:Mat	typeref:typename:bool	file:
operator ==	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^    inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Math/Hafnian of a Matrix.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Math/Lagrange Interpolation Brute.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Math/Lagrange Interpolation.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Math/Linear Recurrence.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Math/Matrix Exponentiation.cpp	/^  inline bool operator == (const Mat& b) { return a == b.a; }$/;"	f	struct:Mat	typeref:typename:bool	file:
operator ==	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Math/Polynomial Sum.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Math/Polynomial.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Math/Subset Sum Problem.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Math/The Slime Trick.cpp	/^    inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Math/Thomas Algorithm.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Math/Vandermonde Matrix.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Miscellaneous/BigInt.cpp	/^  bool operator==(const BigInt &v) const {$/;"	f	struct:BigInt	typeref:typename:bool	file:
operator ==	code-library/Miscellaneous/Bitset Custom.cpp	/^    inline bool operator == (const Bitset &x) const {$/;"	f	struct:Bitset	typeref:typename:bool	file:
operator ==	code-library/Number Theory/Bell Number.cpp	/^    inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Number Theory/Combinatorics Basics.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Number Theory/Dirichlet Convolution.cpp	/^    inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Number Theory/Lucas Theorem.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Number Theory/Min_25 Sieve.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Number Theory/Partition Function.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Number Theory/Phi Field.cpp	/^  bool operator == (const field &oth) const {$/;"	f	struct:field	typeref:typename:bool	file:
operator ==	code-library/Number Theory/Phi Field.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Geometry/All Pair Segment Intersection.cpp	/^    bool operator == (PT a) const {$/;"	f	struct:PT	typeref:typename:bool	file:
operator ==	code/Geometry/Delaunay Triangulation.cpp	/^    bool operator == (PT a) const { return sign(a.x - x) == 0 && sign(a.y - y) == 0; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator ==	code/Geometry/Geometry 2D.cpp	/^    bool operator == (PT a) const { return sign(a.x - x) == 0 && sign(a.y - y) == 0; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator ==	code/Geometry/Geometry 2D.cpp	/^    bool operator == (circle v) { return p == v.p && sign(r - v.r) == 0; }$/;"	f	struct:circle	typeref:typename:bool	file:
operator ==	code/Geometry/Geometry 3D.cpp	/^    bool operator == (PT a) const { return sign(a.x - x) == 0 && sign(a.y - y) == 0; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator ==	code/Geometry/Geometry 3D.cpp	/^    bool operator == (p3 a) const { return sign(a.x - x) == 0 && sign(a.y - y) == 0 && sign(a.z /;"	f	struct:p3	typeref:typename:bool	file:
operator ==	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    bool operator == (PT a) const { return sign(a.x - x) == 0 && sign(a.y - y) == 0; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator ==	code/Geometry/Half Plane Intersection.cpp	/^    bool operator == (PT a) const { return sign(a.x - x) == 0 && sign(a.y - y) == 0; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator ==	code/Geometry/Onion Decomposition.cpp	/^    bool operator == (PT p) const { return x == p.x && y == p.y; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator ==	code/Geometry/Point Location.cpp	/^    bool operator == (const PT& a) const { return a.x == x && a.y == y; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator ==	code/Geometry/Voronoi Diagram.cpp	/^    bool operator == (P a) const { return sgn(a.x - x) == 0 && sgn(a.y - y) == 0; }$/;"	f	struct:P	typeref:typename:bool	file:
operator ==	code/Geometry/Voronoi Diagram.cpp	/^    bool operator == (PT a) const { return sign(a.x - x) == 0 && sign(a.y - y) == 0; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator ==	code/Graph Theory/Chromatic Polynoimial.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Graph Theory/Counting Labeled Graphs.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Graph Theory/Hafnian of a Matrix.cpp	/^    inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Graph Theory/Number of Arborescence.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Graph Theory/Number of DAG.cpp	/^    inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Graph Theory/Tree Isomorphism.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Math/BerleKamp Massey.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Math/Characteristic Polynomial Faster.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Math/Determinant of Sparse Matrix.cpp	/^  inline bool operator == (const Mat& b) { return a == b.a; }$/;"	f	struct:Mat	typeref:typename:bool	file:
operator ==	code/Math/Determinant of Sparse Matrix.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Math/FWHT in Ternary Base.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Math/Faulhaber Formula Fastest.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Math/Freivalds Algorithm.cpp	/^  inline bool operator == (const Mat& b) { return a == b.a; }$/;"	f	struct:Mat	typeref:typename:bool	file:
operator ==	code/Math/Generating Function of a Linear Recurrence.cpp	/^    inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Math/Hafnian of a Matrix.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Math/Lagrange Interpolation Brute.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Math/Lagrange Interpolation.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Math/Linear Recurrence.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Math/Matrix Exponentiation.cpp	/^  inline bool operator == (const Mat& b) { return a == b.a; }$/;"	f	struct:Mat	typeref:typename:bool	file:
operator ==	code/Math/Number of Solutions of A Equation MITM.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Math/Polynomial Sum.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Math/Polynomial.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Math/Subset Sum Problem.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Math/The Slime Trick.cpp	/^    inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Math/Thomas Algorithm.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Math/Vandermonde Matrix.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Miscellaneous/BigInt.cpp	/^  bool operator==(const BigInt &v) const {$/;"	f	struct:BigInt	typeref:typename:bool	file:
operator ==	code/Miscellaneous/Bitset Custom.cpp	/^    inline bool operator == (const Bitset &x) const {$/;"	f	struct:Bitset	typeref:typename:bool	file:
operator ==	code/Number Theory/Bell Number.cpp	/^    inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Number Theory/Combinatorics Basics.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Number Theory/Dirichlet Convolution.cpp	/^    inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Number Theory/Lucas Theorem.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Number Theory/Min_25 Sieve.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Number Theory/Partition Function.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Number Theory/Phi Field.cpp	/^  bool operator == (const field &oth) const {$/;"	f	struct:field	typeref:typename:bool	file:
operator ==	code/Number Theory/Phi Field.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	code/modint.hpp	/^    friend bool operator==(Mint const& a, Mint const& b) {return a.value == b.value;}$/;"	f	typeref:typename:bool
operator ==	practice/cf/random/i_hate_math_problems/1422C.cpp	/^bool operator==(mi a, mi b) { return a.v == b.v; }$/;"	f	typeref:typename:bool
operator ==	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	practice/cf/random/i_hate_math_problems/testing.cpp	/^  inline bool operator == (modint<MOD> other) const { return value == other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator ==	practice/december2021/DP/counting_towers/sol.cpp	/^    friend bool operator==(Modular const& a, Modular const& b) {return a.value == b.value;}$/;"	f	typeref:typename:bool	file:
operator ==	practice/usacoguide/gold/introDP/arraydescription.cpp	/^bool operator==(mi a, mi b) { return a.v == b.v; }$/;"	f	typeref:typename:bool
operator >	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Geometry/All Pair Segment Intersection.cpp	/^    bool operator > (PT a) const {$/;"	f	struct:PT	typeref:typename:bool	file:
operator >	code-library/Geometry/Geometry 2D.cpp	/^    bool operator > (PT a) const { return sign(a.x - x) == 0 ? y > a.y : x > a.x; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator >	code-library/Geometry/Geometry 3D.cpp	/^    bool operator > (PT a) const { return sign(a.x - x) == 0 ? y > a.y : x > a.x; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator >	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    bool operator > (PT a) const { return sign(a.x - x) == 0 ? y > a.y : x > a.x; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator >	code-library/Geometry/Half Plane Intersection.cpp	/^    bool operator > (PT a) const { return sign(a.x - x) == 0 ? y > a.y : x > a.x; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator >	code-library/Geometry/Voronoi Diagram.cpp	/^    bool operator > (PT a) const { return sign(a.x - x) == 0 ? y > a.y : x > a.x; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator >	code-library/Graph Theory/Directed MST.cpp	/^  bool operator > (const edge &rhs) const { return w > rhs.w; }$/;"	f	struct:edge	typeref:typename:bool	file:
operator >	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^    inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Graph Theory/Number of Arborescence.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Graph Theory/Tree Isomorphism.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Math/BerleKamp Massey.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Math/Characteristic Polynomial Faster.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Math/Determinant of Sparse Matrix.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Math/Faulhaber Formula Fastest.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^    inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Math/Hafnian of a Matrix.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Math/Lagrange Interpolation Brute.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Math/Lagrange Interpolation.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Math/Linear Recurrence.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Math/Polynomial Sum.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Math/Polynomial.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Math/Subset Sum Problem.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Math/The Slime Trick.cpp	/^    inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Math/Thomas Algorithm.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Math/Vandermonde Matrix.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Miscellaneous/BigInt.cpp	/^  bool operator>(const BigInt &v) const {$/;"	f	struct:BigInt	typeref:typename:bool	file:
operator >	code-library/Miscellaneous/Bitset Custom.cpp	/^    inline bool operator > (const Bitset &x) const {$/;"	f	struct:Bitset	typeref:typename:bool	file:
operator >	code-library/Number Theory/Bell Number.cpp	/^    inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Number Theory/Combinatorics Basics.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Number Theory/Dirichlet Convolution.cpp	/^    inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Number Theory/Lucas Theorem.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Number Theory/Min_25 Sieve.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Number Theory/Partition Function.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Number Theory/Phi Field.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Geometry/All Pair Segment Intersection.cpp	/^    bool operator > (PT a) const {$/;"	f	struct:PT	typeref:typename:bool	file:
operator >	code/Geometry/Geometry 2D.cpp	/^    bool operator > (PT a) const { return sign(a.x - x) == 0 ? y > a.y : x > a.x; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator >	code/Geometry/Geometry 3D.cpp	/^    bool operator > (PT a) const { return sign(a.x - x) == 0 ? y > a.y : x > a.x; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator >	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    bool operator > (PT a) const { return sign(a.x - x) == 0 ? y > a.y : x > a.x; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator >	code/Geometry/Half Plane Intersection.cpp	/^    bool operator > (PT a) const { return sign(a.x - x) == 0 ? y > a.y : x > a.x; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator >	code/Geometry/Voronoi Diagram.cpp	/^    bool operator > (PT a) const { return sign(a.x - x) == 0 ? y > a.y : x > a.x; }$/;"	f	struct:PT	typeref:typename:bool	file:
operator >	code/Graph Theory/Directed MST.cpp	/^  bool operator > (const edge &rhs) const { return w > rhs.w; }$/;"	f	struct:edge	typeref:typename:bool	file:
operator >	code/Graph Theory/Hafnian of a Matrix.cpp	/^    inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Graph Theory/Number of Arborescence.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Graph Theory/Tree Isomorphism.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Math/BerleKamp Massey.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Math/Characteristic Polynomial Faster.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Math/Determinant of Sparse Matrix.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Math/Faulhaber Formula Fastest.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Math/Generating Function of a Linear Recurrence.cpp	/^    inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Math/Hafnian of a Matrix.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Math/Lagrange Interpolation Brute.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Math/Lagrange Interpolation.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Math/Linear Recurrence.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Math/Number of Solutions of A Equation MITM.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Math/Polynomial Sum.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Math/Polynomial.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Math/Subset Sum Problem.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Math/The Slime Trick.cpp	/^    inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Math/Thomas Algorithm.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Math/Vandermonde Matrix.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Miscellaneous/BigInt.cpp	/^  bool operator>(const BigInt &v) const {$/;"	f	struct:BigInt	typeref:typename:bool	file:
operator >	code/Miscellaneous/Bitset Custom.cpp	/^    inline bool operator > (const Bitset &x) const {$/;"	f	struct:Bitset	typeref:typename:bool	file:
operator >	code/Number Theory/Bell Number.cpp	/^    inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Number Theory/Combinatorics Basics.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Number Theory/Dirichlet Convolution.cpp	/^    inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Number Theory/Lucas Theorem.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Number Theory/Min_25 Sieve.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Number Theory/Partition Function.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Number Theory/Phi Field.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >	practice/cf/random/i_hate_math_problems/testing.cpp	/^  inline bool operator > (modint<MOD> other) const { return value > other.value; }$/;"	f	struct:modint	typeref:typename:bool	file:
operator >=	code-library/Miscellaneous/BigInt.cpp	/^  bool operator>=(const BigInt &v) const {$/;"	f	struct:BigInt	typeref:typename:bool	file:
operator >=	code/Miscellaneous/BigInt.cpp	/^  bool operator>=(const BigInt &v) const {$/;"	f	struct:BigInt	typeref:typename:bool	file:
operator >>	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code-library/Graph Theory/Number of Arborescence.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code-library/Graph Theory/Tree Isomorphism.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code-library/Math/BerleKamp Massey.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code-library/Math/Characteristic Polynomial Faster.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code-library/Math/Determinant of Sparse Matrix.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code-library/Math/Hafnian of a Matrix.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code-library/Math/Linear Recurrence.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code-library/Math/Polynomial Sum.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code-library/Math/The Slime Trick.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code-library/Math/Thomas Algorithm.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code-library/Miscellaneous/BigInt.cpp	/^  friend istream& operator>>(istream &in, BigInt &v) {$/;"	f	typeref:typename:istream &	file:
operator >>	code-library/Miscellaneous/Bitset Custom.cpp	/^    inline Bitset operator >> (const int k) const {$/;"	f	struct:Bitset	typeref:typename:Bitset	file:
operator >>	code-library/Number Theory/Combinatorics Basics.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code-library/Number Theory/Dirichlet Convolution.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code-library/Number Theory/Lucas Theorem.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code-library/Number Theory/Min_25 Sieve.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code-library/Number Theory/Partition Function.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code-library/Number Theory/Phi Field.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Graph Theory/Hafnian of a Matrix.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Graph Theory/Number of Arborescence.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Graph Theory/Tree Isomorphism.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Math/BerleKamp Massey.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Math/Characteristic Polynomial Faster.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Math/Determinant of Sparse Matrix.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Math/Generating Function of a Linear Recurrence.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Math/Hafnian of a Matrix.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Math/Linear Recurrence.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Math/Number of Solutions of A Equation MITM.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Math/Polynomial Sum.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Math/The Slime Trick.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Math/Thomas Algorithm.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Miscellaneous/BigInt.cpp	/^  friend istream& operator>>(istream &in, BigInt &v) {$/;"	f	typeref:typename:istream &	file:
operator >>	code/Miscellaneous/Bitset Custom.cpp	/^    inline Bitset operator >> (const int k) const {$/;"	f	struct:Bitset	typeref:typename:Bitset	file:
operator >>	code/Number Theory/Combinatorics Basics.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Number Theory/Dirichlet Convolution.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Number Theory/Lucas Theorem.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Number Theory/Min_25 Sieve.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Number Theory/Partition Function.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Number Theory/Phi Field.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator >>	practice/cf/random/i_hate_math_problems/testing.cpp	/^template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.val/;"	f	typeref:typename:istream &
operator []	code-library/Math/Faulhaber Formula Fastest.cpp	/^  mint operator[](const int i) const { return (i < a.size() && i >= 0) ? a[i]: mint(0); } \/\/Be/;"	f	struct:poly	typeref:typename:mint	file:
operator []	code-library/Math/Polynomial.cpp	/^  mint operator[](const int i) const { return (i < a.size() && i >= 0) ? a[i]: mint(0); } \/\/Be/;"	f	struct:poly	typeref:typename:mint	file:
operator []	code-library/Math/Subset Sum Problem.cpp	/^  mint operator[](const int i) const { return (i < a.size() && i >= 0) ? a[i]: mint(0); } \/\/Be/;"	f	struct:poly	typeref:typename:mint	file:
operator []	code-library/Number Theory/Bell Number.cpp	/^  mint operator[](const int i) const { return (i < a.size() && i >= 0) ? a[i]: mint(0); } \/\/Be/;"	f	struct:poly	typeref:typename:mint	file:
operator []	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  mint operator[](const int i) const { return (i < a.size() && i >= 0) ? a[i]: mint(0); } \/\/Be/;"	f	struct:poly	typeref:typename:mint	file:
operator []	code/Math/Faulhaber Formula Fastest.cpp	/^  mint operator[](const int i) const { return (i < a.size() && i >= 0) ? a[i]: mint(0); } \/\/Be/;"	f	struct:poly	typeref:typename:mint	file:
operator []	code/Math/Polynomial.cpp	/^  mint operator[](const int i) const { return (i < a.size() && i >= 0) ? a[i]: mint(0); } \/\/Be/;"	f	struct:poly	typeref:typename:mint	file:
operator []	code/Math/Subset Sum Problem.cpp	/^  mint operator[](const int i) const { return (i < a.size() && i >= 0) ? a[i]: mint(0); } \/\/Be/;"	f	struct:poly	typeref:typename:mint	file:
operator []	code/Number Theory/Bell Number.cpp	/^  mint operator[](const int i) const { return (i < a.size() && i >= 0) ? a[i]: mint(0); } \/\/Be/;"	f	struct:poly	typeref:typename:mint	file:
operator []	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  mint operator[](const int i) const { return (i < a.size() && i >= 0) ? a[i]: mint(0); } \/\/Be/;"	f	struct:poly	typeref:typename:mint	file:
operator [] 	code-library/Miscellaneous/Bitset Custom.cpp	/^    bool operator [] (const int i) {$/;"	f	struct:Bitset	typeref:typename:bool	file:
operator [] 	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  R& operator [] (int i) { return coefs[i]; }$/;"	f	class:poly	typeref:typename:R &	file:
operator [] 	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  const R& operator [] (int i) const { return coefs[i]; }$/;"	f	class:poly	typeref:typename:const R &	file:
operator [] 	code/Miscellaneous/Bitset Custom.cpp	/^    bool operator [] (const int i) {$/;"	f	struct:Bitset	typeref:typename:bool	file:
operator [] 	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  R& operator [] (int i) { return coefs[i]; }$/;"	f	class:poly	typeref:typename:R &	file:
operator [] 	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  const R& operator [] (int i) const { return coefs[i]; }$/;"	f	class:poly	typeref:typename:const R &	file:
operator ^	code-library/Miscellaneous/Bitset Custom.cpp	/^    inline Bitset operator ^ (const Bitset &x) const {$/;"	f	struct:Bitset	typeref:typename:Bitset	file:
operator ^	code/Miscellaneous/Bitset Custom.cpp	/^    inline Bitset operator ^ (const Bitset &x) const {$/;"	f	struct:Bitset	typeref:typename:Bitset	file:
operator int	practice/cf/random/1700/6.cpp	/^ 	int v; explicit operator int() const { return v; }$/;"	f	struct:mi	file:
operator int	practice/cf/random/i_hate_math_problems/1422C.cpp	/^ 	int v; explicit operator int() const { return v; } $/;"	f	struct:mi	file:
operator int	practice/usacoguide/gold/introDP/arraydescription.cpp	/^ 	int v; explicit operator int() const { return v; } $/;"	f	struct:mi	file:
operator |	code-library/Geometry/Geometry 3D.cpp	/^double operator | (p3 v, p3 w) { \/\/dot product$/;"	f	typeref:typename:double
operator |	code-library/Miscellaneous/Bitset Custom.cpp	/^    inline Bitset operator | (const Bitset &x) const {$/;"	f	struct:Bitset	typeref:typename:Bitset	file:
operator |	code-library/Strings/Bit LCS.cpp	/^    Bitset operator | (const Bitset &r) const {$/;"	f	struct:Bitset	typeref:typename:Bitset	file:
operator |	code/Geometry/Geometry 3D.cpp	/^double operator | (p3 v, p3 w) { \/\/dot product$/;"	f	typeref:typename:double
operator |	code/Miscellaneous/Bitset Custom.cpp	/^    inline Bitset operator | (const Bitset &x) const {$/;"	f	struct:Bitset	typeref:typename:Bitset	file:
operator |	code/Strings/Bit LCS.cpp	/^    Bitset operator | (const Bitset &r) const {$/;"	f	struct:Bitset	typeref:typename:Bitset	file:
operator ~	code-library/Miscellaneous/Bitset Custom.cpp	/^    friend Bitset operator ~ (const Bitset &x) {$/;"	f	typeref:typename:Bitset	file:
operator ~	code/Miscellaneous/Bitset Custom.cpp	/^    friend Bitset operator ~ (const Bitset &x) {$/;"	f	typeref:typename:Bitset	file:
ord	code-library/Graph Theory/Articulation Bridges.cpp	/^  vector<int> comp, ord, low;$/;"	m	struct:TECC	typeref:typename:vector<int>	file:
ord	code/Graph Theory/Articulation Bridges.cpp	/^  vector<int> comp, ord, low;$/;"	m	struct:TECC	typeref:typename:vector<int>	file:
order	code-library/Number Theory/Factoradic Number System.cpp	/^int order(vector<int> p) {$/;"	f	typeref:typename:int
order	code/Number Theory/Factoradic Number System.cpp	/^int order(vector<int> p) {$/;"	f	typeref:typename:int
ordering	practice/usacoguide/gold/dsu/wormhole/main.cpp	/^vector<int> ordering;$/;"	v	typeref:typename:vector<int>
ori	code-library/Geometry/Voronoi Diagram.cpp	/^double ori(PT a, PT b, PT c) {$/;"	f	typeref:typename:double
ori	code/Geometry/Voronoi Diagram.cpp	/^double ori(PT a, PT b, PT c) {$/;"	f	typeref:typename:double
orient	code-library/Geometry/Geometry 3D.cpp	/^double orient(p3 p, p3 q, p3 r, p3 s) { return (q - p) * (r - p) | (s - p); }$/;"	f	typeref:typename:double
orient	code/Geometry/Geometry 3D.cpp	/^double orient(p3 p, p3 q, p3 r, p3 s) { return (q - p) * (r - p) | (s - p); }$/;"	f	typeref:typename:double
orient_by_normal	code-library/Geometry/Geometry 3D.cpp	/^double orient_by_normal(p3 p, p3 q, p3 r, p3 n) { return (q - p) * (r - p) | n; }$/;"	f	typeref:typename:double
orient_by_normal	code/Geometry/Geometry 3D.cpp	/^double orient_by_normal(p3 p, p3 q, p3 r, p3 n) { return (q - p) * (r - p) | n; }$/;"	f	typeref:typename:double
orientation	code-library/Dynamic Programming Optimizations/Persistent CHT.cpp	/^  friend int orientation(PT &a, PT &b, PT &c) {$/;"	f	typeref:typename:int	file:
orientation	code-library/Geometry/All Pair Segment Intersection.cpp	/^inline int orientation(PT a, PT b, PT c) {$/;"	f	typeref:typename:int
orientation	code-library/Geometry/Geometry 2D.cpp	/^inline int orientation(PT a, PT b, PT c) { return sign(cross(b - a, c - a)); }$/;"	f	typeref:typename:int
orientation	code-library/Geometry/Geometry 3D.cpp	/^inline int orientation(PT a, PT b, PT c) { return sign(cross(b - a, c - a)); }$/;"	f	typeref:typename:int
orientation	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^inline int orientation(PT a, PT b, PT c) { return sign(cross(b - a, c - a)); }$/;"	f	typeref:typename:int
orientation	code-library/Geometry/Half Plane Intersection.cpp	/^inline int orientation(PT a, PT b, PT c) { return sign(cross(b - a, c - a)); }$/;"	f	typeref:typename:int
orientation	code-library/Geometry/Voronoi Diagram.cpp	/^inline int orientation(PT a, PT b, PT c) { return sign(cross(b - a, c - a)); }$/;"	f	typeref:typename:int
orientation	code/Dynamic Programming Optimizations/Persistent CHT.cpp	/^  friend int orientation(PT &a, PT &b, PT &c) {$/;"	f	typeref:typename:int	file:
orientation	code/Geometry/All Pair Segment Intersection.cpp	/^inline int orientation(PT a, PT b, PT c) {$/;"	f	typeref:typename:int
orientation	code/Geometry/Geometry 2D.cpp	/^inline int orientation(PT a, PT b, PT c) { return sign(cross(b - a, c - a)); }$/;"	f	typeref:typename:int
orientation	code/Geometry/Geometry 3D.cpp	/^inline int orientation(PT a, PT b, PT c) { return sign(cross(b - a, c - a)); }$/;"	f	typeref:typename:int
orientation	code/Geometry/Half Plane Intersection Dynamic.cpp	/^inline int orientation(PT a, PT b, PT c) { return sign(cross(b - a, c - a)); }$/;"	f	typeref:typename:int
orientation	code/Geometry/Half Plane Intersection.cpp	/^inline int orientation(PT a, PT b, PT c) { return sign(cross(b - a, c - a)); }$/;"	f	typeref:typename:int
orientation	code/Geometry/Voronoi Diagram.cpp	/^inline int orientation(PT a, PT b, PT c) { return sign(cross(b - a, c - a)); }$/;"	f	typeref:typename:int
oriented_angle_on_sphere	code-library/Geometry/Geometry 3D.cpp	/^double oriented_angle_on_sphere(p3 a, p3 b, p3 c) {$/;"	f	typeref:typename:double
oriented_angle_on_sphere	code/Geometry/Geometry 3D.cpp	/^double oriented_angle_on_sphere(p3 a, p3 b, p3 c) {$/;"	f	typeref:typename:double
orig	code-library/Game Theory/Matching Game On A Graph.cpp	/^  int vis[N], par[N], orig[N], match[N], aux[N], t;$/;"	m	struct:Blossom	typeref:typename:int[]	file:
orig	code-library/Graph Theory/Blossom Algorithm.cpp	/^  int vis[N], par[N], orig[N], match[N], aux[N], t;$/;"	m	struct:Blossom	typeref:typename:int[]	file:
orig	code/Game Theory/Matching Game On A Graph.cpp	/^  int vis[N], par[N], orig[N], match[N], aux[N], t;$/;"	m	struct:Blossom	typeref:typename:int[]	file:
orig	code/Graph Theory/Blossom Algorithm.cpp	/^  int vis[N], par[N], orig[N], match[N], aux[N], t;$/;"	m	struct:Blossom	typeref:typename:int[]	file:
origin	code-library/Geometry/Point Location.cpp	/^        PT origin;$/;"	m	struct:DCEL::edge	typeref:typename:PT	file:
origin	code/Geometry/Point Location.cpp	/^        PT origin;$/;"	m	struct:DCEL::edge	typeref:typename:PT	file:
out	code-library/Graph Theory/SCC.cpp	/^int idx[N], in[N], out[N];$/;"	v	typeref:typename:int[]
out	code-library/Strings/Aho Corasick.cpp	/^  vector <vector <int>> out;$/;"	m	struct:AC	typeref:typename:vector<vector<int>>	file:
out	code-library/Strings/Number of Palindromes in Range.cpp	/^inline void out(int n) {$/;"	f	typeref:typename:void
out	code/Graph Theory/SCC.cpp	/^int idx[N], in[N], out[N];$/;"	v	typeref:typename:int[]
out	code/Strings/Aho Corasick.cpp	/^  vector <vector <int>> out;$/;"	m	struct:AC	typeref:typename:vector<vector<int>>	file:
out	code/Strings/Number of Palindromes in Range.cpp	/^inline void out(int n) {$/;"	f	typeref:typename:void
out_link	code-library/Strings/Aho Corasick.cpp	/^  vector <int> link, out_link;$/;"	m	struct:AC	typeref:typename:vector<int>	file:
out_link	code/Strings/Aho Corasick.cpp	/^  vector <int> link, out_link;$/;"	m	struct:AC	typeref:typename:vector<int>	file:
out_of_order	practice/usacoguide/gold/dsu/wormhole/main.cpp	/^vector<int> out_of_order;$/;"	v	typeref:typename:vector<int>
output	contests/LIT2021/C.cpp	/^void output() {$/;"	f	typeref:typename:void
output	practice/cf/random/1700/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	o
output	practice/cf/random/1700/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	s	object:tests.0
output	practice/cf/random/1700/1618E/problem.json	/^{"name": "E. Singers' Tour", "group": "Codeforces - Codeforces Round #760 (Div. 3)", "url": "htt/;"	o
output	practice/cf/random/1700/1618E/problem.json	/^{"name": "E. Singers' Tour", "group": "Codeforces - Codeforces Round #760 (Div. 3)", "url": "htt/;"	s	object:tests.0
output	practice/cf/random/coloring/problem.json	/^{"name": "A. Dreamoon Likes Coloring", "group": "Codeforces - Codeforces Round #631 (Div. 1) - T/;"	o
output	practice/cf/random/coloring/problem.json	/^{"name": "A. Dreamoon Likes Coloring", "group": "Codeforces - Codeforces Round #631 (Div. 1) - T/;"	s	object:tests.0
output	practice/cf/random/coloring/problem.json	/^{"name": "A. Dreamoon Likes Coloring", "group": "Codeforces - Codeforces Round #631 (Div. 1) - T/;"	s	object:tests.1
output	practice/cf/random/diane/problem.json	/^{"name": "D. Diane", "group": "Codeforces - Codeforces Round #735 (Div. 2)", "url": "https:\/\/c/;"	o
output	practice/cf/random/diane/problem.json	/^{"name": "D. Diane", "group": "Codeforces - Codeforces Round #735 (Div. 2)", "url": "https:\/\/c/;"	s	object:tests.0
output	practice/cf/random/pink/problem.json	/^{"name": "C. Pinkie Pie Eats Patty-cakes", "group": "Codeforces - Codeforces Round #662 (Div. 2)/;"	o
output	practice/cf/random/pink/problem.json	/^{"name": "C. Pinkie Pie Eats Patty-cakes", "group": "Codeforces - Codeforces Round #662 (Div. 2)/;"	s	object:tests.0
output	practice/cf/stuff/dec 20 2021/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	o
output	practice/cf/stuff/dec 20 2021/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	s	object:tests.0
output	practice/usacoguide/gold/SP/dining/problem.json	/^{"name": "Problem 1. Fine Dining", "group": "USACO - USACO 2018 December Contest, Gold", "url": /;"	o
output	practice/usacoguide/gold/SP/dining/problem.json	/^{"name": "Problem 1. Fine Dining", "group": "USACO - USACO 2018 December Contest, Gold", "url": /;"	s	object:tests.0
output	practice/usacoguide/gold/SP/visitfj/problem.json	/^{"name": "Problem 1. Why Did the Cow Cross the Road", "group": "USACO - USACO 2017 February Cont/;"	o
output	practice/usacoguide/gold/SP/visitfj/problem.json	/^{"name": "Problem 1. Why Did the Cow Cross the Road", "group": "USACO - USACO 2017 February Cont/;"	s	object:tests.0
output	practice/usacoguide/gold/bfs/cownav/problem.json	/^{"name": "Problem 3. Cow Navigation", "group": "USACO - USACO 2017 January Contest, Gold", "url"/;"	o
output	practice/usacoguide/gold/bfs/cownav/problem.json	/^{"name": "Problem 3. Cow Navigation", "group": "USACO - USACO 2017 January Contest, Gold", "url"/;"	s	object:tests.0
output	practice/usacoguide/gold/bfs/swap/problem.json	/^{"name": "Swap Game", "group": "CSES - CSES Problem Set", "url": "https:\/\/cses.fi\/problemset\//;"	o
output	practice/usacoguide/gold/bfs/swap/problem.json	/^{"name": "Swap Game", "group": "CSES - CSES Problem Set", "url": "https:\/\/cses.fi\/problemset\//;"	s	object:tests.0
output	practice/usacoguide/gold/dsu/closing/problem.json	/^{"name": "Problem 2. Closing the Farm", "group": "USACO - USACO 2016 US Open Contest, Gold", "ur/;"	o
output	practice/usacoguide/gold/dsu/closing/problem.json	/^{"name": "Problem 2. Closing the Farm", "group": "USACO - USACO 2016 US Open Contest, Gold", "ur/;"	s	object:tests.0
output	practice/usacoguide/gold/dsu/moocast/problem.json	/^{"name": "Problem 1. Moocast", "group": "USACO - USACO 2016 December Contest, Gold", "url": "htt/;"	o
output	practice/usacoguide/gold/dsu/moocast/problem.json	/^{"name": "Problem 1. Moocast", "group": "USACO - USACO 2016 December Contest, Gold", "url": "htt/;"	s	object:tests.0
output	practice/usacoguide/gold/dsu/mootube/problem.json	/^{"name": "Problem 1. MooTube", "group": "USACO - USACO 2018 January Contest, Gold", "url": "http/;"	o
output	practice/usacoguide/gold/dsu/mootube/problem.json	/^{"name": "Problem 1. MooTube", "group": "USACO - USACO 2018 January Contest, Gold", "url": "http/;"	s	object:tests.0
output	practice/usacoguide/gold/dsu/tractor/problem.json	/^{"name": "Problem 2. Tractor", "group": "USACO - USACO 2013 February Contest, Silver", "url": "h/;"	o
output	practice/usacoguide/gold/dsu/wormhole/problem.json	/^{"name": "Problem 3. Wormhole Sort", "group": "USACO - USACO 2020 January Contest, Silver", "url/;"	o
output	practice/usacoguide/gold/dsu/wormhole/problem.json	/^{"name": "Problem 3. Wormhole Sort", "group": "USACO - USACO 2020 January Contest, Silver", "url/;"	s	object:tests.0
output	practice/usacoguide/gold/dsu/wormhole/problem.json	/^{"name": "Problem 3. Wormhole Sort", "group": "USACO - USACO 2020 January Contest, Silver", "url/;"	s	object:tests.1
output	practice/usacoguide/silver/idk/lirs/problem.json	/^{"name": "Problem 3. Liars and Truth Tellers", "group": "USACO - USACO 2013 January Contest, Bro/;"	o
output	practice/usacoguide/silver/idk/maze/problem.json	/^{"name": "Problem 1. Maze Tac Toe", "group": "USACO - USACO 2021 US Open, Silver", "url": "http:/;"	o
output	practice/usacoguide/silver/idk/maze/problem.json	/^{"name": "Problem 1. Maze Tac Toe", "group": "USACO - USACO 2021 US Open, Silver", "url": "http:/;"	s	object:tests.0
own_A	code-library/Data Structures/Top Tree.cpp	/^  int64_t own_A = 0;$/;"	m	struct:top_tree_node	typeref:typename:int64_t	file:
own_A	code/Data Structures/Top Tree.cpp	/^  int64_t own_A = 0;$/;"	m	struct:top_tree_node	typeref:typename:int64_t	file:
p	code-library/Data Structures/KD Tree.cpp	/^  int p[d];$/;"	m	struct:point	typeref:typename:int[]	file:
p	code-library/Data Structures/KD Tree.cpp	/^  point p;$/;"	m	struct:kd_node	typeref:typename:point	file:
p	code-library/Data Structures/Link Cut Tree.cpp	/^  int p = 0, c[2] = {0, 0}, pp = 0;$/;"	m	struct:node	typeref:typename:int	file:
p	code-library/Data Structures/Permutation Tree.cpp	/^int p[N];$/;"	v	typeref:typename:int[]
p	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^    int l = 0, r = 0, lazy = 0, p = 0;$/;"	m	struct:PST::node	typeref:typename:int	file:
p	code-library/Data Structures/Top Tree.cpp	/^  mutable top_tree_node* p = nullptr;$/;"	m	struct:top_tree_node	typeref:typename:top_tree_node *	file:
p	code-library/Dynamic Programming Optimizations/Persistent CHT.cpp	/^  int p[N][lg], sz;$/;"	m	struct:PersistentCHT	typeref:typename:int[][]	file:
p	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^ll ans[N], p[N], s[N];$/;"	v	typeref:typename:ll[]
p	code-library/Geometry/All Pair Segment Intersection.cpp	/^    PT p, q;$/;"	m	struct:seg	typeref:typename:PT	file:
p	code-library/Geometry/Delaunay Triangulation.cpp	/^    bool mark; Q o, rot; PT p;$/;"	m	struct:Quad	typeref:typename:PT	file:
p	code-library/Geometry/Geometry 2D.cpp	/^    PT p; double r;$/;"	m	struct:circle	typeref:typename:PT	file:
p	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    PT p(bool truncate = 1) const {$/;"	f	struct:Angle	typeref:typename:PT	file:
p	code-library/Geometry/Voronoi Diagram.cpp	/^    bool mark; Q o, rot; P p;$/;"	m	struct:Quad	typeref:typename:P	file:
p	code-library/Geometry/Voronoi Diagram.cpp	/^vector<PT> p;$/;"	v	typeref:typename:vector<PT>
p	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^  vector<mint> p;$/;"	m	struct:ChromaticPolynomial	typeref:typename:vector<mint>	file:
p	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  vector<int> p, w, c;$/;"	m	struct:GomoryHuTree	typeref:typename:vector<int>	file:
p	code-library/Graph Theory/Manhattan MST.cpp	/^  int p[N];$/;"	m	struct:DSU	typeref:typename:int[]	file:
p	code-library/Graph Theory/Manhattan MST.cpp	/^} p[N];$/;"	v	typeref:struct:PT[]
p	code-library/Math/All Possible Perfect Matching XOR Values.cpp	/^int a[N][N], p[N], n, vis[N];$/;"	v	typeref:typename:int[]
p	code-library/Math/Basis Vector Reduced Row Echelon Form.cpp	/^int a[N], p[N];$/;"	v	typeref:typename:int[]
p	code-library/Math/Lagrange Multiplier.cpp	/^double p[N];$/;"	v	typeref:typename:double[]
p	code-library/Miscellaneous/Fraction Binary Search.cpp	/^struct frac { long long p, q; };$/;"	m	struct:frac	typeref:typename:long long	file:
p	code-library/Number Theory/Min_25 Sieve.cpp	/^int primes[N], p, deg;$/;"	v	typeref:typename:int
p	code-library/Number Theory/Rational Approximation.py	/^p = Fraction(x).limit_denominator(2323)$/;"	v
p	code-library/Number Theory/Sieve upto 1e9.cpp	/^    int p; int pos[8];$/;"	m	struct:sieve::P	typeref:typename:int	file:
p	code-library/Strings/Prefix Automaton.cpp	/^string s, p;$/;"	v	typeref:typename:string
p	code/Data Structures/KD Tree.cpp	/^  int p[d];$/;"	m	struct:point	typeref:typename:int[]	file:
p	code/Data Structures/KD Tree.cpp	/^  point p;$/;"	m	struct:kd_node	typeref:typename:point	file:
p	code/Data Structures/Link Cut Tree.cpp	/^  int p = 0, c[2] = {0, 0}, pp = 0;$/;"	m	struct:node	typeref:typename:int	file:
p	code/Data Structures/Permutation Tree.cpp	/^int p[N];$/;"	v	typeref:typename:int[]
p	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^    int l = 0, r = 0, lazy = 0, p = 0;$/;"	m	struct:PST::node	typeref:typename:int	file:
p	code/Data Structures/Top Tree.cpp	/^  mutable top_tree_node* p = nullptr;$/;"	m	struct:top_tree_node	typeref:typename:top_tree_node *	file:
p	code/Dynamic Programming Optimizations/Persistent CHT.cpp	/^  int p[N][lg], sz;$/;"	m	struct:PersistentCHT	typeref:typename:int[][]	file:
p	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^ll ans[N], p[N], s[N];$/;"	v	typeref:typename:ll[]
p	code/Geometry/All Pair Segment Intersection.cpp	/^    PT p, q;$/;"	m	struct:seg	typeref:typename:PT	file:
p	code/Geometry/Delaunay Triangulation.cpp	/^    bool mark; Q o, rot; PT p;$/;"	m	struct:Quad	typeref:typename:PT	file:
p	code/Geometry/Geometry 2D.cpp	/^    PT p; double r;$/;"	m	struct:circle	typeref:typename:PT	file:
p	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    PT p(bool truncate = 1) const {$/;"	f	struct:Angle	typeref:typename:PT	file:
p	code/Geometry/Voronoi Diagram.cpp	/^    bool mark; Q o, rot; P p;$/;"	m	struct:Quad	typeref:typename:P	file:
p	code/Geometry/Voronoi Diagram.cpp	/^vector<PT> p;$/;"	v	typeref:typename:vector<PT>
p	code/Graph Theory/Chromatic Polynoimial.cpp	/^  vector<mint> p;$/;"	m	struct:ChromaticPolynomial	typeref:typename:vector<mint>	file:
p	code/Graph Theory/Gomory Hu Tree.cpp	/^  vector<int> p, w, c;$/;"	m	struct:GomoryHuTree	typeref:typename:vector<int>	file:
p	code/Graph Theory/Manhattan MST.cpp	/^  int p[N];$/;"	m	struct:DSU	typeref:typename:int[]	file:
p	code/Graph Theory/Manhattan MST.cpp	/^} p[N];$/;"	v	typeref:struct:PT[]
p	code/Math/All Possible Perfect Matching XOR Values.cpp	/^int a[N][N], p[N], n, vis[N];$/;"	v	typeref:typename:int[]
p	code/Math/Basis Vector Reduced Row Echelon Form.cpp	/^int a[N], p[N];$/;"	v	typeref:typename:int[]
p	code/Math/Lagrange Multiplier.cpp	/^double p[N];$/;"	v	typeref:typename:double[]
p	code/Miscellaneous/Fraction Binary Search.cpp	/^struct frac { long long p, q; };$/;"	m	struct:frac	typeref:typename:long long	file:
p	code/Number Theory/Min_25 Sieve.cpp	/^int primes[N], p, deg;$/;"	v	typeref:typename:int
p	code/Number Theory/Rational Approximation.py	/^p = Fraction(x).limit_denominator(2323)$/;"	v
p	code/Number Theory/Sieve upto 1e9.cpp	/^    int p; int pos[8];$/;"	m	struct:sieve::P	typeref:typename:int	file:
p	code/Strings/Prefix Automaton.cpp	/^string s, p;$/;"	v	typeref:typename:string
p1	code-library/Strings/String Hashing.cpp	/^const int p1 = 137, p2 = 277;$/;"	v	typeref:typename:const int
p1	code/Strings/String Hashing.cpp	/^const int p1 = 137, p2 = 277;$/;"	v	typeref:typename:const int
p2	code-library/Strings/String Hashing.cpp	/^const int p1 = 137, p2 = 277;$/;"	v	typeref:typename:const int
p2	code/Strings/String Hashing.cpp	/^const int p1 = 137, p2 = 277;$/;"	v	typeref:typename:const int
p3	code-library/Geometry/Geometry 3D.cpp	/^    p3() { x = 0, y = 0; z = 0; }$/;"	f	struct:p3	file:
p3	code-library/Geometry/Geometry 3D.cpp	/^    p3(const p3 &p) : x(p.x), y(p.y), z(p.z)    {}$/;"	f	struct:p3	file:
p3	code-library/Geometry/Geometry 3D.cpp	/^    p3(double x, double y, double z) : x(x), y(y), z(z) {}$/;"	f	struct:p3	file:
p3	code-library/Geometry/Geometry 3D.cpp	/^struct p3 {$/;"	s	file:
p3	code/Geometry/Geometry 3D.cpp	/^    p3() { x = 0, y = 0; z = 0; }$/;"	f	struct:p3	file:
p3	code/Geometry/Geometry 3D.cpp	/^    p3(const p3 &p) : x(p.x), y(p.y), z(p.z)    {}$/;"	f	struct:p3	file:
p3	code/Geometry/Geometry 3D.cpp	/^    p3(double x, double y, double z) : x(x), y(y), z(z) {}$/;"	f	struct:p3	file:
p3	code/Geometry/Geometry 3D.cpp	/^struct p3 {$/;"	s	file:
p_c	code-library/Data Structures/Top Tree.cpp	/^  top_tree_node*& p_c() const { return p->c[d()]; } \/\/ p->c which points to you$/;"	f	struct:top_tree_node	typeref:typename:top_tree_node * &	file:
p_c	code-library/Number Theory/Dirichlet Convolution.cpp	/^  mint p_c(long long n) {$/;"	f	namespace:Dirichlet	typeref:typename:mint
p_c	code/Data Structures/Top Tree.cpp	/^  top_tree_node*& p_c() const { return p->c[d()]; } \/\/ p->c which points to you$/;"	f	struct:top_tree_node	typeref:typename:top_tree_node * &	file:
p_c	code/Number Theory/Dirichlet Convolution.cpp	/^  mint p_c(long long n) {$/;"	f	namespace:Dirichlet	typeref:typename:mint
p_g	code-library/Number Theory/Dirichlet Convolution.cpp	/^  mint p_g(long long n) {$/;"	f	namespace:Dirichlet	typeref:typename:mint
p_g	code/Number Theory/Dirichlet Convolution.cpp	/^  mint p_g(long long n) {$/;"	f	namespace:Dirichlet	typeref:typename:mint
pa	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  int n, n_x, match[N * 2], slack[N * 2], st[N * 2], pa[N * 2], flower_from[N * 2][N * 2], S[N */;"	m	struct:Blossom	typeref:typename:int[]	file:
pa	code-library/Graph Theory/Dynamic MST.cpp	/^  int pa[MAXN], rk[MAXN];$/;"	m	struct:disj	typeref:typename:int[]	file:
pa	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  int n, n_x, match[N * 2], slack[N * 2], st[N * 2], pa[N * 2], flower_from[N * 2][N * 2], S[N */;"	m	struct:Blossom	typeref:typename:int[]	file:
pa	code/Graph Theory/Dynamic MST.cpp	/^  int pa[MAXN], rk[MAXN];$/;"	m	struct:disj	typeref:typename:int[]	file:
par	code-library/Data Structures/DSU Partially Persistent.cpp	/^  vector<vector<pair<int, int>>> par;$/;"	m	struct:DSU	typeref:typename:vector<vector<pair<int,int>>>	file:
par	code-library/Data Structures/DSU with Rollbacks.cpp	/^  vector<int> par, sz, w;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
par	code-library/Data Structures/DSU.cpp	/^  vector<int> par, rnk, sz;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
par	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^  int par[N], depth[N];$/;"	m	struct:persistent_dsu	typeref:typename:int[]	file:
par	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int par[N][LG + 1], dep[N], sz[N];$/;"	v	typeref:typename:int[][]
par	code-library/Data Structures/HLD.cpp	/^int par[N][LG + 1], dep[N], sz[N];$/;"	v	typeref:typename:int[][]
par	code-library/Data Structures/Implicit Treap.cpp	/^    node *l, *r, *par;$/;"	m	struct:treap::node	typeref:typename:node *	file:
par	code-library/Data Structures/LCA.cpp	/^int par[N][LG + 1], dep[N], sz[N];$/;"	v	typeref:typename:int[][]
par	code-library/Data Structures/Link Cut Tree.cpp	/^int par[N];$/;"	v	typeref:typename:int[]
par	code-library/Data Structures/MOs on tree.cpp	/^int st[N], en[N], T, par[N][20], dep[N], id[N * 2];$/;"	v	typeref:typename:int[][20]
par	code-library/Data Structures/MOs with DSU.cpp	/^  int depth[N], par[N];$/;"	m	struct:persistent_dsu	typeref:typename:int[]	file:
par	code-library/Data Structures/Permutation Tree.cpp	/^int par[N * 2];$/;"	v	typeref:typename:int[]
par	code-library/Data Structures/Persistent UnionFind.cpp	/^  PersistentArray<int> par, sz;$/;"	m	struct:PersistentDSU	typeref:typename:PersistentArray<int>	file:
par	code-library/Data Structures/Queue Undo Trick.cpp	/^  vector<int> par, sz, w;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
par	code-library/Data Structures/Reachability Tree.cpp	/^  int n, par[2 * N], sp[LG + 1][2 * N], val[2 * N], rid[2 * N];$/;"	m	struct:RT	typeref:typename:int[]	file:
par	code-library/Game Theory/Matching Game On A Graph.cpp	/^  int vis[N], par[N], orig[N], match[N], aux[N], t;$/;"	m	struct:Blossom	typeref:typename:int[]	file:
par	code-library/Graph Theory/Block Cut Tree.cpp	/^int dep[N], par[N][20], cnt[N], id[N];$/;"	v	typeref:typename:int[][20]
par	code-library/Graph Theory/Blossom Algorithm.cpp	/^  int vis[N], par[N], orig[N], match[N], aux[N], t;$/;"	m	struct:Blossom	typeref:typename:int[]	file:
par	code-library/Graph Theory/Boruvka's Algorithm.cpp	/^  vector<int> par, rnk, size; int c;$/;"	m	struct:dsu	typeref:typename:vector<int>	file:
par	code-library/Graph Theory/Cycle Detection.cpp	/^int vis[N], par[N], e_id[N];$/;"	v	typeref:typename:int[]
par	code-library/Graph Theory/DAG Reachability Dynamic.cpp	/^  vector<vector<int>> par;$/;"	m	struct:Italiano	typeref:typename:vector<vector<int>>	file:
par	code-library/Graph Theory/Directed MST.cpp	/^  vector<int> par;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
par	code-library/Graph Theory/Dominator Tree.cpp	/^int sdom[N], par[N], idom[N], dsu[N], label[N];$/;"	v	typeref:typename:int[]
par	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  vector<int> par, rank, size;$/;"	m	struct:dsu	typeref:typename:vector<int>	file:
par	code-library/Graph Theory/Inverse Graph.cpp	/^int par[N], col[N], vis[N], ty[N], n;$/;"	v	typeref:typename:int[]
par	code-library/Graph Theory/Kirchoffs Theorem.cpp	/^  vector<int> par, rnk, size;$/;"	m	struct:dsu	typeref:typename:vector<int>	file:
par	code-library/Graph Theory/Krushkal's MST.cpp	/^  vector<int> par, rnk, size; int c;$/;"	m	struct:dsu	typeref:typename:vector<int>	file:
par	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  vector<int> par;$/;"	m	struct:MCMF	typeref:typename:vector<int>	file:
par	code-library/Graph Theory/LCA.cpp	/^int par[N][LG + 1], dep[N], sz[N];$/;"	v	typeref:typename:int[][]
par	code-library/Graph Theory/Min Cost Max Flow.cpp	/^  vector<int> par;$/;"	m	struct:MCMF	typeref:typename:vector<int>	file:
par	code-library/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^int n, m, U[M], V[M], id[N], par[N];$/;"	v	typeref:typename:int[]
par	code-library/Graph Theory/Minimum Weight Cycle For Each Edge.cpp	/^int d[N], vis[N], par[N];$/;"	v	typeref:typename:int[]
par	code-library/Graph Theory/Minimum Weight Cycle For Each Vertex.cpp	/^int g[N][N], d[N], vis[N], par[N];$/;"	v	typeref:typename:int[]
par	code-library/Graph Theory/Online Articulation Bridges.cpp	/^int n, bridges, par[N], bl[N], comp[N], sz[N];$/;"	v	typeref:typename:int[]
par	code-library/Graph Theory/Path Intersection.cpp	/^int par[N][20], dep[N], sz[N];$/;"	v	typeref:typename:int[][20]
par	code-library/Graph Theory/Path Union.cpp	/^int par[N][20], dep[N], sz[N];$/;"	v	typeref:typename:int[][20]
par	code-library/Graph Theory/ST Numbering.cpp	/^int low[N], dis[N], T = 0, par[N], sign[N];$/;"	v	typeref:typename:int[]
par	code-library/Graph Theory/Virtual Tree.cpp	/^int par[N][20], dep[N], sz[N], st[N], en[N], T;$/;"	v	typeref:typename:int[][20]
par	code-library/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^int n, m, tot, col[N], where[N], par[N];$/;"	v	typeref:typename:int[]
par	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  int par[N * 2], lazy[N * 2], last[N * 2], c[N * 2][2];$/;"	v	namespace:lct	typeref:typename:int[]
par	code/Data Structures/DSU Partially Persistent.cpp	/^  vector<vector<pair<int, int>>> par;$/;"	m	struct:DSU	typeref:typename:vector<vector<pair<int,int>>>	file:
par	code/Data Structures/DSU with Rollbacks.cpp	/^  vector<int> par, sz, w;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
par	code/Data Structures/DSU.cpp	/^  vector<int> par, rnk, sz;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
par	code/Data Structures/Dynamic Connectivity Problem.cpp	/^  int par[N], depth[N];$/;"	m	struct:persistent_dsu	typeref:typename:int[]	file:
par	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int par[N][LG + 1], dep[N], sz[N];$/;"	v	typeref:typename:int[][]
par	code/Data Structures/HLD.cpp	/^int par[N][LG + 1], dep[N], sz[N];$/;"	v	typeref:typename:int[][]
par	code/Data Structures/Implicit Treap.cpp	/^    node *l, *r, *par;$/;"	m	struct:treap::node	typeref:typename:node *	file:
par	code/Data Structures/LCA.cpp	/^int par[N][LG + 1], dep[N], sz[N];$/;"	v	typeref:typename:int[][]
par	code/Data Structures/Link Cut Tree.cpp	/^int par[N];$/;"	v	typeref:typename:int[]
par	code/Data Structures/MOs on tree.cpp	/^int st[N], en[N], T, par[N][20], dep[N], id[N * 2];$/;"	v	typeref:typename:int[][20]
par	code/Data Structures/MOs with DSU.cpp	/^  int depth[N], par[N];$/;"	m	struct:persistent_dsu	typeref:typename:int[]	file:
par	code/Data Structures/Permutation Tree.cpp	/^int par[N * 2];$/;"	v	typeref:typename:int[]
par	code/Data Structures/Persistent UnionFind.cpp	/^  PersistentArray<int> par, sz;$/;"	m	struct:PersistentDSU	typeref:typename:PersistentArray<int>	file:
par	code/Data Structures/Queue Undo Trick.cpp	/^  vector<int> par, sz, w;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
par	code/Data Structures/Reachability Tree.cpp	/^  int n, par[2 * N], sp[LG + 1][2 * N], val[2 * N], rid[2 * N];$/;"	m	struct:RT	typeref:typename:int[]	file:
par	code/Game Theory/Matching Game On A Graph.cpp	/^  int vis[N], par[N], orig[N], match[N], aux[N], t;$/;"	m	struct:Blossom	typeref:typename:int[]	file:
par	code/Graph Theory/Block Cut Tree.cpp	/^int dep[N], par[N][20], cnt[N], id[N];$/;"	v	typeref:typename:int[][20]
par	code/Graph Theory/Blossom Algorithm.cpp	/^  int vis[N], par[N], orig[N], match[N], aux[N], t;$/;"	m	struct:Blossom	typeref:typename:int[]	file:
par	code/Graph Theory/Boruvka's Algorithm.cpp	/^  vector<int> par, rnk, size; int c;$/;"	m	struct:dsu	typeref:typename:vector<int>	file:
par	code/Graph Theory/Cycle Detection.cpp	/^int vis[N], par[N], e_id[N];$/;"	v	typeref:typename:int[]
par	code/Graph Theory/DAG Reachability Dynamic.cpp	/^  vector<vector<int>> par;$/;"	m	struct:Italiano	typeref:typename:vector<vector<int>>	file:
par	code/Graph Theory/Directed MST.cpp	/^  vector<int> par;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
par	code/Graph Theory/Dominator Tree.cpp	/^int sdom[N], par[N], idom[N], dsu[N], label[N];$/;"	v	typeref:typename:int[]
par	code/Graph Theory/Gomory Hu Tree.cpp	/^  vector<int> par, rank, size;$/;"	m	struct:dsu	typeref:typename:vector<int>	file:
par	code/Graph Theory/Inverse Graph.cpp	/^int par[N], col[N], vis[N], ty[N], n;$/;"	v	typeref:typename:int[]
par	code/Graph Theory/Kirchoffs Theorem.cpp	/^  vector<int> par, rnk, size;$/;"	m	struct:dsu	typeref:typename:vector<int>	file:
par	code/Graph Theory/Krushkal's MST.cpp	/^  vector<int> par, rnk, size; int c;$/;"	m	struct:dsu	typeref:typename:vector<int>	file:
par	code/Graph Theory/L R Flow with MCMF.cpp	/^  vector<int> par;$/;"	m	struct:MCMF	typeref:typename:vector<int>	file:
par	code/Graph Theory/LCA.cpp	/^int par[N][LG + 1], dep[N], sz[N];$/;"	v	typeref:typename:int[][]
par	code/Graph Theory/Min Cost Max Flow.cpp	/^  vector<int> par;$/;"	m	struct:MCMF	typeref:typename:vector<int>	file:
par	code/Graph Theory/Minimum Diameter Spanning Tree.cpp	/^int n, m, U[M], V[M], id[N], par[N];$/;"	v	typeref:typename:int[]
par	code/Graph Theory/Minimum Weight Cycle For Each Edge.cpp	/^int d[N], vis[N], par[N];$/;"	v	typeref:typename:int[]
par	code/Graph Theory/Minimum Weight Cycle For Each Vertex.cpp	/^int g[N][N], d[N], vis[N], par[N];$/;"	v	typeref:typename:int[]
par	code/Graph Theory/Online Articulation Bridges.cpp	/^int n, bridges, par[N], bl[N], comp[N], sz[N];$/;"	v	typeref:typename:int[]
par	code/Graph Theory/Path Intersection.cpp	/^int par[N][20], dep[N], sz[N];$/;"	v	typeref:typename:int[][20]
par	code/Graph Theory/Path Union.cpp	/^int par[N][20], dep[N], sz[N];$/;"	v	typeref:typename:int[][20]
par	code/Graph Theory/ST Numbering.cpp	/^int low[N], dis[N], T = 0, par[N], sign[N];$/;"	v	typeref:typename:int[]
par	code/Graph Theory/Virtual Tree.cpp	/^int par[N][20], dep[N], sz[N], st[N], en[N], T;$/;"	v	typeref:typename:int[][20]
par	code/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^int n, m, tot, col[N], where[N], par[N];$/;"	v	typeref:typename:int[]
par	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  int par[N * 2], lazy[N * 2], last[N * 2], c[N * 2][2];$/;"	v	namespace:lct	typeref:typename:int[]
parent	code-library/Graph Theory/Prufer Code.cpp	/^int parent[N], degree[N];$/;"	v	typeref:typename:int[]
parent	code/Graph Theory/Prufer Code.cpp	/^int parent[N], degree[N];$/;"	v	typeref:typename:int[]
parsum	code-library/Data Structures/Binarizing a Tree.cpp	/^  long long sum = 0, parsum = 0;$/;"	m	struct:node	typeref:typename:long long	file:
parsum	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^  long long sum = 0, parsum = 0;$/;"	m	struct:node	typeref:typename:long long	file:
parsum	code/Data Structures/Binarizing a Tree.cpp	/^  long long sum = 0, parsum = 0;$/;"	m	struct:node	typeref:typename:long long	file:
parsum	code/Data Structures/Centroid Decomposition Persistent.cpp	/^  long long sum = 0, parsum = 0;$/;"	m	struct:node	typeref:typename:long long	file:
path_intersection	code-library/Graph Theory/Path Intersection.cpp	/^pair<int, int> path_intersection(int a, int b, int c, int d) {$/;"	f	typeref:typename:pair<int,int>
path_intersection	code/Graph Theory/Path Intersection.cpp	/^pair<int, int> path_intersection(int a, int b, int c, int d) {$/;"	f	typeref:typename:pair<int,int>
path_lazy	code-library/Data Structures/Top Tree.cpp	/^  int64_t path_lazy = 0;$/;"	m	struct:top_tree_node	typeref:typename:int64_t	file:
path_lazy	code/Data Structures/Top Tree.cpp	/^  int64_t path_lazy = 0;$/;"	m	struct:top_tree_node	typeref:typename:int64_t	file:
path_size	code-library/Data Structures/Top Tree.cpp	/^  int64_t path_size = 0;$/;"	m	struct:top_tree_node	typeref:typename:int64_t	file:
path_size	code/Data Structures/Top Tree.cpp	/^  int64_t path_size = 0;$/;"	m	struct:top_tree_node	typeref:typename:int64_t	file:
path_union_light	code-library/Graph Theory/Path Intersection.cpp	/^pair<int, int> path_union_light(pair<int, int> x, pair<int, int> y) {$/;"	f	typeref:typename:pair<int,int>
path_union_light	code/Graph Theory/Path Intersection.cpp	/^pair<int, int> path_union_light(pair<int, int> x, pair<int, int> y) {$/;"	f	typeref:typename:pair<int,int>
pawn	practice/cpbook/ch1/1.6/chess/10284/main.cpp	/^void pawn(int row, int col, bool black) {$/;"	f	typeref:typename:void
pb	contests/Codeforces/737/C.cpp	/^#define pb /;"	d	file:
pb	practice/usacoguide/gold/introDP/711C.cpp	/^#define pb /;"	d	file:
pbds	practice/usacoguide/gold/introDP/711C.cpp	/^typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;$/;"	t	typeref:typename:tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>	file:
pcf	code-library/Number Theory/K Divisors.cpp	/^namespace pcf {$/;"	n	file:
pcf	code-library/Number Theory/Prime Counting Function.cpp	/^namespace pcf {$/;"	n	file:
pcf	code/Number Theory/K Divisors.cpp	/^namespace pcf {$/;"	n	file:
pcf	code/Number Theory/Prime Counting Function.cpp	/^namespace pcf {$/;"	n	file:
pd	practice/cpbook/ch1/1.6/card/10388/main2.cpp	/^int pu[2], pd[2], len[2];$/;"	v	typeref:typename:int[2]
pedler	practice/cpbook/ch1/1.6/card/11225/main.cpp	/^bool pedler(string s) {$/;"	f	typeref:typename:bool
pedler	practice/cpbook/ch1/1.6/card/11225/test.cpp	/^bool pedler(string s) {$/;"	f	typeref:typename:bool
per	code-library/Geometry/All Pair Segment Intersection.cpp	/^double per[N];$/;"	v	typeref:typename:double[]
per	code/Geometry/All Pair Segment Intersection.cpp	/^double per[N];$/;"	v	typeref:typename:double[]
perform_reverse	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^  void perform_reverse() {$/;"	f	struct:Block	typeref:typename:void	file:
perform_reverse	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^  void perform_reverse() {$/;"	f	struct:Block	typeref:typename:void	file:
perimeter	code-library/Geometry/Geometry 2D.cpp	/^double perimeter(vector<PT> &p) {$/;"	f	typeref:typename:double
perimeter	code/Geometry/Geometry 2D.cpp	/^double perimeter(vector<PT> &p) {$/;"	f	typeref:typename:double
perp	code-library/Geometry/All Pair Segment Intersection.cpp	/^    PT perp() {$/;"	f	struct:PT	typeref:typename:PT	file:
perp	code-library/Geometry/All Pair Segment Intersection.cpp	/^PT perp(PT a) {$/;"	f	typeref:typename:PT
perp	code-library/Geometry/Geometry 2D.cpp	/^    PT perp() { return PT(-y, x); }$/;"	f	struct:PT	typeref:typename:PT	file:
perp	code-library/Geometry/Geometry 2D.cpp	/^PT perp(PT a) { return PT(-a.y, a.x); }$/;"	f	typeref:typename:PT
perp	code-library/Geometry/Geometry 3D.cpp	/^    PT perp() { return PT(-y, x); }$/;"	f	struct:PT	typeref:typename:PT	file:
perp	code-library/Geometry/Geometry 3D.cpp	/^PT perp(PT a) { return PT(-a.y, a.x); }$/;"	f	typeref:typename:PT
perp	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    PT perp() { return PT(-y, x); }$/;"	f	struct:PT	typeref:typename:PT	file:
perp	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^PT perp(PT a) { return PT(-a.y, a.x); }$/;"	f	typeref:typename:PT
perp	code-library/Geometry/Half Plane Intersection.cpp	/^    PT perp() { return PT(-y, x); }$/;"	f	struct:PT	typeref:typename:PT	file:
perp	code-library/Geometry/Half Plane Intersection.cpp	/^PT perp(PT a) { return PT(-a.y, a.x); }$/;"	f	typeref:typename:PT
perp	code-library/Geometry/Voronoi Diagram.cpp	/^    PT perp() { return PT(-y, x); }$/;"	f	struct:PT	typeref:typename:PT	file:
perp	code-library/Geometry/Voronoi Diagram.cpp	/^PT perp(PT a) { return PT(-a.y, a.x); }$/;"	f	typeref:typename:PT
perp	code/Geometry/All Pair Segment Intersection.cpp	/^    PT perp() {$/;"	f	struct:PT	typeref:typename:PT	file:
perp	code/Geometry/All Pair Segment Intersection.cpp	/^PT perp(PT a) {$/;"	f	typeref:typename:PT
perp	code/Geometry/Geometry 2D.cpp	/^    PT perp() { return PT(-y, x); }$/;"	f	struct:PT	typeref:typename:PT	file:
perp	code/Geometry/Geometry 2D.cpp	/^PT perp(PT a) { return PT(-a.y, a.x); }$/;"	f	typeref:typename:PT
perp	code/Geometry/Geometry 3D.cpp	/^    PT perp() { return PT(-y, x); }$/;"	f	struct:PT	typeref:typename:PT	file:
perp	code/Geometry/Geometry 3D.cpp	/^PT perp(PT a) { return PT(-a.y, a.x); }$/;"	f	typeref:typename:PT
perp	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    PT perp() { return PT(-y, x); }$/;"	f	struct:PT	typeref:typename:PT	file:
perp	code/Geometry/Half Plane Intersection Dynamic.cpp	/^PT perp(PT a) { return PT(-a.y, a.x); }$/;"	f	typeref:typename:PT
perp	code/Geometry/Half Plane Intersection.cpp	/^    PT perp() { return PT(-y, x); }$/;"	f	struct:PT	typeref:typename:PT	file:
perp	code/Geometry/Half Plane Intersection.cpp	/^PT perp(PT a) { return PT(-a.y, a.x); }$/;"	f	typeref:typename:PT
perp	code/Geometry/Voronoi Diagram.cpp	/^    PT perp() { return PT(-y, x); }$/;"	f	struct:PT	typeref:typename:PT	file:
perp	code/Geometry/Voronoi Diagram.cpp	/^PT perp(PT a) { return PT(-a.y, a.x); }$/;"	f	typeref:typename:PT
perpendicular_through	code-library/Geometry/Geometry 2D.cpp	/^    line perpendicular_through(PT p) { return {p, p + perp(v)}; }$/;"	f	struct:line	typeref:typename:line	file:
perpendicular_through	code/Geometry/Geometry 2D.cpp	/^    line perpendicular_through(PT p) { return {p, p + perp(v)}; }$/;"	f	struct:line	typeref:typename:line	file:
persistent_dsu	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^  persistent_dsu() {$/;"	f	struct:persistent_dsu	file:
persistent_dsu	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^struct persistent_dsu {$/;"	s	file:
persistent_dsu	code-library/Data Structures/MOs with DSU.cpp	/^  persistent_dsu() {$/;"	f	struct:persistent_dsu	file:
persistent_dsu	code-library/Data Structures/MOs with DSU.cpp	/^struct persistent_dsu {$/;"	s	file:
persistent_dsu	code/Data Structures/Dynamic Connectivity Problem.cpp	/^  persistent_dsu() {$/;"	f	struct:persistent_dsu	file:
persistent_dsu	code/Data Structures/Dynamic Connectivity Problem.cpp	/^struct persistent_dsu {$/;"	s	file:
persistent_dsu	code/Data Structures/MOs with DSU.cpp	/^  persistent_dsu() {$/;"	f	struct:persistent_dsu	file:
persistent_dsu	code/Data Structures/MOs with DSU.cpp	/^struct persistent_dsu {$/;"	s	file:
peth_root	code-library/Number Theory/Discrete Root Faster.cpp	/^ll peth_root(ll a, ll p, int e, ll mod) {$/;"	f	typeref:typename:ll
peth_root	code/Number Theory/Discrete Root Faster.cpp	/^ll peth_root(ll a, ll p, int e, ll mod) {$/;"	f	typeref:typename:ll
pf1	code-library/Miscellaneous/Parallel Binary Search.cpp	/^#define pf1(/;"	d	file:
pf1	code/Miscellaneous/Parallel Binary Search.cpp	/^#define pf1(/;"	d	file:
pf1ll	code-library/Miscellaneous/Parallel Binary Search.cpp	/^#define pf1ll(/;"	d	file:
pf1ll	code/Miscellaneous/Parallel Binary Search.cpp	/^#define pf1ll(/;"	d	file:
phi	code-library/Number Theory/Dirichlet Convolution.cpp	/^  long long phi[T];$/;"	v	namespace:Dirichlet	typeref:typename:long long[]
phi	code-library/Number Theory/Phi Field.cpp	/^}phi((mod + 1) \/ 2, (mod + 1) \/ 2);$/;"	v	typeref:struct:field
phi	code-library/Number Theory/Phi Function.cpp	/^int phi[N];$/;"	v	typeref:typename:int[]
phi	code-library/Number Theory/Power Tower.cpp	/^ll phi(ll n) {$/;"	f	typeref:typename:ll
phi	code/Number Theory/Dirichlet Convolution.cpp	/^  long long phi[T];$/;"	v	namespace:Dirichlet	typeref:typename:long long[]
phi	code/Number Theory/Phi Field.cpp	/^}phi((mod + 1) \/ 2, (mod + 1) \/ 2);$/;"	v	typeref:struct:field
phi	code/Number Theory/Phi Function.cpp	/^int phi[N];$/;"	v	typeref:typename:int[]
phi	code/Number Theory/Power Tower.cpp	/^ll phi(ll n) {$/;"	f	typeref:typename:ll
pi	contests/USACO/dec_silver_2021/A/A.cpp	/^struct pi {$/;"	s	file:
pi	contests/USACO/dec_silver_2021/A/AA.cpp	/^struct pi {$/;"	s	file:
pi	contests/USACO/dec_silver_2021/A/A_safe.cpp	/^struct pi {$/;"	s	file:
pi	contests/USACO/dec_silver_2021/A/a_save.cpp	/^struct pi {$/;"	s	file:
pi	contests/USACO/dec_silver_2021/A/a_testing.cpp	/^struct pi {$/;"	s	file:
pi	contests/USACO/dec_silver_2021/A/restart_A.cpp	/^struct pi {$/;"	s	file:
pi	practice/december2021/DP/removal_game/sol.cpp	/^using pi = pair<ll, ll>;$/;"	t	typeref:typename:pair<ll,ll>	file:
pii	code-library/Data Structures/Disjoint Sparse Table.cpp	/^#define pii /;"	d	file:
pii	code-library/Dynamic Programming Optimizations/DP Over Divisors.cpp	/^#define pii /;"	d	file:
pii	code-library/Strings/Prefix Automaton.cpp	/^#define pii /;"	d	file:
pii	code/Data Structures/Disjoint Sparse Table.cpp	/^#define pii /;"	d	file:
pii	code/Dynamic Programming Optimizations/DP Over Divisors.cpp	/^#define pii /;"	d	file:
pii	code/Strings/Prefix Automaton.cpp	/^#define pii /;"	d	file:
pisano_period	code-library/Number Theory/Pisano Period.cpp	/^ll pisano_period(ll n) {$/;"	f	typeref:typename:ll
pisano_period	code/Number Theory/Pisano Period.cpp	/^ll pisano_period(ll n) {$/;"	f	typeref:typename:ll
pisano_period_prime	code-library/Number Theory/Pisano Period.cpp	/^ll pisano_period_prime(ll p) {$/;"	f	typeref:typename:ll
pisano_period_prime	code/Number Theory/Pisano Period.cpp	/^ll pisano_period_prime(ll p) {$/;"	f	typeref:typename:ll
pivot	code-library/Math/Simplex Algorithm.cpp	/^  inline void pivot(int m, int n, int a, int b){ \/\/\/ Pivoting and exchanging a non-basic vari/;"	f	namespace:lp	typeref:typename:void
pivot	code/Math/Simplex Algorithm.cpp	/^  inline void pivot(int m, int n, int a, int b){ \/\/\/ Pivoting and exchanging a non-basic vari/;"	f	namespace:lp	typeref:typename:void
plane	code-library/Geometry/Geometry 3D.cpp	/^    plane(p3 n, double d) : n(n), d(d) {}$/;"	f	struct:plane	file:
plane	code-library/Geometry/Geometry 3D.cpp	/^    plane(p3 n, p3 p) : n(n), d(n | p) {}$/;"	f	struct:plane	file:
plane	code-library/Geometry/Geometry 3D.cpp	/^    plane(p3 p, p3 q, p3 r) : plane((q - p) * (r - p), p) {}$/;"	f	struct:plane	file:
plane	code-library/Geometry/Geometry 3D.cpp	/^struct plane {$/;"	s	file:
plane	code/Geometry/Geometry 3D.cpp	/^    plane(p3 n, double d) : n(n), d(d) {}$/;"	f	struct:plane	file:
plane	code/Geometry/Geometry 3D.cpp	/^    plane(p3 n, p3 p) : n(n), d(n | p) {}$/;"	f	struct:plane	file:
plane	code/Geometry/Geometry 3D.cpp	/^    plane(p3 p, p3 q, p3 r) : plane((q - p) * (r - p), p) {}$/;"	f	struct:plane	file:
plane	code/Geometry/Geometry 3D.cpp	/^struct plane {$/;"	s	file:
plane_plane_intersection	code-library/Geometry/Geometry 3D.cpp	/^pair<p3, p3> plane_plane_intersection(p3 a1, p3 b1, p3 c1, p3 a2, p3 b2, p3 c2) {$/;"	f	typeref:typename:pair<p3,p3>
plane_plane_intersection	code/Geometry/Geometry 3D.cpp	/^pair<p3, p3> plane_plane_intersection(p3 a1, p3 b1, p3 c1, p3 a2, p3 b2, p3 c2) {$/;"	f	typeref:typename:pair<p3,p3>
pll	code-library/Data Structures/Disjoint Sparse Table.cpp	/^#define pll /;"	d	file:
pll	code-library/Dynamic Programming Optimizations/DP Over Divisors.cpp	/^#define pll /;"	d	file:
pll	code-library/Strings/Prefix Automaton.cpp	/^#define pll /;"	d	file:
pll	code/Data Structures/Disjoint Sparse Table.cpp	/^#define pll /;"	d	file:
pll	code/Dynamic Programming Optimizations/DP Over Divisors.cpp	/^#define pll /;"	d	file:
pll	code/Strings/Prefix Automaton.cpp	/^#define pll /;"	d	file:
plr	code-library/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^vector<vector<int> > plr;$/;"	v	typeref:typename:vector<vector<int>>
plr	code/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^vector<vector<int> > plr;$/;"	v	typeref:typename:vector<vector<int>>
pnode	code-library/Data Structures/Implicit Treap.cpp	/^  typedef node* pnode;$/;"	t	struct:treap	typeref:typename:node *	file:
pnode	code-library/Data Structures/Persistent Trie.cpp	/^typedef node_t * pnode;$/;"	t	typeref:typename:node_t *	file:
pnode	code/Data Structures/Implicit Treap.cpp	/^  typedef node* pnode;$/;"	t	struct:treap	typeref:typename:node *	file:
pnode	code/Data Structures/Persistent Trie.cpp	/^typedef node_t * pnode;$/;"	t	typeref:typename:node_t *	file:
pnt	code-library/Dynamic Programming Optimizations/Persistent CHT.cpp	/^  PT pnt[N];$/;"	m	struct:PersistentCHT	typeref:typename:PT[]	file:
pnt	code/Dynamic Programming Optimizations/Persistent CHT.cpp	/^  PT pnt[N];$/;"	m	struct:PersistentCHT	typeref:typename:PT[]	file:
point	code-library/Data Structures/KD Tree.cpp	/^struct point {$/;"	s	file:
point	code/Data Structures/KD Tree.cpp	/^struct point {$/;"	s	file:
point_along_line	code-library/Geometry/Geometry 2D.cpp	/^PT point_along_line(PT a, PT b, double d) {$/;"	f	typeref:typename:PT
point_along_line	code/Geometry/Geometry 2D.cpp	/^PT point_along_line(PT a, PT b, double d) {$/;"	f	typeref:typename:PT
point_line_relation	code-library/Geometry/Geometry 2D.cpp	/^int point_line_relation(PT a, PT b, PT p) {$/;"	f	typeref:typename:int
point_line_relation	code/Geometry/Geometry 2D.cpp	/^int point_line_relation(PT a, PT b, PT p) {$/;"	f	typeref:typename:int
point_location	code-library/Geometry/Point Location.cpp	/^vector<pair<int, int>> point_location(DCEL planar, vector<PT> queries) {$/;"	f	typeref:typename:vector<pair<int,int>>
point_location	code/Geometry/Point Location.cpp	/^vector<pair<int, int>> point_location(DCEL planar, vector<PT> queries) {$/;"	f	typeref:typename:vector<pair<int,int>>
point_on_sphere_segment	code-library/Geometry/Geometry 3D.cpp	/^bool point_on_sphere_segment(p3 a, p3 b, p3 p) {$/;"	f	typeref:typename:bool
point_on_sphere_segment	code/Geometry/Geometry 3D.cpp	/^bool point_on_sphere_segment(p3 a, p3 b, p3 p) {$/;"	f	typeref:typename:bool
point_poly_tangent	code-library/Geometry/Geometry 2D.cpp	/^pair<PT, int> point_poly_tangent(vector<PT> &p, PT Q, int dir, int l, int r) {$/;"	f	typeref:typename:pair<PT,int>
point_poly_tangent	code/Geometry/Geometry 2D.cpp	/^pair<PT, int> point_poly_tangent(vector<PT> &p, PT Q, int dir, int l, int r) {$/;"	f	typeref:typename:pair<PT,int>
point_to_face_distance	code-library/Geometry/Geometry 3D.cpp	/^    double point_to_face_distance(p3 p, int i) {$/;"	f	struct:CH3D	typeref:typename:double	file:
point_to_face_distance	code/Geometry/Geometry 3D.cpp	/^    double point_to_face_distance(p3 p, int i) {$/;"	f	struct:CH3D	typeref:typename:double	file:
pol	code-library/Geometry/Geometry 2D.cpp	/^    double arc, pol;$/;"	m	struct:CircleUnion	typeref:typename:double	file:
pol	code/Geometry/Geometry 2D.cpp	/^    double arc, pol;$/;"	m	struct:CircleUnion	typeref:typename:double	file:
polar	code-library/Miscellaneous/BigInt.cpp	/^#define polar(/;"	d	file:
polar	code/Miscellaneous/BigInt.cpp	/^#define polar(/;"	d	file:
polar_sort	code-library/Geometry/Geometry 2D.cpp	/^void polar_sort(vector<PT> &v) { \/\/ sort points in counterclockwise$/;"	f	typeref:typename:void
polar_sort	code-library/Geometry/Voronoi Diagram.cpp	/^void polar_sort(vector<PT> &v) { \/\/ sort points in counterclockwise$/;"	f	typeref:typename:void
polar_sort	code/Geometry/Geometry 2D.cpp	/^void polar_sort(vector<PT> &v) { \/\/ sort points in counterclockwise$/;"	f	typeref:typename:void
polar_sort	code/Geometry/Voronoi Diagram.cpp	/^void polar_sort(vector<PT> &v) { \/\/ sort points in counterclockwise$/;"	f	typeref:typename:void
pollard_rho	code-library/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^  ll pollard_rho(ll n) {$/;"	f	namespace:PollardRho	typeref:typename:ll
pollard_rho	code-library/Number Theory/Pisano Period.cpp	/^  ll pollard_rho(ll n) {$/;"	f	namespace:PollardRho	typeref:typename:ll
pollard_rho	code-library/Number Theory/Pollard Rho.cpp	/^  ll pollard_rho(ll n) {$/;"	f	namespace:PollardRho	typeref:typename:ll
pollard_rho	code/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^  ll pollard_rho(ll n) {$/;"	f	namespace:PollardRho	typeref:typename:ll
pollard_rho	code/Number Theory/Pisano Period.cpp	/^  ll pollard_rho(ll n) {$/;"	f	namespace:PollardRho	typeref:typename:ll
pollard_rho	code/Number Theory/Pollard Rho.cpp	/^  ll pollard_rho(ll n) {$/;"	f	namespace:PollardRho	typeref:typename:ll
poly	code-library/Math/FWHT in Ternary Base.cpp	/^typedef vector<cmplx> poly;$/;"	t	typeref:typename:vector<cmplx>	file:
poly	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly(const initializer_list<mint> &x): a(x.begin(), x.end()) { }$/;"	f	struct:poly	file:
poly	code-library/Math/Faulhaber Formula Fastest.cpp	/^  template<class...Args> poly(Args...args): a(args...) { }$/;"	f	struct:poly	file:
poly	code-library/Math/Faulhaber Formula Fastest.cpp	/^struct poly {$/;"	s	file:
poly	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^using poly = vector<mint>;$/;"	t	typeref:typename:vector<mint>	file:
poly	code-library/Math/Polynomial.cpp	/^  poly(const initializer_list<mint> &x): a(x.begin(), x.end()) { }$/;"	f	struct:poly	file:
poly	code-library/Math/Polynomial.cpp	/^  template<class...Args> poly(Args...args): a(args...) { }$/;"	f	struct:poly	file:
poly	code-library/Math/Polynomial.cpp	/^struct poly {$/;"	s	file:
poly	code-library/Math/Subset Sum Problem.cpp	/^  poly(const initializer_list<mint> &x): a(x.begin(), x.end()) { }$/;"	f	struct:poly	file:
poly	code-library/Math/Subset Sum Problem.cpp	/^  template<class...Args> poly(Args...args): a(args...) { }$/;"	f	struct:poly	file:
poly	code-library/Math/Subset Sum Problem.cpp	/^struct poly {$/;"	s	file:
poly	code-library/Number Theory/Bell Number.cpp	/^    poly(const initializer_list<mint> &x): a(x.begin(), x.end()) { }$/;"	f	struct:poly	file:
poly	code-library/Number Theory/Bell Number.cpp	/^    template<class...Args> poly(Args...args): a(args...) { }$/;"	f	struct:poly	file:
poly	code-library/Number Theory/Bell Number.cpp	/^struct poly {$/;"	s	file:
poly	code-library/Number Theory/Min_25 Sieve.cpp	/^T poly[D]; \/\/ polynomial representation of f(p)$/;"	v	typeref:typename:T[]
poly	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^using poly = vector<mint>;$/;"	t	typeref:typename:vector<mint>	file:
poly	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly(const initializer_list<mint> &x): a(x.begin(), x.end()) { }$/;"	f	struct:poly	file:
poly	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    template<class...Args> poly(Args...args): a(args...) { }$/;"	f	struct:poly	file:
poly	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^struct poly {$/;"	s	file:
poly	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly() {}$/;"	f	class:poly	file:
poly	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly(const R* ar, int s) : coefs(ar, ar + s) {}$/;"	f	class:poly	file:
poly	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly(const poly& f, int beg, int end=-1) {$/;"	f	class:poly	file:
poly	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly(const vector<R>& v) : coefs(v) {}$/;"	f	class:poly	file:
poly	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly(int n) : coefs(n) {}$/;"	f	class:poly	file:
poly	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly(int n, int c) : coefs(n, c % mod) {}$/;"	f	class:poly	file:
poly	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^class poly {$/;"	c	file:
poly	code/Math/FWHT in Ternary Base.cpp	/^typedef vector<cmplx> poly;$/;"	t	typeref:typename:vector<cmplx>	file:
poly	code/Math/Faulhaber Formula Fastest.cpp	/^  poly(const initializer_list<mint> &x): a(x.begin(), x.end()) { }$/;"	f	struct:poly	file:
poly	code/Math/Faulhaber Formula Fastest.cpp	/^  template<class...Args> poly(Args...args): a(args...) { }$/;"	f	struct:poly	file:
poly	code/Math/Faulhaber Formula Fastest.cpp	/^struct poly {$/;"	s	file:
poly	code/Math/Number of Solutions of A Equation MITM.cpp	/^using poly = vector<mint>;$/;"	t	typeref:typename:vector<mint>	file:
poly	code/Math/Polynomial.cpp	/^  poly(const initializer_list<mint> &x): a(x.begin(), x.end()) { }$/;"	f	struct:poly	file:
poly	code/Math/Polynomial.cpp	/^  template<class...Args> poly(Args...args): a(args...) { }$/;"	f	struct:poly	file:
poly	code/Math/Polynomial.cpp	/^struct poly {$/;"	s	file:
poly	code/Math/Subset Sum Problem.cpp	/^  poly(const initializer_list<mint> &x): a(x.begin(), x.end()) { }$/;"	f	struct:poly	file:
poly	code/Math/Subset Sum Problem.cpp	/^  template<class...Args> poly(Args...args): a(args...) { }$/;"	f	struct:poly	file:
poly	code/Math/Subset Sum Problem.cpp	/^struct poly {$/;"	s	file:
poly	code/Number Theory/Bell Number.cpp	/^    poly(const initializer_list<mint> &x): a(x.begin(), x.end()) { }$/;"	f	struct:poly	file:
poly	code/Number Theory/Bell Number.cpp	/^    template<class...Args> poly(Args...args): a(args...) { }$/;"	f	struct:poly	file:
poly	code/Number Theory/Bell Number.cpp	/^struct poly {$/;"	s	file:
poly	code/Number Theory/Min_25 Sieve.cpp	/^T poly[D]; \/\/ polynomial representation of f(p)$/;"	v	typeref:typename:T[]
poly	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^using poly = vector<mint>;$/;"	t	typeref:typename:vector<mint>	file:
poly	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    poly(const initializer_list<mint> &x): a(x.begin(), x.end()) { }$/;"	f	struct:poly	file:
poly	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    template<class...Args> poly(Args...args): a(args...) { }$/;"	f	struct:poly	file:
poly	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^struct poly {$/;"	s	file:
poly	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly() {}$/;"	f	class:poly	file:
poly	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly(const R* ar, int s) : coefs(ar, ar + s) {}$/;"	f	class:poly	file:
poly	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly(const poly& f, int beg, int end=-1) {$/;"	f	class:poly	file:
poly	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly(const vector<R>& v) : coefs(v) {}$/;"	f	class:poly	file:
poly	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly(int n) : coefs(n) {}$/;"	f	class:poly	file:
poly	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly(int n, int c) : coefs(n, c % mod) {}$/;"	f	class:poly	file:
poly	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^class poly {$/;"	c	file:
polygon_circle_intersection	code-library/Geometry/Geometry 2D.cpp	/^double polygon_circle_intersection(vector<PT> &v, PT p, double r) {$/;"	f	typeref:typename:double
polygon_circle_intersection	code/Geometry/Geometry 2D.cpp	/^double polygon_circle_intersection(vector<PT> &v, PT p, double r) {$/;"	f	typeref:typename:double
polygon_line_intersection	code-library/Geometry/Geometry 2D.cpp	/^double polygon_line_intersection(vector<PT> p, PT a, PT b) {$/;"	f	typeref:typename:double
polygon_line_intersection	code/Geometry/Geometry 2D.cpp	/^double polygon_line_intersection(vector<PT> p, PT a, PT b) {$/;"	f	typeref:typename:double
polygon_union	code-library/Geometry/Geometry 2D.cpp	/^double polygon_union(vector<vector<PT>> &p) {$/;"	f	typeref:typename:double
polygon_union	code/Geometry/Geometry 2D.cpp	/^double polygon_union(vector<vector<PT>> &p) {$/;"	f	typeref:typename:double
polynomial	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^  vector<mint> polynomial(vector<bitset<V>> g) {$/;"	f	struct:ChromaticPolynomial	typeref:typename:vector<mint>	file:
polynomial	code/Graph Theory/Chromatic Polynoimial.cpp	/^  vector<mint> polynomial(vector<bitset<V>> g) {$/;"	f	struct:ChromaticPolynomial	typeref:typename:vector<mint>	file:
pop	code-library/Data Structures/DSU with Rollbacks.cpp	/^  void pop() {$/;"	f	struct:DSUQueue	typeref:typename:void	file:
pop	code-library/Data Structures/Monotonous Queue.cpp	/^  void pop() {$/;"	f	struct:monotonous_queue	typeref:typename:void	file:
pop	code-library/Data Structures/Persistent Array.cpp	/^  T pop(int r) { \/\/ pops the top element of the rth queue and returns the popped element$/;"	f	struct:PersistentQueue	typeref:typename:T	file:
pop	code-library/Data Structures/Persistent Meldable Heap.cpp	/^  heap pop() {$/;"	f	struct:heap	typeref:typename:heap	file:
pop	code-library/Data Structures/Persistent Queue.cpp	/^  T pop(int r) { \/\/ pops the top element of the rth queue and returns the popped element$/;"	f	struct:PersistentQueue	typeref:typename:T	file:
pop	code-library/Data Structures/Queue Undo Trick.cpp	/^  void pop() {$/;"	f	struct:DSUQueue	typeref:typename:void	file:
pop	code-library/Data Structures/Venice Technique.cpp	/^  T pop() { auto ans = Q.top(); Q.pop(); ans.w += sum; return ans; }$/;"	f	struct:PQ	typeref:typename:T	file:
pop	code-library/Graph Theory/3 SAT.cpp	/^  void pop() {$/;"	f	struct:SAT_GOD	typeref:typename:void	file:
pop	code-library/Graph Theory/Directed MST.cpp	/^  T pop() { auto ans = Q.top(); Q.pop(); ans.w += sum; return ans; }$/;"	f	struct:PQ	typeref:typename:T	file:
pop	code-library/Graph Theory/Eppsteins Algorithm.cpp	/^  heap pop() {$/;"	f	struct:heap	typeref:typename:heap	file:
pop	code/Data Structures/DSU with Rollbacks.cpp	/^  void pop() {$/;"	f	struct:DSUQueue	typeref:typename:void	file:
pop	code/Data Structures/Monotonous Queue.cpp	/^  void pop() {$/;"	f	struct:monotonous_queue	typeref:typename:void	file:
pop	code/Data Structures/Persistent Array.cpp	/^  T pop(int r) { \/\/ pops the top element of the rth queue and returns the popped element$/;"	f	struct:PersistentQueue	typeref:typename:T	file:
pop	code/Data Structures/Persistent Meldable Heap.cpp	/^  heap pop() {$/;"	f	struct:heap	typeref:typename:heap	file:
pop	code/Data Structures/Persistent Queue.cpp	/^  T pop(int r) { \/\/ pops the top element of the rth queue and returns the popped element$/;"	f	struct:PersistentQueue	typeref:typename:T	file:
pop	code/Data Structures/Queue Undo Trick.cpp	/^  void pop() {$/;"	f	struct:DSUQueue	typeref:typename:void	file:
pop	code/Data Structures/Venice Technique.cpp	/^  T pop() { auto ans = Q.top(); Q.pop(); ans.w += sum; return ans; }$/;"	f	struct:PQ	typeref:typename:T	file:
pop	code/Graph Theory/3 SAT.cpp	/^  void pop() {$/;"	f	struct:SAT_GOD	typeref:typename:void	file:
pop	code/Graph Theory/Directed MST.cpp	/^  T pop() { auto ans = Q.top(); Q.pop(); ans.w += sum; return ans; }$/;"	f	struct:PQ	typeref:typename:T	file:
pop	code/Graph Theory/Eppsteins Algorithm.cpp	/^  heap pop() {$/;"	f	struct:heap	typeref:typename:heap	file:
pos	code-library/Data Structures/Dynamic Diameter Online.cpp	/^int T, st[N * 2], en[N * 2], pos[N];$/;"	v	typeref:typename:int[]
pos	code-library/Data Structures/MOs with Update.cpp	/^  int pos, old, cur;$/;"	m	struct:upd	typeref:typename:int	file:
pos	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  int pos, key, mn, mx;$/;"	m	struct:node	typeref:typename:int	file:
pos	code-library/Geometry/Point Location.cpp	/^    EventType type; int pos;$/;"	m	struct:Event	typeref:typename:int	file:
pos	code-library/Graph Theory/3 SAT.cpp	/^  vector<int> occ, pos, neg;$/;"	m	struct:SAT_GOD	typeref:typename:vector<int>	file:
pos	code-library/Graph Theory/Path Union.cpp	/^int pos[N];$/;"	v	typeref:typename:int[]
pos	code-library/Number Theory/Sieve upto 1e9.cpp	/^    int p; int pos[8];$/;"	m	struct:sieve::P	typeref:typename:int[8]	file:
pos	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^int pos[N];$/;"	v	typeref:typename:int[]
pos	code/Data Structures/Dynamic Diameter Online.cpp	/^int T, st[N * 2], en[N * 2], pos[N];$/;"	v	typeref:typename:int[]
pos	code/Data Structures/MOs with Update.cpp	/^  int pos, old, cur;$/;"	m	struct:upd	typeref:typename:int	file:
pos	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  int pos, key, mn, mx;$/;"	m	struct:node	typeref:typename:int	file:
pos	code/Geometry/Point Location.cpp	/^    EventType type; int pos;$/;"	m	struct:Event	typeref:typename:int	file:
pos	code/Graph Theory/3 SAT.cpp	/^  vector<int> occ, pos, neg;$/;"	m	struct:SAT_GOD	typeref:typename:vector<int>	file:
pos	code/Graph Theory/Path Union.cpp	/^int pos[N];$/;"	v	typeref:typename:int[]
pos	code/Number Theory/Sieve upto 1e9.cpp	/^    int p; int pos[8];$/;"	m	struct:sieve::P	typeref:typename:int[8]	file:
pos	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^int pos[N];$/;"	v	typeref:typename:int[]
pos	contests/Codeforces/1560/F1/main.cpp	/^vector<vector<bool>> pos;$/;"	v	typeref:typename:vector<vector<bool>>
pos2d	code-library/Geometry/Geometry 3D.cpp	/^    PT pos2d(p3 p) {$/;"	f	struct:coords	typeref:typename:PT	file:
pos2d	code/Geometry/Geometry 3D.cpp	/^    PT pos2d(p3 p) {$/;"	f	struct:coords	typeref:typename:PT	file:
pos3d	code-library/Geometry/Geometry 3D.cpp	/^    p3 pos3d(PT p){ \/\/original position vector$/;"	f	struct:coords	typeref:typename:p3	file:
pos3d	code-library/Geometry/Geometry 3D.cpp	/^    p3 pos3d(p3 p) {$/;"	f	struct:coords	typeref:typename:p3	file:
pos3d	code/Geometry/Geometry 3D.cpp	/^    p3 pos3d(PT p){ \/\/original position vector$/;"	f	struct:coords	typeref:typename:p3	file:
pos3d	code/Geometry/Geometry 3D.cpp	/^    p3 pos3d(p3 p) {$/;"	f	struct:coords	typeref:typename:p3	file:
position	code-library/Data Structures/Implicit Treap.cpp	/^  map<int, pnode> position;\/\/positions of all the values$/;"	m	struct:treap	typeref:typename:map<int,pnode>	file:
position	code/Data Structures/Implicit Treap.cpp	/^  map<int, pnode> position;\/\/positions of all the values$/;"	m	struct:treap	typeref:typename:map<int,pnode>	file:
possible	practice/usacoguide/gold/bfs/monsters.cpp	/^bool one_it = 0, possible = 0;$/;"	v	typeref:typename:bool
pot	code-library/Data Structures/Augmented DSU.cpp	/^int pot[N], prec[N];$/;"	v	typeref:typename:int[]
pot	code/Data Structures/Augmented DSU.cpp	/^int pot[N], prec[N];$/;"	v	typeref:typename:int[]
potential	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  vector<T> d, potential, flow_through;$/;"	m	struct:MCMF	typeref:typename:vector<T>	file:
potential	code-library/Graph Theory/Min Cost Max Flow.cpp	/^  vector<T> d, potential, flow_through;$/;"	m	struct:MCMF	typeref:typename:vector<T>	file:
potential	code/Graph Theory/L R Flow with MCMF.cpp	/^  vector<T> d, potential, flow_through;$/;"	m	struct:MCMF	typeref:typename:vector<T>	file:
potential	code/Graph Theory/Min Cost Max Flow.cpp	/^  vector<T> d, potential, flow_through;$/;"	m	struct:MCMF	typeref:typename:vector<T>	file:
pow	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^  modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^  modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^    modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Graph Theory/Number of Arborescence.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Graph Theory/Number of DAG.cpp	/^    modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Graph Theory/Tree Isomorphism.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Math/BerleKamp Massey.cpp	/^  modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Math/Characteristic Polynomial Faster.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Math/Determinant of Sparse Matrix.cpp	/^  inline Mat pow(long long k) {$/;"	f	struct:Mat	typeref:typename:Mat	file:
pow	code-library/Math/Determinant of Sparse Matrix.cpp	/^  modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Math/FWHT in Any Base.cpp	/^  vector<int> pow(vector<int> a, long long p, int k) {$/;"	f	namespace:FWHT	typeref:typename:vector<int>
pow	code-library/Math/FWHT in Ternary Base.cpp	/^  modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Math/FWHT in Ternary Base.cpp	/^  vector<int> pow(int n, vector<int> &a, long long k) {$/;"	f	struct:FWHT	typeref:typename:vector<int>	file:
pow	code-library/Math/FWHT.cpp	/^  vector<int> pow(int n, vector<int> A, long long k, int flag = XOR) {$/;"	f	struct:FWHT	typeref:typename:vector<int>	file:
pow	code-library/Math/Faulhaber Formula Fastest.cpp	/^  modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly pow(int k, int n) const { \/\/ p(x)^k mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
pow	code-library/Math/Freivalds Algorithm.cpp	/^  inline Mat pow(long long k) {$/;"	f	struct:Mat	typeref:typename:Mat	file:
pow	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^    modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Math/Hafnian of a Matrix.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Math/Lagrange Interpolation Brute.cpp	/^  modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Math/Lagrange Interpolation.cpp	/^  modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Math/Linear Recurrence.cpp	/^  modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Math/Matrix Exponentiation.cpp	/^  inline Mat pow(long long k) {$/;"	f	struct:Mat	typeref:typename:Mat	file:
pow	code-library/Math/NTT With Any Prime MOD.cpp	/^vector<int> pow(vector<int>& a, int p) {$/;"	f	typeref:typename:vector<int>
pow	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Math/Polynomial Sum.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Math/Polynomial.cpp	/^  modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Math/Polynomial.cpp	/^  poly pow(int k, int n) const { \/\/ p(x)^k mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
pow	code-library/Math/Subset Sum Problem.cpp	/^  modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Math/The Slime Trick.cpp	/^    modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Math/Thomas Algorithm.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Math/Vandermonde Matrix.cpp	/^  modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Number Theory/Bell Number.cpp	/^    modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Number Theory/Combinatorics Basics.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Number Theory/Dirichlet Convolution.cpp	/^    modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Number Theory/Lucas Theorem.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Number Theory/Min_25 Sieve.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Number Theory/Partition Function.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Number Theory/Phi Field.cpp	/^  field pow(ll k) {$/;"	f	struct:field	typeref:typename:field	file:
pow	code-library/Number Theory/Phi Field.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Number Theory/Prime Number System.cpp	/^  base pow(int k) {$/;"	f	struct:base	typeref:typename:base	file:
pow	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  Mod pow(word_t exp) const {$/;"	f	class:ntt::Mod	typeref:typename:Mod	file:
pow	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Graph Theory/Chromatic Polynoimial.cpp	/^  modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Graph Theory/Counting Labeled Graphs.cpp	/^  modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Graph Theory/Hafnian of a Matrix.cpp	/^    modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Graph Theory/Number of Arborescence.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Graph Theory/Number of DAG.cpp	/^    modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Graph Theory/Tree Isomorphism.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Math/BerleKamp Massey.cpp	/^  modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Math/Characteristic Polynomial Faster.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Math/Determinant of Sparse Matrix.cpp	/^  inline Mat pow(long long k) {$/;"	f	struct:Mat	typeref:typename:Mat	file:
pow	code/Math/Determinant of Sparse Matrix.cpp	/^  modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Math/FWHT in Any Base.cpp	/^  vector<int> pow(vector<int> a, long long p, int k) {$/;"	f	namespace:FWHT	typeref:typename:vector<int>
pow	code/Math/FWHT in Ternary Base.cpp	/^  modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Math/FWHT in Ternary Base.cpp	/^  vector<int> pow(int n, vector<int> &a, long long k) {$/;"	f	struct:FWHT	typeref:typename:vector<int>	file:
pow	code/Math/FWHT.cpp	/^  vector<int> pow(int n, vector<int> A, long long k, int flag = XOR) {$/;"	f	struct:FWHT	typeref:typename:vector<int>	file:
pow	code/Math/Faulhaber Formula Fastest.cpp	/^  modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Math/Faulhaber Formula Fastest.cpp	/^  poly pow(int k, int n) const { \/\/ p(x)^k mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
pow	code/Math/Freivalds Algorithm.cpp	/^  inline Mat pow(long long k) {$/;"	f	struct:Mat	typeref:typename:Mat	file:
pow	code/Math/Generating Function of a Linear Recurrence.cpp	/^    modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Math/Hafnian of a Matrix.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Math/Lagrange Interpolation Brute.cpp	/^  modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Math/Lagrange Interpolation.cpp	/^  modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Math/Linear Recurrence.cpp	/^  modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Math/Matrix Exponentiation.cpp	/^  inline Mat pow(long long k) {$/;"	f	struct:Mat	typeref:typename:Mat	file:
pow	code/Math/NTT With Any Prime MOD.cpp	/^vector<int> pow(vector<int>& a, int p) {$/;"	f	typeref:typename:vector<int>
pow	code/Math/Number of Solutions of A Equation MITM.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Math/Polynomial Sum.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Math/Polynomial.cpp	/^  modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Math/Polynomial.cpp	/^  poly pow(int k, int n) const { \/\/ p(x)^k mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
pow	code/Math/Subset Sum Problem.cpp	/^  modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Math/The Slime Trick.cpp	/^    modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Math/Thomas Algorithm.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Math/Vandermonde Matrix.cpp	/^  modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Number Theory/Bell Number.cpp	/^    modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Number Theory/Combinatorics Basics.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Number Theory/Dirichlet Convolution.cpp	/^    modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Number Theory/Lucas Theorem.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Number Theory/Min_25 Sieve.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Number Theory/Partition Function.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Number Theory/Phi Field.cpp	/^  field pow(ll k) {$/;"	f	struct:field	typeref:typename:field	file:
pow	code/Number Theory/Phi Field.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Number Theory/Prime Number System.cpp	/^  base pow(int k) {$/;"	f	struct:base	typeref:typename:base	file:
pow	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    modint<MOD> pow(uint64_t k) const {$/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  Mod pow(word_t exp) const {$/;"	f	class:ntt::Mod	typeref:typename:Mod	file:
pow	practice/cf/random/1700/6.cpp	/^mi pow(mi a, long long p) {$/;"	f	typeref:typename:mi
pow	practice/cf/random/i_hate_math_problems/1422C.cpp	/^mi pow(mi a, ll p) { assert(p >= 0); \/\/ won't work for negative p$/;"	f	typeref:typename:mi
pow	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	practice/cf/random/i_hate_math_problems/testing.cpp	/^  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k &/;"	f	struct:modint	typeref:typename:modint<MOD>	file:
pow	practice/usacoguide/gold/introDP/arraydescription.cpp	/^mi pow(mi a, ll p) { assert(p >= 0); \/\/ won't work for negative p$/;"	f	typeref:typename:mi
pow2	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly pow2(int k, int n) const { \/\/ p(x)^k mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
pow2	code-library/Math/Polynomial.cpp	/^  poly pow2(int k, int n) const { \/\/ p(x)^k mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
pow2	code/Math/Faulhaber Formula Fastest.cpp	/^  poly pow2(int k, int n) const { \/\/ p(x)^k mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
pow2	code/Math/Polynomial.cpp	/^  poly pow2(int k, int n) const { \/\/ p(x)^k mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
pow3	practice/usacoguide/silver/idk/maze/main.cpp	/^vector<int> pow3(10);$/;"	v	typeref:typename:vector<int>
pow_mod	code-library/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^  inline ll pow_mod(ll x, ll n, ll m) {$/;"	f	namespace:PollardRho	typeref:typename:ll
pow_mod	code-library/Number Theory/Pisano Period.cpp	/^  inline ll pow_mod(ll x, ll n, ll m) {$/;"	f	namespace:PollardRho	typeref:typename:ll
pow_mod	code-library/Number Theory/Pollard Rho.cpp	/^  inline ll pow_mod(ll x, ll n, ll m) {$/;"	f	namespace:PollardRho	typeref:typename:ll
pow_mod	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static R pow_mod(R a, int e) {$/;"	f	class:poly	typeref:typename:R	file:
pow_mod	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^int pow_mod(int b, int e, int mod) {$/;"	f	typeref:typename:int
pow_mod	code/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^  inline ll pow_mod(ll x, ll n, ll m) {$/;"	f	namespace:PollardRho	typeref:typename:ll
pow_mod	code/Number Theory/Pisano Period.cpp	/^  inline ll pow_mod(ll x, ll n, ll m) {$/;"	f	namespace:PollardRho	typeref:typename:ll
pow_mod	code/Number Theory/Pollard Rho.cpp	/^  inline ll pow_mod(ll x, ll n, ll m) {$/;"	f	namespace:PollardRho	typeref:typename:ll
pow_mod	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static R pow_mod(R a, int e) {$/;"	f	class:poly	typeref:typename:R	file:
pow_mod	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^int pow_mod(int b, int e, int mod) {$/;"	f	typeref:typename:int
power	code-library/Graph Theory/Kirchoffs Theorem.cpp	/^int power(long long n, long long k) {$/;"	f	typeref:typename:int
power	code-library/Math/Determinant of Cyclic Matrix.cpp	/^int power(int a, int b) {$/;"	f	typeref:typename:int
power	code-library/Math/Determinant of Permutant Matrix.cpp	/^int power(int a, int b) {$/;"	f	typeref:typename:int
power	code-library/Math/Determinant under Prime Modulo.cpp	/^int power(long long n, long long k) {$/;"	f	typeref:typename:int
power	code-library/Math/FWHT in Ternary Base.cpp	/^  cmplx power(cmplx x, long long n) {$/;"	f	struct:FWHT	typeref:typename:cmplx	file:
power	code-library/Math/Finite Field Arithmetic Binary.cpp	/^  inline int power(int a, long long k) {$/;"	f	namespace:FFA	typeref:typename:int
power	code-library/Math/Gaussian Elimination Modular.cpp	/^int power(long long n, long long k) {$/;"	f	typeref:typename:int
power	code-library/Math/Inverse of A Matrix.cpp	/^int power(long long n, long long k, const int mod) {$/;"	f	typeref:typename:int
power	code-library/Miscellaneous/BigInt.cpp	/^BigInt power(BigInt a, ll k) {$/;"	f	typeref:typename:BigInt
power	code-library/Miscellaneous/K-th Root of a Permutation.cpp	/^vector<vector<int>> power(vector<int> &p, int k) {$/;"	f	typeref:typename:vector<vector<int>>
power	code-library/Number Theory/Discrete Root Faster.cpp	/^ll power(ll a, ll n, ll p) {$/;"	f	typeref:typename:ll
power	code-library/Number Theory/Discrete Root.cpp	/^int power(int a, int b, int m) {$/;"	f	typeref:typename:int
power	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^ll power(ll n, ll k) {$/;"	f	typeref:typename:ll
power	code-library/Number Theory/K Divisors.cpp	/^ll power(ll n, int k) {$/;"	f	typeref:typename:ll
power	code-library/Number Theory/LCM of Fibonacci Numbers.cpp	/^int power(long long n, long long k) {$/;"	f	typeref:typename:int
power	code-library/Number Theory/Multiplicative Order.cpp	/^ll power(ll n, ll k, const ll mod) {$/;"	f	typeref:typename:ll
power	code-library/Number Theory/Number of Distinct Kth Powers Modulo n.cpp	/^ll power(ll n, ll k) {$/;"	f	typeref:typename:ll
power	code-library/Number Theory/Pisano Period.cpp	/^ll power(ll n, ll k, const ll mod) {$/;"	f	typeref:typename:ll
power	code-library/Number Theory/Power Tower.cpp	/^ll power(ll n, ll k, ll mod) {$/;"	f	typeref:typename:ll
power	code-library/Number Theory/Prime Number System.cpp	/^int power(long long n, long long k) {$/;"	f	typeref:typename:int
power	code-library/Number Theory/Primitive Root.cpp	/^int power(int a, int b, int m) {$/;"	f	typeref:typename:int
power	code-library/Number Theory/Smallest Number Having Exactly K Divisors.cpp	/^int power(long long n, long long k) {$/;"	f	typeref:typename:int
power	code-library/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^vector<int> power(vector<int> a, int k, int n) {$/;"	f	typeref:typename:vector<int>
power	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^long long power(long long n, long long k) {$/;"	f	typeref:typename:long long
power	code-library/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^int power(long long n, long long k) {$/;"	f	typeref:typename:int
power	code-library/Number Theory/Tonelli Shanks Algorithm.cpp	/^int power(long long n, long long k, const int mod) {$/;"	f	typeref:typename:int
power	code-library/Number Theory/nCr Modulo Any Mod.cpp	/^int power(long long n, long long k, const int mod) {$/;"	f	typeref:typename:int
power	code-library/Strings/String Hashing.cpp	/^int power(long long n, long long k, const int mod) {$/;"	f	typeref:typename:int
power	code/Graph Theory/Kirchoffs Theorem.cpp	/^int power(long long n, long long k) {$/;"	f	typeref:typename:int
power	code/Math/Determinant of Cyclic Matrix.cpp	/^int power(int a, int b) {$/;"	f	typeref:typename:int
power	code/Math/Determinant of Permutant Matrix.cpp	/^int power(int a, int b) {$/;"	f	typeref:typename:int
power	code/Math/Determinant under Prime Modulo.cpp	/^int power(long long n, long long k) {$/;"	f	typeref:typename:int
power	code/Math/FWHT in Ternary Base.cpp	/^  cmplx power(cmplx x, long long n) {$/;"	f	struct:FWHT	typeref:typename:cmplx	file:
power	code/Math/Finite Field Arithmetic Binary.cpp	/^  inline int power(int a, long long k) {$/;"	f	namespace:FFA	typeref:typename:int
power	code/Math/Gaussian Elimination Modular.cpp	/^int power(long long n, long long k) {$/;"	f	typeref:typename:int
power	code/Math/Inverse of A Matrix.cpp	/^int power(long long n, long long k, const int mod) {$/;"	f	typeref:typename:int
power	code/Miscellaneous/BigInt.cpp	/^BigInt power(BigInt a, ll k) {$/;"	f	typeref:typename:BigInt
power	code/Miscellaneous/K-th Root of a Permutation.cpp	/^vector<vector<int>> power(vector<int> &p, int k) {$/;"	f	typeref:typename:vector<vector<int>>
power	code/Number Theory/Discrete Root Faster.cpp	/^ll power(ll a, ll n, ll p) {$/;"	f	typeref:typename:ll
power	code/Number Theory/Discrete Root.cpp	/^int power(int a, int b, int m) {$/;"	f	typeref:typename:int
power	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^ll power(ll n, ll k) {$/;"	f	typeref:typename:ll
power	code/Number Theory/K Divisors.cpp	/^ll power(ll n, int k) {$/;"	f	typeref:typename:ll
power	code/Number Theory/LCM of Fibonacci Numbers.cpp	/^int power(long long n, long long k) {$/;"	f	typeref:typename:int
power	code/Number Theory/Multiplicative Order.cpp	/^ll power(ll n, ll k, const ll mod) {$/;"	f	typeref:typename:ll
power	code/Number Theory/Number of Distinct Kth Powers Modulo n.cpp	/^ll power(ll n, ll k) {$/;"	f	typeref:typename:ll
power	code/Number Theory/Pisano Period.cpp	/^ll power(ll n, ll k, const ll mod) {$/;"	f	typeref:typename:ll
power	code/Number Theory/Power Tower.cpp	/^ll power(ll n, ll k, ll mod) {$/;"	f	typeref:typename:ll
power	code/Number Theory/Prime Number System.cpp	/^int power(long long n, long long k) {$/;"	f	typeref:typename:int
power	code/Number Theory/Primitive Root.cpp	/^int power(int a, int b, int m) {$/;"	f	typeref:typename:int
power	code/Number Theory/Smallest Number Having Exactly K Divisors.cpp	/^int power(long long n, long long k) {$/;"	f	typeref:typename:int
power	code/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^vector<int> power(vector<int> a, int k, int n) {$/;"	f	typeref:typename:vector<int>
power	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^long long power(long long n, long long k) {$/;"	f	typeref:typename:long long
power	code/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^int power(long long n, long long k) {$/;"	f	typeref:typename:int
power	code/Number Theory/Tonelli Shanks Algorithm.cpp	/^int power(long long n, long long k, const int mod) {$/;"	f	typeref:typename:int
power	code/Number Theory/nCr Modulo Any Mod.cpp	/^int power(long long n, long long k, const int mod) {$/;"	f	typeref:typename:int
power	code/Strings/String Hashing.cpp	/^int power(long long n, long long k, const int mod) {$/;"	f	typeref:typename:int
power_sum	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^ll power_sum(ll n, int k) {$/;"	f	typeref:typename:ll
power_sum	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^long long power_sum(long long n, int k) {$/;"	f	typeref:typename:long long
power_sum	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^ll power_sum(ll n, int k) {$/;"	f	typeref:typename:ll
power_sum	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^long long power_sum(long long n, int k) {$/;"	f	typeref:typename:long long
pp	code-library/Data Structures/Link Cut Tree.cpp	/^  int p = 0, c[2] = {0, 0}, pp = 0;$/;"	m	struct:node	typeref:typename:int	file:
pp	code/Data Structures/Link Cut Tree.cpp	/^  int p = 0, c[2] = {0, 0}, pp = 0;$/;"	m	struct:node	typeref:typename:int	file:
pp	practice/december2021/DP/counting_towers/sol.cpp	/^void pp() {$/;"	f	typeref:typename:void
pre	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^void pre() {$/;"	f	typeref:typename:void
pre	code-library/Math/NTT Online.cpp	/^void pre() {$/;"	f	typeref:typename:void
pre	code-library/Math/Polynomial with Binomial Coefficients.cpp	/^void pre()$/;"	f	typeref:typename:void
pre	code/Graph Theory/Counting Labeled Graphs.cpp	/^void pre() {$/;"	f	typeref:typename:void
pre	code/Math/NTT Online.cpp	/^void pre() {$/;"	f	typeref:typename:void
pre	code/Math/Polynomial with Binomial Coefficients.cpp	/^void pre()$/;"	f	typeref:typename:void
prec	code-library/Data Structures/Augmented DSU.cpp	/^int pot[N], prec[N];$/;"	v	typeref:typename:int[]
prec	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^void prec() {$/;"	f	typeref:typename:void
prec	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^void prec() {$/;"	f	typeref:typename:void
prec	code-library/Strings/String Hashing.cpp	/^void prec() {$/;"	f	typeref:typename:void
prec	code-library/Strings/Suffix Array Isomorphic.cpp	/^  void prec() {$/;"	f	struct:IsomorphicSuffixArray	typeref:typename:void	file:
prec	code-library/Strings/Suffix Array Isomorphic.cpp	/^  void prec() {$/;"	f	struct:SuffixArray	typeref:typename:void	file:
prec	code-library/Strings/Suffix Array.cpp	/^  void prec() {$/;"	f	struct:SuffixArray	typeref:typename:void	file:
prec	code/Data Structures/Augmented DSU.cpp	/^int pot[N], prec[N];$/;"	v	typeref:typename:int[]
prec	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^void prec() {$/;"	f	typeref:typename:void
prec	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^void prec() {$/;"	f	typeref:typename:void
prec	code/Strings/String Hashing.cpp	/^void prec() {$/;"	f	typeref:typename:void
prec	code/Strings/Suffix Array Isomorphic.cpp	/^  void prec() {$/;"	f	struct:IsomorphicSuffixArray	typeref:typename:void	file:
prec	code/Strings/Suffix Array Isomorphic.cpp	/^  void prec() {$/;"	f	struct:SuffixArray	typeref:typename:void	file:
prec	code/Strings/Suffix Array.cpp	/^  void prec() {$/;"	f	struct:SuffixArray	typeref:typename:void	file:
precomp	code-library/Math/Polynomial Factorization.cpp	/^void precomp() {$/;"	f	typeref:typename:void
precomp	code/Math/Polynomial Factorization.cpp	/^void precomp() {$/;"	f	typeref:typename:void
precompute	code-library/Math/NTT.cpp	/^void precompute(int len) {$/;"	f	typeref:typename:void
precompute	code-library/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^void precompute(int len) {$/;"	f	typeref:typename:void
precompute	code-library/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^void precompute(int len) {$/;"	f	typeref:typename:void
precompute	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^void precompute(int len) {$/;"	f	typeref:typename:void
precompute	code-library/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^void precompute(int len) {$/;"	f	typeref:typename:void
precompute	code/Math/NTT.cpp	/^void precompute(int len) {$/;"	f	typeref:typename:void
precompute	code/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^void precompute(int len) {$/;"	f	typeref:typename:void
precompute	code/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^void precompute(int len) {$/;"	f	typeref:typename:void
precompute	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^void precompute(int len) {$/;"	f	typeref:typename:void
precompute	code/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^void precompute(int len) {$/;"	f	typeref:typename:void
pref	code-library/Data Structures/SQRT Tree.cpp	/^  vector< vector<SqrtTreeItem> > pref, suf, between;$/;"	m	struct:SqrtTree	typeref:typename:vector<vector<SqrtTreeItem>>	file:
pref	code-library/Graph Theory/Stable Marriage Problem.cpp	/^int m[N][N], w[N][N], id[N], marry[N], ans[N], pref[N][N];$/;"	v	typeref:typename:int[][]
pref	code-library/Number Theory/K Divisors.cpp	/^  int pref[MAXN]; \/\/ pref[i] --> number of primes <= i$/;"	v	namespace:pcf	typeref:typename:int[]
pref	code-library/Number Theory/Min_25 Sieve.cpp	/^T pref[D][N];$/;"	v	typeref:typename:T[][]
pref	code-library/Number Theory/Prime Counting Function.cpp	/^  int pref[MAXN]; \/\/ pref[i] --> number of primes <= i$/;"	v	namespace:pcf	typeref:typename:int[]
pref	code-library/Strings/Palindromic Tree Persistent.cpp	/^  vector<int> pref;$/;"	m	struct:PalindromicTree	typeref:typename:vector<int>	file:
pref	code/Data Structures/SQRT Tree.cpp	/^  vector< vector<SqrtTreeItem> > pref, suf, between;$/;"	m	struct:SqrtTree	typeref:typename:vector<vector<SqrtTreeItem>>	file:
pref	code/Graph Theory/Stable Marriage Problem.cpp	/^int m[N][N], w[N][N], id[N], marry[N], ans[N], pref[N][N];$/;"	v	typeref:typename:int[][]
pref	code/Number Theory/K Divisors.cpp	/^  int pref[MAXN]; \/\/ pref[i] --> number of primes <= i$/;"	v	namespace:pcf	typeref:typename:int[]
pref	code/Number Theory/Min_25 Sieve.cpp	/^T pref[D][N];$/;"	v	typeref:typename:T[][]
pref	code/Number Theory/Prime Counting Function.cpp	/^  int pref[MAXN]; \/\/ pref[i] --> number of primes <= i$/;"	v	namespace:pcf	typeref:typename:int[]
pref	code/Strings/Palindromic Tree Persistent.cpp	/^  vector<int> pref;$/;"	m	struct:PalindromicTree	typeref:typename:vector<int>	file:
prefix_function	code-library/Strings/Prefix Automaton.cpp	/^vector<int> prefix_function(string &s) {$/;"	f	typeref:typename:vector<int>
prefix_function	code/Strings/Prefix Automaton.cpp	/^vector<int> prefix_function(string &s) {$/;"	f	typeref:typename:vector<int>
preorder	code-library/Graph Theory/ST Numbering.cpp	/^vector<int> preorder;$/;"	v	typeref:typename:vector<int>
preorder	code/Graph Theory/ST Numbering.cpp	/^vector<int> preorder;$/;"	v	typeref:typename:vector<int>
prepare	code-library/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^void prepare() {$/;"	f	typeref:typename:void
prepare	code/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^void prepare() {$/;"	f	typeref:typename:void
preprocess	practice/usacoguide/gold/bfs/mechonew/main.cpp	/^void preprocess() {$/;"	f	typeref:typename:void
prev	code-library/Geometry/Delaunay Triangulation.cpp	/^    Q prev() { return rot -> o -> rot; }$/;"	f	struct:Quad	typeref:typename:Q	file:
prev	code-library/Geometry/Voronoi Diagram.cpp	/^    Q prev() { return rot -> o -> rot; }$/;"	f	struct:Quad	typeref:typename:Q	file:
prev	code/Geometry/Delaunay Triangulation.cpp	/^    Q prev() { return rot -> o -> rot; }$/;"	f	struct:Quad	typeref:typename:Q	file:
prev	code/Geometry/Voronoi Diagram.cpp	/^    Q prev() { return rot -> o -> rot; }$/;"	f	struct:Quad	typeref:typename:Q	file:
prime	code-library/Math/BerleKamp Massey.cpp	/^int prime[] = {2, 3, 5, 7, 11, 13, 17, 19}, ok[20];$/;"	v	typeref:typename:int[]
prime	code-library/Number Theory/Dirichlet Convolution.cpp	/^  int sz, spf[T], prime[T];$/;"	v	namespace:Dirichlet	typeref:typename:int[]
prime	code/Math/BerleKamp Massey.cpp	/^int prime[] = {2, 3, 5, 7, 11, 13, 17, 19}, ok[20];$/;"	v	typeref:typename:int[]
prime	code/Number Theory/Dirichlet Convolution.cpp	/^  int sz, spf[T], prime[T];$/;"	v	namespace:Dirichlet	typeref:typename:int[]
prime_factor	practice/usacoguide/gold/divisibility/powerproducts.cpp	/^vector<pair<int, int>> prime_factor(int a) {$/;"	f	typeref:typename:vector<pair<int,int>>
primes	code-library/Number Theory/K Divisors.cpp	/^  int primes[MAX_PRIMES];$/;"	v	namespace:pcf	typeref:typename:int[]
primes	code-library/Number Theory/Linear Sieve for Multiplicative Functions.cpp	/^vector<int> primes;$/;"	v	typeref:typename:vector<int>
primes	code-library/Number Theory/Min_25 Sieve.cpp	/^int primes[N], p, deg;$/;"	v	typeref:typename:int[]
primes	code-library/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^  int primes[P], spf[P];$/;"	v	namespace:PollardRho	typeref:typename:int[]
primes	code-library/Number Theory/Pisano Period.cpp	/^  int primes[P], spf[P];$/;"	v	namespace:PollardRho	typeref:typename:int[]
primes	code-library/Number Theory/Pollard Rho.cpp	/^  int primes[P], spf[P];$/;"	v	namespace:PollardRho	typeref:typename:int[]
primes	code-library/Number Theory/Prime Counting Function.cpp	/^  int primes[MAX_PRIMES];$/;"	v	namespace:pcf	typeref:typename:int[]
primes	code-library/Number Theory/Prime Number System.cpp	/^vector<int> primes;$/;"	v	typeref:typename:vector<int>
primes	code-library/Number Theory/Sieve.cpp	/^vector<int> primes;$/;"	v	typeref:typename:vector<int>
primes	code-library/Number Theory/Smallest Number Having Exactly K Divisors.cpp	/^vector<int> primes;$/;"	v	typeref:typename:vector<int>
primes	code-library/Number Theory/nCr Modulo Any Mod.cpp	/^vector<int> primes;$/;"	v	typeref:typename:vector<int>
primes	code/Number Theory/K Divisors.cpp	/^  int primes[MAX_PRIMES];$/;"	v	namespace:pcf	typeref:typename:int[]
primes	code/Number Theory/Linear Sieve for Multiplicative Functions.cpp	/^vector<int> primes;$/;"	v	typeref:typename:vector<int>
primes	code/Number Theory/Min_25 Sieve.cpp	/^int primes[N], p, deg;$/;"	v	typeref:typename:int[]
primes	code/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^  int primes[P], spf[P];$/;"	v	namespace:PollardRho	typeref:typename:int[]
primes	code/Number Theory/Pisano Period.cpp	/^  int primes[P], spf[P];$/;"	v	namespace:PollardRho	typeref:typename:int[]
primes	code/Number Theory/Pollard Rho.cpp	/^  int primes[P], spf[P];$/;"	v	namespace:PollardRho	typeref:typename:int[]
primes	code/Number Theory/Prime Counting Function.cpp	/^  int primes[MAX_PRIMES];$/;"	v	namespace:pcf	typeref:typename:int[]
primes	code/Number Theory/Prime Number System.cpp	/^vector<int> primes;$/;"	v	typeref:typename:vector<int>
primes	code/Number Theory/Sieve.cpp	/^vector<int> primes;$/;"	v	typeref:typename:vector<int>
primes	code/Number Theory/Smallest Number Having Exactly K Divisors.cpp	/^vector<int> primes;$/;"	v	typeref:typename:vector<int>
primes	code/Number Theory/nCr Modulo Any Mod.cpp	/^vector<int> primes;$/;"	v	typeref:typename:vector<int>
primitive_root	code-library/Number Theory/Discrete Root.cpp	/^int primitive_root(int p) {$/;"	f	typeref:typename:int
primitive_root	code-library/Number Theory/Primitive Root.cpp	/^int primitive_root(int p) {$/;"	f	typeref:typename:int
primitive_root	code/Number Theory/Discrete Root.cpp	/^int primitive_root(int p) {$/;"	f	typeref:typename:int
primitive_root	code/Number Theory/Primitive Root.cpp	/^int primitive_root(int p) {$/;"	f	typeref:typename:int
print	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  void print(node *t) {$/;"	f	struct:treap	typeref:typename:void	file:
print	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^  void print(int cur, int b, int e) {$/;"	f	struct:PST	typeref:typename:void	file:
print	code-library/Data Structures/Treap persistent.cpp	/^void print(node* t, int L, int R) {$/;"	f	namespace:PersistentTreap	typeref:typename:void
print	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    void print() {$/;"	f	struct:HalfPlaneSet	typeref:typename:void	file:
print	code-library/Math/Determinant of Sparse Matrix.cpp	/^  void print() {$/;"	f	struct:Mat	typeref:typename:void	file:
print	code-library/Number Theory/Prime Number System.cpp	/^  void print() {$/;"	f	struct:base	typeref:typename:void	file:
print	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  void print() const {$/;"	f	class:poly	typeref:typename:void	file:
print	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  void print(node *t) {$/;"	f	struct:treap	typeref:typename:void	file:
print	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^  void print(int cur, int b, int e) {$/;"	f	struct:PST	typeref:typename:void	file:
print	code/Data Structures/Treap persistent.cpp	/^void print(node* t, int L, int R) {$/;"	f	namespace:PersistentTreap	typeref:typename:void
print	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    void print() {$/;"	f	struct:HalfPlaneSet	typeref:typename:void	file:
print	code/Math/Determinant of Sparse Matrix.cpp	/^  void print() {$/;"	f	struct:Mat	typeref:typename:void	file:
print	code/Number Theory/Prime Number System.cpp	/^  void print() {$/;"	f	struct:base	typeref:typename:void	file:
print	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  void print() const {$/;"	f	class:poly	typeref:typename:void	file:
print_adj	practice/cf/random/1700/4.cpp	/^void print_adj() {$/;"	f	typeref:typename:void
print_array	code-library/Data Structures/Implicit Treap.cpp	/^  void print_array() {$/;"	f	struct:treap	typeref:typename:void	file:
print_array	code/Data Structures/Implicit Treap.cpp	/^  void print_array() {$/;"	f	struct:treap	typeref:typename:void	file:
print_nodes	code-library/Data Structures/Treap persistent.cpp	/^void print_nodes(node* t) {$/;"	f	namespace:PersistentTreap	typeref:typename:void
print_nodes	code/Data Structures/Treap persistent.cpp	/^void print_nodes(node* t) {$/;"	f	namespace:PersistentTreap	typeref:typename:void
prior	code-library/Data Structures/Implicit Treap.cpp	/^    int val, sz, prior, lazy, sum, mx, mn, repl;$/;"	m	struct:treap::node	typeref:typename:int	file:
prior	code-library/Data Structures/Treap persistent.cpp	/^  int val, prior, sz;$/;"	m	struct:node	typeref:typename:int	file:
prior	code-library/Data Structures/Treap.cpp	/^  int key, prior;$/;"	m	struct:node	typeref:typename:int	file:
prior	code/Data Structures/Implicit Treap.cpp	/^    int val, sz, prior, lazy, sum, mx, mn, repl;$/;"	m	struct:treap::node	typeref:typename:int	file:
prior	code/Data Structures/Treap persistent.cpp	/^  int val, prior, sz;$/;"	m	struct:node	typeref:typename:int	file:
prior	code/Data Structures/Treap.cpp	/^  int key, prior;$/;"	m	struct:node	typeref:typename:int	file:
priority	code-library/Miscellaneous/Expression Parsing.cpp	/^int priority (char op) {$/;"	f	typeref:typename:int
priority	code/Miscellaneous/Expression Parsing.cpp	/^int priority (char op) {$/;"	f	typeref:typename:int
process_op	code-library/Miscellaneous/Expression Parsing.cpp	/^void process_op(stack<int>& st, char op) {$/;"	f	typeref:typename:void
process_op	code/Miscellaneous/Expression Parsing.cpp	/^void process_op(stack<int>& st, char op) {$/;"	f	typeref:typename:void
proj	code-library/Geometry/Geometry 3D.cpp	/^    p3 proj(p3 p) { return o + d * (d|(p - o)) \/ sq(d); }$/;"	f	struct:line3d	typeref:typename:p3	file:
proj	code-library/Geometry/Geometry 3D.cpp	/^    p3 proj(p3 p) { return p - n * side(p) \/ sq(n); }$/;"	f	struct:plane	typeref:typename:p3	file:
proj	code/Geometry/Geometry 3D.cpp	/^    p3 proj(p3 p) { return o + d * (d|(p - o)) \/ sq(d); }$/;"	f	struct:line3d	typeref:typename:p3	file:
proj	code/Geometry/Geometry 3D.cpp	/^    p3 proj(p3 p) { return p - n * side(p) \/ sq(n); }$/;"	f	struct:plane	typeref:typename:p3	file:
project_from_point_to_line	code-library/Geometry/Geometry 2D.cpp	/^PT project_from_point_to_line(PT a, PT b, PT c) {$/;"	f	typeref:typename:PT
project_from_point_to_line	code-library/Geometry/Voronoi Diagram.cpp	/^PT project_from_point_to_line(PT a, PT b, PT c) {$/;"	f	typeref:typename:PT
project_from_point_to_line	code/Geometry/Geometry 2D.cpp	/^PT project_from_point_to_line(PT a, PT b, PT c) {$/;"	f	typeref:typename:PT
project_from_point_to_line	code/Geometry/Voronoi Diagram.cpp	/^PT project_from_point_to_line(PT a, PT b, PT c) {$/;"	f	typeref:typename:PT
project_from_point_to_seg	code-library/Geometry/Geometry 2D.cpp	/^PT project_from_point_to_seg(PT a, PT b, PT c) {$/;"	f	typeref:typename:PT
project_from_point_to_seg	code-library/Geometry/Voronoi Diagram.cpp	/^PT project_from_point_to_seg(PT a, PT b, PT c) {$/;"	f	typeref:typename:PT
project_from_point_to_seg	code/Geometry/Geometry 2D.cpp	/^PT project_from_point_to_seg(PT a, PT b, PT c) {$/;"	f	typeref:typename:PT
project_from_point_to_seg	code/Geometry/Voronoi Diagram.cpp	/^PT project_from_point_to_seg(PT a, PT b, PT c) {$/;"	f	typeref:typename:PT
proper_intersection	code-library/Geometry/Geometry 3D.cpp	/^bool proper_intersection(p3 a, p3 b, p3 c, p3 d, p3 &out) {$/;"	f	typeref:typename:bool
proper_intersection	code/Geometry/Geometry 3D.cpp	/^bool proper_intersection(p3 a, p3 b, p3 c, p3 d, p3 &out) {$/;"	f	typeref:typename:bool
prufer_code	code-library/Graph Theory/Prufer Code.cpp	/^vector<int> prufer_code() {$/;"	f	typeref:typename:vector<int>
prufer_code	code/Graph Theory/Prufer Code.cpp	/^vector<int> prufer_code() {$/;"	f	typeref:typename:vector<int>
prufer_to_tree	code-library/Graph Theory/Prufer Code.cpp	/^vector < pair<int, int> > prufer_to_tree(const vector<int> & prufer_code) {$/;"	f	typeref:typename:vector<pair<int,int>>
prufer_to_tree	code/Graph Theory/Prufer Code.cpp	/^vector < pair<int, int> > prufer_to_tree(const vector<int> & prufer_code) {$/;"	f	typeref:typename:vector<pair<int,int>>
ps	code-library/Geometry/Onion Decomposition.cpp	/^    vector<PT> ps;$/;"	m	struct:LeftHull	typeref:typename:vector<PT>	file:
ps	code/Geometry/Onion Decomposition.cpp	/^    vector<PT> ps;$/;"	m	struct:LeftHull	typeref:typename:vector<PT>	file:
psum	contests/Codeforces/1622/C/sol.cpp	/^vector<int> psum;$/;"	v	typeref:typename:vector<int>
psz	code-library/Data Structures/Static to Dynamic Trick.cpp	/^  int cnt[N], link[N], psz;$/;"	m	struct:aho_corasick_static	typeref:typename:int	file:
psz	code-library/Strings/Aho Corasick Dynamic.cpp	/^  int cnt[N], link[N], psz;$/;"	m	struct:aho_corasick_static	typeref:typename:int	file:
psz	code/Data Structures/Static to Dynamic Trick.cpp	/^  int cnt[N], link[N], psz;$/;"	m	struct:aho_corasick_static	typeref:typename:int	file:
psz	code/Strings/Aho Corasick Dynamic.cpp	/^  int cnt[N], link[N], psz;$/;"	m	struct:aho_corasick_static	typeref:typename:int	file:
pt	code-library/Data Structures/Permutation Tree.cpp	/^vector<int> pt[N * 2]; \/\/directed permutation tree$/;"	v	typeref:typename:vector<int>[]
pt	code-library/Miscellaneous/BigInt.cpp	/^typedef complex<ld> pt;$/;"	t	typeref:typename:complex<ld>	file:
pt	code/Data Structures/Permutation Tree.cpp	/^vector<int> pt[N * 2]; \/\/directed permutation tree$/;"	v	typeref:typename:vector<int>[]
pt	code/Miscellaneous/BigInt.cpp	/^typedef complex<ld> pt;$/;"	t	typeref:typename:complex<ld>	file:
pt_type	code-library/Geometry/Point Location.cpp	/^    using pt_type = decltype(PT::x);$/;"	t	function:sweepline	file:
pt_type	code/Geometry/Point Location.cpp	/^    using pt_type = decltype(PT::x);$/;"	t	function:sweepline	file:
ptr	code-library/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^  int ptr = 0;$/;"	m	struct:CHT	typeref:typename:int	file:
ptr	code/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^  int ptr = 0;$/;"	m	struct:CHT	typeref:typename:int	file:
pts	code-library/Data Structures/KD Tree.cpp	/^point arr[N], pts[N];$/;"	v	typeref:typename:point[]
pts	code-library/Geometry/Onion Decomposition.cpp	/^vector<PT> pts;$/;"	v	typeref:typename:vector<PT>
pts	code/Data Structures/KD Tree.cpp	/^point arr[N], pts[N];$/;"	v	typeref:typename:point[]
pts	code/Geometry/Onion Decomposition.cpp	/^vector<PT> pts;$/;"	v	typeref:typename:vector<PT>
pu	practice/cpbook/ch1/1.6/card/10388/main2.cpp	/^int pu[2], pd[2], len[2];$/;"	v	typeref:typename:int[2]
pull	code-library/Data Structures/Dynamic Diameter Online.cpp	/^    inline void pull(int n) {$/;"	f	struct:ST	typeref:typename:void	file:
pull	code-library/Data Structures/HLD.cpp	/^  inline void pull(int n) {$/;"	f	struct:ST	typeref:typename:void	file:
pull	code-library/Data Structures/Link Cut Tree.cpp	/^  void pull(int x) {$/;"	f	struct:LCT	typeref:typename:void	file:
pull	code-library/Data Structures/Permutation Tree.cpp	/^  inline void pull(int n) {$/;"	f	struct:ST	typeref:typename:void	file:
pull	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  void pull() {$/;"	f	struct:node	typeref:typename:void	file:
pull	code-library/Data Structures/Segment Tree Lazy.cpp	/^  inline void pull(int n) {$/;"	f	struct:ST	typeref:typename:void	file:
pull	code-library/Geometry/Onion Decomposition.cpp	/^    void pull(int w) {$/;"	f	struct:LeftHull	typeref:typename:void	file:
pull	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  inline void pull(int n) {$/;"	f	struct:ST	typeref:typename:void	file:
pull	code/Data Structures/Dynamic Diameter Online.cpp	/^    inline void pull(int n) {$/;"	f	struct:ST	typeref:typename:void	file:
pull	code/Data Structures/HLD.cpp	/^  inline void pull(int n) {$/;"	f	struct:ST	typeref:typename:void	file:
pull	code/Data Structures/Link Cut Tree.cpp	/^  void pull(int x) {$/;"	f	struct:LCT	typeref:typename:void	file:
pull	code/Data Structures/Permutation Tree.cpp	/^  inline void pull(int n) {$/;"	f	struct:ST	typeref:typename:void	file:
pull	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  void pull() {$/;"	f	struct:node	typeref:typename:void	file:
pull	code/Data Structures/Segment Tree Lazy.cpp	/^  inline void pull(int n) {$/;"	f	struct:ST	typeref:typename:void	file:
pull	code/Geometry/Onion Decomposition.cpp	/^    void pull(int w) {$/;"	f	struct:LeftHull	typeref:typename:void	file:
pull	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  inline void pull(int n) {$/;"	f	struct:ST	typeref:typename:void	file:
pure_stack	code-library/Graph Theory/3 SAT.cpp	/^  vector<int> unit_stack, pure_stack;$/;"	m	struct:SAT_GOD	typeref:typename:vector<int>	file:
pure_stack	code/Graph Theory/3 SAT.cpp	/^  vector<int> unit_stack, pure_stack;$/;"	m	struct:SAT_GOD	typeref:typename:vector<int>	file:
push	code-library/Data Structures/DSU with Rollbacks.cpp	/^  void push(update u) {$/;"	f	struct:DSUQueue	typeref:typename:void	file:
push	code-library/Data Structures/Dynamic Diameter Online.cpp	/^    inline void push(int n, int b, int e) {$/;"	f	struct:ST	typeref:typename:void	file:
push	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline int push(int pre, int b, int e, mint af = 0, mint as = 0) {$/;"	f	struct:PST	typeref:typename:int	file:
push	code-library/Data Structures/HLD.cpp	/^  inline void push(int n, int b, int e) {$/;"	f	struct:ST	typeref:typename:void	file:
push	code-library/Data Structures/Link Cut Tree.cpp	/^  void push(int x) { $/;"	f	struct:LCT	typeref:typename:void	file:
push	code-library/Data Structures/Monotonous Queue.cpp	/^  void push(int val) {$/;"	f	struct:monotonous_queue	typeref:typename:void	file:
push	code-library/Data Structures/Permutation Tree.cpp	/^  inline void push(int n, int b, int e) {$/;"	f	struct:ST	typeref:typename:void	file:
push	code-library/Data Structures/Persistent Array.cpp	/^  void push(int r, T x) { \/\/ push x at the end of the rth queue$/;"	f	struct:PersistentQueue	typeref:typename:void	file:
push	code-library/Data Structures/Persistent Queue.cpp	/^  void push(int r, T x) { \/\/ push x at the end of the rth queue$/;"	f	struct:PersistentQueue	typeref:typename:void	file:
push	code-library/Data Structures/Queue Undo Trick.cpp	/^  void push(update u) {$/;"	f	struct:DSUQueue	typeref:typename:void	file:
push	code-library/Data Structures/Reachability Tree.cpp	/^inline void push(int n, int l, int r) {$/;"	f	typeref:typename:void
push	code-library/Data Structures/Segment Tree Beats.cpp	/^  void push(int k) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
push	code-library/Data Structures/Segment Tree Lazy.cpp	/^  inline void push(int n, int b, int e) {$/;"	f	struct:ST	typeref:typename:void	file:
push	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^  int push(int pre, int b, int e, int x = 0) {$/;"	f	struct:PST	typeref:typename:int	file:
push	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  void push(int n, int b, int e) {$/;"	f	struct:ST	typeref:typename:void	file:
push	code-library/Data Structures/Venice Technique.cpp	/^  void push(T x) { x.w -= sum; Q.push(x); }$/;"	f	struct:PQ	typeref:typename:void	file:
push	code-library/Graph Theory/3 SAT.cpp	/^  void push(int u) {$/;"	f	struct:SAT_GOD	typeref:typename:void	file:
push	code-library/Graph Theory/Directed MST.cpp	/^  void push(T x) { x.w -= sum; Q.push(x); }$/;"	f	struct:PQ	typeref:typename:void	file:
push	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  void push(Edge &e, flow_t amt) {$/;"	f	struct:mcSFlow	typeref:typename:void	file:
push	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  inline void push(int n, int b, int e) {$/;"	f	struct:ST	typeref:typename:void	file:
push	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  void push(int x) {$/;"	f	namespace:lct	typeref:typename:void
push	code/Data Structures/DSU with Rollbacks.cpp	/^  void push(update u) {$/;"	f	struct:DSUQueue	typeref:typename:void	file:
push	code/Data Structures/Dynamic Diameter Online.cpp	/^    inline void push(int n, int b, int e) {$/;"	f	struct:ST	typeref:typename:void	file:
push	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    inline int push(int pre, int b, int e, mint af = 0, mint as = 0) {$/;"	f	struct:PST	typeref:typename:int	file:
push	code/Data Structures/HLD.cpp	/^  inline void push(int n, int b, int e) {$/;"	f	struct:ST	typeref:typename:void	file:
push	code/Data Structures/Link Cut Tree.cpp	/^  void push(int x) { $/;"	f	struct:LCT	typeref:typename:void	file:
push	code/Data Structures/Monotonous Queue.cpp	/^  void push(int val) {$/;"	f	struct:monotonous_queue	typeref:typename:void	file:
push	code/Data Structures/Permutation Tree.cpp	/^  inline void push(int n, int b, int e) {$/;"	f	struct:ST	typeref:typename:void	file:
push	code/Data Structures/Persistent Array.cpp	/^  void push(int r, T x) { \/\/ push x at the end of the rth queue$/;"	f	struct:PersistentQueue	typeref:typename:void	file:
push	code/Data Structures/Persistent Queue.cpp	/^  void push(int r, T x) { \/\/ push x at the end of the rth queue$/;"	f	struct:PersistentQueue	typeref:typename:void	file:
push	code/Data Structures/Queue Undo Trick.cpp	/^  void push(update u) {$/;"	f	struct:DSUQueue	typeref:typename:void	file:
push	code/Data Structures/Reachability Tree.cpp	/^inline void push(int n, int l, int r) {$/;"	f	typeref:typename:void
push	code/Data Structures/Segment Tree Beats.cpp	/^  void push(int k) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
push	code/Data Structures/Segment Tree Lazy.cpp	/^  inline void push(int n, int b, int e) {$/;"	f	struct:ST	typeref:typename:void	file:
push	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^  int push(int pre, int b, int e, int x = 0) {$/;"	f	struct:PST	typeref:typename:int	file:
push	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  void push(int n, int b, int e) {$/;"	f	struct:ST	typeref:typename:void	file:
push	code/Data Structures/Venice Technique.cpp	/^  void push(T x) { x.w -= sum; Q.push(x); }$/;"	f	struct:PQ	typeref:typename:void	file:
push	code/Graph Theory/3 SAT.cpp	/^  void push(int u) {$/;"	f	struct:SAT_GOD	typeref:typename:void	file:
push	code/Graph Theory/Directed MST.cpp	/^  void push(T x) { x.w -= sum; Q.push(x); }$/;"	f	struct:PQ	typeref:typename:void	file:
push	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  void push(Edge &e, flow_t amt) {$/;"	f	struct:mcSFlow	typeref:typename:void	file:
push	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  inline void push(int n, int b, int e) {$/;"	f	struct:ST	typeref:typename:void	file:
push	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  void push(int x) {$/;"	f	namespace:lct	typeref:typename:void
push_back	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  void push_back(R c) { coefs.push_back(c); }$/;"	f	class:poly	typeref:typename:void	file:
push_back	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  void push_back(R c) { coefs.push_back(c); }$/;"	f	class:poly	typeref:typename:void	file:
push_links	code-library/Data Structures/Static to Dynamic Trick.cpp	/^  void push_links() {$/;"	f	struct:aho_corasick_static	typeref:typename:void	file:
push_links	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  void push_links() {$/;"	f	struct:AhoCorasick	typeref:typename:void	file:
push_links	code-library/Strings/Aho Corasick Dynamic.cpp	/^  void push_links() {$/;"	f	struct:aho_corasick_static	typeref:typename:void	file:
push_links	code/Data Structures/Static to Dynamic Trick.cpp	/^  void push_links() {$/;"	f	struct:aho_corasick_static	typeref:typename:void	file:
push_links	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  void push_links() {$/;"	f	struct:AhoCorasick	typeref:typename:void	file:
push_links	code/Strings/Aho Corasick Dynamic.cpp	/^  void push_links() {$/;"	f	struct:aho_corasick_static	typeref:typename:void	file:
pw	code-library/Dynamic Programming Optimizations/Digit DP.cpp	/^int pw[20][20], b[1 << 10][3000], cnt[1 << 10], dp[2][20][1 << 10][2520];$/;"	v	typeref:typename:int[20][20]
pw	code-library/Graph Theory/Tree Isomorphism.cpp	/^mint pw[N];$/;"	v	typeref:typename:mint[]
pw	code-library/Number Theory/K Divisors.cpp	/^ll pw[C][L]; int s[M]; $/;"	v	typeref:typename:ll[][]
pw	code-library/Strings/String Hashing.cpp	/^pair<int, int> pw[N], ipw[N];$/;"	v	typeref:typename:pair<int,int>[]
pw	code/Dynamic Programming Optimizations/Digit DP.cpp	/^int pw[20][20], b[1 << 10][3000], cnt[1 << 10], dp[2][20][1 << 10][2520];$/;"	v	typeref:typename:int[20][20]
pw	code/Graph Theory/Tree Isomorphism.cpp	/^mint pw[N];$/;"	v	typeref:typename:mint[]
pw	code/Number Theory/K Divisors.cpp	/^ll pw[C][L]; int s[M]; $/;"	v	typeref:typename:ll[][]
pw	code/Strings/String Hashing.cpp	/^pair<int, int> pw[N], ipw[N];$/;"	v	typeref:typename:pair<int,int>[]
q	code-library/Data Structures/MOs with DSU.cpp	/^query q[N];$/;"	v	typeref:typename:query[]
q	code-library/Data Structures/Segment Tree Merging.cpp	/^int n, q, a[N];$/;"	v	typeref:typename:int
q	code-library/Geometry/All Pair Segment Intersection.cpp	/^    PT p, q;$/;"	m	struct:seg	typeref:typename:PT	file:
q	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  deque<int> q;$/;"	m	struct:Blossom	typeref:typename:deque<int>	file:
q	code-library/Graph Theory/Dynamic MST.cpp	/^int n, m, q;$/;"	v	typeref:typename:int
q	code-library/Graph Theory/Hungarian Algorithm.cpp	/^  queue<int> q;$/;"	m	struct:Hungarian	typeref:typename:queue<int>	file:
q	code-library/Miscellaneous/Fraction Binary Search.cpp	/^struct frac { long long p, q; };$/;"	m	struct:frac	typeref:typename:long long	file:
q	code/Data Structures/MOs with DSU.cpp	/^query q[N];$/;"	v	typeref:typename:query[]
q	code/Data Structures/Segment Tree Merging.cpp	/^int n, q, a[N];$/;"	v	typeref:typename:int
q	code/Geometry/All Pair Segment Intersection.cpp	/^    PT p, q;$/;"	m	struct:seg	typeref:typename:PT	file:
q	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  deque<int> q;$/;"	m	struct:Blossom	typeref:typename:deque<int>	file:
q	code/Graph Theory/Dynamic MST.cpp	/^int n, m, q;$/;"	v	typeref:typename:int
q	code/Graph Theory/Hungarian Algorithm.cpp	/^  queue<int> q;$/;"	m	struct:Hungarian	typeref:typename:queue<int>	file:
q	code/Miscellaneous/Fraction Binary Search.cpp	/^struct frac { long long p, q; };$/;"	m	struct:frac	typeref:typename:long long	file:
q	contests/LIT2021/C.cpp	/^queue<pair<P, P>> q; $/;"	v	typeref:typename:queue<pair<P,P>>
q	practice/cf/random/1700/1476D.cpp	/^queue<pair<int, int>> q;$/;"	v	typeref:typename:queue<pair<int,int>>
q	practice/usacoguide/gold/bfs/monsters.cpp	/^queue<pair<int, int>> q;$/;"	v	typeref:typename:queue<pair<int,int>>
q_push	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  inline void q_push(int x) {$/;"	f	struct:Blossom	typeref:typename:void	file:
q_push	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  inline void q_push(int x) {$/;"	f	struct:Blossom	typeref:typename:void	file:
qr	code-library/Graph Theory/Dynamic MST.cpp	/^pair<int, int> qr[MAXN];$/;"	v	typeref:typename:pair<int,int>[]
qr	code/Graph Theory/Dynamic MST.cpp	/^pair<int, int> qr[MAXN];$/;"	v	typeref:typename:pair<int,int>[]
quad	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    int quad() const {$/;"	f	struct:Angle	typeref:typename:int	file:
quad	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    int quad() const {$/;"	f	struct:Angle	typeref:typename:int	file:
queen	practice/cpbook/ch1/1.6/chess/00225/main.cpp	/^int king, queen, mov;$/;"	v	typeref:typename:int
queen	practice/cpbook/ch1/1.6/chess/10284/main.cpp	/^void queen(int row, int col, bool black) {$/;"	f	typeref:typename:void
queen_pos	practice/cpbook/ch1/1.6/chess/00225/main.cpp	/^pair<int, int> queen_pos, king_pos, mov_pos;$/;"	v	typeref:typename:pair<int,int>
queen_vis	practice/cpbook/ch1/1.6/chess/00225/main.cpp	/^bool queen_vis[8][8], king_vis[8][8], queen_vis1[8][8];$/;"	v	typeref:typename:bool[8][8]
queen_vis1	practice/cpbook/ch1/1.6/chess/00225/main.cpp	/^bool queen_vis[8][8], king_vis[8][8], queen_vis1[8][8];$/;"	v	typeref:typename:bool[8][8]
query	code-library/Data Structures/BIT 2D with Range Update and Range Query.cpp	/^  long long query(int x1, int y1, int x2, int y2) {$/;"	f	struct:BIT2D	typeref:typename:long long	file:
query	code-library/Data Structures/BIT with Range Update and Range Query.cpp	/^  long long query(int i) {$/;"	f	struct:BIT	typeref:typename:long long	file:
query	code-library/Data Structures/BIT with Range Update and Range Query.cpp	/^  long long query(int l, int r) {$/;"	f	struct:BIT	typeref:typename:long long	file:
query	code-library/Data Structures/BIT.cpp	/^  T query(int i) {$/;"	f	struct:BIT	typeref:typename:T	file:
query	code-library/Data Structures/BIT.cpp	/^  T query(int l, int r) {$/;"	f	struct:BIT	typeref:typename:T	file:
query	code-library/Data Structures/Binarizing a Tree.cpp	/^long long query(int cur, int u) { \/\/query on cur tree$/;"	f	typeref:typename:long long
query	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^long long query(int cur, int u) { \/\/query on cur tree$/;"	f	typeref:typename:long long
query	code-library/Data Structures/Disjoint Sparse Table.cpp	/^  int query(int l, int r) {$/;"	f	struct:DST	typeref:typename:int	file:
query	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^void query(int n, int b, int e) {$/;"	f	typeref:typename:void
query	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    mint query(int cur, int b, int e, int i, int j) {$/;"	f	struct:PST	typeref:typename:mint	file:
query	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^vector<array<int, 3>> query(int u, int v) {$/;"	f	typeref:typename:vector<array<int,3>>
query	code-library/Data Structures/HLD.cpp	/^  int query(int n, int b, int e, int i, int j) {$/;"	f	struct:ST	typeref:typename:int	file:
query	code-library/Data Structures/HLD.cpp	/^int query(int u, int v) {$/;"	f	typeref:typename:int
query	code-library/Data Structures/Implicit Treap.cpp	/^  int query(int qL, int qR) {$/;"	f	struct:treap	typeref:typename:int	file:
query	code-library/Data Structures/Link Cut Tree.cpp	/^  long long query(int u, int v) {$/;"	f	struct:LCT	typeref:typename:long long	file:
query	code-library/Data Structures/MOs Algorithm.cpp	/^struct query {$/;"	s	file:
query	code-library/Data Structures/MOs Online.cpp	/^int query(int l, int r) {$/;"	f	typeref:typename:int
query	code-library/Data Structures/MOs on tree.cpp	/^struct query {$/;"	s	file:
query	code-library/Data Structures/MOs with DSU.cpp	/^  query() {$/;"	f	struct:query	file:
query	code-library/Data Structures/MOs with DSU.cpp	/^  query(int _l, int _r, int _idx) {$/;"	f	struct:query	file:
query	code-library/Data Structures/MOs with DSU.cpp	/^struct query {$/;"	s	file:
query	code-library/Data Structures/MOs with Update.cpp	/^struct query {$/;"	s	file:
query	code-library/Data Structures/Permutation Tree.cpp	/^  int query(int n, int b, int e, int i, int j) {$/;"	f	struct:ST	typeref:typename:int	file:
query	code-library/Data Structures/Persistent Trie.cpp	/^int query(pnode v, int x, int l) {$/;"	f	typeref:typename:int
query	code-library/Data Structures/Reachability Tree.cpp	/^inline pair<int, int> query(int n, int l, int r, int ql, int qr) {$/;"	f	typeref:typename:pair<int,int>
query	code-library/Data Structures/SQRT Tree.cpp	/^  inline SqrtTreeItem query(int l, int r) {$/;"	f	struct:SqrtTree	typeref:typename:SqrtTreeItem	file:
query	code-library/Data Structures/SQRT Tree.cpp	/^  inline SqrtTreeItem query(int l, int r, int betweenOffs, int base) {$/;"	f	struct:SqrtTree	typeref:typename:SqrtTreeItem	file:
query	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  long long query(int i, int j, int st, int en) { \/\/gcd of a[x][y] such that i <= x <= j && st/;"	f	struct:ST	typeref:typename:long long	file:
query	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  long long query(int l, int r) { \/\/gcd of a_i such that l <= i <= r$/;"	f	struct:treap	typeref:typename:long long	file:
query	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  long long query(node *t, int st, int en) {$/;"	f	struct:treap	typeref:typename:long long	file:
query	code-library/Data Structures/Segment Tree Lazy.cpp	/^  long long query(int n, int b, int e, int i, int j) {$/;"	f	struct:ST	typeref:typename:long long	file:
query	code-library/Data Structures/Segment Tree Merging.cpp	/^  int query(int cur, int b, int e, int k) {$/;"	f	struct:STM	typeref:typename:int	file:
query	code-library/Data Structures/Segment Tree Merging.cpp	/^int query(int l, int k) {$/;"	f	typeref:typename:int
query	code-library/Data Structures/Segment Tree NonRecursive.cpp	/^  int query(int l, int r) {$/;"	f	struct:ST	typeref:typename:int	file:
query	code-library/Data Structures/Segment Tree Persistent.cpp	/^  int query(int pre, int cur, int b, int e, int k) {$/;"	f	struct:PST	typeref:typename:int	file:
query	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  mint query(int n, int b, int e, int i, int j) {$/;"	f	struct:ST	typeref:typename:mint	file:
query	code-library/Data Structures/Segment Tree.cpp	/^  int query(int n, int b, int e, int i, int j) {$/;"	f	struct:ST	typeref:typename:int	file:
query	code-library/Data Structures/Sparse Table.cpp	/^int query(int l, int r) {$/;"	f	typeref:typename:int
query	code-library/Data Structures/Trie.cpp	/^  int query(int x, int k) { \/\/ number of values s.t. val ^ x < k$/;"	f	struct:Trie	typeref:typename:int	file:
query	code-library/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^  ll query(ll x) {$/;"	f	struct:CHT	typeref:typename:ll	file:
query	code-library/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^  ll query(ll x) {$/;"	f	struct:CHT	typeref:typename:ll	file:
query	code-library/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  ll query(ll x) {$/;"	f	struct:LiChaoTree	typeref:typename:ll	file:
query	code-library/Dynamic Programming Optimizations/Persistent CHT.cpp	/^  ll query(PT a, int rt) {$/;"	f	struct:PersistentCHT	typeref:typename:ll	file:
query	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  ll query(int i, int x) {$/;"	f	struct:PersistentLiChaoTree	typeref:typename:ll	file:
query	code-library/Graph Theory/LCA in O(1).cpp	/^  T query(int a, int b) { \/\/ [a, b)$/;"	f	struct:RMQ	typeref:typename:T	file:
query	code-library/Graph Theory/LCA in O(1).cpp	/^  int query(int a, int b) {$/;"	f	struct:LCA	typeref:typename:int	file:
query	code-library/Graph Theory/Manhattan MST.cpp	/^int query(int x) {$/;"	f	typeref:typename:int
query	code-library/Graph Theory/Path Union.cpp	/^  int query(int n, int b, int e, pair<int, int> p) {$/;"	f	struct:segtree	typeref:typename:int	file:
query	code-library/Math/Basis Vector ft Weighted Linearly Independent Vectors.cpp	/^  long long query() {$/;"	f	struct:Basis	typeref:typename:long long	file:
query	code-library/Miscellaneous/Parallel Binary Search.cpp	/^  T query(int idx) {$/;"	f	struct:BIT	typeref:typename:T	file:
query	code-library/Miscellaneous/Parallel Binary Search.cpp	/^  T query(int l, int r) {$/;"	f	struct:BIT	typeref:typename:T	file:
query	code-library/Number Theory/Mobius Function.cpp	/^int query(int x) {$/;"	f	typeref:typename:int
query	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^struct query {$/;"	s	file:
query	code-library/Strings/Suffix Array Isomorphic.cpp	/^  int query(int l, int r) { \/\/ minimum of lcp[l], ..., lcp[r]$/;"	f	struct:IsomorphicSuffixArray	typeref:typename:int	file:
query	code-library/Strings/Suffix Array Isomorphic.cpp	/^  int query(int l, int r) { \/\/ minimum of lcp[l], ..., lcp[r]$/;"	f	struct:SuffixArray	typeref:typename:int	file:
query	code-library/Strings/Suffix Array.cpp	/^  int query(int l, int r) { \/\/ minimum of lcp[l], ..., lcp[r]$/;"	f	struct:SuffixArray	typeref:typename:int	file:
query	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  long long query(int n, int b, int e, int i, int j) {$/;"	f	struct:ST	typeref:typename:long long	file:
query	code/Data Structures/BIT 2D with Range Update and Range Query.cpp	/^  long long query(int x1, int y1, int x2, int y2) {$/;"	f	struct:BIT2D	typeref:typename:long long	file:
query	code/Data Structures/BIT with Range Update and Range Query.cpp	/^  long long query(int i) {$/;"	f	struct:BIT	typeref:typename:long long	file:
query	code/Data Structures/BIT with Range Update and Range Query.cpp	/^  long long query(int l, int r) {$/;"	f	struct:BIT	typeref:typename:long long	file:
query	code/Data Structures/BIT.cpp	/^  T query(int i) {$/;"	f	struct:BIT	typeref:typename:T	file:
query	code/Data Structures/BIT.cpp	/^  T query(int l, int r) {$/;"	f	struct:BIT	typeref:typename:T	file:
query	code/Data Structures/Binarizing a Tree.cpp	/^long long query(int cur, int u) { \/\/query on cur tree$/;"	f	typeref:typename:long long
query	code/Data Structures/Centroid Decomposition Persistent.cpp	/^long long query(int cur, int u) { \/\/query on cur tree$/;"	f	typeref:typename:long long
query	code/Data Structures/Disjoint Sparse Table.cpp	/^  int query(int l, int r) {$/;"	f	struct:DST	typeref:typename:int	file:
query	code/Data Structures/Dynamic Connectivity Problem.cpp	/^void query(int n, int b, int e) {$/;"	f	typeref:typename:void
query	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    mint query(int cur, int b, int e, int i, int j) {$/;"	f	struct:PST	typeref:typename:mint	file:
query	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^vector<array<int, 3>> query(int u, int v) {$/;"	f	typeref:typename:vector<array<int,3>>
query	code/Data Structures/HLD.cpp	/^  int query(int n, int b, int e, int i, int j) {$/;"	f	struct:ST	typeref:typename:int	file:
query	code/Data Structures/HLD.cpp	/^int query(int u, int v) {$/;"	f	typeref:typename:int
query	code/Data Structures/Implicit Treap.cpp	/^  int query(int qL, int qR) {$/;"	f	struct:treap	typeref:typename:int	file:
query	code/Data Structures/Link Cut Tree.cpp	/^  long long query(int u, int v) {$/;"	f	struct:LCT	typeref:typename:long long	file:
query	code/Data Structures/MOs Algorithm.cpp	/^struct query {$/;"	s	file:
query	code/Data Structures/MOs Online.cpp	/^int query(int l, int r) {$/;"	f	typeref:typename:int
query	code/Data Structures/MOs on tree.cpp	/^struct query {$/;"	s	file:
query	code/Data Structures/MOs with DSU.cpp	/^  query() {$/;"	f	struct:query	file:
query	code/Data Structures/MOs with DSU.cpp	/^  query(int _l, int _r, int _idx) {$/;"	f	struct:query	file:
query	code/Data Structures/MOs with DSU.cpp	/^struct query {$/;"	s	file:
query	code/Data Structures/MOs with Update.cpp	/^struct query {$/;"	s	file:
query	code/Data Structures/Permutation Tree.cpp	/^  int query(int n, int b, int e, int i, int j) {$/;"	f	struct:ST	typeref:typename:int	file:
query	code/Data Structures/Persistent Trie.cpp	/^int query(pnode v, int x, int l) {$/;"	f	typeref:typename:int
query	code/Data Structures/Reachability Tree.cpp	/^inline pair<int, int> query(int n, int l, int r, int ql, int qr) {$/;"	f	typeref:typename:pair<int,int>
query	code/Data Structures/SQRT Tree.cpp	/^  inline SqrtTreeItem query(int l, int r) {$/;"	f	struct:SqrtTree	typeref:typename:SqrtTreeItem	file:
query	code/Data Structures/SQRT Tree.cpp	/^  inline SqrtTreeItem query(int l, int r, int betweenOffs, int base) {$/;"	f	struct:SqrtTree	typeref:typename:SqrtTreeItem	file:
query	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  long long query(int i, int j, int st, int en) { \/\/gcd of a[x][y] such that i <= x <= j && st/;"	f	struct:ST	typeref:typename:long long	file:
query	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  long long query(int l, int r) { \/\/gcd of a_i such that l <= i <= r$/;"	f	struct:treap	typeref:typename:long long	file:
query	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  long long query(node *t, int st, int en) {$/;"	f	struct:treap	typeref:typename:long long	file:
query	code/Data Structures/Segment Tree Lazy.cpp	/^  long long query(int n, int b, int e, int i, int j) {$/;"	f	struct:ST	typeref:typename:long long	file:
query	code/Data Structures/Segment Tree Merging.cpp	/^  int query(int cur, int b, int e, int k) {$/;"	f	struct:STM	typeref:typename:int	file:
query	code/Data Structures/Segment Tree Merging.cpp	/^int query(int l, int k) {$/;"	f	typeref:typename:int
query	code/Data Structures/Segment Tree NonRecursive.cpp	/^  int query(int l, int r) {$/;"	f	struct:ST	typeref:typename:int	file:
query	code/Data Structures/Segment Tree Persistent.cpp	/^  int query(int pre, int cur, int b, int e, int k) {$/;"	f	struct:PST	typeref:typename:int	file:
query	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  mint query(int n, int b, int e, int i, int j) {$/;"	f	struct:ST	typeref:typename:mint	file:
query	code/Data Structures/Segment Tree.cpp	/^  int query(int n, int b, int e, int i, int j) {$/;"	f	struct:ST	typeref:typename:int	file:
query	code/Data Structures/Sparse Table.cpp	/^int query(int l, int r) {$/;"	f	typeref:typename:int
query	code/Data Structures/Trie.cpp	/^  int query(int x, int k) { \/\/ number of values s.t. val ^ x < k$/;"	f	struct:Trie	typeref:typename:int	file:
query	code/Dynamic Programming Optimizations/Convex Hull Trick.cpp	/^  ll query(ll x) {$/;"	f	struct:CHT	typeref:typename:ll	file:
query	code/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^  ll query(ll x) {$/;"	f	struct:CHT	typeref:typename:ll	file:
query	code/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  ll query(ll x) {$/;"	f	struct:LiChaoTree	typeref:typename:ll	file:
query	code/Dynamic Programming Optimizations/Persistent CHT.cpp	/^  ll query(PT a, int rt) {$/;"	f	struct:PersistentCHT	typeref:typename:ll	file:
query	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  ll query(int i, int x) {$/;"	f	struct:PersistentLiChaoTree	typeref:typename:ll	file:
query	code/Graph Theory/LCA in O(1).cpp	/^  T query(int a, int b) { \/\/ [a, b)$/;"	f	struct:RMQ	typeref:typename:T	file:
query	code/Graph Theory/LCA in O(1).cpp	/^  int query(int a, int b) {$/;"	f	struct:LCA	typeref:typename:int	file:
query	code/Graph Theory/Manhattan MST.cpp	/^int query(int x) {$/;"	f	typeref:typename:int
query	code/Graph Theory/Path Union.cpp	/^  int query(int n, int b, int e, pair<int, int> p) {$/;"	f	struct:segtree	typeref:typename:int	file:
query	code/Math/Basis Vector ft Weighted Linearly Independent Vectors.cpp	/^  long long query() {$/;"	f	struct:Basis	typeref:typename:long long	file:
query	code/Miscellaneous/Parallel Binary Search.cpp	/^  T query(int idx) {$/;"	f	struct:BIT	typeref:typename:T	file:
query	code/Miscellaneous/Parallel Binary Search.cpp	/^  T query(int l, int r) {$/;"	f	struct:BIT	typeref:typename:T	file:
query	code/Number Theory/Mobius Function.cpp	/^int query(int x) {$/;"	f	typeref:typename:int
query	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^struct query {$/;"	s	file:
query	code/Strings/Suffix Array Isomorphic.cpp	/^  int query(int l, int r) { \/\/ minimum of lcp[l], ..., lcp[r]$/;"	f	struct:IsomorphicSuffixArray	typeref:typename:int	file:
query	code/Strings/Suffix Array Isomorphic.cpp	/^  int query(int l, int r) { \/\/ minimum of lcp[l], ..., lcp[r]$/;"	f	struct:SuffixArray	typeref:typename:int	file:
query	code/Strings/Suffix Array.cpp	/^  int query(int l, int r) { \/\/ minimum of lcp[l], ..., lcp[r]$/;"	f	struct:SuffixArray	typeref:typename:int	file:
query	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  long long query(int n, int b, int e, int i, int j) {$/;"	f	struct:ST	typeref:typename:long long	file:
query1	code-library/Data Structures/BIT 2D with Range Update and Range Query.cpp	/^  long long query1(int x, int y) {$/;"	f	struct:BIT2D	typeref:typename:long long	file:
query1	code/Data Structures/BIT 2D with Range Update and Range Query.cpp	/^  long long query1(int x, int y) {$/;"	f	struct:BIT2D	typeref:typename:long long	file:
query2	code-library/Data Structures/BIT 2D with Range Update and Range Query.cpp	/^  long long query2(long long t[N][N][2], int x, int y) {$/;"	f	struct:BIT2D	typeref:typename:long long	file:
query2	code/Data Structures/BIT 2D with Range Update and Range Query.cpp	/^  long long query2(long long t[N][N][2], int x, int y) {$/;"	f	struct:BIT2D	typeref:typename:long long	file:
query_max	code-library/Data Structures/Segment Tree Beats.cpp	/^  ll query_max(int a, int b) {$/;"	f	struct:SGTBeats	typeref:typename:ll	file:
query_max	code/Data Structures/Segment Tree Beats.cpp	/^  ll query_max(int a, int b) {$/;"	f	struct:SGTBeats	typeref:typename:ll	file:
query_min	code-library/Data Structures/Segment Tree Beats.cpp	/^  ll query_min(int a, int b) {$/;"	f	struct:SGTBeats	typeref:typename:ll	file:
query_min	code/Data Structures/Segment Tree Beats.cpp	/^  ll query_min(int a, int b) {$/;"	f	struct:SGTBeats	typeref:typename:ll	file:
query_segment	code-library/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  ll query_segment(ll x, int l, int r) {$/;"	f	struct:LiChaoTree	typeref:typename:ll	file:
query_segment	code-library/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  ll query_segment(ll x, int l, int r, int L, int R) {$/;"	f	struct:node	typeref:typename:ll	file:
query_segment	code/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  ll query_segment(ll x, int l, int r) {$/;"	f	struct:LiChaoTree	typeref:typename:ll	file:
query_segment	code/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  ll query_segment(ll x, int l, int r, int L, int R) {$/;"	f	struct:node	typeref:typename:ll	file:
query_sum	code-library/Data Structures/Segment Tree Beats.cpp	/^  ll query_sum(int a, int b) {$/;"	f	struct:SGTBeats	typeref:typename:ll	file:
query_sum	code/Data Structures/Segment Tree Beats.cpp	/^  ll query_sum(int a, int b) {$/;"	f	struct:SGTBeats	typeref:typename:ll	file:
query_up	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^vector<array<int, 3>> query_up(int u, int v, int ty) {$/;"	f	typeref:typename:vector<array<int,3>>
query_up	code-library/Data Structures/HLD.cpp	/^int query_up(int u, int v) {$/;"	f	typeref:typename:int
query_up	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^vector<array<int, 3>> query_up(int u, int v, int ty) {$/;"	f	typeref:typename:vector<array<int,3>>
query_up	code/Data Structures/HLD.cpp	/^int query_up(int u, int v) {$/;"	f	typeref:typename:int
r	code-library/Data Structures/BST using STL.cpp	/^map<int, int>l, r; \/\/l contains the left child of the node, r contains right child of the node$/;"	v	typeref:typename:map<int,int>
r	code-library/Data Structures/Cartesian Tree.cpp	/^int n, tot, st[N], l[N], r[N], vis[N];$/;"	v	typeref:typename:int[]
r	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^        int l = 0, r = 0; mint lf = 0, ls = 0; mint val = 0;$/;"	m	struct:PST::node	typeref:typename:int	file:
r	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^PST<2> r;$/;"	v	typeref:typename:PST<2>
r	code-library/Data Structures/Implicit Treap.cpp	/^    node *l, *r, *par;$/;"	m	struct:treap::node	typeref:typename:node *	file:
r	code-library/Data Structures/MOs Algorithm.cpp	/^  int l, r, id;$/;"	m	struct:query	typeref:typename:int	file:
r	code-library/Data Structures/MOs on tree.cpp	/^  int l, r, id;$/;"	m	struct:query	typeref:typename:int	file:
r	code-library/Data Structures/MOs with DSU.cpp	/^  int l, r, idx;$/;"	m	struct:query	typeref:typename:int	file:
r	code-library/Data Structures/MOs with Update.cpp	/^  int l, r, t, id;$/;"	m	struct:query	typeref:typename:int	file:
r	code-library/Data Structures/MOs with Update.cpp	/^int cnt[N], f[N], ans[N], l, r, t;$/;"	v	typeref:typename:int
r	code-library/Data Structures/Monotonous Queue.cpp	/^  int a[N + 10], b[N + 10], l = 0, r = -1;$/;"	m	struct:monotonous_queue	typeref:typename:int	file:
r	code-library/Data Structures/Persistent Array.cpp	/^    node* l, * r; T x;$/;"	m	struct:PersistentArray::node	typeref:typename:node *	file:
r	code-library/Data Structures/Persistent Queue.cpp	/^    node* l, * r; T x;$/;"	m	struct:PersistentArray::node	typeref:typename:node *	file:
r	code-library/Data Structures/Persistent UnionFind.cpp	/^    node* l, * r; T x;$/;"	m	struct:PersistentArray::node	typeref:typename:node *	file:
r	code-library/Data Structures/Persistent UnionFind.cpp	/^int r[N];$/;"	v	typeref:typename:int[]
r	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  ST *l, *r;$/;"	m	struct:ST	typeref:typename:ST *	file:
r	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  node *l, *r;$/;"	m	struct:node	typeref:typename:node *	file:
r	code-library/Data Structures/Segment Tree Merging.cpp	/^    int l, r, sz;$/;"	m	struct:STM::node	typeref:typename:int	file:
r	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^    int l = 0, r = 0, lazy = 0, p = 0;$/;"	m	struct:PST::node	typeref:typename:int	file:
r	code-library/Data Structures/Segment Tree Persistent.cpp	/^    int l = 0, r = 0, val = 0;$/;"	m	struct:PST::node	typeref:typename:int	file:
r	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^int ty[N], l[N], r[N], x[N];$/;"	v	typeref:typename:int[]
r	code-library/Data Structures/Top Tree.cpp	/^  bool r() const { return !p || p->is_path != is_path; }$/;"	f	struct:top_tree_node	typeref:typename:bool	file:
r	code-library/Data Structures/Treap persistent.cpp	/^  node *l, *r;$/;"	m	struct:node	typeref:typename:node *	file:
r	code-library/Data Structures/Treap.cpp	/^  node *l, *r;$/;"	m	struct:node	typeref:typename:node *	file:
r	code-library/Data Structures/Wavelet Tree.cpp	/^  wavelet_tree *l, *r;$/;"	m	struct:wavelet_tree	typeref:typename:wavelet_tree *	file:
r	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  int l, r;$/;"	m	struct:LiChaoNode	typeref:typename:int	file:
r	code-library/Geometry/Delaunay Triangulation.cpp	/^    Q r() { return rot -> rot; }$/;"	f	struct:Quad	typeref:typename:Q	file:
r	code-library/Geometry/Geometry 2D.cpp	/^    PT p; double r;$/;"	m	struct:circle	typeref:typename:double	file:
r	code-library/Geometry/Geometry 2D.cpp	/^    double x[2020], y[2020], r[2020];$/;"	m	struct:CircleUnion	typeref:typename:double[2020]	file:
r	code-library/Geometry/Point Location.cpp	/^    PT l, r;$/;"	m	struct:edge	typeref:typename:PT	file:
r	code-library/Geometry/Voronoi Diagram.cpp	/^    Q r() { return rot -> rot; }$/;"	f	struct:Quad	typeref:typename:Q	file:
r	code-library/Graph Theory/Dijkstra.cpp	/^vector<pair<int, int>> g[N], r[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
r	code-library/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^int deg[N][2], id[N][2], l, r;$/;"	v	typeref:typename:int
r	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  const int r;  \/\/ index of the reverse edge$/;"	m	struct:S	typeref:typename:const int	file:
r	code-library/Graph Theory/HopCroft Karp Algorithm.cpp	/^  vector<int> l, r, d;$/;"	m	struct:HopcroftKarp	typeref:typename:vector<int>	file:
r	code-library/Graph Theory/Hungarian Algorithm.cpp	/^  int l[N], r[N], arg[N], trace[N];$/;"	m	struct:Hungarian	typeref:typename:int[]	file:
r	code-library/Graph Theory/Kuhns Algorithm.cpp	/^  vector<int> l, r;$/;"	m	struct:Kuhn	typeref:typename:vector<int>	file:
r	code-library/Graph Theory/Kuhns Algorithm.cpp	/^vector<int> g[N], r[N], G[N], vec; \/\/G is the condensed graph$/;"	v	typeref:typename:vector<int>[]
r	code-library/Graph Theory/L R Flow with Dinic.cpp	/^    int u, v, l, r, id;$/;"	m	struct:LR_Flow::edge	typeref:typename:int	file:
r	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  vector<vector<int>> g, r, G;\/\/G is the condensed graph$/;"	m	struct:MaximumClosure	typeref:typename:vector<vector<int>>	file:
r	code-library/Graph Theory/SCC.cpp	/^vector<int> g[N], r[N], G[N], vec; \/\/G is the condensed graph$/;"	v	typeref:typename:vector<int>[]
r	code-library/Miscellaneous/Parallel Binary Search.cpp	/^int amount[N], want[N], st[N], en[N], l[N], r[N], ans[N];$/;"	v	typeref:typename:int[]
r	code-library/Number Theory/Min_25 Sieve.cpp	/^int r, id1[N], id2[N];$/;"	v	typeref:typename:int
r	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  int l, r, id;$/;"	m	struct:query	typeref:typename:int	file:
r	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  vector<int> l, r;$/;"	m	struct:Kuhn	typeref:typename:vector<int>	file:
r	code-library/Strings/Number of Palindromes in Range.cpp	/^  wavelet_tree *l, *r;$/;"	m	struct:wavelet_tree	typeref:typename:wavelet_tree *	file:
r	code-library/Strings/Suffix Array Isomorphic.cpp	/^int buc[N], r[N], suf[N], X[N], Y[N], high[N];$/;"	v	typeref:typename:int[]
r	code/Data Structures/BST using STL.cpp	/^map<int, int>l, r; \/\/l contains the left child of the node, r contains right child of the node$/;"	v	typeref:typename:map<int,int>
r	code/Data Structures/Cartesian Tree.cpp	/^int n, tot, st[N], l[N], r[N], vis[N];$/;"	v	typeref:typename:int[]
r	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^        int l = 0, r = 0; mint lf = 0, ls = 0; mint val = 0;$/;"	m	struct:PST::node	typeref:typename:int	file:
r	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^PST<2> r;$/;"	v	typeref:typename:PST<2>
r	code/Data Structures/Implicit Treap.cpp	/^    node *l, *r, *par;$/;"	m	struct:treap::node	typeref:typename:node *	file:
r	code/Data Structures/MOs Algorithm.cpp	/^  int l, r, id;$/;"	m	struct:query	typeref:typename:int	file:
r	code/Data Structures/MOs on tree.cpp	/^  int l, r, id;$/;"	m	struct:query	typeref:typename:int	file:
r	code/Data Structures/MOs with DSU.cpp	/^  int l, r, idx;$/;"	m	struct:query	typeref:typename:int	file:
r	code/Data Structures/MOs with Update.cpp	/^  int l, r, t, id;$/;"	m	struct:query	typeref:typename:int	file:
r	code/Data Structures/MOs with Update.cpp	/^int cnt[N], f[N], ans[N], l, r, t;$/;"	v	typeref:typename:int
r	code/Data Structures/Monotonous Queue.cpp	/^  int a[N + 10], b[N + 10], l = 0, r = -1;$/;"	m	struct:monotonous_queue	typeref:typename:int	file:
r	code/Data Structures/Persistent Array.cpp	/^    node* l, * r; T x;$/;"	m	struct:PersistentArray::node	typeref:typename:node *	file:
r	code/Data Structures/Persistent Queue.cpp	/^    node* l, * r; T x;$/;"	m	struct:PersistentArray::node	typeref:typename:node *	file:
r	code/Data Structures/Persistent UnionFind.cpp	/^    node* l, * r; T x;$/;"	m	struct:PersistentArray::node	typeref:typename:node *	file:
r	code/Data Structures/Persistent UnionFind.cpp	/^int r[N];$/;"	v	typeref:typename:int[]
r	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  ST *l, *r;$/;"	m	struct:ST	typeref:typename:ST *	file:
r	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  node *l, *r;$/;"	m	struct:node	typeref:typename:node *	file:
r	code/Data Structures/Segment Tree Merging.cpp	/^    int l, r, sz;$/;"	m	struct:STM::node	typeref:typename:int	file:
r	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^    int l = 0, r = 0, lazy = 0, p = 0;$/;"	m	struct:PST::node	typeref:typename:int	file:
r	code/Data Structures/Segment Tree Persistent.cpp	/^    int l = 0, r = 0, val = 0;$/;"	m	struct:PST::node	typeref:typename:int	file:
r	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^int ty[N], l[N], r[N], x[N];$/;"	v	typeref:typename:int[]
r	code/Data Structures/Top Tree.cpp	/^  bool r() const { return !p || p->is_path != is_path; }$/;"	f	struct:top_tree_node	typeref:typename:bool	file:
r	code/Data Structures/Treap persistent.cpp	/^  node *l, *r;$/;"	m	struct:node	typeref:typename:node *	file:
r	code/Data Structures/Treap.cpp	/^  node *l, *r;$/;"	m	struct:node	typeref:typename:node *	file:
r	code/Data Structures/Wavelet Tree.cpp	/^  wavelet_tree *l, *r;$/;"	m	struct:wavelet_tree	typeref:typename:wavelet_tree *	file:
r	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  int l, r;$/;"	m	struct:LiChaoNode	typeref:typename:int	file:
r	code/Geometry/Delaunay Triangulation.cpp	/^    Q r() { return rot -> rot; }$/;"	f	struct:Quad	typeref:typename:Q	file:
r	code/Geometry/Geometry 2D.cpp	/^    PT p; double r;$/;"	m	struct:circle	typeref:typename:double	file:
r	code/Geometry/Geometry 2D.cpp	/^    double x[2020], y[2020], r[2020];$/;"	m	struct:CircleUnion	typeref:typename:double[2020]	file:
r	code/Geometry/Point Location.cpp	/^    PT l, r;$/;"	m	struct:edge	typeref:typename:PT	file:
r	code/Geometry/Voronoi Diagram.cpp	/^    Q r() { return rot -> rot; }$/;"	f	struct:Quad	typeref:typename:Q	file:
r	code/Graph Theory/Dijkstra.cpp	/^vector<pair<int, int>> g[N], r[N];$/;"	v	typeref:typename:vector<pair<int,int>>[]
r	code/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^int deg[N][2], id[N][2], l, r;$/;"	v	typeref:typename:int
r	code/Graph Theory/Gomory Hu Tree.cpp	/^  const int r;  \/\/ index of the reverse edge$/;"	m	struct:S	typeref:typename:const int	file:
r	code/Graph Theory/HopCroft Karp Algorithm.cpp	/^  vector<int> l, r, d;$/;"	m	struct:HopcroftKarp	typeref:typename:vector<int>	file:
r	code/Graph Theory/Hungarian Algorithm.cpp	/^  int l[N], r[N], arg[N], trace[N];$/;"	m	struct:Hungarian	typeref:typename:int[]	file:
r	code/Graph Theory/Kuhns Algorithm.cpp	/^  vector<int> l, r;$/;"	m	struct:Kuhn	typeref:typename:vector<int>	file:
r	code/Graph Theory/Kuhns Algorithm.cpp	/^vector<int> g[N], r[N], G[N], vec; \/\/G is the condensed graph$/;"	v	typeref:typename:vector<int>[]
r	code/Graph Theory/L R Flow with Dinic.cpp	/^    int u, v, l, r, id;$/;"	m	struct:LR_Flow::edge	typeref:typename:int	file:
r	code/Graph Theory/Maximum Closure Problem.cpp	/^  vector<vector<int>> g, r, G;\/\/G is the condensed graph$/;"	m	struct:MaximumClosure	typeref:typename:vector<vector<int>>	file:
r	code/Graph Theory/SCC.cpp	/^vector<int> g[N], r[N], G[N], vec; \/\/G is the condensed graph$/;"	v	typeref:typename:vector<int>[]
r	code/Miscellaneous/Parallel Binary Search.cpp	/^int amount[N], want[N], st[N], en[N], l[N], r[N], ans[N];$/;"	v	typeref:typename:int[]
r	code/Number Theory/Min_25 Sieve.cpp	/^int r, id1[N], id2[N];$/;"	v	typeref:typename:int
r	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  int l, r, id;$/;"	m	struct:query	typeref:typename:int	file:
r	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  vector<int> l, r;$/;"	m	struct:Kuhn	typeref:typename:vector<int>	file:
r	code/Strings/Number of Palindromes in Range.cpp	/^  wavelet_tree *l, *r;$/;"	m	struct:wavelet_tree	typeref:typename:wavelet_tree *	file:
r	code/Strings/Suffix Array Isomorphic.cpp	/^int buc[N], r[N], suf[N], X[N], Y[N], high[N];$/;"	v	typeref:typename:int[]
r	practice/cf/random/1700/test1.cpp	/^int l, r;$/;"	v	typeref:typename:int
r2	code-library/Number Theory/Prime Factorization Fastest.cpp	/^  static uint64_t mod, inv, r2;$/;"	m	struct:Mint	typeref:typename:uint64_t	file:
r2	code-library/Number Theory/Prime Factorization Fastest.cpp	/^uint64_t Mint::mod, Mint::inv, Mint::r2;$/;"	m	class:Mint	typeref:typename:uint64_t
r2	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static constexpr word_t r2 = -dword_t(mod) % mod;$/;"	m	class:ntt::Mod	typeref:typename:word_t	file:
r2	code/Number Theory/Prime Factorization Fastest.cpp	/^  static uint64_t mod, inv, r2;$/;"	m	struct:Mint	typeref:typename:uint64_t	file:
r2	code/Number Theory/Prime Factorization Fastest.cpp	/^uint64_t Mint::mod, Mint::inv, Mint::r2;$/;"	m	class:Mint	typeref:typename:uint64_t
r2	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static constexpr word_t r2 = -dword_t(mod) % mod;$/;"	m	class:ntt::Mod	typeref:typename:word_t	file:
rad_to_deg	code-library/Geometry/All Pair Segment Intersection.cpp	/^double rad_to_deg(double r) {$/;"	f	typeref:typename:double
rad_to_deg	code-library/Geometry/Geometry 2D.cpp	/^double rad_to_deg(double r) { return (r * 180.0 \/ PI); }$/;"	f	typeref:typename:double
rad_to_deg	code-library/Geometry/Geometry 3D.cpp	/^double rad_to_deg(double r) { return (r * 180.0 \/ PI); }$/;"	f	typeref:typename:double
rad_to_deg	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^double rad_to_deg(double r) { return (r * 180.0 \/ PI); }$/;"	f	typeref:typename:double
rad_to_deg	code-library/Geometry/Half Plane Intersection.cpp	/^double rad_to_deg(double r) { return (r * 180.0 \/ PI); }$/;"	f	typeref:typename:double
rad_to_deg	code-library/Geometry/Voronoi Diagram.cpp	/^double rad_to_deg(double r) { return (r * 180.0 \/ PI); }$/;"	f	typeref:typename:double
rad_to_deg	code/Geometry/All Pair Segment Intersection.cpp	/^double rad_to_deg(double r) {$/;"	f	typeref:typename:double
rad_to_deg	code/Geometry/Geometry 2D.cpp	/^double rad_to_deg(double r) { return (r * 180.0 \/ PI); }$/;"	f	typeref:typename:double
rad_to_deg	code/Geometry/Geometry 3D.cpp	/^double rad_to_deg(double r) { return (r * 180.0 \/ PI); }$/;"	f	typeref:typename:double
rad_to_deg	code/Geometry/Half Plane Intersection Dynamic.cpp	/^double rad_to_deg(double r) { return (r * 180.0 \/ PI); }$/;"	f	typeref:typename:double
rad_to_deg	code/Geometry/Half Plane Intersection.cpp	/^double rad_to_deg(double r) { return (r * 180.0 \/ PI); }$/;"	f	typeref:typename:double
rad_to_deg	code/Geometry/Voronoi Diagram.cpp	/^double rad_to_deg(double r) { return (r * 180.0 \/ PI); }$/;"	f	typeref:typename:double
rand	contests/Codeforces/1560/F1/stress.cpp	/^int rand(int a, int b) {$/;"	f	typeref:typename:int
rand	contests/USACO/dec_silver_2021/A/gen.cpp	/^int rand(int a, int b) {$/;"	f	typeref:typename:int
rand	contests/USACO/dec_silver_2021/B/gen.cpp	/^int rand(int a, int b) {$/;"	f	typeref:typename:int
rand	contests/USACO/dec_silver_2021/C/gen.cpp	/^int rand(int a, int b) {$/;"	f	typeref:typename:int
rand	practice/cf/random/1700/stress.cpp	/^int rand(int a, int b) {$/;"	f	typeref:typename:int
rand	practice/club/prob1/generator_prob1.cpp	/^int rand(int a, int b) {$/;"	f	typeref:typename:int
rand	practice/club/prob2/generator_prob2.cpp	/^int rand(int a, int b) {$/;"	f	typeref:typename:int
rand	practice/club/prob3/generator_prob3.cpp	/^ll rand(ll a, ll b) {$/;"	f	typeref:typename:ll
rand	practice/cpbook/ch1/1.6/reallife/medium/01091/stress.cpp	/^int rand(int a, int b) {$/;"	f	typeref:typename:int
range	code-library/Data Structures/Permutation Tree.cpp	/^pair<int, int> range[N * 2]; \/\/ range of permutation values$/;"	v	typeref:typename:pair<int,int>[]
range	code/Data Structures/Permutation Tree.cpp	/^pair<int, int> range[N * 2]; \/\/ range of permutation values$/;"	v	typeref:typename:pair<int,int>[]
range	contests/USACO/dec_silver_2021/A/A.cpp	/^	pair<int, int> range;$/;"	m	struct:pi	typeref:typename:pair<int,int>	file:
range	contests/USACO/dec_silver_2021/A/AA.cpp	/^	pair<int, int> range;$/;"	m	struct:pi	typeref:typename:pair<int,int>	file:
range	contests/USACO/dec_silver_2021/A/A_safe.cpp	/^	pair<int, int> range;$/;"	m	struct:pi	typeref:typename:pair<int,int>	file:
range	contests/USACO/dec_silver_2021/A/a_save.cpp	/^	pair<int, int> range;$/;"	m	struct:pi	typeref:typename:pair<int,int>	file:
range	contests/USACO/dec_silver_2021/A/a_testing.cpp	/^	pair<int, int> range;$/;"	m	struct:pi	typeref:typename:pair<int,int>	file:
range	contests/USACO/dec_silver_2021/A/restart_A.cpp	/^	pair<int, int> range;$/;"	m	struct:pi	typeref:typename:pair<int,int>	file:
range_mul	code-library/Math/NTT.cpp	/^vector<int> range_mul(int n) { \/\/(x+1)*(x+2)*(x+3)...(x+n)$/;"	f	typeref:typename:vector<int>
range_mul	code-library/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^vector<int> range_mul(int n) {$/;"	f	typeref:typename:vector<int>
range_mul	code/Math/NTT.cpp	/^vector<int> range_mul(int n) { \/\/(x+1)*(x+2)*(x+3)...(x+n)$/;"	f	typeref:typename:vector<int>
range_mul	code/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^vector<int> range_mul(int n) {$/;"	f	typeref:typename:vector<int>
rank	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  vector<int> par, rank, size;$/;"	m	struct:dsu	typeref:typename:vector<int>	file:
rank	code-library/Strings/Suffix Array Isomorphic.cpp	/^  vector<int> sa, rank, lcp, a;$/;"	m	struct:IsomorphicSuffixArray	typeref:typename:vector<int>	file:
rank	code-library/Strings/Suffix Array Isomorphic.cpp	/^  vector<int> sa, rank, lcp;$/;"	m	struct:SuffixArray	typeref:typename:vector<int>	file:
rank	code-library/Strings/Suffix Array.cpp	/^  vector<int> sa, rank, lcp;$/;"	m	struct:SuffixArray	typeref:typename:vector<int>	file:
rank	code/Graph Theory/Gomory Hu Tree.cpp	/^  vector<int> par, rank, size;$/;"	m	struct:dsu	typeref:typename:vector<int>	file:
rank	code/Strings/Suffix Array Isomorphic.cpp	/^  vector<int> sa, rank, lcp, a;$/;"	m	struct:IsomorphicSuffixArray	typeref:typename:vector<int>	file:
rank	code/Strings/Suffix Array Isomorphic.cpp	/^  vector<int> sa, rank, lcp;$/;"	m	struct:SuffixArray	typeref:typename:vector<int>	file:
rank	code/Strings/Suffix Array.cpp	/^  vector<int> sa, rank, lcp;$/;"	m	struct:SuffixArray	typeref:typename:vector<int>	file:
rat	code-library/Geometry/Geometry 2D.cpp	/^double rat(PT a, PT b, PT p) {$/;"	f	typeref:typename:double
rat	code/Geometry/Geometry 2D.cpp	/^double rat(PT a, PT b, PT p) {$/;"	f	typeref:typename:double
ray_ray_distance	code-library/Geometry/Geometry 2D.cpp	/^double ray_ray_distance(PT as, PT ad, PT bs, PT bd) {$/;"	f	typeref:typename:double
ray_ray_distance	code/Geometry/Geometry 2D.cpp	/^double ray_ray_distance(PT as, PT ad, PT bs, PT bd) {$/;"	f	typeref:typename:double
ray_ray_intersection	code-library/Geometry/Geometry 2D.cpp	/^bool ray_ray_intersection(PT as, PT ad, PT bs, PT bd) {$/;"	f	typeref:typename:bool
ray_ray_intersection	code/Geometry/Geometry 2D.cpp	/^bool ray_ray_intersection(PT as, PT ad, PT bs, PT bd) {$/;"	f	typeref:typename:bool
rb	code-library/Data Structures/Segment Tree Merging.cpp	/^int root[N], rb[N];$/;"	v	typeref:typename:int[]
rb	code/Data Structures/Segment Tree Merging.cpp	/^int root[N], rb[N];$/;"	v	typeref:typename:int[]
rc	code-library/Data Structures/Dynamic Diameter Online.cpp	/^    #define rc /;"	d	file:
rc	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    #define rc /;"	d	file:
rc	code-library/Data Structures/HLD.cpp	/^#define rc /;"	d	file:
rc	code-library/Data Structures/Permutation Tree.cpp	/^#define rc /;"	d	file:
rc	code-library/Data Structures/Segment Tree Lazy.cpp	/^  #define rc /;"	d	file:
rc	code-library/Data Structures/Segment Tree Merging.cpp	/^#define rc /;"	d	file:
rc	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^#define rc /;"	d	file:
rc	code-library/Data Structures/Segment Tree Persistent.cpp	/^#define rc /;"	d	file:
rc	code-library/Geometry/Onion Decomposition.cpp	/^        int lc, rc;$/;"	m	struct:LeftHull::node	typeref:typename:int	file:
rc	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  #define rc /;"	d	file:
rc	code/Data Structures/Dynamic Diameter Online.cpp	/^    #define rc /;"	d	file:
rc	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    #define rc /;"	d	file:
rc	code/Data Structures/HLD.cpp	/^#define rc /;"	d	file:
rc	code/Data Structures/Permutation Tree.cpp	/^#define rc /;"	d	file:
rc	code/Data Structures/Segment Tree Lazy.cpp	/^  #define rc /;"	d	file:
rc	code/Data Structures/Segment Tree Merging.cpp	/^#define rc /;"	d	file:
rc	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^#define rc /;"	d	file:
rc	code/Data Structures/Segment Tree Persistent.cpp	/^#define rc /;"	d	file:
rc	code/Geometry/Onion Decomposition.cpp	/^        int lc, rc;$/;"	m	struct:LeftHull::node	typeref:typename:int	file:
rc	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  #define rc /;"	d	file:
reach	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^bool reach[N][N];$/;"	v	typeref:typename:bool[][]
reach	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^bool reach[N][N];$/;"	v	typeref:typename:bool[][]
read	code-library/Data Structures/MOs with DSU.cpp	/^void read() {$/;"	f	typeref:typename:void
read	code-library/Math/Gaussian Elimination Modulo 2.cpp	/^string read() {$/;"	f	typeref:typename:string
read	code-library/Miscellaneous/BigInt.cpp	/^  void read(const string& s) {$/;"	f	struct:BigInt	typeref:typename:void	file:
read	code/Data Structures/MOs with DSU.cpp	/^void read() {$/;"	f	typeref:typename:void
read	code/Math/Gaussian Elimination Modulo 2.cpp	/^string read() {$/;"	f	typeref:typename:string
read	code/Miscellaneous/BigInt.cpp	/^  void read(const string& s) {$/;"	f	struct:BigInt	typeref:typename:void	file:
real	code-library/Miscellaneous/BigInt.cpp	/^  inline T real() const {$/;"	f	struct:cplx	typeref:typename:T	file:
real	code/Miscellaneous/BigInt.cpp	/^  inline T real() const {$/;"	f	struct:cplx	typeref:typename:T	file:
rebuild	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^inline void rebuild() {$/;"	f	typeref:typename:void
rebuild	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^inline void rebuild() {$/;"	f	typeref:typename:void
rec	code-library/Geometry/Delaunay Triangulation.cpp	/^pair<Q,Q> rec(const vector<PT>& s) {$/;"	f	typeref:typename:pair<Q,Q>
rec	code-library/Geometry/Voronoi Diagram.cpp	/^pair<Q,Q> rec(const vector<P>& s) {$/;"	f	typeref:typename:pair<Q,Q>
rec	code/Geometry/Delaunay Triangulation.cpp	/^pair<Q,Q> rec(const vector<PT>& s) {$/;"	f	typeref:typename:pair<Q,Q>
rec	code/Geometry/Voronoi Diagram.cpp	/^pair<Q,Q> rec(const vector<P>& s) {$/;"	f	typeref:typename:pair<Q,Q>
recurse	practice/club/prob3/solution_prob3.cpp	/^int recurse(int l, int r){	$/;"	f	typeref:typename:int
reduce	code-library/Math/NTT.cpp	/^void reduce(int &x) { x = (x + mod) % mod; }$/;"	f	typeref:typename:void
reduce	code-library/Number Theory/Prime Factorization Fastest.cpp	/^  static uint64_t reduce(const __uint128_t &x) {$/;"	f	struct:Mint	typeref:typename:uint64_t	file:
reduce	code-library/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^void reduce(int &x) { x = (x + mod) % mod; }$/;"	f	typeref:typename:void
reduce	code-library/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^void reduce(int &x) { x = (x + mod) % mod; }$/;"	f	typeref:typename:void
reduce	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^void reduce(int &x) { x = (x + mod) % mod; }$/;"	f	typeref:typename:void
reduce	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static word_t reduce(const dword_t w) { return word_t(w >> word_bits) + mod - word_t((dword_t(/;"	f	class:ntt::Mod	typeref:typename:word_t	file:
reduce	code-library/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^void reduce(int &x) { x = (x + mod) % mod; }$/;"	f	typeref:typename:void
reduce	code/Math/NTT.cpp	/^void reduce(int &x) { x = (x + mod) % mod; }$/;"	f	typeref:typename:void
reduce	code/Number Theory/Prime Factorization Fastest.cpp	/^  static uint64_t reduce(const __uint128_t &x) {$/;"	f	struct:Mint	typeref:typename:uint64_t	file:
reduce	code/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^void reduce(int &x) { x = (x + mod) % mod; }$/;"	f	typeref:typename:void
reduce	code/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^void reduce(int &x) { x = (x + mod) % mod; }$/;"	f	typeref:typename:void
reduce	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^void reduce(int &x) { x = (x + mod) % mod; }$/;"	f	typeref:typename:void
reduce	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static word_t reduce(const dword_t w) { return word_t(w >> word_bits) + mod - word_t((dword_t(/;"	f	class:ntt::Mod	typeref:typename:word_t	file:
reduce	code/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^void reduce(int &x) { x = (x + mod) % mod; }$/;"	f	typeref:typename:void
reduced_row_echelon_form	code-library/Math/Basis Vector Reduced Row Echelon Form.cpp	/^  void reduced_row_echelon_form() {$/;"	f	struct:Basis	typeref:typename:void	file:
reduced_row_echelon_form	code/Math/Basis Vector Reduced Row Echelon Form.cpp	/^  void reduced_row_echelon_form() {$/;"	f	struct:Basis	typeref:typename:void	file:
reduction	code-library/Graph Theory/3 SAT.cpp	/^  bool reduction() {$/;"	f	struct:SAT_GOD	typeref:typename:bool	file:
reduction	code/Graph Theory/3 SAT.cpp	/^  bool reduction() {$/;"	f	struct:SAT_GOD	typeref:typename:bool	file:
refl	code-library/Geometry/Geometry 3D.cpp	/^    p3 refl(p3 p) { return p - n * 2 * side(p) \/ sq(n); }$/;"	f	struct:plane	typeref:typename:p3	file:
refl	code-library/Geometry/Geometry 3D.cpp	/^    p3 refl(p3 p) { return proj(p) * 2 - p; }$/;"	f	struct:line3d	typeref:typename:p3	file:
refl	code/Geometry/Geometry 3D.cpp	/^    p3 refl(p3 p) { return p - n * 2 * side(p) \/ sq(n); }$/;"	f	struct:plane	typeref:typename:p3	file:
refl	code/Geometry/Geometry 3D.cpp	/^    p3 refl(p3 p) { return proj(p) * 2 - p; }$/;"	f	struct:line3d	typeref:typename:p3	file:
reflection_from_point_to_line	code-library/Geometry/Geometry 2D.cpp	/^PT reflection_from_point_to_line(PT a, PT b, PT c) {$/;"	f	typeref:typename:PT
reflection_from_point_to_line	code/Geometry/Geometry 2D.cpp	/^PT reflection_from_point_to_line(PT a, PT b, PT c) {$/;"	f	typeref:typename:PT
relabel	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  void relabel(int vertex) {$/;"	f	struct:mcSFlow	typeref:typename:void	file:
relabel	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  void relabel(int vertex) {$/;"	f	struct:mcSFlow	typeref:typename:void	file:
rem	code-library/Data Structures/MOs on tree.cpp	/^inline void rem(int u) {$/;"	f	typeref:typename:void
rem	code/Data Structures/MOs on tree.cpp	/^inline void rem(int u) {$/;"	f	typeref:typename:void
rem	practice/cf/random/1700/4.cpp	/^int deepest = INT_MIN; pair<int, int> rem;$/;"	v	typeref:typename:pair<int,int>
rem_left	code-library/Data Structures/MOs Algorithm.cpp	/^inline void rem_left(int i) {$/;"	f	typeref:typename:void
rem_left	code/Data Structures/MOs Algorithm.cpp	/^inline void rem_left(int i) {$/;"	f	typeref:typename:void
rem_right	code-library/Data Structures/MOs Algorithm.cpp	/^inline void rem_right(int i) {$/;"	f	typeref:typename:void
rem_right	code/Data Structures/MOs Algorithm.cpp	/^inline void rem_right(int i) {$/;"	f	typeref:typename:void
reorient	code-library/Geometry/Geometry 3D.cpp	/^vector<vector<p3>> reorient(vector<vector<p3>> fs) {$/;"	f	typeref:typename:vector<vector<p3>>
reorient	code/Geometry/Geometry 3D.cpp	/^vector<vector<p3>> reorient(vector<vector<p3>> fs) {$/;"	f	typeref:typename:vector<vector<p3>>
rep	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^#define rep(/;"	d	file:
rep	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^#define rep(/;"	d	file:
rep	contests/Codeforces/737/D.cpp	/^#define rep(/;"	d	file:
rep	contests/Codeforces/737/E.cpp	/^#define rep(/;"	d	file:
rep2	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^#define rep2(/;"	d	file:
rep2	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^#define rep2(/;"	d	file:
rep3	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^#define rep3(/;"	d	file:
rep3	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^#define rep3(/;"	d	file:
rep4	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^#define rep4(/;"	d	file:
rep4	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^#define rep4(/;"	d	file:
repl	code-library/Data Structures/Implicit Treap.cpp	/^    int val, sz, prior, lazy, sum, mx, mn, repl;$/;"	m	struct:treap::node	typeref:typename:int	file:
repl	code/Data Structures/Implicit Treap.cpp	/^    int val, sz, prior, lazy, sum, mx, mn, repl;$/;"	m	struct:treap::node	typeref:typename:int	file:
repl_flag	code-library/Data Structures/Implicit Treap.cpp	/^    bool repl_flag, rev;$/;"	m	struct:treap::node	typeref:typename:bool	file:
repl_flag	code/Data Structures/Implicit Treap.cpp	/^    bool repl_flag, rev;$/;"	m	struct:treap::node	typeref:typename:bool	file:
replace	code-library/Data Structures/Implicit Treap.cpp	/^  void replace(int qL, int qR, int v) {$/;"	f	struct:treap	typeref:typename:void	file:
replace	code/Data Structures/Implicit Treap.cpp	/^  void replace(int qL, int qR, int v) {$/;"	f	struct:treap	typeref:typename:void	file:
res	code-library/Data Structures/MOs on tree.cpp	/^int res[N];$/;"	v	typeref:typename:int[]
res	code-library/Dynamic Programming Optimizations/Knuth Optimization.cpp	/^ll res[N][N];$/;"	v	typeref:typename:ll[][]
res	code-library/Graph Theory/2 SAT.cpp	/^  vector<bool> vis, res;$/;"	m	struct:twosat	typeref:typename:vector<bool>	file:
res	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  inline F res() const {$/;"	f	struct:S	typeref:typename:F	file:
res	code-library/Graph Theory/Maximum Clique.cpp	/^int res;$/;"	v	typeref:typename:int
res	code/Data Structures/MOs on tree.cpp	/^int res[N];$/;"	v	typeref:typename:int[]
res	code/Dynamic Programming Optimizations/Knuth Optimization.cpp	/^ll res[N][N];$/;"	v	typeref:typename:ll[][]
res	code/Graph Theory/2 SAT.cpp	/^  vector<bool> vis, res;$/;"	m	struct:twosat	typeref:typename:vector<bool>	file:
res	code/Graph Theory/Gomory Hu Tree.cpp	/^  inline F res() const {$/;"	f	struct:S	typeref:typename:F	file:
res	code/Graph Theory/Maximum Clique.cpp	/^int res;$/;"	v	typeref:typename:int
reset	code-library/Data Structures/Implicit Treap.cpp	/^  void reset(pnode &t) {$/;"	f	struct:treap	typeref:typename:void	file:
reset	code-library/Miscellaneous/Bitset Custom.cpp	/^    void reset() {$/;"	f	struct:Bitset	typeref:typename:void	file:
reset	code-library/Miscellaneous/Bitset Custom.cpp	/^    void reset(int i) {$/;"	f	struct:Bitset	typeref:typename:void	file:
reset	code-library/Miscellaneous/Bitset Custom.cpp	/^    void reset(int l, int r) {$/;"	f	struct:Bitset	typeref:typename:void	file:
reset	code/Data Structures/Implicit Treap.cpp	/^  void reset(pnode &t) {$/;"	f	struct:treap	typeref:typename:void	file:
reset	code/Miscellaneous/Bitset Custom.cpp	/^    void reset() {$/;"	f	struct:Bitset	typeref:typename:void	file:
reset	code/Miscellaneous/Bitset Custom.cpp	/^    void reset(int i) {$/;"	f	struct:Bitset	typeref:typename:void	file:
reset	code/Miscellaneous/Bitset Custom.cpp	/^    void reset(int l, int r) {$/;"	f	struct:Bitset	typeref:typename:void	file:
resize	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  void resize(int s) { coefs.resize(s); }$/;"	f	class:poly	typeref:typename:void	file:
resize	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  void resize(int s) { coefs.resize(s); }$/;"	f	class:poly	typeref:typename:void	file:
restore	code-library/Miscellaneous/K-th Root of a Permutation.cpp	/^vector<int> restore(int n, vector<vector<int>> &cycles) {$/;"	f	typeref:typename:vector<int>
restore	code/Miscellaneous/K-th Root of a Permutation.cpp	/^vector<int> restore(int n, vector<vector<int>> &cycles) {$/;"	f	typeref:typename:vector<int>
resultant	code-library/Math/Determinant of Cyclic Matrix.cpp	/^int resultant(const Poly &a, const Poly &b) {$/;"	f	typeref:typename:int
resultant	code-library/Math/Determinant of Permutant Matrix.cpp	/^int resultant(const Poly &a, const Poly &b) {$/;"	f	typeref:typename:int
resultant	code-library/Math/Polynomial.cpp	/^mint resultant(poly a, poly b) { \/\/computes resultant of a and b, assert(!a.is_zero())$/;"	f	typeref:typename:mint
resultant	code/Math/Determinant of Cyclic Matrix.cpp	/^int resultant(const Poly &a, const Poly &b) {$/;"	f	typeref:typename:int
resultant	code/Math/Determinant of Permutant Matrix.cpp	/^int resultant(const Poly &a, const Poly &b) {$/;"	f	typeref:typename:int
resultant	code/Math/Polynomial.cpp	/^mint resultant(poly a, poly b) { \/\/computes resultant of a and b, assert(!a.is_zero())$/;"	f	typeref:typename:mint
rev	code-library/Data Structures/Implicit Treap.cpp	/^    bool repl_flag, rev;$/;"	m	struct:treap::node	typeref:typename:bool	file:
rev	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^  bool rev = false;$/;"	m	struct:Block	typeref:typename:bool	file:
rev	code-library/Graph Theory/Dinics Algorithm.cpp	/^    int to, rev;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
rev	code-library/Graph Theory/Dominator Tree.cpp	/^int id[N], rev[N], T;$/;"	v	typeref:typename:int[]
rev	code-library/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^  int from, to, rev;$/;"	m	struct:EDGE	typeref:typename:int	file:
rev	code-library/Graph Theory/L R Flow with Dinic.cpp	/^    int to, rev;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
rev	code-library/Graph Theory/Maximum Closure Problem.cpp	/^    int to, rev;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
rev	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^    int to, rev;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
rev	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^    int to, rev;$/;"	m	struct:mcSFlow::Edge	typeref:typename:int	file:
rev	code-library/Graph Theory/Unique Min Cut.cpp	/^    int to, rev;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
rev	code-library/Math/Faulhaber Formula Fastest.cpp	/^vector<int> rev = {0, 1};$/;"	v	typeref:typename:vector<int>
rev	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^vector<int> rev = {0, 1};$/;"	v	typeref:typename:vector<int>
rev	code-library/Math/Linear Recurrence Fastest.cpp	/^vector<int> rev = {0, 1};$/;"	v	typeref:typename:vector<int>
rev	code-library/Math/NTT Online.cpp	/^vector<int> rev = {0, 1};$/;"	v	typeref:typename:vector<int>
rev	code-library/Math/NTT With Any Prime MOD.cpp	/^vector<int> rev = {0, 1};$/;"	v	typeref:typename:vector<int>
rev	code-library/Math/NTT.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
rev	code-library/Math/Polynomial with Binomial Coefficients.cpp	/^vector<int> rev = {0, 1};$/;"	v	typeref:typename:vector<int>
rev	code-library/Math/Polynomial.cpp	/^vector<int> rev = {0, 1};$/;"	v	typeref:typename:vector<int>
rev	code-library/Math/Subset Sum Problem.cpp	/^vector<int> rev = {0, 1};$/;"	v	typeref:typename:vector<int>
rev	code-library/Number Theory/Bell Number.cpp	/^vector<int> rev = {0, 1};$/;"	v	typeref:typename:vector<int>
rev	code-library/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
rev	code-library/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
rev	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^vector<int> rev = {0, 1};$/;"	v	typeref:typename:vector<int>
rev	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
rev	code-library/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^vector<int> rev = {0, 1};$/;"	v	typeref:typename:vector<int>
rev	code-library/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
rev	code/Data Structures/Implicit Treap.cpp	/^    bool repl_flag, rev;$/;"	m	struct:treap::node	typeref:typename:bool	file:
rev	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^  bool rev = false;$/;"	m	struct:Block	typeref:typename:bool	file:
rev	code/Graph Theory/Dinics Algorithm.cpp	/^    int to, rev;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
rev	code/Graph Theory/Dominator Tree.cpp	/^int id[N], rev[N], T;$/;"	v	typeref:typename:int[]
rev	code/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^  int from, to, rev;$/;"	m	struct:EDGE	typeref:typename:int	file:
rev	code/Graph Theory/L R Flow with Dinic.cpp	/^    int to, rev;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
rev	code/Graph Theory/Maximum Closure Problem.cpp	/^    int to, rev;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
rev	code/Graph Theory/Maximum Density Subgraph.cpp	/^    int to, rev;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
rev	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^    int to, rev;$/;"	m	struct:mcSFlow::Edge	typeref:typename:int	file:
rev	code/Graph Theory/Unique Min Cut.cpp	/^    int to, rev;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
rev	code/Math/Faulhaber Formula Fastest.cpp	/^vector<int> rev = {0, 1};$/;"	v	typeref:typename:vector<int>
rev	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^vector<int> rev = {0, 1};$/;"	v	typeref:typename:vector<int>
rev	code/Math/Linear Recurrence Fastest.cpp	/^vector<int> rev = {0, 1};$/;"	v	typeref:typename:vector<int>
rev	code/Math/NTT Online.cpp	/^vector<int> rev = {0, 1};$/;"	v	typeref:typename:vector<int>
rev	code/Math/NTT With Any Prime MOD.cpp	/^vector<int> rev = {0, 1};$/;"	v	typeref:typename:vector<int>
rev	code/Math/NTT.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
rev	code/Math/Polynomial with Binomial Coefficients.cpp	/^vector<int> rev = {0, 1};$/;"	v	typeref:typename:vector<int>
rev	code/Math/Polynomial.cpp	/^vector<int> rev = {0, 1};$/;"	v	typeref:typename:vector<int>
rev	code/Math/Subset Sum Problem.cpp	/^vector<int> rev = {0, 1};$/;"	v	typeref:typename:vector<int>
rev	code/Number Theory/Bell Number.cpp	/^vector<int> rev = {0, 1};$/;"	v	typeref:typename:vector<int>
rev	code/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
rev	code/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
rev	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^vector<int> rev = {0, 1};$/;"	v	typeref:typename:vector<int>
rev	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
rev	code/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^vector<int> rev = {0, 1};$/;"	v	typeref:typename:vector<int>
rev	code/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
rev_add	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly& rev_add(const poly& rhs) {$/;"	f	class:poly	typeref:typename:poly &	file:
rev_add	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  poly& rev_add(const poly& rhs) {$/;"	f	class:poly	typeref:typename:poly &	file:
rev_g	code-library/Miscellaneous/Gray Code.cpp	/^int rev_g (int g) {$/;"	f	typeref:typename:int
rev_g	code/Miscellaneous/Gray Code.cpp	/^int rev_g (int g) {$/;"	f	typeref:typename:int
rev_incr	code-library/Miscellaneous/BigInt.cpp	/^  static inline int rev_incr(int a, int n) {$/;"	f	struct:BigInt	typeref:typename:int	file:
rev_incr	code/Miscellaneous/BigInt.cpp	/^  static inline int rev_incr(int a, int n) {$/;"	f	struct:BigInt	typeref:typename:int	file:
rev_permute	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^void rev_permute(mod_t* A, int n) {$/;"	f	namespace:ntt	typeref:typename:void
rev_permute	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^void rev_permute(mod_t* A, int n) {$/;"	f	namespace:ntt	typeref:typename:void
reverse	code-library/Data Structures/Implicit Treap.cpp	/^  void reverse(int qL, int qR) {$/;"	f	struct:treap	typeref:typename:void	file:
reverse	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  void reverse() { std::reverse(coefs.begin(), coefs.end()); }$/;"	f	class:poly	typeref:typename:void	file:
reverse	code/Data Structures/Implicit Treap.cpp	/^  void reverse(int qL, int qR) {$/;"	f	struct:treap	typeref:typename:void	file:
reverse	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  void reverse() { std::reverse(coefs.begin(), coefs.end()); }$/;"	f	class:poly	typeref:typename:void	file:
reverse_it	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly reverse_it(int n, bool rev = 0) const { \/\/ reverses and leaves only n terms$/;"	f	struct:poly	typeref:typename:poly	file:
reverse_it	code-library/Math/Polynomial.cpp	/^  poly reverse_it(int n, bool rev = 0) const { \/\/ reverses and leaves only n terms$/;"	f	struct:poly	typeref:typename:poly	file:
reverse_it	code-library/Number Theory/Bell Number.cpp	/^  poly reverse_it(int n, bool rev = 0) const { \/\/ reverses and leaves only n terms$/;"	f	struct:poly	typeref:typename:poly	file:
reverse_it	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  poly reverse_it(int n, bool rev = 0) const { \/\/ reverses and leaves only n terms$/;"	f	struct:poly	typeref:typename:poly	file:
reverse_it	code/Math/Faulhaber Formula Fastest.cpp	/^  poly reverse_it(int n, bool rev = 0) const { \/\/ reverses and leaves only n terms$/;"	f	struct:poly	typeref:typename:poly	file:
reverse_it	code/Math/Polynomial.cpp	/^  poly reverse_it(int n, bool rev = 0) const { \/\/ reverses and leaves only n terms$/;"	f	struct:poly	typeref:typename:poly	file:
reverse_it	code/Number Theory/Bell Number.cpp	/^  poly reverse_it(int n, bool rev = 0) const { \/\/ reverses and leaves only n terms$/;"	f	struct:poly	typeref:typename:poly	file:
reverse_it	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  poly reverse_it(int n, bool rev = 0) const { \/\/ reverses and leaves only n terms$/;"	f	struct:poly	typeref:typename:poly	file:
revert	code-library/Graph Theory/Dynamic MST.cpp	/^  void revert(vector<pair<int, int>> &snapshot){$/;"	f	struct:disj	typeref:typename:void	file:
revert	code/Graph Theory/Dynamic MST.cpp	/^  void revert(vector<pair<int, int>> &snapshot){$/;"	f	struct:disj	typeref:typename:void	file:
rg	code-library/Data Structures/Persistent Meldable Heap.cpp	/^vector<vector<array<int, 3>>> rg;$/;"	v	typeref:typename:vector<vector<array<int,3>>>
rg	code-library/Graph Theory/Dominator Tree.cpp	/^vector<int> t[N], rg[N], bucket[N]; \/\/t = dominator tree of the nodes reachable from root$/;"	v	typeref:typename:vector<int>[]
rg	code-library/Graph Theory/Eppsteins Algorithm.cpp	/^vector<vector<array<int, 3>>> rg;$/;"	v	typeref:typename:vector<vector<array<int,3>>>
rg	code/Data Structures/Persistent Meldable Heap.cpp	/^vector<vector<array<int, 3>>> rg;$/;"	v	typeref:typename:vector<vector<array<int,3>>>
rg	code/Graph Theory/Dominator Tree.cpp	/^vector<int> t[N], rg[N], bucket[N]; \/\/t = dominator tree of the nodes reachable from root$/;"	v	typeref:typename:vector<int>[]
rg	code/Graph Theory/Eppsteins Algorithm.cpp	/^vector<vector<array<int, 3>>> rg;$/;"	v	typeref:typename:vector<vector<array<int,3>>>
rho_pollard	code-library/Number Theory/Prime Factorization Fastest.cpp	/^uint64_t rho_pollard(const uint64_t &n) {$/;"	f	typeref:typename:uint64_t
rho_pollard	code/Number Theory/Prime Factorization Fastest.cpp	/^uint64_t rho_pollard(const uint64_t &n) {$/;"	f	typeref:typename:uint64_t
rid	code-library/Data Structures/Reachability Tree.cpp	/^  int n, par[2 * N], sp[LG + 1][2 * N], val[2 * N], rid[2 * N];$/;"	m	struct:RT	typeref:typename:int[]	file:
rid	code/Data Structures/Reachability Tree.cpp	/^  int n, par[2 * N], sp[LG + 1][2 * N], val[2 * N], rid[2 * N];$/;"	m	struct:RT	typeref:typename:int[]	file:
right	code-library/Data Structures/Disjoint Sparse Table.cpp	/^  vector<vector<int>> left, right;$/;"	m	struct:DST	typeref:typename:vector<vector<int>>	file:
right	code-library/Data Structures/KD Tree.cpp	/^  kd_node *left, *right;$/;"	m	struct:kd_node	typeref:typename:kd_node *	file:
right	code-library/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  node* right = nullptr;$/;"	m	struct:node	typeref:typename:node *	file:
right	code/Data Structures/Disjoint Sparse Table.cpp	/^  vector<vector<int>> left, right;$/;"	m	struct:DST	typeref:typename:vector<vector<int>>	file:
right	code/Data Structures/KD Tree.cpp	/^  kd_node *left, *right;$/;"	m	struct:kd_node	typeref:typename:kd_node *	file:
right	code/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  node* right = nullptr;$/;"	m	struct:node	typeref:typename:node *	file:
rk	code-library/Graph Theory/Dynamic MST.cpp	/^  int pa[MAXN], rk[MAXN];$/;"	m	struct:disj	typeref:typename:int[]	file:
rk	code/Graph Theory/Dynamic MST.cpp	/^  int pa[MAXN], rk[MAXN];$/;"	m	struct:disj	typeref:typename:int[]	file:
rmq	code-library/Graph Theory/LCA in O(1).cpp	/^  RMQ<pair<int, int>> rmq;$/;"	m	struct:LCA	typeref:typename:RMQ<pair<int,int>>	file:
rmq	code-library/Graph Theory/LCA in O(1).cpp	/^  vector<vector<T>> rmq;$/;"	m	struct:RMQ	typeref:typename:vector<vector<T>>	file:
rmq	code/Graph Theory/LCA in O(1).cpp	/^  RMQ<pair<int, int>> rmq;$/;"	m	struct:LCA	typeref:typename:RMQ<pair<int,int>>	file:
rmq	code/Graph Theory/LCA in O(1).cpp	/^  vector<vector<T>> rmq;$/;"	m	struct:RMQ	typeref:typename:vector<vector<T>>	file:
rn	.config/nvim/init.vim	/^nnoremap <silent>rn :Lspsaga rename<CR>$/;"	m
rn	dotfiles/init.vim	/^nnoremap <silent>rn :Lspsaga rename<CR>$/;"	m
rn	dotfiles/macinit.vim	/^nnoremap <silent>rn :Lspsaga rename<CR>$/;"	m
rnd	code-library/Data Structures/Implicit Treap.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnd	code-library/Data Structures/Persistent UnionFind.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnd	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnd	code-library/Data Structures/Treap persistent.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnd	code-library/Data Structures/Treap.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnd	code-library/Game Theory/Matching Game On A Graph.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnd	code-library/Graph Theory/Blossom Algorithm.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnd	code-library/Graph Theory/Kuhns Algorithm.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnd	code-library/Graph Theory/Randomized Matching Unweighted.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnd	code-library/Graph Theory/Stoer Wagner Algorithm.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnd	code-library/Math/Determinant of Sparse Matrix.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnd	code-library/Math/Finite Field Arithmetic Binary.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnd	code-library/Math/Freivalds Algorithm.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnd	code-library/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^  mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	namespace:PollardRho	typeref:typename:mt19937
rnd	code-library/Number Theory/Pisano Period.cpp	/^  mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	namespace:PollardRho	typeref:typename:mt19937
rnd	code-library/Number Theory/Pollard Rho.cpp	/^  mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	namespace:PollardRho	typeref:typename:mt19937
rnd	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnd	code/Data Structures/Implicit Treap.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnd	code/Data Structures/Persistent UnionFind.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnd	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnd	code/Data Structures/Treap persistent.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnd	code/Data Structures/Treap.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnd	code/Game Theory/Matching Game On A Graph.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnd	code/Graph Theory/Blossom Algorithm.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnd	code/Graph Theory/Kuhns Algorithm.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnd	code/Graph Theory/Randomized Matching Unweighted.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnd	code/Graph Theory/Stoer Wagner Algorithm.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnd	code/Math/Determinant of Sparse Matrix.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnd	code/Math/Finite Field Arithmetic Binary.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnd	code/Math/Freivalds Algorithm.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnd	code/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^  mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	namespace:PollardRho	typeref:typename:mt19937
rnd	code/Number Theory/Pisano Period.cpp	/^  mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	namespace:PollardRho	typeref:typename:mt19937
rnd	code/Number Theory/Pollard Rho.cpp	/^  mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	namespace:PollardRho	typeref:typename:mt19937
rnd	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());$/;"	v	typeref:typename:mt19937
rnk	code-library/Data Structures/DSU.cpp	/^  vector<int> par, rnk, sz;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
rnk	code-library/Graph Theory/Boruvka's Algorithm.cpp	/^  vector<int> par, rnk, size; int c;$/;"	m	struct:dsu	typeref:typename:vector<int>	file:
rnk	code-library/Graph Theory/Kirchoffs Theorem.cpp	/^  vector<int> par, rnk, size;$/;"	m	struct:dsu	typeref:typename:vector<int>	file:
rnk	code-library/Graph Theory/Krushkal's MST.cpp	/^  vector<int> par, rnk, size; int c;$/;"	m	struct:dsu	typeref:typename:vector<int>	file:
rnk	code/Data Structures/DSU.cpp	/^  vector<int> par, rnk, sz;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
rnk	code/Graph Theory/Boruvka's Algorithm.cpp	/^  vector<int> par, rnk, size; int c;$/;"	m	struct:dsu	typeref:typename:vector<int>	file:
rnk	code/Graph Theory/Kirchoffs Theorem.cpp	/^  vector<int> par, rnk, size;$/;"	m	struct:dsu	typeref:typename:vector<int>	file:
rnk	code/Graph Theory/Krushkal's MST.cpp	/^  vector<int> par, rnk, size; int c;$/;"	m	struct:dsu	typeref:typename:vector<int>	file:
rnku	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^    int u, v, rnku, rnkv;$/;"	m	struct:persistent_dsu::state	typeref:typename:int	file:
rnku	code/Data Structures/Dynamic Connectivity Problem.cpp	/^    int u, v, rnku, rnkv;$/;"	m	struct:persistent_dsu::state	typeref:typename:int	file:
rnkv	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^    int u, v, rnku, rnkv;$/;"	m	struct:persistent_dsu::state	typeref:typename:int	file:
rnkv	code/Data Structures/Dynamic Connectivity Problem.cpp	/^    int u, v, rnku, rnkv;$/;"	m	struct:persistent_dsu::state	typeref:typename:int	file:
rollback	code-library/Data Structures/MOs with DSU.cpp	/^  void rollback() {$/;"	f	struct:persistent_dsu	typeref:typename:void	file:
rollback	code-library/Strings/Palindromic Tree Persistent.cpp	/^  void rollback() {$/;"	f	struct:PalindromicTree	typeref:typename:void	file:
rollback	code/Data Structures/MOs with DSU.cpp	/^  void rollback() {$/;"	f	struct:persistent_dsu	typeref:typename:void	file:
rollback	code/Strings/Palindromic Tree Persistent.cpp	/^  void rollback() {$/;"	f	struct:PalindromicTree	typeref:typename:void	file:
rook	practice/cpbook/ch1/1.6/chess/10284/main.cpp	/^void rook(int row, int col, bool black) {$/;"	f	typeref:typename:void
root	code-library/Data Structures/Binarizing a Tree.cpp	/^int a[N], root[N];$/;"	v	typeref:typename:int[]
root	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^int a[N], root[N];$/;"	v	typeref:typename:int[]
root	code-library/Data Structures/DSU Partially Persistent.cpp	/^  int root(int u, int t) { \/\/root of u at time t$/;"	f	struct:DSU	typeref:typename:int	file:
root	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^  int root(int x) {$/;"	f	struct:persistent_dsu	typeref:typename:int	file:
root	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int root[N], rootr[N];$/;"	v	typeref:typename:int[]
root	code-library/Data Structures/Implicit Treap.cpp	/^  pnode root;$/;"	m	struct:treap	typeref:typename:pnode	file:
root	code-library/Data Structures/KD Tree.cpp	/^node_ptr root;$/;"	v	typeref:typename:node_ptr
root	code-library/Data Structures/MOs with DSU.cpp	/^  int root(int x) {$/;"	f	struct:persistent_dsu	typeref:typename:int	file:
root	code-library/Data Structures/Persistent Array.cpp	/^  vector<node*> root;$/;"	m	struct:PersistentArray	typeref:typename:vector<node * >	file:
root	code-library/Data Structures/Persistent Meldable Heap.cpp	/^  node* root = 0;$/;"	m	struct:heap	typeref:typename:node *	file:
root	code-library/Data Structures/Persistent Queue.cpp	/^  vector<node*> root;$/;"	m	struct:PersistentArray	typeref:typename:vector<node * >	file:
root	code-library/Data Structures/Persistent UnionFind.cpp	/^  vector<node*> root;$/;"	m	struct:PersistentArray	typeref:typename:vector<node * >	file:
root	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  node *root;$/;"	m	struct:treap	typeref:typename:node *	file:
root	code-library/Data Structures/Segment Tree Merging.cpp	/^int root[N], rb[N];$/;"	v	typeref:typename:int[]
root	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^int root[N];$/;"	v	typeref:typename:int[]
root	code-library/Data Structures/Segment Tree Persistent.cpp	/^int V[N], root[N], a[N];$/;"	v	typeref:typename:int[]
root	code-library/Data Structures/Treap persistent.cpp	/^node* root[N];$/;"	v	typeref:typename:node * []
root	code-library/Data Structures/Treap.cpp	/^  node *root;$/;"	m	struct:treap	typeref:typename:node *	file:
root	code-library/Data Structures/Trie.cpp	/^  }*root;$/;"	m	struct:Trie	typeref:struct:Trie::node *	file:
root	code-library/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  node* root;$/;"	m	struct:LiChaoTree	typeref:typename:node *	file:
root	code-library/Geometry/Onion Decomposition.cpp	/^    int root;$/;"	m	struct:LeftHull	typeref:typename:int	file:
root	code-library/Graph Theory/Directed MST.cpp	/^  int root(int i) { return par[i] < 0 ? i : par[i] = root(par[i]); }$/;"	f	struct:DSU	typeref:typename:int	file:
root	code-library/Graph Theory/Eppsteins Algorithm.cpp	/^  node* root = 0;$/;"	m	struct:heap	typeref:typename:node *	file:
root	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly root(int n, int k = 2) const { \/\/kth root of p(x) mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
root	code-library/Math/NTT.cpp	/^const int root = 3;$/;"	v	typeref:typename:const int
root	code-library/Math/Polynomial.cpp	/^  poly root(int n, int k = 2) const { \/\/kth root of p(x) mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
root	code-library/Miscellaneous/K-th Root of a Permutation.cpp	/^vector<vector<int>> root(vector<int> &p, int k, int toggle = 0) {$/;"	f	typeref:typename:vector<vector<int>>
root	code-library/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^const int root = 3;$/;"	v	typeref:typename:const int
root	code-library/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^const int root = 3;$/;"	v	typeref:typename:const int
root	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^const int root = 3;$/;"	v	typeref:typename:const int
root	code-library/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^const int root = 3;$/;"	v	typeref:typename:const int
root	code/Data Structures/Binarizing a Tree.cpp	/^int a[N], root[N];$/;"	v	typeref:typename:int[]
root	code/Data Structures/Centroid Decomposition Persistent.cpp	/^int a[N], root[N];$/;"	v	typeref:typename:int[]
root	code/Data Structures/DSU Partially Persistent.cpp	/^  int root(int u, int t) { \/\/root of u at time t$/;"	f	struct:DSU	typeref:typename:int	file:
root	code/Data Structures/Dynamic Connectivity Problem.cpp	/^  int root(int x) {$/;"	f	struct:persistent_dsu	typeref:typename:int	file:
root	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int root[N], rootr[N];$/;"	v	typeref:typename:int[]
root	code/Data Structures/Implicit Treap.cpp	/^  pnode root;$/;"	m	struct:treap	typeref:typename:pnode	file:
root	code/Data Structures/KD Tree.cpp	/^node_ptr root;$/;"	v	typeref:typename:node_ptr
root	code/Data Structures/MOs with DSU.cpp	/^  int root(int x) {$/;"	f	struct:persistent_dsu	typeref:typename:int	file:
root	code/Data Structures/Persistent Array.cpp	/^  vector<node*> root;$/;"	m	struct:PersistentArray	typeref:typename:vector<node * >	file:
root	code/Data Structures/Persistent Meldable Heap.cpp	/^  node* root = 0;$/;"	m	struct:heap	typeref:typename:node *	file:
root	code/Data Structures/Persistent Queue.cpp	/^  vector<node*> root;$/;"	m	struct:PersistentArray	typeref:typename:vector<node * >	file:
root	code/Data Structures/Persistent UnionFind.cpp	/^  vector<node*> root;$/;"	m	struct:PersistentArray	typeref:typename:vector<node * >	file:
root	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  node *root;$/;"	m	struct:treap	typeref:typename:node *	file:
root	code/Data Structures/Segment Tree Merging.cpp	/^int root[N], rb[N];$/;"	v	typeref:typename:int[]
root	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^int root[N];$/;"	v	typeref:typename:int[]
root	code/Data Structures/Segment Tree Persistent.cpp	/^int V[N], root[N], a[N];$/;"	v	typeref:typename:int[]
root	code/Data Structures/Treap persistent.cpp	/^node* root[N];$/;"	v	typeref:typename:node * []
root	code/Data Structures/Treap.cpp	/^  node *root;$/;"	m	struct:treap	typeref:typename:node *	file:
root	code/Data Structures/Trie.cpp	/^  }*root;$/;"	m	struct:Trie	typeref:struct:Trie::node *	file:
root	code/Dynamic Programming Optimizations/Li Chao Tree.cpp	/^  node* root;$/;"	m	struct:LiChaoTree	typeref:typename:node *	file:
root	code/Geometry/Onion Decomposition.cpp	/^    int root;$/;"	m	struct:LeftHull	typeref:typename:int	file:
root	code/Graph Theory/Directed MST.cpp	/^  int root(int i) { return par[i] < 0 ? i : par[i] = root(par[i]); }$/;"	f	struct:DSU	typeref:typename:int	file:
root	code/Graph Theory/Eppsteins Algorithm.cpp	/^  node* root = 0;$/;"	m	struct:heap	typeref:typename:node *	file:
root	code/Math/Faulhaber Formula Fastest.cpp	/^  poly root(int n, int k = 2) const { \/\/kth root of p(x) mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
root	code/Math/NTT.cpp	/^const int root = 3;$/;"	v	typeref:typename:const int
root	code/Math/Polynomial.cpp	/^  poly root(int n, int k = 2) const { \/\/kth root of p(x) mod x^n$/;"	f	struct:poly	typeref:typename:poly	file:
root	code/Miscellaneous/K-th Root of a Permutation.cpp	/^vector<vector<int>> root(vector<int> &p, int k, int toggle = 0) {$/;"	f	typeref:typename:vector<vector<int>>
root	code/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^const int root = 3;$/;"	v	typeref:typename:const int
root	code/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^const int root = 3;$/;"	v	typeref:typename:const int
root	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^const int root = 3;$/;"	v	typeref:typename:const int
root	code/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^const int root = 3;$/;"	v	typeref:typename:const int
rootr	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int root[N], rootr[N];$/;"	v	typeref:typename:int[]
rootr	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int root[N], rootr[N];$/;"	v	typeref:typename:int[]
roots	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  vector<int> roots;$/;"	m	struct:PersistentLiChaoTree	typeref:typename:vector<int>	file:
roots	code-library/Math/Faulhaber Formula Fastest.cpp	/^vector<base> roots = {{0, 0}, {1, 0}};$/;"	v	typeref:typename:vector<base>
roots	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^vector<base> roots = {{0, 0}, {1, 0}};$/;"	v	typeref:typename:vector<base>
roots	code-library/Math/Linear Recurrence Fastest.cpp	/^vector<base> roots = {{0, 0}, {1, 0}};$/;"	v	typeref:typename:vector<base>
roots	code-library/Math/NTT Online.cpp	/^vector<base> roots = {{0, 0}, {1, 0}};$/;"	v	typeref:typename:vector<base>
roots	code-library/Math/NTT With Any Prime MOD.cpp	/^vector<base> roots = {{0, 0}, {1, 0}};$/;"	v	typeref:typename:vector<base>
roots	code-library/Math/Polynomial with Binomial Coefficients.cpp	/^vector<base> roots = {{0, 0}, {1, 0}};$/;"	v	typeref:typename:vector<base>
roots	code-library/Math/Polynomial.cpp	/^vector<base> roots = {{0, 0}, {1, 0}};$/;"	v	typeref:typename:vector<base>
roots	code-library/Math/Subset Sum Problem.cpp	/^vector<base> roots = {{0, 0}, {1, 0}};$/;"	v	typeref:typename:vector<base>
roots	code-library/Number Theory/Bell Number.cpp	/^vector<base> roots = {{0, 0}, {1, 0}};$/;"	v	typeref:typename:vector<base>
roots	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^vector<base> roots = {{0, 0}, {1, 0}};$/;"	v	typeref:typename:vector<base>
roots	code-library/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^vector<base> roots = {{0, 0}, {1, 0}};$/;"	v	typeref:typename:vector<base>
roots	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^  vector<int> roots;$/;"	m	struct:PersistentLiChaoTree	typeref:typename:vector<int>	file:
roots	code/Math/Faulhaber Formula Fastest.cpp	/^vector<base> roots = {{0, 0}, {1, 0}};$/;"	v	typeref:typename:vector<base>
roots	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^vector<base> roots = {{0, 0}, {1, 0}};$/;"	v	typeref:typename:vector<base>
roots	code/Math/Linear Recurrence Fastest.cpp	/^vector<base> roots = {{0, 0}, {1, 0}};$/;"	v	typeref:typename:vector<base>
roots	code/Math/NTT Online.cpp	/^vector<base> roots = {{0, 0}, {1, 0}};$/;"	v	typeref:typename:vector<base>
roots	code/Math/NTT With Any Prime MOD.cpp	/^vector<base> roots = {{0, 0}, {1, 0}};$/;"	v	typeref:typename:vector<base>
roots	code/Math/Polynomial with Binomial Coefficients.cpp	/^vector<base> roots = {{0, 0}, {1, 0}};$/;"	v	typeref:typename:vector<base>
roots	code/Math/Polynomial.cpp	/^vector<base> roots = {{0, 0}, {1, 0}};$/;"	v	typeref:typename:vector<base>
roots	code/Math/Subset Sum Problem.cpp	/^vector<base> roots = {{0, 0}, {1, 0}};$/;"	v	typeref:typename:vector<base>
roots	code/Number Theory/Bell Number.cpp	/^vector<base> roots = {{0, 0}, {1, 0}};$/;"	v	typeref:typename:vector<base>
roots	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^vector<base> roots = {{0, 0}, {1, 0}};$/;"	v	typeref:typename:vector<base>
roots	code/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^vector<base> roots = {{0, 0}, {1, 0}};$/;"	v	typeref:typename:vector<base>
rot	code-library/Data Structures/Top Tree.cpp	/^  void rot() {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
rot	code-library/Geometry/Delaunay Triangulation.cpp	/^    bool mark; Q o, rot; PT p;$/;"	m	struct:Quad	typeref:typename:Q	file:
rot	code-library/Geometry/Voronoi Diagram.cpp	/^    bool mark; Q o, rot; P p;$/;"	m	struct:Quad	typeref:typename:Q	file:
rot	code/Data Structures/Top Tree.cpp	/^  void rot() {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
rot	code/Geometry/Delaunay Triangulation.cpp	/^    bool mark; Q o, rot; PT p;$/;"	m	struct:Quad	typeref:typename:Q	file:
rot	code/Geometry/Voronoi Diagram.cpp	/^    bool mark; Q o, rot; P p;$/;"	m	struct:Quad	typeref:typename:Q	file:
rot_2	code-library/Data Structures/Top Tree.cpp	/^  void rot_2(int c_d) {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
rot_2	code/Data Structures/Top Tree.cpp	/^  void rot_2(int c_d) {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
rotate	code-library/Data Structures/Link Cut Tree.cpp	/^  void rotate(int x, int d) { $/;"	f	struct:LCT	typeref:typename:void	file:
rotate	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  void rotate(int x) {$/;"	f	namespace:lct	typeref:typename:void
rotate	code/Data Structures/Link Cut Tree.cpp	/^  void rotate(int x, int d) { $/;"	f	struct:LCT	typeref:typename:void	file:
rotate	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  void rotate(int x) {$/;"	f	namespace:lct	typeref:typename:void
rotateccw	code-library/Geometry/All Pair Segment Intersection.cpp	/^PT rotateccw(PT a, double t) {$/;"	f	typeref:typename:PT
rotateccw	code-library/Geometry/Geometry 2D.cpp	/^PT rotateccw(PT a, double t) { return PT(a.x * cos(t) - a.y * sin(t), a.x * sin(t) + a.y * cos(t/;"	f	typeref:typename:PT
rotateccw	code-library/Geometry/Geometry 3D.cpp	/^PT rotateccw(PT a, double t) { return PT(a.x * cos(t) - a.y * sin(t), a.x * sin(t) + a.y * cos(t/;"	f	typeref:typename:PT
rotateccw	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^PT rotateccw(PT a, double t) { return PT(a.x * cos(t) - a.y * sin(t), a.x * sin(t) + a.y * cos(t/;"	f	typeref:typename:PT
rotateccw	code-library/Geometry/Half Plane Intersection.cpp	/^PT rotateccw(PT a, double t) { return PT(a.x * cos(t) - a.y * sin(t), a.x * sin(t) + a.y * cos(t/;"	f	typeref:typename:PT
rotateccw	code-library/Geometry/Voronoi Diagram.cpp	/^PT rotateccw(PT a, double t) { return PT(a.x * cos(t) - a.y * sin(t), a.x * sin(t) + a.y * cos(t/;"	f	typeref:typename:PT
rotateccw	code/Geometry/All Pair Segment Intersection.cpp	/^PT rotateccw(PT a, double t) {$/;"	f	typeref:typename:PT
rotateccw	code/Geometry/Geometry 2D.cpp	/^PT rotateccw(PT a, double t) { return PT(a.x * cos(t) - a.y * sin(t), a.x * sin(t) + a.y * cos(t/;"	f	typeref:typename:PT
rotateccw	code/Geometry/Geometry 3D.cpp	/^PT rotateccw(PT a, double t) { return PT(a.x * cos(t) - a.y * sin(t), a.x * sin(t) + a.y * cos(t/;"	f	typeref:typename:PT
rotateccw	code/Geometry/Half Plane Intersection Dynamic.cpp	/^PT rotateccw(PT a, double t) { return PT(a.x * cos(t) - a.y * sin(t), a.x * sin(t) + a.y * cos(t/;"	f	typeref:typename:PT
rotateccw	code/Geometry/Half Plane Intersection.cpp	/^PT rotateccw(PT a, double t) { return PT(a.x * cos(t) - a.y * sin(t), a.x * sin(t) + a.y * cos(t/;"	f	typeref:typename:PT
rotateccw	code/Geometry/Voronoi Diagram.cpp	/^PT rotateccw(PT a, double t) { return PT(a.x * cos(t) - a.y * sin(t), a.x * sin(t) + a.y * cos(t/;"	f	typeref:typename:PT
rotateccw90	code-library/Geometry/All Pair Segment Intersection.cpp	/^PT rotateccw90(PT a) {$/;"	f	typeref:typename:PT
rotateccw90	code-library/Geometry/Geometry 2D.cpp	/^PT rotateccw90(PT a) { return PT(-a.y, a.x); }$/;"	f	typeref:typename:PT
rotateccw90	code-library/Geometry/Geometry 3D.cpp	/^PT rotateccw90(PT a) { return PT(-a.y, a.x); }$/;"	f	typeref:typename:PT
rotateccw90	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    Angle rotateccw90() const { return {-y, x}; }$/;"	f	struct:Angle	typeref:typename:Angle	file:
rotateccw90	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^PT rotateccw90(PT a) { return PT(-a.y, a.x); }$/;"	f	typeref:typename:PT
rotateccw90	code-library/Geometry/Half Plane Intersection.cpp	/^PT rotateccw90(PT a) { return PT(-a.y, a.x); }$/;"	f	typeref:typename:PT
rotateccw90	code-library/Geometry/Voronoi Diagram.cpp	/^PT rotateccw90(PT a) { return PT(-a.y, a.x); }$/;"	f	typeref:typename:PT
rotateccw90	code/Geometry/All Pair Segment Intersection.cpp	/^PT rotateccw90(PT a) {$/;"	f	typeref:typename:PT
rotateccw90	code/Geometry/Geometry 2D.cpp	/^PT rotateccw90(PT a) { return PT(-a.y, a.x); }$/;"	f	typeref:typename:PT
rotateccw90	code/Geometry/Geometry 3D.cpp	/^PT rotateccw90(PT a) { return PT(-a.y, a.x); }$/;"	f	typeref:typename:PT
rotateccw90	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    Angle rotateccw90() const { return {-y, x}; }$/;"	f	struct:Angle	typeref:typename:Angle	file:
rotateccw90	code/Geometry/Half Plane Intersection Dynamic.cpp	/^PT rotateccw90(PT a) { return PT(-a.y, a.x); }$/;"	f	typeref:typename:PT
rotateccw90	code/Geometry/Half Plane Intersection.cpp	/^PT rotateccw90(PT a) { return PT(-a.y, a.x); }$/;"	f	typeref:typename:PT
rotateccw90	code/Geometry/Voronoi Diagram.cpp	/^PT rotateccw90(PT a) { return PT(-a.y, a.x); }$/;"	f	typeref:typename:PT
rotatecw	code-library/Geometry/All Pair Segment Intersection.cpp	/^PT rotatecw(PT a, double t) {$/;"	f	typeref:typename:PT
rotatecw	code-library/Geometry/Geometry 2D.cpp	/^PT rotatecw(PT a, double t) { return PT(a.x * cos(t) + a.y * sin(t), -a.x * sin(t) + a.y * cos(t/;"	f	typeref:typename:PT
rotatecw	code-library/Geometry/Geometry 3D.cpp	/^PT rotatecw(PT a, double t) { return PT(a.x * cos(t) + a.y * sin(t), -a.x * sin(t) + a.y * cos(t/;"	f	typeref:typename:PT
rotatecw	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^PT rotatecw(PT a, double t) { return PT(a.x * cos(t) + a.y * sin(t), -a.x * sin(t) + a.y * cos(t/;"	f	typeref:typename:PT
rotatecw	code-library/Geometry/Half Plane Intersection.cpp	/^PT rotatecw(PT a, double t) { return PT(a.x * cos(t) + a.y * sin(t), -a.x * sin(t) + a.y * cos(t/;"	f	typeref:typename:PT
rotatecw	code-library/Geometry/Voronoi Diagram.cpp	/^PT rotatecw(PT a, double t) { return PT(a.x * cos(t) + a.y * sin(t), -a.x * sin(t) + a.y * cos(t/;"	f	typeref:typename:PT
rotatecw	code/Geometry/All Pair Segment Intersection.cpp	/^PT rotatecw(PT a, double t) {$/;"	f	typeref:typename:PT
rotatecw	code/Geometry/Geometry 2D.cpp	/^PT rotatecw(PT a, double t) { return PT(a.x * cos(t) + a.y * sin(t), -a.x * sin(t) + a.y * cos(t/;"	f	typeref:typename:PT
rotatecw	code/Geometry/Geometry 3D.cpp	/^PT rotatecw(PT a, double t) { return PT(a.x * cos(t) + a.y * sin(t), -a.x * sin(t) + a.y * cos(t/;"	f	typeref:typename:PT
rotatecw	code/Geometry/Half Plane Intersection Dynamic.cpp	/^PT rotatecw(PT a, double t) { return PT(a.x * cos(t) + a.y * sin(t), -a.x * sin(t) + a.y * cos(t/;"	f	typeref:typename:PT
rotatecw	code/Geometry/Half Plane Intersection.cpp	/^PT rotatecw(PT a, double t) { return PT(a.x * cos(t) + a.y * sin(t), -a.x * sin(t) + a.y * cos(t/;"	f	typeref:typename:PT
rotatecw	code/Geometry/Voronoi Diagram.cpp	/^PT rotatecw(PT a, double t) { return PT(a.x * cos(t) + a.y * sin(t), -a.x * sin(t) + a.y * cos(t/;"	f	typeref:typename:PT
rotatecw90	code-library/Geometry/All Pair Segment Intersection.cpp	/^PT rotatecw90(PT a) {$/;"	f	typeref:typename:PT
rotatecw90	code-library/Geometry/Delaunay Triangulation.cpp	/^dPT rotatecw90(dPT a) { return dPT(a.y, -a.x); }$/;"	f	typeref:typename:dPT
rotatecw90	code-library/Geometry/Geometry 2D.cpp	/^PT rotatecw90(PT a) { return PT(a.y, -a.x); }$/;"	f	typeref:typename:PT
rotatecw90	code-library/Geometry/Geometry 3D.cpp	/^PT rotatecw90(PT a) { return PT(a.y, -a.x); }$/;"	f	typeref:typename:PT
rotatecw90	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^PT rotatecw90(PT a) { return PT(a.y, -a.x); }$/;"	f	typeref:typename:PT
rotatecw90	code-library/Geometry/Half Plane Intersection.cpp	/^PT rotatecw90(PT a) { return PT(a.y, -a.x); }$/;"	f	typeref:typename:PT
rotatecw90	code-library/Geometry/Voronoi Diagram.cpp	/^PT rotatecw90(PT a) { return PT(a.y, -a.x); }$/;"	f	typeref:typename:PT
rotatecw90	code/Geometry/All Pair Segment Intersection.cpp	/^PT rotatecw90(PT a) {$/;"	f	typeref:typename:PT
rotatecw90	code/Geometry/Delaunay Triangulation.cpp	/^dPT rotatecw90(dPT a) { return dPT(a.y, -a.x); }$/;"	f	typeref:typename:dPT
rotatecw90	code/Geometry/Geometry 2D.cpp	/^PT rotatecw90(PT a) { return PT(a.y, -a.x); }$/;"	f	typeref:typename:PT
rotatecw90	code/Geometry/Geometry 3D.cpp	/^PT rotatecw90(PT a) { return PT(a.y, -a.x); }$/;"	f	typeref:typename:PT
rotatecw90	code/Geometry/Half Plane Intersection Dynamic.cpp	/^PT rotatecw90(PT a) { return PT(a.y, -a.x); }$/;"	f	typeref:typename:PT
rotatecw90	code/Geometry/Half Plane Intersection.cpp	/^PT rotatecw90(PT a) { return PT(a.y, -a.x); }$/;"	f	typeref:typename:PT
rotatecw90	code/Geometry/Voronoi Diagram.cpp	/^PT rotatecw90(PT a) { return PT(a.y, -a.x); }$/;"	f	typeref:typename:PT
row	code-library/Strings/Bit LCS.cpp	/^} row, bs[SIGMA], x;$/;"	v	typeref:struct:Bitset
row	code/Strings/Bit LCS.cpp	/^} row, bs[SIGMA], x;$/;"	v	typeref:struct:Bitset
rrep	contests/Codeforces/737/D.cpp	/^#define rrep(/;"	d	file:
rrep	contests/Codeforces/737/E.cpp	/^#define rrep(/;"	d	file:
rt	code-library/Data Structures/MOs with DSU.cpp	/^int rt, cnt_q;$/;"	v	typeref:typename:int
rt	code-library/Data Structures/Reachability Tree.cpp	/^} rt;$/;"	v	typeref:struct:RT
rt	code/Data Structures/MOs with DSU.cpp	/^int rt, cnt_q;$/;"	v	typeref:typename:int
rt	code/Data Structures/Reachability Tree.cpp	/^} rt;$/;"	v	typeref:struct:RT
ru	code-library/Data Structures/MOs with DSU.cpp	/^    int u, ru, v, rv;$/;"	m	struct:persistent_dsu::state	typeref:typename:int	file:
ru	code/Data Structures/MOs with DSU.cpp	/^    int u, ru, v, rv;$/;"	m	struct:persistent_dsu::state	typeref:typename:int	file:
run	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  long long run() {$/;"	f	struct:Dinic	typeref:typename:long long	file:
run	code/Graph Theory/Gomory Hu Tree.cpp	/^  long long run() {$/;"	f	struct:Dinic	typeref:typename:long long	file:
rv	code-library/Data Structures/MOs with DSU.cpp	/^    int u, ru, v, rv;$/;"	m	struct:persistent_dsu::state	typeref:typename:int	file:
rv	code/Data Structures/MOs with DSU.cpp	/^    int u, ru, v, rv;$/;"	m	struct:persistent_dsu::state	typeref:typename:int	file:
s	.config/nvim/init.vim	/^nmap        s   <Plug>(vsnip-select-text)$/;"	m
s	.config/nvim/init.vim	/^xmap        s   <Plug>(vsnip-select-text)$/;"	m
s	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^mint s[N], P = 37;$/;"	v	typeref:typename:mint[]
s	code-library/Data Structures/Sparse Table 2D.cpp	/^string s[N];$/;"	v	typeref:typename:string[]
s	code-library/Data Structures/Static to Dynamic Trick.cpp	/^string s[N];$/;"	v	typeref:typename:string[]
s	code-library/Dynamic Programming Optimizations/1D1D DP.cpp	/^int n, s, t[N], f[N];$/;"	v	typeref:typename:int
s	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^ll ans[N], p[N], s[N];$/;"	v	typeref:typename:ll[]
s	code-library/Graph Theory/Dinics Algorithm.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
s	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  int V, s, t;$/;"	m	struct:Dinic	typeref:typename:int	file:
s	code-library/Graph Theory/L R Flow with Dinic.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
s	code-library/Graph Theory/L R Flow with Dinic.cpp	/^  int n, s, t;$/;"	m	struct:LR_Flow	typeref:typename:int	file:
s	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  int n, s, t, mxid;$/;"	m	struct:MCMF	typeref:typename:int	file:
s	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  int n, s, t;$/;"	m	struct:LR_Flow	typeref:typename:int	file:
s	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
s	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
s	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^int s, t, n, m, u[N], v[N], deg[N];$/;"	v	typeref:typename:int
s	code-library/Graph Theory/Min Cost Max Flow.cpp	/^  int n, s, t, mxid;$/;"	m	struct:MCMF	typeref:typename:int	file:
s	code-library/Graph Theory/Min Cut in a Planar Graph.cpp	/^int n, s, t, a[N];$/;"	v	typeref:typename:int
s	code-library/Graph Theory/Prim's MST.cpp	/^string s[N];$/;"	v	typeref:typename:string[]
s	code-library/Graph Theory/Unique Min Cut.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
s	code-library/Number Theory/K Divisors.cpp	/^ll pw[C][L]; int s[M]; $/;"	v	typeref:typename:int[]
s	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^    u64 m, s, x;$/;"	m	struct:poly::fast_div	typeref:typename:u64	file:
s	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^string s[N]; \/\/it assumes all strings are distinct$/;"	v	typeref:typename:string[]
s	code-library/Strings/Aho Corasick Dynamic.cpp	/^string s[N];$/;"	v	typeref:typename:string[]
s	code-library/Strings/Palindromic Tree Persistent.cpp	/^  string s; vector<node> t;$/;"	m	struct:PalindromicTree	typeref:typename:string	file:
s	code-library/Strings/Palindromic Tree.cpp	/^  string s;$/;"	m	struct:PalindromicTree	typeref:typename:string	file:
s	code-library/Strings/Prefix Automaton.cpp	/^string s, p;$/;"	v	typeref:typename:string
s	code-library/Strings/String Hashing.cpp	/^  string s; \/\/ 0 - indexed$/;"	m	struct:Hashing	typeref:typename:string	file:
s	code-library/Strings/Suffix Array Isomorphic.cpp	/^  string s;$/;"	m	struct:IsomorphicSuffixArray	typeref:typename:string	file:
s	code-library/Strings/Suffix Array Isomorphic.cpp	/^  vector<int> s;$/;"	m	struct:SuffixArray	typeref:typename:vector<int>	file:
s	code-library/Strings/Suffix Array.cpp	/^  string s;$/;"	m	struct:SuffixArray	typeref:typename:string	file:
s	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^mint s[N], P = 37;$/;"	v	typeref:typename:mint[]
s	code/Data Structures/Sparse Table 2D.cpp	/^string s[N];$/;"	v	typeref:typename:string[]
s	code/Data Structures/Static to Dynamic Trick.cpp	/^string s[N];$/;"	v	typeref:typename:string[]
s	code/Dynamic Programming Optimizations/1D1D DP.cpp	/^int n, s, t[N], f[N];$/;"	v	typeref:typename:int
s	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^ll ans[N], p[N], s[N];$/;"	v	typeref:typename:ll[]
s	code/Graph Theory/Dinics Algorithm.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
s	code/Graph Theory/Gomory Hu Tree.cpp	/^  int V, s, t;$/;"	m	struct:Dinic	typeref:typename:int	file:
s	code/Graph Theory/L R Flow with Dinic.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
s	code/Graph Theory/L R Flow with Dinic.cpp	/^  int n, s, t;$/;"	m	struct:LR_Flow	typeref:typename:int	file:
s	code/Graph Theory/L R Flow with MCMF.cpp	/^  int n, s, t, mxid;$/;"	m	struct:MCMF	typeref:typename:int	file:
s	code/Graph Theory/L R Flow with MCMF.cpp	/^  int n, s, t;$/;"	m	struct:LR_Flow	typeref:typename:int	file:
s	code/Graph Theory/Maximum Closure Problem.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
s	code/Graph Theory/Maximum Density Subgraph.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
s	code/Graph Theory/Maximum Density Subgraph.cpp	/^int s, t, n, m, u[N], v[N], deg[N];$/;"	v	typeref:typename:int
s	code/Graph Theory/Min Cost Max Flow.cpp	/^  int n, s, t, mxid;$/;"	m	struct:MCMF	typeref:typename:int	file:
s	code/Graph Theory/Min Cut in a Planar Graph.cpp	/^int n, s, t, a[N];$/;"	v	typeref:typename:int
s	code/Graph Theory/Prim's MST.cpp	/^string s[N];$/;"	v	typeref:typename:string[]
s	code/Graph Theory/Unique Min Cut.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
s	code/Number Theory/K Divisors.cpp	/^ll pw[C][L]; int s[M]; $/;"	v	typeref:typename:int[]
s	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^    u64 m, s, x;$/;"	m	struct:poly::fast_div	typeref:typename:u64	file:
s	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^string s[N]; \/\/it assumes all strings are distinct$/;"	v	typeref:typename:string[]
s	code/Strings/Aho Corasick Dynamic.cpp	/^string s[N];$/;"	v	typeref:typename:string[]
s	code/Strings/Palindromic Tree Persistent.cpp	/^  string s; vector<node> t;$/;"	m	struct:PalindromicTree	typeref:typename:string	file:
s	code/Strings/Palindromic Tree.cpp	/^  string s;$/;"	m	struct:PalindromicTree	typeref:typename:string	file:
s	code/Strings/Prefix Automaton.cpp	/^string s, p;$/;"	v	typeref:typename:string
s	code/Strings/String Hashing.cpp	/^  string s; \/\/ 0 - indexed$/;"	m	struct:Hashing	typeref:typename:string	file:
s	code/Strings/Suffix Array Isomorphic.cpp	/^  string s;$/;"	m	struct:IsomorphicSuffixArray	typeref:typename:string	file:
s	code/Strings/Suffix Array Isomorphic.cpp	/^  vector<int> s;$/;"	m	struct:SuffixArray	typeref:typename:vector<int>	file:
s	code/Strings/Suffix Array.cpp	/^  string s;$/;"	m	struct:SuffixArray	typeref:typename:string	file:
s	dotfiles/init.vim	/^nmap        s   <Plug>(vsnip-select-text)$/;"	m
s	dotfiles/init.vim	/^xmap        s   <Plug>(vsnip-select-text)$/;"	m
sa	code-library/Strings/Suffix Array Isomorphic.cpp	/^  vector<int> sa, rank, lcp, a;$/;"	m	struct:IsomorphicSuffixArray	typeref:typename:vector<int>	file:
sa	code-library/Strings/Suffix Array Isomorphic.cpp	/^  vector<int> sa, rank, lcp;$/;"	m	struct:SuffixArray	typeref:typename:vector<int>	file:
sa	code-library/Strings/Suffix Array.cpp	/^  vector<int> sa, rank, lcp;$/;"	m	struct:SuffixArray	typeref:typename:vector<int>	file:
sa	code/Strings/Suffix Array Isomorphic.cpp	/^  vector<int> sa, rank, lcp, a;$/;"	m	struct:IsomorphicSuffixArray	typeref:typename:vector<int>	file:
sa	code/Strings/Suffix Array Isomorphic.cpp	/^  vector<int> sa, rank, lcp;$/;"	m	struct:SuffixArray	typeref:typename:vector<int>	file:
sa	code/Strings/Suffix Array.cpp	/^  vector<int> sa, rank, lcp;$/;"	m	struct:SuffixArray	typeref:typename:vector<int>	file:
same	code-library/Data Structures/DSU Partially Persistent.cpp	/^  bool same(int u, int v, int t) {$/;"	f	struct:DSU	typeref:typename:bool	file:
same	code-library/Data Structures/DSU.cpp	/^  bool same(int i, int j) {$/;"	f	struct:DSU	typeref:typename:bool	file:
same	code-library/Data Structures/Persistent UnionFind.cpp	/^  bool same(int r, int u, int v) { return find(r, u) == find(r, v); }$/;"	f	struct:PersistentDSU	typeref:typename:bool	file:
same	code-library/Geometry/Geometry 3D.cpp	/^    bool same(int s, int t) {$/;"	f	struct:CH3D	typeref:typename:bool	file:
same	code-library/Geometry/Geometry 3D.cpp	/^    bool same; \/\/ is the common edge in the same order?$/;"	m	struct:edge	typeref:typename:bool	file:
same	code-library/Graph Theory/Boruvka's Algorithm.cpp	/^  bool same(int i, int j) { return find(i) == find(j); }$/;"	f	struct:dsu	typeref:typename:bool	file:
same	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  bool same(int i, int j) {$/;"	f	struct:dsu	typeref:typename:bool	file:
same	code-library/Graph Theory/Kirchoffs Theorem.cpp	/^  bool same(int i, int j) {$/;"	f	struct:dsu	typeref:typename:bool	file:
same	code-library/Graph Theory/Krushkal's MST.cpp	/^  bool same(int i, int j) { return find(i) == find(j); }$/;"	f	struct:dsu	typeref:typename:bool	file:
same	code/Data Structures/DSU Partially Persistent.cpp	/^  bool same(int u, int v, int t) {$/;"	f	struct:DSU	typeref:typename:bool	file:
same	code/Data Structures/DSU.cpp	/^  bool same(int i, int j) {$/;"	f	struct:DSU	typeref:typename:bool	file:
same	code/Data Structures/Persistent UnionFind.cpp	/^  bool same(int r, int u, int v) { return find(r, u) == find(r, v); }$/;"	f	struct:PersistentDSU	typeref:typename:bool	file:
same	code/Geometry/Geometry 3D.cpp	/^    bool same(int s, int t) {$/;"	f	struct:CH3D	typeref:typename:bool	file:
same	code/Geometry/Geometry 3D.cpp	/^    bool same; \/\/ is the common edge in the same order?$/;"	m	struct:edge	typeref:typename:bool	file:
same	code/Graph Theory/Boruvka's Algorithm.cpp	/^  bool same(int i, int j) { return find(i) == find(j); }$/;"	f	struct:dsu	typeref:typename:bool	file:
same	code/Graph Theory/Gomory Hu Tree.cpp	/^  bool same(int i, int j) {$/;"	f	struct:dsu	typeref:typename:bool	file:
same	code/Graph Theory/Kirchoffs Theorem.cpp	/^  bool same(int i, int j) {$/;"	f	struct:dsu	typeref:typename:bool	file:
same	code/Graph Theory/Krushkal's MST.cpp	/^  bool same(int i, int j) { return find(i) == find(j); }$/;"	f	struct:dsu	typeref:typename:bool	file:
same_set	contests/USACO/dec_silver_2021/B/brute.cpp	/^	bool same_set(int a, int b) { return get(a) == get(b); }$/;"	f	struct:DSU	typeref:typename:bool	file:
same_set	practice/usacoguide/gold/dsu/closing/main.cpp	/^	bool same_set(int a, int b) { return get(a) == get(b); }$/;"	f	struct:DSU	typeref:typename:bool	file:
same_set	practice/usacoguide/gold/dsu/moocast/main.cpp	/^	bool same_set(int a, int b) { return get(a) == get(b); }$/;"	f	struct:DSU	typeref:typename:bool	file:
same_set	practice/usacoguide/gold/dsu/mootube/main.cpp	/^	bool same_set(int a, int b) { return get(a) == get(b); }$/;"	f	struct:DSU	typeref:typename:bool	file:
same_set	practice/usacoguide/gold/dsu/tractor/main.cpp	/^	bool same_set(int a, int b) { return get(a) == get(b); }$/;"	f	struct:DSU	typeref:typename:bool	file:
same_set	practice/usacoguide/gold/dsu/tractor/mountain.cpp	/^	bool same_set(int a, int b) { return get(a) == get(b); }$/;"	f	struct:DSU	typeref:typename:bool	file:
same_set	practice/usacoguide/gold/dsu/wormhole/main.cpp	/^	bool same_set(int a, int b) { return get(a) == get(b); }$/;"	f	struct:DSU	typeref:typename:bool	file:
same_set	practice/usacoguide/silver/idk/lirs/main.cpp	/^	bool same_set(int a, int b) { return get(a) == get(b); }$/;"	f	struct:DSU	typeref:typename:bool	file:
save_memory	code-library/Data Structures/Segment Tree Merging.cpp	/^  inline void save_memory(int x) {$/;"	f	struct:STM	typeref:typename:void	file:
save_memory	code/Data Structures/Segment Tree Merging.cpp	/^  inline void save_memory(int x) {$/;"	f	struct:STM	typeref:typename:void	file:
save_samples	.compilingScripts/download_prob.py	/^def save_samples(data, probDir):$/;"	f
sc	code-library/Dynamic Programming Optimizations/Divide and Conquer Optimization.cpp	/^int sc() {$/;"	f	typeref:typename:int
sc	code-library/Strings/Number of Palindromes in Range.cpp	/^int sc() {$/;"	f	typeref:typename:int
sc	code/Dynamic Programming Optimizations/Divide and Conquer Optimization.cpp	/^int sc() {$/;"	f	typeref:typename:int
sc	code/Strings/Number of Palindromes in Range.cpp	/^int sc() {$/;"	f	typeref:typename:int
scale	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  static constexpr int scale = 2;$/;"	m	struct:mcSFlow	typeref:typename:int	file:
scale	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^  static constexpr int scale = 2;$/;"	m	struct:mcSFlow	typeref:typename:int	file:
scan	code-library/Geometry/Geometry 3D.cpp	/^    void scan() { cin >> x >> y >> z; }$/;"	f	struct:p3	typeref:typename:void	file:
scan	code-library/Geometry/Geometry 3D.cpp	/^    void scan() { cin >> x >> y; }$/;"	f	struct:PT	typeref:typename:void	file:
scan	code/Geometry/Geometry 3D.cpp	/^    void scan() { cin >> x >> y >> z; }$/;"	f	struct:p3	typeref:typename:void	file:
scan	code/Geometry/Geometry 3D.cpp	/^    void scan() { cin >> x >> y; }$/;"	f	struct:PT	typeref:typename:void	file:
sdom	code-library/Graph Theory/Dominator Tree.cpp	/^int sdom[N], par[N], idom[N], dsu[N], label[N];$/;"	v	typeref:typename:int[]
sdom	code/Graph Theory/Dominator Tree.cpp	/^int sdom[N], par[N], idom[N], dsu[N], label[N];$/;"	v	typeref:typename:int[]
se	code-library/Data Structures/BST using STL.cpp	/^set<int>se;$/;"	v	typeref:typename:set<int>
se	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^set<pair<int, int>>se;$/;"	v	typeref:typename:set<pair<int,int>>
se	code-library/Data Structures/Interval Set.cpp	/^interval_set<int>se;$/;"	v	typeref:typename:interval_set<int>
se	code/Data Structures/BST using STL.cpp	/^set<int>se;$/;"	v	typeref:typename:set<int>
se	code/Data Structures/Dynamic Connectivity Problem.cpp	/^set<pair<int, int>>se;$/;"	v	typeref:typename:set<pair<int,int>>
se	code/Data Structures/Interval Set.cpp	/^interval_set<int>se;$/;"	v	typeref:typename:interval_set<int>
se	practice/usacoguide/gold/introDP/711C.cpp	/^#define se /;"	d	file:
search_up	.compilingScripts/make_prob.sh	/^search_up ()$/;"	f
second	practice/usacoguide/gold/bfs/cownav.cpp	/^	int first, second, direction;$/;"	m	struct:Point	typeref:typename:int	file:
seg	code-library/Geometry/All Pair Segment Intersection.cpp	/^    seg(PT a, PT b, int c) {$/;"	f	struct:seg	file:
seg	code-library/Geometry/All Pair Segment Intersection.cpp	/^struct seg {$/;"	s	file:
seg	code-library/Geometry/Geometry 2D.cpp	/^    vector<pair<double, double> > seg, cover;$/;"	m	struct:CircleUnion	typeref:typename:vector<pair<double,double>>	file:
seg	code/Geometry/All Pair Segment Intersection.cpp	/^    seg(PT a, PT b, int c) {$/;"	f	struct:seg	file:
seg	code/Geometry/All Pair Segment Intersection.cpp	/^struct seg {$/;"	s	file:
seg	code/Geometry/Geometry 2D.cpp	/^    vector<pair<double, double> > seg, cover;$/;"	m	struct:CircleUnion	typeref:typename:vector<pair<double,double>>	file:
seg_line_intersection	code-library/Geometry/Geometry 2D.cpp	/^bool seg_line_intersection(PT a, PT b, PT c, PT d, PT &ans) {$/;"	f	typeref:typename:bool
seg_line_intersection	code/Geometry/Geometry 2D.cpp	/^bool seg_line_intersection(PT a, PT b, PT c, PT d, PT &ans) {$/;"	f	typeref:typename:bool
seg_line_relation	code-library/Geometry/Geometry 2D.cpp	/^int seg_line_relation(PT a, PT b, PT c, PT d) {$/;"	f	typeref:typename:int
seg_line_relation	code/Geometry/Geometry 2D.cpp	/^int seg_line_relation(PT a, PT b, PT c, PT d) {$/;"	f	typeref:typename:int
seg_seg_intersection	code-library/Geometry/Geometry 2D.cpp	/^bool seg_seg_intersection(PT a, PT b, PT c, PT d, PT &ans) {$/;"	f	typeref:typename:bool
seg_seg_intersection	code-library/Geometry/Voronoi Diagram.cpp	/^bool seg_seg_intersection(PT a, PT b, PT c, PT d, PT &ans) {$/;"	f	typeref:typename:bool
seg_seg_intersection	code/Geometry/Geometry 2D.cpp	/^bool seg_seg_intersection(PT a, PT b, PT c, PT d, PT &ans) {$/;"	f	typeref:typename:bool
seg_seg_intersection	code/Geometry/Voronoi Diagram.cpp	/^bool seg_seg_intersection(PT a, PT b, PT c, PT d, PT &ans) {$/;"	f	typeref:typename:bool
seg_seg_intersection_inside	code-library/Geometry/Geometry 2D.cpp	/^set<PT> seg_seg_intersection_inside(PT a,  PT b,  PT c,  PT d) {$/;"	f	typeref:typename:set<PT>
seg_seg_intersection_inside	code/Geometry/Geometry 2D.cpp	/^set<PT> seg_seg_intersection_inside(PT a,  PT b,  PT c,  PT d) {$/;"	f	typeref:typename:set<PT>
segment_segment_intersection_on_sphere	code-library/Geometry/Geometry 3D.cpp	/^Set segment_segment_intersection_on_sphere(p3 a, p3 b, p3 c, p3 d) {$/;"	f	typeref:typename:Set
segment_segment_intersection_on_sphere	code/Geometry/Geometry 3D.cpp	/^Set segment_segment_intersection_on_sphere(p3 a, p3 b, p3 c, p3 d) {$/;"	f	typeref:typename:Set
segtree	code-library/Graph Theory/Path Union.cpp	/^struct segtree {$/;"	s	file:
segtree	code/Graph Theory/Path Union.cpp	/^struct segtree {$/;"	s	file:
selected	code-library/Graph Theory/Prim's MST.cpp	/^int g[N][N], w[N], to[N], selected[N];$/;"	v	typeref:typename:int[]
selected	code/Graph Theory/Prim's MST.cpp	/^int g[N][N], w[N], to[N], selected[N];$/;"	v	typeref:typename:int[]
send_flow	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  T send_flow(int v, T cur) {$/;"	f	struct:MCMF	typeref:typename:T	file:
send_flow	code-library/Graph Theory/Min Cost Max Flow.cpp	/^  T send_flow(int v, T cur) {$/;"	f	struct:MCMF	typeref:typename:T	file:
send_flow	code/Graph Theory/L R Flow with MCMF.cpp	/^  T send_flow(int v, T cur) {$/;"	f	struct:MCMF	typeref:typename:T	file:
send_flow	code/Graph Theory/Min Cost Max Flow.cpp	/^  T send_flow(int v, T cur) {$/;"	f	struct:MCMF	typeref:typename:T	file:
seq	code-library/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^  ll seq[P];$/;"	v	namespace:PollardRho	typeref:typename:ll[]
seq	code-library/Number Theory/Pisano Period.cpp	/^  ll seq[P];$/;"	v	namespace:PollardRho	typeref:typename:ll[]
seq	code-library/Number Theory/Pollard Rho.cpp	/^  ll seq[P];$/;"	v	namespace:PollardRho	typeref:typename:ll[]
seq	code/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^  ll seq[P];$/;"	v	namespace:PollardRho	typeref:typename:ll[]
seq	code/Number Theory/Pisano Period.cpp	/^  ll seq[P];$/;"	v	namespace:PollardRho	typeref:typename:ll[]
seq	code/Number Theory/Pollard Rho.cpp	/^  ll seq[P];$/;"	v	namespace:PollardRho	typeref:typename:ll[]
set	code-library/Data Structures/Link Cut Tree.cpp	/^  void set(int x, int d, int y) {$/;"	f	struct:LCT	typeref:typename:void	file:
set	code-library/Data Structures/Persistent UnionFind.cpp	/^  void set(int r, int i, T x) {$/;"	f	struct:PersistentArray	typeref:typename:void	file:
set	code-library/Miscellaneous/Bitset Custom.cpp	/^    void set() {$/;"	f	struct:Bitset	typeref:typename:void	file:
set	code-library/Miscellaneous/Bitset Custom.cpp	/^    void set(int i) {$/;"	f	struct:Bitset	typeref:typename:void	file:
set	code-library/Miscellaneous/Bitset Custom.cpp	/^    void set(int l, int r) {$/;"	f	struct:Bitset	typeref:typename:void	file:
set	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  void set(word_t n) const { this->x = n; }$/;"	f	class:ntt::Mod	typeref:typename:void	file:
set	code-library/Strings/Bit LCS.cpp	/^    void set(int x) {$/;"	f	struct:Bitset	typeref:typename:void	file:
set	code/Data Structures/Link Cut Tree.cpp	/^  void set(int x, int d, int y) {$/;"	f	struct:LCT	typeref:typename:void	file:
set	code/Data Structures/Persistent UnionFind.cpp	/^  void set(int r, int i, T x) {$/;"	f	struct:PersistentArray	typeref:typename:void	file:
set	code/Miscellaneous/Bitset Custom.cpp	/^    void set() {$/;"	f	struct:Bitset	typeref:typename:void	file:
set	code/Miscellaneous/Bitset Custom.cpp	/^    void set(int i) {$/;"	f	struct:Bitset	typeref:typename:void	file:
set	code/Miscellaneous/Bitset Custom.cpp	/^    void set(int l, int r) {$/;"	f	struct:Bitset	typeref:typename:void	file:
set	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  void set(word_t n) const { this->x = n; }$/;"	f	class:ntt::Mod	typeref:typename:void	file:
set	code/Strings/Bit LCS.cpp	/^    void set(int x) {$/;"	f	struct:Bitset	typeref:typename:void	file:
set_match	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  inline void set_match(int u, int v) {$/;"	f	struct:Blossom	typeref:typename:void	file:
set_match	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  inline void set_match(int u, int v) {$/;"	f	struct:Blossom	typeref:typename:void	file:
set_mod	code-library/Number Theory/Prime Factorization Fastest.cpp	/^  static void set_mod(const uint64_t &m) {$/;"	f	struct:Mint	typeref:typename:void	file:
set_mod	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static void set_mod(R m, int N=2) {$/;"	f	class:poly	typeref:typename:void	file:
set_mod	code/Number Theory/Prime Factorization Fastest.cpp	/^  static void set_mod(const uint64_t &m) {$/;"	f	struct:Mint	typeref:typename:void	file:
set_mod	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static void set_mod(R m, int N=2) {$/;"	f	class:poly	typeref:typename:void	file:
set_par	code-library/Graph Theory/Directed MST.cpp	/^  void set_par(int c, int p) { par[c] = p; }$/;"	f	struct:DSU	typeref:typename:void	file:
set_par	code/Graph Theory/Directed MST.cpp	/^  void set_par(int c, int p) { par[c] = p; }$/;"	f	struct:DSU	typeref:typename:void	file:
set_slack	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  inline void set_slack(int x) {$/;"	f	struct:Blossom	typeref:typename:void	file:
set_slack	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  inline void set_slack(int x) {$/;"	f	struct:Blossom	typeref:typename:void	file:
set_st	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  inline void set_st(int x, int b) {$/;"	f	struct:Blossom	typeref:typename:void	file:
set_st	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  inline void set_st(int x, int b) {$/;"	f	struct:Blossom	typeref:typename:void	file:
sgn	code-library/Geometry/Voronoi Diagram.cpp	/^int sgn(long long x) { return (x > 0) - (x < 0); }$/;"	f	typeref:typename:int
sgn	code-library/Miscellaneous/BigInt.cpp	/^  int sgn;$/;"	m	struct:BigInt	typeref:typename:int	file:
sgn	code/Geometry/Voronoi Diagram.cpp	/^int sgn(long long x) { return (x > 0) - (x < 0); }$/;"	f	typeref:typename:int
sgn	code/Miscellaneous/BigInt.cpp	/^  int sgn;$/;"	m	struct:BigInt	typeref:typename:int	file:
shift	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^    Int shift(mint n) {return Int((a + (n - 1) * d), d);}$/;"	f	struct:ST::Int	typeref:typename:Int	file:
shift	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly shift(mint a) { \/\/p(x + a)$/;"	f	struct:poly	typeref:typename:poly	file:
shift	code-library/Math/NTT.cpp	/^vector<int> shift(vector<int> &f, int c) { \/\/f(x + c)$/;"	f	typeref:typename:vector<int>
shift	code-library/Math/Polynomial.cpp	/^  poly shift(mint a) { \/\/p(x + a)$/;"	f	struct:poly	typeref:typename:poly	file:
shift	code-library/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^vector<int> shift(vector<int> &f, int c) { \/\/f(x + c)$/;"	f	typeref:typename:vector<int>
shift	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^    Int shift(mint n) {return Int((a + (n - 1) * d), d);}$/;"	f	struct:ST::Int	typeref:typename:Int	file:
shift	code/Math/Faulhaber Formula Fastest.cpp	/^  poly shift(mint a) { \/\/p(x + a)$/;"	f	struct:poly	typeref:typename:poly	file:
shift	code/Math/NTT.cpp	/^vector<int> shift(vector<int> &f, int c) { \/\/f(x + c)$/;"	f	typeref:typename:vector<int>
shift	code/Math/Polynomial.cpp	/^  poly shift(mint a) { \/\/p(x + a)$/;"	f	struct:poly	typeref:typename:poly	file:
shift	code/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^vector<int> shift(vector<int> &f, int c) { \/\/f(x + c)$/;"	f	typeref:typename:vector<int>
shiftUp	code-library/Geometry/Geometry 3D.cpp	/^    plane shiftUp(double dist) { return {n, d + dist * abs(n)}; }$/;"	f	struct:plane	typeref:typename:plane	file:
shiftUp	code/Geometry/Geometry 3D.cpp	/^    plane shiftUp(double dist) { return {n, d + dist * abs(n)}; }$/;"	f	struct:plane	typeref:typename:plane	file:
shift_it	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly shift_it(int m, vector<poly> &pw) {$/;"	f	struct:poly	typeref:typename:poly	file:
shift_it	code-library/Math/Polynomial.cpp	/^  poly shift_it(int m, vector<poly> &pw) {$/;"	f	struct:poly	typeref:typename:poly	file:
shift_it	code/Math/Faulhaber Formula Fastest.cpp	/^  poly shift_it(int m, vector<poly> &pw) {$/;"	f	struct:poly	typeref:typename:poly	file:
shift_it	code/Math/Polynomial.cpp	/^  poly shift_it(int m, vector<poly> &pw) {$/;"	f	struct:poly	typeref:typename:poly	file:
shift_left	code-library/Geometry/Geometry 2D.cpp	/^	line shift_left(double d) {$/;"	f	struct:line	typeref:typename:line	file:
shift_left	code/Geometry/Geometry 2D.cpp	/^	line shift_left(double d) {$/;"	f	struct:line	typeref:typename:line	file:
shift_solution	code-library/Number Theory/Linear Diophantine Equation with Two Variables.cpp	/^void shift_solution(ll &x, ll &y, ll a, ll b, ll cnt) {$/;"	f	typeref:typename:void
shift_solution	code/Number Theory/Linear Diophantine Equation with Two Variables.cpp	/^void shift_solution(ll &x, ll &y, ll a, ll b, ll cnt) {$/;"	f	typeref:typename:void
shl	code-library/Strings/Bit LCS.cpp	/^    void shl() {$/;"	f	struct:Bitset	typeref:typename:void	file:
shl	code/Strings/Bit LCS.cpp	/^    void shl() {$/;"	f	struct:Bitset	typeref:typename:void	file:
show_extended_sequence	code-library/Math/Linear Recurrence With Polynomial Coefficients.cpp	/^void show_extended_sequence(int n, const vector<int>& terms, int degree, int mod) {$/;"	f	typeref:typename:void
show_extended_sequence	code/Math/Linear Recurrence With Polynomial Coefficients.cpp	/^void show_extended_sequence(int n, const vector<int>& terms, int degree, int mod) {$/;"	f	typeref:typename:void
side	code-library/Geometry/Geometry 2D.cpp	/^    int side(PT p) { return sign(cross(v, p) - c); }$/;"	f	struct:line	typeref:typename:int	file:
side	code-library/Geometry/Geometry 3D.cpp	/^    double side(p3 p) { return (n | p) - d; }$/;"	f	struct:plane	typeref:typename:double	file:
side	code/Geometry/Geometry 2D.cpp	/^    int side(PT p) { return sign(cross(v, p) - c); }$/;"	f	struct:line	typeref:typename:int	file:
side	code/Geometry/Geometry 3D.cpp	/^    double side(p3 p) { return (n | p) - d; }$/;"	f	struct:plane	typeref:typename:double	file:
sieve	code-library/Number Theory/K Divisors.cpp	/^  void sieve(int n) {$/;"	f	namespace:pcf	typeref:typename:void
sieve	code-library/Number Theory/Linear Sieve for Multiplicative Functions.cpp	/^void sieve() {$/;"	f	typeref:typename:void
sieve	code-library/Number Theory/Min_25 Sieve.cpp	/^void sieve(int n) {$/;"	f	typeref:typename:void
sieve	code-library/Number Theory/Prime Counting Function.cpp	/^  void sieve(int n) {$/;"	f	namespace:pcf	typeref:typename:void
sieve	code-library/Number Theory/Sieve upto 1e9.cpp	/^vector<int> sieve(const int N, const int Q = 17, const int L = 1 << 15) {$/;"	f	typeref:typename:vector<int>
sieve	code-library/Number Theory/Sieve.cpp	/^void sieve() {$/;"	f	typeref:typename:void
sieve	code-library/Number Theory/Smallest Number Having Exactly K Divisors.cpp	/^void sieve() {$/;"	f	typeref:typename:void
sieve	code-library/Number Theory/nCr Modulo Any Mod.cpp	/^void sieve() {$/;"	f	typeref:typename:void
sieve	code/Number Theory/K Divisors.cpp	/^  void sieve(int n) {$/;"	f	namespace:pcf	typeref:typename:void
sieve	code/Number Theory/Linear Sieve for Multiplicative Functions.cpp	/^void sieve() {$/;"	f	typeref:typename:void
sieve	code/Number Theory/Min_25 Sieve.cpp	/^void sieve(int n) {$/;"	f	typeref:typename:void
sieve	code/Number Theory/Prime Counting Function.cpp	/^  void sieve(int n) {$/;"	f	namespace:pcf	typeref:typename:void
sieve	code/Number Theory/Sieve upto 1e9.cpp	/^vector<int> sieve(const int N, const int Q = 17, const int L = 1 << 15) {$/;"	f	typeref:typename:vector<int>
sieve	code/Number Theory/Sieve.cpp	/^void sieve() {$/;"	f	typeref:typename:void
sieve	code/Number Theory/Smallest Number Having Exactly K Divisors.cpp	/^void sieve() {$/;"	f	typeref:typename:void
sieve	code/Number Theory/nCr Modulo Any Mod.cpp	/^void sieve() {$/;"	f	typeref:typename:void
sieve	contests/Codeforces/1609/C.cpp	/^void sieve() {$/;"	f	typeref:typename:void
sieve	contests/Codeforces/1609/D.cpp	/^void sieve() {$/;"	f	typeref:typename:void
sign	code-library/Geometry/All Pair Segment Intersection.cpp	/^int sign(double x) {$/;"	f	typeref:typename:int
sign	code-library/Geometry/Delaunay Triangulation.cpp	/^int sign(long long x) { return (x > 0) - (x < 0); }$/;"	f	typeref:typename:int
sign	code-library/Geometry/Geometry 2D.cpp	/^    inline int sign(double x) {return x < -eps ? -1 : x > eps;}$/;"	f	struct:CircleUnion	typeref:typename:int	file:
sign	code-library/Geometry/Geometry 2D.cpp	/^    inline int sign(double x, double y) {return sign(x - y);}$/;"	f	struct:CircleUnion	typeref:typename:int	file:
sign	code-library/Geometry/Geometry 2D.cpp	/^int sign(double x) { return (x > eps) - (x < -eps); }$/;"	f	typeref:typename:int
sign	code-library/Geometry/Geometry 3D.cpp	/^int sign(double x) { return (x > eps) - (x < -eps); }$/;"	f	typeref:typename:int
sign	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^int sign(double x) { return (x > eps) - (x < -eps); }$/;"	f	typeref:typename:int
sign	code-library/Geometry/Half Plane Intersection.cpp	/^int sign(double x) { return (x > eps) - (x < -eps); }$/;"	f	typeref:typename:int
sign	code-library/Geometry/Point Location.cpp	/^int sign(const ll& x) { return le(x, 0) ? eq(x, 0) ? 0 : -1 : 1; }$/;"	f	typeref:typename:int
sign	code-library/Geometry/Voronoi Diagram.cpp	/^int sign(double x) { return (x > eps) - (x < -eps); }$/;"	f	typeref:typename:int
sign	code-library/Graph Theory/ST Numbering.cpp	/^int low[N], dis[N], T = 0, par[N], sign[N];$/;"	v	typeref:typename:int[]
sign	code/Geometry/All Pair Segment Intersection.cpp	/^int sign(double x) {$/;"	f	typeref:typename:int
sign	code/Geometry/Delaunay Triangulation.cpp	/^int sign(long long x) { return (x > 0) - (x < 0); }$/;"	f	typeref:typename:int
sign	code/Geometry/Geometry 2D.cpp	/^    inline int sign(double x) {return x < -eps ? -1 : x > eps;}$/;"	f	struct:CircleUnion	typeref:typename:int	file:
sign	code/Geometry/Geometry 2D.cpp	/^    inline int sign(double x, double y) {return sign(x - y);}$/;"	f	struct:CircleUnion	typeref:typename:int	file:
sign	code/Geometry/Geometry 2D.cpp	/^int sign(double x) { return (x > eps) - (x < -eps); }$/;"	f	typeref:typename:int
sign	code/Geometry/Geometry 3D.cpp	/^int sign(double x) { return (x > eps) - (x < -eps); }$/;"	f	typeref:typename:int
sign	code/Geometry/Half Plane Intersection Dynamic.cpp	/^int sign(double x) { return (x > eps) - (x < -eps); }$/;"	f	typeref:typename:int
sign	code/Geometry/Half Plane Intersection.cpp	/^int sign(double x) { return (x > eps) - (x < -eps); }$/;"	f	typeref:typename:int
sign	code/Geometry/Point Location.cpp	/^int sign(const ll& x) { return le(x, 0) ? eq(x, 0) ? 0 : -1 : 1; }$/;"	f	typeref:typename:int
sign	code/Geometry/Voronoi Diagram.cpp	/^int sign(double x) { return (x > eps) - (x < -eps); }$/;"	f	typeref:typename:int
sign	code/Graph Theory/ST Numbering.cpp	/^int low[N], dis[N], T = 0, par[N], sign[N];$/;"	v	typeref:typename:int[]
sim	practice/cpbook/ch1/1.6/card/10388/main2.cpp	/^int sim()$/;"	f	typeref:typename:int
simpson	code-library/Math/Integration (Simpsons).cpp	/^inline double simpson(double fl, double fr, double fmid, double l, double r){$/;"	f	typeref:typename:double
simpson	code/Math/Integration (Simpsons).cpp	/^inline double simpson(double fl, double fr, double fmid, double l, double r){$/;"	f	typeref:typename:double
sit	practice/usacoguide/gold/introDP/711C.cpp	/^typedef set<int>::iterator sit;$/;"	t	typeref:typename:set<int>::iterator	file:
size	code-library/Data Structures/DSU Partially Persistent.cpp	/^  int size(int u, int t) { \/\/size of the component of u at time t$/;"	f	struct:DSU	typeref:typename:int	file:
size	code-library/Data Structures/Implicit Treap.cpp	/^  int size() {$/;"	f	struct:treap	typeref:typename:int	file:
size	code-library/Data Structures/Implicit Treap.cpp	/^  int size(pnode t) {$/;"	f	struct:treap	typeref:typename:int	file:
size	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^  int size() {$/;"	f	struct:Block	typeref:typename:int	file:
size	code-library/Data Structures/Treap persistent.cpp	/^int size(node* t) {$/;"	f	namespace:PersistentTreap	typeref:typename:int
size	code-library/Data Structures/Venice Technique.cpp	/^  int size() { return Q.size(); }$/;"	f	struct:PQ	typeref:typename:int	file:
size	code-library/Graph Theory/Boruvka's Algorithm.cpp	/^  vector<int> par, rnk, size; int c;$/;"	m	struct:dsu	typeref:typename:vector<int>	file:
size	code-library/Graph Theory/Directed MST.cpp	/^  int size() { return Q.size(); }$/;"	f	struct:PQ	typeref:typename:int	file:
size	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  vector<int> par, rank, size;$/;"	m	struct:dsu	typeref:typename:vector<int>	file:
size	code-library/Graph Theory/Kirchoffs Theorem.cpp	/^  vector<int> par, rnk, size;$/;"	m	struct:dsu	typeref:typename:vector<int>	file:
size	code-library/Graph Theory/Krushkal's MST.cpp	/^  vector<int> par, rnk, size; int c;$/;"	m	struct:dsu	typeref:typename:vector<int>	file:
size	code-library/Graph Theory/Three Edge Connectivity.cpp	/^  int size() { return nxt.size(); }$/;"	f	struct:Components	typeref:typename:int	file:
size	code-library/Math/Faulhaber Formula Fastest.cpp	/^  int size() const { return (int)a.size(); }$/;"	f	struct:poly	typeref:typename:int	file:
size	code-library/Math/Polynomial.cpp	/^  int size() const { return (int)a.size(); }$/;"	f	struct:poly	typeref:typename:int	file:
size	code-library/Math/Subset Sum Problem.cpp	/^  int size() const { return (int)a.size(); }$/;"	f	struct:poly	typeref:typename:int	file:
size	code-library/Miscellaneous/Schreier–Sims algorithm.cpp	/^  ll size() {$/;"	f	struct:Group	typeref:typename:ll	file:
size	code-library/Number Theory/Bell Number.cpp	/^    int size() const { return (int)a.size(); }$/;"	f	struct:poly	typeref:typename:int	file:
size	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    int size() const { return (int)a.size(); }$/;"	f	struct:poly	typeref:typename:int	file:
size	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  int size() const { return coefs.size(); }$/;"	f	class:poly	typeref:typename:int	file:
size	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^const int size = 1 << 16;$/;"	v	namespace:ntt	typeref:typename:const int
size	code/Data Structures/DSU Partially Persistent.cpp	/^  int size(int u, int t) { \/\/size of the component of u at time t$/;"	f	struct:DSU	typeref:typename:int	file:
size	code/Data Structures/Implicit Treap.cpp	/^  int size() {$/;"	f	struct:treap	typeref:typename:int	file:
size	code/Data Structures/Implicit Treap.cpp	/^  int size(pnode t) {$/;"	f	struct:treap	typeref:typename:int	file:
size	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^  int size() {$/;"	f	struct:Block	typeref:typename:int	file:
size	code/Data Structures/Treap persistent.cpp	/^int size(node* t) {$/;"	f	namespace:PersistentTreap	typeref:typename:int
size	code/Data Structures/Venice Technique.cpp	/^  int size() { return Q.size(); }$/;"	f	struct:PQ	typeref:typename:int	file:
size	code/Graph Theory/Boruvka's Algorithm.cpp	/^  vector<int> par, rnk, size; int c;$/;"	m	struct:dsu	typeref:typename:vector<int>	file:
size	code/Graph Theory/Directed MST.cpp	/^  int size() { return Q.size(); }$/;"	f	struct:PQ	typeref:typename:int	file:
size	code/Graph Theory/Gomory Hu Tree.cpp	/^  vector<int> par, rank, size;$/;"	m	struct:dsu	typeref:typename:vector<int>	file:
size	code/Graph Theory/Kirchoffs Theorem.cpp	/^  vector<int> par, rnk, size;$/;"	m	struct:dsu	typeref:typename:vector<int>	file:
size	code/Graph Theory/Krushkal's MST.cpp	/^  vector<int> par, rnk, size; int c;$/;"	m	struct:dsu	typeref:typename:vector<int>	file:
size	code/Graph Theory/Three Edge Connectivity.cpp	/^  int size() { return nxt.size(); }$/;"	f	struct:Components	typeref:typename:int	file:
size	code/Math/Faulhaber Formula Fastest.cpp	/^  int size() const { return (int)a.size(); }$/;"	f	struct:poly	typeref:typename:int	file:
size	code/Math/Polynomial.cpp	/^  int size() const { return (int)a.size(); }$/;"	f	struct:poly	typeref:typename:int	file:
size	code/Math/Subset Sum Problem.cpp	/^  int size() const { return (int)a.size(); }$/;"	f	struct:poly	typeref:typename:int	file:
size	code/Miscellaneous/Schreier–Sims algorithm.cpp	/^  ll size() {$/;"	f	struct:Group	typeref:typename:ll	file:
size	code/Number Theory/Bell Number.cpp	/^    int size() const { return (int)a.size(); }$/;"	f	struct:poly	typeref:typename:int	file:
size	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    int size() const { return (int)a.size(); }$/;"	f	struct:poly	typeref:typename:int	file:
size	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  int size() const { return coefs.size(); }$/;"	f	class:poly	typeref:typename:int	file:
size	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^const int size = 1 << 16;$/;"	v	namespace:ntt	typeref:typename:const int
size	contests/USACO/dec_silver_2021/B/brute.cpp	/^	int size(int x) { return -e[get(x)]; }$/;"	f	struct:DSU	typeref:typename:int	file:
size	practice/cf/random/1700/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	n	object:batch
size	practice/cf/random/1700/1618E/problem.json	/^{"name": "E. Singers' Tour", "group": "Codeforces - Codeforces Round #760 (Div. 3)", "url": "htt/;"	n	object:batch
size	practice/cf/random/coloring/problem.json	/^{"name": "A. Dreamoon Likes Coloring", "group": "Codeforces - Codeforces Round #631 (Div. 1) - T/;"	n	object:batch
size	practice/cf/random/diane/problem.json	/^{"name": "D. Diane", "group": "Codeforces - Codeforces Round #735 (Div. 2)", "url": "https:\/\/c/;"	n	object:batch
size	practice/cf/random/pink/problem.json	/^{"name": "C. Pinkie Pie Eats Patty-cakes", "group": "Codeforces - Codeforces Round #662 (Div. 2)/;"	n	object:batch
size	practice/cf/stuff/dec 20 2021/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	n	object:batch
size	practice/usacoguide/gold/SP/dining/problem.json	/^{"name": "Problem 1. Fine Dining", "group": "USACO - USACO 2018 December Contest, Gold", "url": /;"	n	object:batch
size	practice/usacoguide/gold/SP/visitfj/problem.json	/^{"name": "Problem 1. Why Did the Cow Cross the Road", "group": "USACO - USACO 2017 February Cont/;"	n	object:batch
size	practice/usacoguide/gold/bfs/cownav/problem.json	/^{"name": "Problem 3. Cow Navigation", "group": "USACO - USACO 2017 January Contest, Gold", "url"/;"	n	object:batch
size	practice/usacoguide/gold/bfs/swap/problem.json	/^{"name": "Swap Game", "group": "CSES - CSES Problem Set", "url": "https:\/\/cses.fi\/problemset\//;"	n	object:batch
size	practice/usacoguide/gold/dsu/closing/main.cpp	/^	int size(int x) { return -e[get(x)]; }$/;"	f	struct:DSU	typeref:typename:int	file:
size	practice/usacoguide/gold/dsu/closing/problem.json	/^{"name": "Problem 2. Closing the Farm", "group": "USACO - USACO 2016 US Open Contest, Gold", "ur/;"	n	object:batch
size	practice/usacoguide/gold/dsu/moocast/main.cpp	/^	int size(int x) { return -e[get(x)]; }$/;"	f	struct:DSU	typeref:typename:int	file:
size	practice/usacoguide/gold/dsu/moocast/problem.json	/^{"name": "Problem 1. Moocast", "group": "USACO - USACO 2016 December Contest, Gold", "url": "htt/;"	n	object:batch
size	practice/usacoguide/gold/dsu/mootube/main.cpp	/^	int size(int x) { return -e[get(x)]; }$/;"	f	struct:DSU	typeref:typename:int	file:
size	practice/usacoguide/gold/dsu/mootube/problem.json	/^{"name": "Problem 1. MooTube", "group": "USACO - USACO 2018 January Contest, Gold", "url": "http/;"	n	object:batch
size	practice/usacoguide/gold/dsu/tractor/main.cpp	/^	int size(int x) { return -e[get(x)]; }$/;"	f	struct:DSU	typeref:typename:int	file:
size	practice/usacoguide/gold/dsu/tractor/mountain.cpp	/^	int size(int x) { return -e[get(x)]; }$/;"	f	struct:DSU	typeref:typename:int	file:
size	practice/usacoguide/gold/dsu/tractor/problem.json	/^{"name": "Problem 2. Tractor", "group": "USACO - USACO 2013 February Contest, Silver", "url": "h/;"	n	object:batch
size	practice/usacoguide/gold/dsu/wormhole/main.cpp	/^	int size(int x) { return -e[get(x)]; }$/;"	f	struct:DSU	typeref:typename:int	file:
size	practice/usacoguide/gold/dsu/wormhole/problem.json	/^{"name": "Problem 3. Wormhole Sort", "group": "USACO - USACO 2020 January Contest, Silver", "url/;"	n	object:batch
size	practice/usacoguide/silver/idk/lirs/main.cpp	/^	int size(int x) { return -e[get(x)]; }$/;"	f	struct:DSU	typeref:typename:int	file:
size	practice/usacoguide/silver/idk/lirs/problem.json	/^{"name": "Problem 3. Liars and Truth Tellers", "group": "USACO - USACO 2013 January Contest, Bro/;"	n	object:batch
size	practice/usacoguide/silver/idk/maze/problem.json	/^{"name": "Problem 1. Maze Tac Toe", "group": "USACO - USACO 2021 US Open, Silver", "url": "http:/;"	n	object:batch
slack	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  int n, n_x, match[N * 2], slack[N * 2], st[N * 2], pa[N * 2], flower_from[N * 2][N * 2], S[N */;"	m	struct:Blossom	typeref:typename:int[]	file:
slack	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  int n, n_x, match[N * 2], slack[N * 2], st[N * 2], pa[N * 2], flower_from[N * 2][N * 2], S[N */;"	m	struct:Blossom	typeref:typename:int[]	file:
slink	code-library/Strings/Palindromic Tree.cpp	/^    int nxt[26], len, st, en, link, diff, slink, cnt, oc;$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
slink	code/Strings/Palindromic Tree.cpp	/^    int nxt[26], len, st, en, link, diff, slink, cnt, oc;$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
small	code-library/Dynamic Programming Optimizations/Dynamic Submask Count.cpp	/^int c[N], small[N], big[N];$/;"	v	typeref:typename:int[]
small	code/Dynamic Programming Optimizations/Dynamic Submask Count.cpp	/^int c[N], small[N], big[N];$/;"	v	typeref:typename:int[]
small_angle	code-library/Geometry/Geometry 3D.cpp	/^double small_angle(p3 v, p3 w) {$/;"	f	typeref:typename:double
small_angle	code/Geometry/Geometry 3D.cpp	/^double small_angle(p3 v, p3 w) {$/;"	f	typeref:typename:double
smart_link	code-library/Strings/Palindromic Tree Persistent.cpp	/^    int nxt[A], len, st, en, link, cnt, oc, smart_link[A];$/;"	m	struct:PalindromicTree::node	typeref:typename:int[]	file:
smart_link	code/Strings/Palindromic Tree Persistent.cpp	/^    int nxt[A], len, st, en, link, cnt, oc, smart_link[A];$/;"	m	struct:PalindromicTree::node	typeref:typename:int[]	file:
smax_v	code-library/Data Structures/Segment Tree Beats.cpp	/^  ll max_v[4 * N], smax_v[4 * N], max_c[4 * N];$/;"	m	struct:SGTBeats	typeref:typename:ll[]	file:
smax_v	code/Data Structures/Segment Tree Beats.cpp	/^  ll max_v[4 * N], smax_v[4 * N], max_c[4 * N];$/;"	m	struct:SGTBeats	typeref:typename:ll[]	file:
smin_v	code-library/Data Structures/Segment Tree Beats.cpp	/^  ll min_v[4 * N], smin_v[4 * N], min_c[4 * N];$/;"	m	struct:SGTBeats	typeref:typename:ll[]	file:
smin_v	code/Data Structures/Segment Tree Beats.cpp	/^  ll min_v[4 * N], smin_v[4 * N], min_c[4 * N];$/;"	m	struct:SGTBeats	typeref:typename:ll[]	file:
snapshot	code-library/Data Structures/MOs with DSU.cpp	/^  void snapshot() {$/;"	f	struct:persistent_dsu	typeref:typename:void	file:
snapshot	code/Data Structures/MOs with DSU.cpp	/^  void snapshot() {$/;"	f	struct:persistent_dsu	typeref:typename:void	file:
solution_flag	code-library/Math/Simplex Algorithm.cpp	/^  int m, n, solution_flag, minmax_flag, basis[MAXC], index[MAXV];$/;"	v	namespace:lp	typeref:typename:int
solution_flag	code/Math/Simplex Algorithm.cpp	/^  int m, n, solution_flag, minmax_flag, basis[MAXC], index[MAXV];$/;"	v	namespace:lp	typeref:typename:int
solve	code-library/Data Structures/Centroid Decomposition.cpp	/^void solve(int u, int pre, int len, int add) {$/;"	f	typeref:typename:void
solve	code-library/Data Structures/MOs with DSU.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	code-library/Data Structures/Persistent Trie.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	code-library/Dynamic Programming Optimizations/Digit DP.cpp	/^int solve(ll n) {$/;"	f	typeref:typename:int
solve	code-library/Dynamic Programming Optimizations/Knuth Optimization.cpp	/^ll solve() {$/;"	f	typeref:typename:ll
solve	code-library/Dynamic Programming Optimizations/XOR Equation.cpp	/^int solve(vector<long long> a, long long x, int K) {$/;"	f	typeref:typename:int
solve	code-library/Geometry/Geometry 2D.cpp	/^    double solve() {$/;"	f	struct:CircleUnion	typeref:typename:double	file:
solve	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  pair<long long, int> solve() {$/;"	f	struct:Blossom	typeref:typename:pair<long long,int>	file:
solve	code-library/Graph Theory/Dynamic MST.cpp	/^void solve(int s, int e, vector<int> v, long long int cv){$/;"	f	typeref:typename:void
solve	code-library/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  int solve(vector<T> _ed, vector<int> &ans) {$/;"	f	struct:EdgeColoring	typeref:typename:int	file:
solve	code-library/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^int solve(vector<pair<int, int>> edges, vector<int> &res) {$/;"	f	namespace:EdgeColoring	typeref:typename:int
solve	code-library/Graph Theory/Edge Coloring Simple Graph.cpp	/^int solve(int n, vector<pair<int, int>> &edges) {$/;"	f	namespace:Vizing	typeref:typename:int
solve	code-library/Graph Theory/Euler Path Directed.cpp	/^int solve(int n) {$/;"	f	typeref:typename:int
solve	code-library/Graph Theory/Euler Path Undirected.cpp	/^int solve(int n) {$/;"	f	typeref:typename:int
solve	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^    mint solve(vector<vector<mint>> a) {$/;"	f	struct:Hafnian	typeref:typename:mint	file:
solve	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  pair<T, T> solve(int _s, int _t) {$/;"	f	struct:LR_Flow	typeref:typename:pair<T,T>	file:
solve	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  pair<T, T> solve(int _s, int _t, T goal = inf) {$/;"	f	struct:MCMF	typeref:typename:pair<T,T>	file:
solve	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  long long solve() {$/;"	f	struct:MaximumClosure	typeref:typename:long long	file:
solve	code-library/Graph Theory/Min Cost Max Flow.cpp	/^  pair<T, T> solve(int _s, int _t, T goal = inf) {$/;"	f	struct:MCMF	typeref:typename:pair<T,T>	file:
solve	code-library/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^void solve(int u, int pre, int len, int add) {$/;"	f	typeref:typename:void
solve	code-library/Graph Theory/Stoer Wagner Algorithm.cpp	/^  long long solve() {$/;"	f	struct:StoerWagner	typeref:typename:long long	file:
solve	code-library/Math/Hafnian of a Matrix.cpp	/^  mint solve(vector<vector<mint>> a) {$/;"	f	namespace:Hafnian	typeref:typename:mint
solve	code-library/Math/Integration (Simpsons).cpp	/^double solve(double slr, double fl, double fr, double fmid, double l, double r){$/;"	f	typeref:typename:double
solve	code-library/Math/Reeds Sloane Algorithm.cpp	/^  ll solve(ll n) {$/;"	f	struct:LinearRecurrence	typeref:typename:ll	file:
solve	code-library/Math/Simplex Algorithm.cpp	/^  inline long double solve(){ \/\/\/ simplex core$/;"	f	namespace:lp	typeref:typename:long double
solve	code-library/Miscellaneous/XOR Equation Arbitrary Range.cpp	/^int solve(vector<long long> a, long long x, int K) {$/;"	f	typeref:typename:int
solve	code-library/Number Theory/Dirichlet Convolution.cpp	/^  mint solve (long long x) {$/;"	f	namespace:Dirichlet	typeref:typename:mint
solve	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^vector<vector<ll>> solve(ll k1, ll k2, ll a, ll b, ll c, ll n) {$/;"	f	typeref:typename:vector<vector<ll>>
solve	code-library/Number Theory/Min_25 Sieve.cpp	/^T solve(ll _n, vector<T> pol) {$/;"	f	typeref:typename:T
solve	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^vector<vector<long long>> solve(long long k1, long long k2, long long a, long long b, long long /;"	f	typeref:typename:vector<vector<long long>>
solve	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	code/Data Structures/Centroid Decomposition.cpp	/^void solve(int u, int pre, int len, int add) {$/;"	f	typeref:typename:void
solve	code/Data Structures/MOs with DSU.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	code/Data Structures/Persistent Trie.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	code/Dynamic Programming Optimizations/Digit DP.cpp	/^int solve(ll n) {$/;"	f	typeref:typename:int
solve	code/Dynamic Programming Optimizations/Knuth Optimization.cpp	/^ll solve() {$/;"	f	typeref:typename:ll
solve	code/Dynamic Programming Optimizations/XOR Equation.cpp	/^int solve(vector<long long> a, long long x, int K) {$/;"	f	typeref:typename:int
solve	code/Geometry/Geometry 2D.cpp	/^    double solve() {$/;"	f	struct:CircleUnion	typeref:typename:double	file:
solve	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  pair<long long, int> solve() {$/;"	f	struct:Blossom	typeref:typename:pair<long long,int>	file:
solve	code/Graph Theory/Dynamic MST.cpp	/^void solve(int s, int e, vector<int> v, long long int cv){$/;"	f	typeref:typename:void
solve	code/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  int solve(vector<T> _ed, vector<int> &ans) {$/;"	f	struct:EdgeColoring	typeref:typename:int	file:
solve	code/Graph Theory/Edge Coloring Bipartite Graph.cpp	/^int solve(vector<pair<int, int>> edges, vector<int> &res) {$/;"	f	namespace:EdgeColoring	typeref:typename:int
solve	code/Graph Theory/Edge Coloring Simple Graph.cpp	/^int solve(int n, vector<pair<int, int>> &edges) {$/;"	f	namespace:Vizing	typeref:typename:int
solve	code/Graph Theory/Euler Path Directed.cpp	/^int solve(int n) {$/;"	f	typeref:typename:int
solve	code/Graph Theory/Euler Path Undirected.cpp	/^int solve(int n) {$/;"	f	typeref:typename:int
solve	code/Graph Theory/Hafnian of a Matrix.cpp	/^    mint solve(vector<vector<mint>> a) {$/;"	f	struct:Hafnian	typeref:typename:mint	file:
solve	code/Graph Theory/L R Flow with MCMF.cpp	/^  pair<T, T> solve(int _s, int _t) {$/;"	f	struct:LR_Flow	typeref:typename:pair<T,T>	file:
solve	code/Graph Theory/L R Flow with MCMF.cpp	/^  pair<T, T> solve(int _s, int _t, T goal = inf) {$/;"	f	struct:MCMF	typeref:typename:pair<T,T>	file:
solve	code/Graph Theory/Maximum Closure Problem.cpp	/^  long long solve() {$/;"	f	struct:MaximumClosure	typeref:typename:long long	file:
solve	code/Graph Theory/Min Cost Max Flow.cpp	/^  pair<T, T> solve(int _s, int _t, T goal = inf) {$/;"	f	struct:MCMF	typeref:typename:pair<T,T>	file:
solve	code/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^void solve(int u, int pre, int len, int add) {$/;"	f	typeref:typename:void
solve	code/Graph Theory/Stoer Wagner Algorithm.cpp	/^  long long solve() {$/;"	f	struct:StoerWagner	typeref:typename:long long	file:
solve	code/Math/Hafnian of a Matrix.cpp	/^  mint solve(vector<vector<mint>> a) {$/;"	f	namespace:Hafnian	typeref:typename:mint
solve	code/Math/Integration (Simpsons).cpp	/^double solve(double slr, double fl, double fr, double fmid, double l, double r){$/;"	f	typeref:typename:double
solve	code/Math/Reeds Sloane Algorithm.cpp	/^  ll solve(ll n) {$/;"	f	struct:LinearRecurrence	typeref:typename:ll	file:
solve	code/Math/Simplex Algorithm.cpp	/^  inline long double solve(){ \/\/\/ simplex core$/;"	f	namespace:lp	typeref:typename:long double
solve	code/Miscellaneous/XOR Equation Arbitrary Range.cpp	/^int solve(vector<long long> a, long long x, int K) {$/;"	f	typeref:typename:int
solve	code/Number Theory/Dirichlet Convolution.cpp	/^  mint solve (long long x) {$/;"	f	namespace:Dirichlet	typeref:typename:mint
solve	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^vector<vector<ll>> solve(ll k1, ll k2, ll a, ll b, ll c, ll n) {$/;"	f	typeref:typename:vector<vector<ll>>
solve	code/Number Theory/Min_25 Sieve.cpp	/^T solve(ll _n, vector<T> pol) {$/;"	f	typeref:typename:T
solve	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^vector<vector<long long>> solve(long long k1, long long k2, long long a, long long b, long long /;"	f	typeref:typename:vector<vector<long long>>
solve	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	code/template.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/AtCoder/225/A.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/AtCoder/225/B.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/AtCoder/225/C.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/AtCoder/225/D.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/AtCoder/225/E.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/AtCoder/225/F.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/AtCoder/231/A.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/AtCoder/231/B.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/AtCoder/231/C.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/AtCoder/231/D.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/AtCoder/231/E.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/Codeforces/1609/A.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/Codeforces/1609/B.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/Codeforces/1609/C.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/Codeforces/1609/D.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/Codeforces/1616/A/sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/Codeforces/1616/B/sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/Codeforces/1616/C/sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/Codeforces/1616/D/new_sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/Codeforces/1616/D/sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/Codeforces/1622/A/sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/Codeforces/1622/B/sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/Codeforces/1622/C/sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/Codeforces/1622/C_new/main.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/Codeforces/1622/C_new/sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/Codeforces/1622/upsolve/C/sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/Codeforces/1623/A/sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/Codeforces/1623/B/sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/Codeforces/1623/C/sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/Codeforces/1623/new_C/sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/Codeforces/737/D.cpp	/^string solve(vlli a,lli n,lli k)$/;"	f	typeref:typename:string
solve	contests/Codeforces/737/E.cpp	/^string solve(vlli a,lli n,lli k)$/;"	f	typeref:typename:string
solve	contests/USACO/dec_silver_2021/A/A.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/USACO/dec_silver_2021/A/AA.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/USACO/dec_silver_2021/A/AAA.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/USACO/dec_silver_2021/A/A_safe.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/USACO/dec_silver_2021/A/A_sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/USACO/dec_silver_2021/A/a_save.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/USACO/dec_silver_2021/A/a_testing.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/USACO/dec_silver_2021/A/restart_A.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/USACO/dec_silver_2021/B/B.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/USACO/dec_silver_2021/B/B_new.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/USACO/dec_silver_2021/B/brute.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/USACO/dec_silver_2021/C/C.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/USACO/dec_silver_2021/C/C_full.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	contests/USACO/dec_silver_2021/C/C_new.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/DP/1051E1.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/DP/1061D.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/DP/1091D.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/DP/1461C.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/DP/altaray.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/DP/knap1.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/DP/main.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/1700/1.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/1700/1472E.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/1700/1473D.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/1700/1476D.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/1700/1608C/main.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/1700/1618E.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/1700/1618E/main.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/1700/2.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/1700/3.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/1700/4.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/1700/5.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/1700/6.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/1700/7.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/1700/8.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/1700/brute.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/1700/test.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/1700/test1.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/1700/test2.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/1700/test3.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/1700/testing.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/coloring/main.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/diane/main.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/i_hate_math_problems/1336B.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/i_hate_math_problems/1368D.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/i_hate_math_problems/1400B.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/i_hate_math_problems/1422C.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/i_hate_math_problems/1451D.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/i_hate_math_problems/1469D.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/random/pink/main.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cf/stuff/dec 20 2021/1608C/main.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/club/prob3/test.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cpbook/ch1/1.6/reallife/medium/00161/main.cpp	/^void solve(vector<int> times) {$/;"	f	typeref:typename:void
solve	practice/cpbook/ch1/1.6/reallife/medium/01091/restartmain.cpp	/^string solve(int N) {$/;"	f	typeref:typename:string
solve	practice/cpbook/ch3/DP/00787.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/cpbook/ch3/DP/10684.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/december2021/1560E/sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/december2021/1572A/new_sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/december2021/1572A/sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/december2021/1619D/sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/december2021/1619E/sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/december2021/1620C/sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/december2021/DP/LIS/sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/december2021/DP/counting_towers/sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/december2021/DP/rectangle_cutting/sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/december2021/DP/removal_game/sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/december2021/DP/teamwork/sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/december2021/stacks/advertisement/sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/december2021/stacks/balloons/sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/december2021/stacks/nsv/sol.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/SP/dining/main.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/SP/flightdiscount.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/SP/main.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/SP/pump.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/SP/shortestroutesii.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/SP/visitfj.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/SP/visitfj/main.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/bfs/cownav.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/bfs/mecho/main.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/bfs/mechonew/main.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/bfs/swap.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/bfs/swap/main.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/bfs/telephone.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/bfs/walls.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/dsu/closing/main.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/dsu/moocast/main.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/dsu/mootube/main.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/dsu/tractor/main.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/dsu/tractor/mountain.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/dsu/wormhole/main.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/introDP/arraydescription.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/introDP/countingtowers.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/introDP/editdistance.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/introDP/feast.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/introDP/hoofpaperscissors.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/introDP/learningdp.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/introDP/main.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/introDP/rectanglecutting.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/gold/introDP/time.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/main.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/silver/idk/lirs/main.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve	practice/usacoguide/silver/idk/maze/main.cpp	/^void solve() {$/;"	f	typeref:typename:void
solve0	code-library/Game Theory/Blue Red Hackenbush.cpp	/^  void solve0() {$/;"	f	struct:surreal	typeref:typename:void	file:
solve0	code/Game Theory/Blue Red Hackenbush.cpp	/^  void solve0() {$/;"	f	struct:surreal	typeref:typename:void	file:
solve1	code-library/Game Theory/Blue Red Hackenbush.cpp	/^  void solve1() {$/;"	f	struct:surreal	typeref:typename:void	file:
solve1	code/Game Theory/Blue Red Hackenbush.cpp	/^  void solve1() {$/;"	f	struct:surreal	typeref:typename:void	file:
sorted_v	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^  vector<int> v, sorted_v; int sz = 0;$/;"	m	struct:Block	typeref:typename:vector<int>	file:
sorted_v	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^  vector<int> v, sorted_v; int sz = 0;$/;"	m	struct:Block	typeref:typename:vector<int>	file:
sp	code-library/Data Structures/Reachability Tree.cpp	/^  int n, par[2 * N], sp[LG + 1][2 * N], val[2 * N], rid[2 * N];$/;"	m	struct:RT	typeref:typename:int[][]	file:
sp	code/Data Structures/Reachability Tree.cpp	/^  int n, par[2 * N], sp[LG + 1][2 * N], val[2 * N], rid[2 * N];$/;"	m	struct:RT	typeref:typename:int[][]	file:
span	code-library/Data Structures/Permutation Tree.cpp	/^pair<int, int> span[N * 2]; \/\/ range of permutation indices$/;"	v	typeref:typename:pair<int,int>[]
span	code/Data Structures/Permutation Tree.cpp	/^pair<int, int> span[N * 2]; \/\/ range of permutation indices$/;"	v	typeref:typename:pair<int,int>[]
spf	code-library/Number Theory/Dirichlet Convolution.cpp	/^  int sz, spf[T], prime[T];$/;"	v	namespace:Dirichlet	typeref:typename:int[]
spf	code-library/Number Theory/Linear Sieve for Multiplicative Functions.cpp	/^int spf[N], f[N], cnt[N]; \/\/ cnt[i] = power of spf[i] in i$/;"	v	typeref:typename:int[]
spf	code-library/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^  int primes[P], spf[P];$/;"	v	namespace:PollardRho	typeref:typename:int[]
spf	code-library/Number Theory/Pisano Period.cpp	/^  int primes[P], spf[P];$/;"	v	namespace:PollardRho	typeref:typename:int[]
spf	code-library/Number Theory/Pollard Rho.cpp	/^  int primes[P], spf[P];$/;"	v	namespace:PollardRho	typeref:typename:int[]
spf	code-library/Number Theory/Prime Number System.cpp	/^int spf[N];$/;"	v	typeref:typename:int[]
spf	code-library/Number Theory/Sieve.cpp	/^int spf[N];$/;"	v	typeref:typename:int[]
spf	code-library/Number Theory/Smallest Number Having Exactly K Divisors.cpp	/^int spf[N];$/;"	v	typeref:typename:int[]
spf	code-library/Number Theory/nCr Modulo Any Mod.cpp	/^int spf[N];$/;"	v	typeref:typename:int[]
spf	code/Number Theory/Dirichlet Convolution.cpp	/^  int sz, spf[T], prime[T];$/;"	v	namespace:Dirichlet	typeref:typename:int[]
spf	code/Number Theory/Linear Sieve for Multiplicative Functions.cpp	/^int spf[N], f[N], cnt[N]; \/\/ cnt[i] = power of spf[i] in i$/;"	v	typeref:typename:int[]
spf	code/Number Theory/Number of Solutions to x^2 = 1 mod m.cpp	/^  int primes[P], spf[P];$/;"	v	namespace:PollardRho	typeref:typename:int[]
spf	code/Number Theory/Pisano Period.cpp	/^  int primes[P], spf[P];$/;"	v	namespace:PollardRho	typeref:typename:int[]
spf	code/Number Theory/Pollard Rho.cpp	/^  int primes[P], spf[P];$/;"	v	namespace:PollardRho	typeref:typename:int[]
spf	code/Number Theory/Prime Number System.cpp	/^int spf[N];$/;"	v	typeref:typename:int[]
spf	code/Number Theory/Sieve.cpp	/^int spf[N];$/;"	v	typeref:typename:int[]
spf	code/Number Theory/Smallest Number Having Exactly K Divisors.cpp	/^int spf[N];$/;"	v	typeref:typename:int[]
spf	code/Number Theory/nCr Modulo Any Mod.cpp	/^int spf[N];$/;"	v	typeref:typename:int[]
spfa	code-library/Graph Theory/Chinese Postman Problem.cpp	/^  bool spfa(int u) {$/;"	f	struct:RandomizedMatching	typeref:typename:bool	file:
spfa	code-library/Graph Theory/Minimum Mean Weight Cycle.cpp	/^bool spfa(int u, double x) {$/;"	f	typeref:typename:bool
spfa	code-library/Graph Theory/Randomized Matching Weighted.cpp	/^	bool spfa(int u) {$/;"	f	struct:RandomizedMatching	typeref:typename:bool	file:
spfa	code-library/Graph Theory/SPFA.cpp	/^bool spfa(int u) {$/;"	f	typeref:typename:bool
spfa	code-library/Graph Theory/System Of Difference Constraints.cpp	/^bool spfa(int u) {$/;"	f	typeref:typename:bool
spfa	code/Graph Theory/Chinese Postman Problem.cpp	/^  bool spfa(int u) {$/;"	f	struct:RandomizedMatching	typeref:typename:bool	file:
spfa	code/Graph Theory/Minimum Mean Weight Cycle.cpp	/^bool spfa(int u, double x) {$/;"	f	typeref:typename:bool
spfa	code/Graph Theory/Randomized Matching Weighted.cpp	/^	bool spfa(int u) {$/;"	f	struct:RandomizedMatching	typeref:typename:bool	file:
spfa	code/Graph Theory/SPFA.cpp	/^bool spfa(int u) {$/;"	f	typeref:typename:bool
spfa	code/Graph Theory/System Of Difference Constraints.cpp	/^bool spfa(int u) {$/;"	f	typeref:typename:bool
sphere_line_intersection	code-library/Geometry/Geometry 3D.cpp	/^int sphere_line_intersection(p3 o, double r, line3d l, pair<p3,p3> &out) {$/;"	f	typeref:typename:int
sphere_line_intersection	code/Geometry/Geometry 3D.cpp	/^int sphere_line_intersection(p3 o, double r, line3d l, pair<p3,p3> &out) {$/;"	f	typeref:typename:int
splay	code-library/Data Structures/Link Cut Tree.cpp	/^  void splay(int x) { $/;"	f	struct:LCT	typeref:typename:void	file:
splay	code-library/Data Structures/Top Tree.cpp	/^  void splay() {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
splay	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  void splay(int x) {$/;"	f	namespace:lct	typeref:typename:void
splay	code/Data Structures/Link Cut Tree.cpp	/^  void splay(int x) { $/;"	f	struct:LCT	typeref:typename:void	file:
splay	code/Data Structures/Top Tree.cpp	/^  void splay() {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
splay	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  void splay(int x) {$/;"	f	namespace:lct	typeref:typename:void
splay_2	code-library/Data Structures/Top Tree.cpp	/^  void splay_2() {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
splay_2	code-library/Data Structures/Top Tree.cpp	/^  void splay_2(int c_d) {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
splay_2	code/Data Structures/Top Tree.cpp	/^  void splay_2() {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
splay_2	code/Data Structures/Top Tree.cpp	/^  void splay_2(int c_d) {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
splay_dir	code-library/Data Structures/Top Tree.cpp	/^  void splay_dir(int x) {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
splay_dir	code/Data Structures/Top Tree.cpp	/^  void splay_dir(int x) {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
splay_vert	code-library/Data Structures/Top Tree.cpp	/^  void splay_vert() {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
splay_vert	code/Data Structures/Top Tree.cpp	/^  void splay_vert() {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
splice	code-library/Geometry/Delaunay Triangulation.cpp	/^void splice(Q a, Q b) {$/;"	f	typeref:typename:void
splice	code-library/Geometry/Voronoi Diagram.cpp	/^void splice(Q a, Q b) {$/;"	f	typeref:typename:void
splice	code/Geometry/Delaunay Triangulation.cpp	/^void splice(Q a, Q b) {$/;"	f	typeref:typename:void
splice	code/Geometry/Voronoi Diagram.cpp	/^void splice(Q a, Q b) {$/;"	f	typeref:typename:void
splice_all	code-library/Data Structures/Top Tree.cpp	/^  void splice_all(top_tree_node*& res) {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
splice_all	code/Data Structures/Top Tree.cpp	/^  void splice_all(top_tree_node*& res) {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
splice_non_path	code-library/Data Structures/Top Tree.cpp	/^  top_tree_node* splice_non_path() {$/;"	f	struct:top_tree_node	typeref:typename:top_tree_node *	file:
splice_non_path	code/Data Structures/Top Tree.cpp	/^  top_tree_node* splice_non_path() {$/;"	f	struct:top_tree_node	typeref:typename:top_tree_node *	file:
split	code-library/Data Structures/Implicit Treap.cpp	/^  void split(pnode t, pnode &l, pnode &r, int k, int add = 0) {$/;"	f	struct:treap	typeref:typename:void	file:
split	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  void split(node *t, int pos, node *&l, node *&r) {$/;"	f	struct:treap	typeref:typename:void	file:
split	code-library/Data Structures/Segment Tree Merging.cpp	/^  void split(int cur, int &b, int k) {$/;"	f	struct:STM	typeref:typename:void	file:
split	code-library/Data Structures/Segment Tree Merging.cpp	/^void split(int l, int r) {$/;"	f	typeref:typename:void
split	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^int split(int i) {$/;"	f	typeref:typename:int
split	code-library/Data Structures/Treap persistent.cpp	/^void split(node *cur, int pos, node *&l, node *&r, int add = 0) {$/;"	f	namespace:PersistentTreap	typeref:typename:void
split	code-library/Data Structures/Treap.cpp	/^  void split(node *t, int pos, node *&l, node *&r) {$/;"	f	struct:treap	typeref:typename:void	file:
split	code-library/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  array<vector<int>, 2> split(vector<int> lab) { \/\/ k is even, split into two parts$/;"	f	struct:EdgeColoring	typeref:typename:array<vector<int>,2>	file:
split	code/Data Structures/Implicit Treap.cpp	/^  void split(pnode t, pnode &l, pnode &r, int k, int add = 0) {$/;"	f	struct:treap	typeref:typename:void	file:
split	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  void split(node *t, int pos, node *&l, node *&r) {$/;"	f	struct:treap	typeref:typename:void	file:
split	code/Data Structures/Segment Tree Merging.cpp	/^  void split(int cur, int &b, int k) {$/;"	f	struct:STM	typeref:typename:void	file:
split	code/Data Structures/Segment Tree Merging.cpp	/^void split(int l, int r) {$/;"	f	typeref:typename:void
split	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^int split(int i) {$/;"	f	typeref:typename:int
split	code/Data Structures/Treap persistent.cpp	/^void split(node *cur, int pos, node *&l, node *&r, int add = 0) {$/;"	f	namespace:PersistentTreap	typeref:typename:void
split	code/Data Structures/Treap.cpp	/^  void split(node *t, int pos, node *&l, node *&r) {$/;"	f	struct:treap	typeref:typename:void	file:
split	code/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  array<vector<int>, 2> split(vector<int> lab) { \/\/ k is even, split into two parts$/;"	f	struct:EdgeColoring	typeref:typename:array<vector<int>,2>	file:
sq	code-library/Geometry/Geometry 3D.cpp	/^    double sq() { return x * x + y * y + z * z; }$/;"	f	struct:p3	typeref:typename:double	file:
sq	code-library/Geometry/Geometry 3D.cpp	/^double sq(p3 v) { return v | v; }$/;"	f	typeref:typename:double
sq	code/Geometry/Geometry 3D.cpp	/^    double sq() { return x * x + y * y + z * z; }$/;"	f	struct:p3	typeref:typename:double	file:
sq	code/Geometry/Geometry 3D.cpp	/^double sq(p3 v) { return v | v; }$/;"	f	typeref:typename:double
sqrt	code-library/Math/Polynomial.cpp	/^  modint sqrt() const {$/;"	f	struct:modint	typeref:typename:modint	file:
sqrt	code-library/Math/Polynomial.cpp	/^  poly sqrt(int n) const {$/;"	f	struct:poly	typeref:typename:poly	file:
sqrt	code-library/Number Theory/Bell Number.cpp	/^    modint sqrt() const {$/;"	f	struct:modint	typeref:typename:modint	file:
sqrt	code-library/Number Theory/Prime Number System.cpp	/^  base sqrt() {$/;"	f	struct:base	typeref:typename:base	file:
sqrt	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    modint sqrt() const {$/;"	f	struct:modint	typeref:typename:modint	file:
sqrt	code/Math/Polynomial.cpp	/^  modint sqrt() const {$/;"	f	struct:modint	typeref:typename:modint	file:
sqrt	code/Math/Polynomial.cpp	/^  poly sqrt(int n) const {$/;"	f	struct:poly	typeref:typename:poly	file:
sqrt	code/Number Theory/Bell Number.cpp	/^    modint sqrt() const {$/;"	f	struct:modint	typeref:typename:modint	file:
sqrt	code/Number Theory/Prime Number System.cpp	/^  base sqrt() {$/;"	f	struct:base	typeref:typename:base	file:
sqrt	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    modint sqrt() const {$/;"	f	struct:modint	typeref:typename:modint	file:
square	practice/cf/random/i_hate_math_problems/1336B.cpp	/^int square(int x) {$/;"	f	typeref:typename:int
squared_distance	code-library/Data Structures/KD Tree.cpp	/^long long squared_distance(point a, point b) {$/;"	f	typeref:typename:long long
squared_distance	code/Data Structures/KD Tree.cpp	/^long long squared_distance(point a, point b) {$/;"	f	typeref:typename:long long
ssz	code-library/Data Structures/Link Cut Tree.cpp	/^  int sz = 0, ssz = 0, vsz = 0; \/\/ sz -> aux tree size, ssz = subtree size in rep tree, vsz = /;"	m	struct:node	typeref:typename:int	file:
ssz	code/Data Structures/Link Cut Tree.cpp	/^  int sz = 0, ssz = 0, vsz = 0; \/\/ sz -> aux tree size, ssz = subtree size in rep tree, vsz = /;"	m	struct:node	typeref:typename:int	file:
st	code-library/Data Structures/Binarizing a Tree.cpp	/^int st[N * 2], en[N * 2], DT;$/;"	v	typeref:typename:int[]
st	code-library/Data Structures/Cartesian Tree.cpp	/^int n, tot, st[N], l[N], r[N], vis[N];$/;"	v	typeref:typename:int[]
st	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^int st[N * 2], en[N * 2], DT;$/;"	v	typeref:typename:int[]
st	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^  stack<state> st;$/;"	m	struct:persistent_dsu	typeref:typename:stack<state>	file:
st	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^unordered_map<pair<int, int>, int, HASH>st;$/;"	v	typeref:typename:unordered_map<pair<int,int>,int,HASH>
st	code-library/Data Structures/Dynamic Diameter Online.cpp	/^int T, st[N * 2], en[N * 2], pos[N];$/;"	v	typeref:typename:int[]
st	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int T, head[N], st[N], en[N];$/;"	v	typeref:typename:int[]
st	code-library/Data Structures/HLD.cpp	/^int T, head[N], st[N], en[N];$/;"	v	typeref:typename:int[]
st	code-library/Data Structures/MOs Online.cpp	/^int st[C], en[C], BC = 0;$/;"	v	typeref:typename:int[]
st	code-library/Data Structures/MOs on tree.cpp	/^int st[N], en[N], T, par[N][20], dep[N], id[N * 2];$/;"	v	typeref:typename:int[]
st	code-library/Data Structures/MOs with DSU.cpp	/^  stack<state> st;$/;"	m	struct:persistent_dsu	typeref:typename:stack<state>	file:
st	code-library/Data Structures/Persistent Array.cpp	/^  PersistentArray<T> st;$/;"	m	struct:PersistentQueue	typeref:typename:PersistentArray<T>	file:
st	code-library/Data Structures/Persistent Queue.cpp	/^  PersistentArray<T> st;$/;"	m	struct:PersistentQueue	typeref:typename:PersistentArray<T>	file:
st	code-library/Data Structures/Reachability Tree.cpp	/^  int T, st[2 * N], en[2 * N];$/;"	m	struct:RT	typeref:typename:int[]	file:
st	code-library/Data Structures/Sparse Table 2D.cpp	/^int st[N][N][LG][LG];$/;"	v	typeref:typename:int[][][][]
st	code-library/Graph Theory/Bellman Ford.cpp	/^struct st {$/;"	s	file:
st	code-library/Graph Theory/Block Cut Tree.cpp	/^vector<int> g[N], bcc[N], st;$/;"	v	typeref:typename:vector<int>
st	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  int n, n_x, match[N * 2], slack[N * 2], st[N * 2], pa[N * 2], flower_from[N * 2][N * 2], S[N */;"	m	struct:Blossom	typeref:typename:int[]	file:
st	code-library/Graph Theory/Dominator Tree.cpp	/^int st[N], en[N];$/;"	v	typeref:typename:int[]
st	code-library/Graph Theory/Dynamic MST.cpp	/^int st[MAXN], ed[MAXN], cost[MAXN], chk[MAXN];$/;"	v	typeref:typename:int[]
st	code-library/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^set<pair<long long, int> > st;$/;"	v	typeref:typename:set<pair<long long,int>>
st	code-library/Graph Theory/Maximum Independant Set.cpp	/^bitset<N> st;$/;"	v	typeref:typename:bitset<N>
st	code-library/Graph Theory/Virtual Tree.cpp	/^int par[N][20], dep[N], sz[N], st[N], en[N], T;$/;"	v	typeref:typename:int[]
st	code-library/Miscellaneous/Parallel Binary Search.cpp	/^int amount[N], want[N], st[N], en[N], l[N], r[N], ans[N];$/;"	v	typeref:typename:int[]
st	code-library/Strings/Palindromic Tree Persistent.cpp	/^    int nxt[A], len, st, en, link, cnt, oc, smart_link[A];$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
st	code-library/Strings/Palindromic Tree.cpp	/^    int nxt[26], len, st, en, link, diff, slink, cnt, oc;$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
st	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^}st;$/;"	v	typeref:struct:ST
st	code/Data Structures/Binarizing a Tree.cpp	/^int st[N * 2], en[N * 2], DT;$/;"	v	typeref:typename:int[]
st	code/Data Structures/Cartesian Tree.cpp	/^int n, tot, st[N], l[N], r[N], vis[N];$/;"	v	typeref:typename:int[]
st	code/Data Structures/Centroid Decomposition Persistent.cpp	/^int st[N * 2], en[N * 2], DT;$/;"	v	typeref:typename:int[]
st	code/Data Structures/Dynamic Connectivity Problem.cpp	/^  stack<state> st;$/;"	m	struct:persistent_dsu	typeref:typename:stack<state>	file:
st	code/Data Structures/Dynamic Connectivity Problem.cpp	/^unordered_map<pair<int, int>, int, HASH>st;$/;"	v	typeref:typename:unordered_map<pair<int,int>,int,HASH>
st	code/Data Structures/Dynamic Diameter Online.cpp	/^int T, st[N * 2], en[N * 2], pos[N];$/;"	v	typeref:typename:int[]
st	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int T, head[N], st[N], en[N];$/;"	v	typeref:typename:int[]
st	code/Data Structures/HLD.cpp	/^int T, head[N], st[N], en[N];$/;"	v	typeref:typename:int[]
st	code/Data Structures/MOs Online.cpp	/^int st[C], en[C], BC = 0;$/;"	v	typeref:typename:int[]
st	code/Data Structures/MOs on tree.cpp	/^int st[N], en[N], T, par[N][20], dep[N], id[N * 2];$/;"	v	typeref:typename:int[]
st	code/Data Structures/MOs with DSU.cpp	/^  stack<state> st;$/;"	m	struct:persistent_dsu	typeref:typename:stack<state>	file:
st	code/Data Structures/Persistent Array.cpp	/^  PersistentArray<T> st;$/;"	m	struct:PersistentQueue	typeref:typename:PersistentArray<T>	file:
st	code/Data Structures/Persistent Queue.cpp	/^  PersistentArray<T> st;$/;"	m	struct:PersistentQueue	typeref:typename:PersistentArray<T>	file:
st	code/Data Structures/Reachability Tree.cpp	/^  int T, st[2 * N], en[2 * N];$/;"	m	struct:RT	typeref:typename:int[]	file:
st	code/Data Structures/Sparse Table 2D.cpp	/^int st[N][N][LG][LG];$/;"	v	typeref:typename:int[][][][]
st	code/Graph Theory/Bellman Ford.cpp	/^struct st {$/;"	s	file:
st	code/Graph Theory/Block Cut Tree.cpp	/^vector<int> g[N], bcc[N], st;$/;"	v	typeref:typename:vector<int>
st	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  int n, n_x, match[N * 2], slack[N * 2], st[N * 2], pa[N * 2], flower_from[N * 2][N * 2], S[N */;"	m	struct:Blossom	typeref:typename:int[]	file:
st	code/Graph Theory/Dominator Tree.cpp	/^int st[N], en[N];$/;"	v	typeref:typename:int[]
st	code/Graph Theory/Dynamic MST.cpp	/^int st[MAXN], ed[MAXN], cost[MAXN], chk[MAXN];$/;"	v	typeref:typename:int[]
st	code/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^set<pair<long long, int> > st;$/;"	v	typeref:typename:set<pair<long long,int>>
st	code/Graph Theory/Maximum Independant Set.cpp	/^bitset<N> st;$/;"	v	typeref:typename:bitset<N>
st	code/Graph Theory/Virtual Tree.cpp	/^int par[N][20], dep[N], sz[N], st[N], en[N], T;$/;"	v	typeref:typename:int[]
st	code/Miscellaneous/Parallel Binary Search.cpp	/^int amount[N], want[N], st[N], en[N], l[N], r[N], ans[N];$/;"	v	typeref:typename:int[]
st	code/Strings/Palindromic Tree Persistent.cpp	/^    int nxt[A], len, st, en, link, cnt, oc, smart_link[A];$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
st	code/Strings/Palindromic Tree.cpp	/^    int nxt[26], len, st, en, link, diff, slink, cnt, oc;$/;"	m	struct:PalindromicTree::node	typeref:typename:int	file:
st	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^}st;$/;"	v	typeref:struct:ST
st	contests/USACO/dec_silver_2021/B/B.cpp	/^set<int> st;$/;"	v	typeref:typename:set<int>
st_numbering	code-library/Graph Theory/ST Numbering.cpp	/^vector<int> st_numbering(int n, int s, int t) {$/;"	f	typeref:typename:vector<int>
st_numbering	code/Graph Theory/ST Numbering.cpp	/^vector<int> st_numbering(int n, int s, int t) {$/;"	f	typeref:typename:vector<int>
start	code-library/Graph Theory/Hungarian Algorithm.cpp	/^  int start, finish, n;$/;"	m	struct:Hungarian	typeref:typename:int	file:
start	code/Graph Theory/Hungarian Algorithm.cpp	/^  int start, finish, n;$/;"	m	struct:Hungarian	typeref:typename:int	file:
start	practice/usacoguide/gold/bfs/mecho/main.cpp	/^pair<int, int> start, finish;$/;"	v	typeref:typename:pair<int,int>
start	practice/usacoguide/gold/bfs/mechonew/main.cpp	/^pair<int, int> start, finish;$/;"	v	typeref:typename:pair<int,int>
start_pos	practice/usacoguide/gold/bfs/monsters.cpp	/^pair<int, int> start_pos;$/;"	v	typeref:typename:pair<int,int>
start_vis	practice/cpbook/ch1/1.6/chess/chess/realsol.cpp	/^bool start_vis[9][9], end_vis[9][9];$/;"	v	typeref:typename:bool[9][9]
state	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^    state() {$/;"	f	struct:persistent_dsu::state	file:
state	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^    state(int _u, int _rnku, int _v, int _rnkv) {$/;"	f	struct:persistent_dsu::state	file:
state	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^  struct state {$/;"	s	struct:persistent_dsu	file:
state	code-library/Data Structures/MOs with DSU.cpp	/^    state() {$/;"	f	struct:persistent_dsu::state	file:
state	code-library/Data Structures/MOs with DSU.cpp	/^    state(int _u, int _ru, int _v, int _rv) {$/;"	f	struct:persistent_dsu::state	file:
state	code-library/Data Structures/MOs with DSU.cpp	/^  struct state {$/;"	s	struct:persistent_dsu	file:
state	code/Data Structures/Dynamic Connectivity Problem.cpp	/^    state() {$/;"	f	struct:persistent_dsu::state	file:
state	code/Data Structures/Dynamic Connectivity Problem.cpp	/^    state(int _u, int _rnku, int _v, int _rnkv) {$/;"	f	struct:persistent_dsu::state	file:
state	code/Data Structures/Dynamic Connectivity Problem.cpp	/^  struct state {$/;"	s	struct:persistent_dsu	file:
state	code/Data Structures/MOs with DSU.cpp	/^    state() {$/;"	f	struct:persistent_dsu::state	file:
state	code/Data Structures/MOs with DSU.cpp	/^    state(int _u, int _ru, int _v, int _rv) {$/;"	f	struct:persistent_dsu::state	file:
state	code/Data Structures/MOs with DSU.cpp	/^  struct state {$/;"	s	struct:persistent_dsu	file:
stirling	code-library/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^vector<int> stirling(int n, int k) {$/;"	f	typeref:typename:vector<int>
stirling	code-library/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^vector<int> stirling(int n) {$/;"	f	typeref:typename:vector<int>
stirling	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^vector<mint> stirling(int n, int k) {$/;"	f	typeref:typename:vector<mint>
stirling	code/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^vector<int> stirling(int n, int k) {$/;"	f	typeref:typename:vector<int>
stirling	code/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^vector<int> stirling(int n) {$/;"	f	typeref:typename:vector<int>
stirling	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^vector<mint> stirling(int n, int k) {$/;"	f	typeref:typename:vector<mint>
stk	code-library/Graph Theory/Chinese Postman Problem.cpp	/^  int mat[N], stk[N], id[N], vis[N];$/;"	m	struct:RandomizedMatching	typeref:typename:int[]	file:
stk	code-library/Graph Theory/Randomized Matching Weighted.cpp	/^	int mat[N], stk[N], id[N], vis[N];$/;"	m	struct:RandomizedMatching	typeref:typename:int[]	file:
stk	code/Graph Theory/Chinese Postman Problem.cpp	/^  int mat[N], stk[N], id[N], vis[N];$/;"	m	struct:RandomizedMatching	typeref:typename:int[]	file:
stk	code/Graph Theory/Randomized Matching Weighted.cpp	/^	int mat[N], stk[N], id[N], vis[N];$/;"	m	struct:RandomizedMatching	typeref:typename:int[]	file:
store_grid	practice/cpbook/ch2/2.2/2D/11581/main.cpp	/^int grid[mxN][mxN], store_grid[mxN][mxN];$/;"	v	typeref:typename:int[][]
store_grid	practice/usacoguide/gold/bfs/mecho/main.cpp	/^char grid[mxN][mxN], store_grid[mxN][mxN];$/;"	v	typeref:typename:char[][]
str	code-library/Strings/Suffix Array Isomorphic.cpp	/^int str[N];$/;"	v	typeref:typename:int[]
str	code/Strings/Suffix Array Isomorphic.cpp	/^int str[N];$/;"	v	typeref:typename:int[]
string_matching	code-library/Strings/String Matching With FFT.cpp	/^vector<int> string_matching(string &s, string &t) {$/;"	f	typeref:typename:vector<int>
string_matching	code/Strings/String Matching With FFT.cpp	/^vector<int> string_matching(string &s, string &t) {$/;"	f	typeref:typename:vector<int>
sub	code-library/Math/Finite Field Arithmetic Binary.cpp	/^  inline int sub(int a, int b) { return a ^ b; }$/;"	f	namespace:FFA	typeref:typename:int
sub	code-library/Strings/Bit LCS.cpp	/^    void sub(const Bitset &r) {$/;"	f	struct:Bitset	typeref:typename:void	file:
sub	code/Math/Finite Field Arithmetic Binary.cpp	/^  inline int sub(int a, int b) { return a ^ b; }$/;"	f	namespace:FFA	typeref:typename:int
sub	code/Strings/Bit LCS.cpp	/^    void sub(const Bitset &r) {$/;"	f	struct:Bitset	typeref:typename:void	file:
subX_addY	code-library/Graph Theory/Hungarian Algorithm.cpp	/^  void subX_addY() {$/;"	f	struct:Hungarian	typeref:typename:void	file:
subX_addY	code/Graph Theory/Hungarian Algorithm.cpp	/^  void subX_addY() {$/;"	f	struct:Hungarian	typeref:typename:void	file:
sub_mod	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static R sub_mod(R a, R b) { return int(a -= b) < 0 ? a + mod : a; }$/;"	f	class:poly	typeref:typename:R	file:
sub_mod	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static R sub_mod(R a, R b) { return int(a -= b) < 0 ? a + mod : a; }$/;"	f	class:poly	typeref:typename:R	file:
sub_mul_mod	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static R64 sub_mul_mod(R64 a, R b, R c) {$/;"	f	class:poly	typeref:typename:R64	file:
sub_mul_mod	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static R64 sub_mul_mod(R64 a, R b, R c) {$/;"	f	class:poly	typeref:typename:R64	file:
subset_sum	code-library/Dynamic Programming Optimizations/Subset Sum in SQRT.cpp	/^vector<int> subset_sum(vector<int> a, int s) {$/;"	f	typeref:typename:vector<int>
subset_sum	code-library/Graph Theory/Tree Orientation.cpp	/^vector<int> subset_sum(vector<int> a) {$/;"	f	typeref:typename:vector<int>
subset_sum	code/Dynamic Programming Optimizations/Subset Sum in SQRT.cpp	/^vector<int> subset_sum(vector<int> a, int s) {$/;"	f	typeref:typename:vector<int>
subset_sum	code/Graph Theory/Tree Orientation.cpp	/^vector<int> subset_sum(vector<int> a) {$/;"	f	typeref:typename:vector<int>
subset_sum_convolution	code-library/Dynamic Programming Optimizations/SOS convolutions.cpp	/^vector<int> subset_sum_convolution(vector<int> f, vector<int> g) {$/;"	f	namespace:SOS	typeref:typename:vector<int>
subset_sum_convolution	code/Dynamic Programming Optimizations/SOS convolutions.cpp	/^vector<int> subset_sum_convolution(vector<int> f, vector<int> g) {$/;"	f	namespace:SOS	typeref:typename:vector<int>
substr	code-library/Math/Faulhaber Formula Fastest.cpp	/^  poly substr(int l, int r) const { \/\/ return mod_xk(r).div_xk(l)$/;"	f	struct:poly	typeref:typename:poly	file:
substr	code-library/Math/Polynomial.cpp	/^  poly substr(int l, int r) const { \/\/ return mod_xk(r).div_xk(l)$/;"	f	struct:poly	typeref:typename:poly	file:
substr	code-library/Math/Subset Sum Problem.cpp	/^  poly substr(int l, int r) const { \/\/ return mod_xk(r).div_xk(l)$/;"	f	struct:poly	typeref:typename:poly	file:
substr	code-library/Number Theory/Bell Number.cpp	/^  poly substr(int l, int r) const { \/\/ return mod_xk(r).div_xk(l)$/;"	f	struct:poly	typeref:typename:poly	file:
substr	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  poly substr(int l, int r) const { \/\/ return mod_xk(r).div_xk(l)$/;"	f	struct:poly	typeref:typename:poly	file:
substr	code/Math/Faulhaber Formula Fastest.cpp	/^  poly substr(int l, int r) const { \/\/ return mod_xk(r).div_xk(l)$/;"	f	struct:poly	typeref:typename:poly	file:
substr	code/Math/Polynomial.cpp	/^  poly substr(int l, int r) const { \/\/ return mod_xk(r).div_xk(l)$/;"	f	struct:poly	typeref:typename:poly	file:
substr	code/Math/Subset Sum Problem.cpp	/^  poly substr(int l, int r) const { \/\/ return mod_xk(r).div_xk(l)$/;"	f	struct:poly	typeref:typename:poly	file:
substr	code/Number Theory/Bell Number.cpp	/^  poly substr(int l, int r) const { \/\/ return mod_xk(r).div_xk(l)$/;"	f	struct:poly	typeref:typename:poly	file:
substr	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^  poly substr(int l, int r) const { \/\/ return mod_xk(r).div_xk(l)$/;"	f	struct:poly	typeref:typename:poly	file:
subsum	code-library/Data Structures/Link Cut Tree.cpp	/^  long long val = 0, sum = 0, lazy = 0, subsum = 0, vsum = 0;$/;"	m	struct:node	typeref:typename:long long	file:
subsum	code/Data Structures/Link Cut Tree.cpp	/^  long long val = 0, sum = 0, lazy = 0, subsum = 0, vsum = 0;$/;"	m	struct:node	typeref:typename:long long	file:
subtree_lazy	code-library/Data Structures/Top Tree.cpp	/^  int64_t subtree_lazy = 0;$/;"	m	struct:top_tree_node	typeref:typename:int64_t	file:
subtree_lazy	code/Data Structures/Top Tree.cpp	/^  int64_t subtree_lazy = 0;$/;"	m	struct:top_tree_node	typeref:typename:int64_t	file:
subtree_query	code-library/Data Structures/Link Cut Tree.cpp	/^  long long subtree_query(int u, int root) {$/;"	f	struct:LCT	typeref:typename:long long	file:
subtree_query	code/Data Structures/Link Cut Tree.cpp	/^  long long subtree_query(int u, int root) {$/;"	f	struct:LCT	typeref:typename:long long	file:
subtree_size	code-library/Data Structures/Link Cut Tree.cpp	/^  int subtree_size(int u) {$/;"	f	struct:LCT	typeref:typename:int	file:
subtree_size	code-library/Data Structures/Top Tree.cpp	/^  int64_t subtree_size = 0;$/;"	m	struct:top_tree_node	typeref:typename:int64_t	file:
subtree_size	code/Data Structures/Link Cut Tree.cpp	/^  int subtree_size(int u) {$/;"	f	struct:LCT	typeref:typename:int	file:
subtree_size	code/Data Structures/Top Tree.cpp	/^  int64_t subtree_size = 0;$/;"	m	struct:top_tree_node	typeref:typename:int64_t	file:
subtree_sum	code-library/Data Structures/Link Cut Tree.cpp	/^  long long subtree_sum(int u) {$/;"	f	struct:LCT	typeref:typename:long long	file:
subtree_sum	code/Data Structures/Link Cut Tree.cpp	/^  long long subtree_sum(int u) {$/;"	f	struct:LCT	typeref:typename:long long	file:
subtree_xor	practice/cf/random/1700/4.cpp	/^vector<int> A, subtree_xor, dist;$/;"	v	typeref:typename:vector<int>
succ	code-library/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^  mutable function<const line*() > succ;$/;"	m	struct:line	typeref:typename:function<const line * ()>	file:
succ	code/Dynamic Programming Optimizations/Dynamic Convex Hull Trick.cpp	/^  mutable function<const line*() > succ;$/;"	m	struct:line	typeref:typename:function<const line * ()>	file:
suf	code-library/Data Structures/SQRT Tree.cpp	/^  vector< vector<SqrtTreeItem> > pref, suf, between;$/;"	m	struct:SqrtTree	typeref:typename:vector<vector<SqrtTreeItem>>	file:
suf	code-library/Strings/Suffix Array Isomorphic.cpp	/^int buc[N], r[N], suf[N], X[N], Y[N], high[N];$/;"	v	typeref:typename:int[]
suf	code/Data Structures/SQRT Tree.cpp	/^  vector< vector<SqrtTreeItem> > pref, suf, between;$/;"	m	struct:SqrtTree	typeref:typename:vector<vector<SqrtTreeItem>>	file:
suf	code/Strings/Suffix Array Isomorphic.cpp	/^int buc[N], r[N], suf[N], X[N], Y[N], high[N];$/;"	v	typeref:typename:int[]
suffix_array	code-library/Strings/Suffix Array.cpp	/^vector<int> suffix_array(const string &s, const int LIM = 128) {$/;"	f	typeref:typename:vector<int>
suffix_array	code/Strings/Suffix Array.cpp	/^vector<int> suffix_array(const string &s, const int LIM = 128) {$/;"	f	typeref:typename:vector<int>
suffix_array_DA	code-library/Strings/Suffix Array Isomorphic.cpp	/^void suffix_array_DA(int n, int m) {$/;"	f	typeref:typename:void
suffix_array_DA	code/Strings/Suffix Array Isomorphic.cpp	/^void suffix_array_DA(int n, int m) {$/;"	f	typeref:typename:void
sum	code-library/Data Structures/Binarizing a Tree.cpp	/^  long long sum = 0, parsum = 0;$/;"	m	struct:node	typeref:typename:long long	file:
sum	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^  long long sum = 0, parsum = 0;$/;"	m	struct:node	typeref:typename:long long	file:
sum	code-library/Data Structures/Implicit Treap.cpp	/^    int val, sz, prior, lazy, sum, mx, mn, repl;$/;"	m	struct:treap::node	typeref:typename:int	file:
sum	code-library/Data Structures/Link Cut Tree.cpp	/^  long long val = 0, sum = 0, lazy = 0, subsum = 0, vsum = 0;$/;"	m	struct:node	typeref:typename:long long	file:
sum	code-library/Data Structures/MOs Algorithm.cpp	/^long long sum;$/;"	v	typeref:typename:long long
sum	code-library/Data Structures/Segment Tree Beats.cpp	/^  ll sum[4 * N];$/;"	m	struct:SGTBeats	typeref:typename:ll[]	file:
sum	code-library/Data Structures/Venice Technique.cpp	/^  long long sum = 0;$/;"	m	struct:PQ	typeref:typename:long long	file:
sum	code-library/Data Structures/Wavelet Tree.cpp	/^  int sum(int l, int r, int k) {$/;"	f	struct:wavelet_tree	typeref:typename:int	file:
sum	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^ll sum[N];$/;"	v	typeref:typename:ll[]
sum	code-library/Graph Theory/Directed MST.cpp	/^  long long sum = 0;$/;"	m	struct:PQ	typeref:typename:long long	file:
sum	code-library/Strings/Number of Palindromes in Range.cpp	/^  int sum(int l, int r, int k) {$/;"	f	struct:wavelet_tree	typeref:typename:int	file:
sum	code/Data Structures/Binarizing a Tree.cpp	/^  long long sum = 0, parsum = 0;$/;"	m	struct:node	typeref:typename:long long	file:
sum	code/Data Structures/Centroid Decomposition Persistent.cpp	/^  long long sum = 0, parsum = 0;$/;"	m	struct:node	typeref:typename:long long	file:
sum	code/Data Structures/Implicit Treap.cpp	/^    int val, sz, prior, lazy, sum, mx, mn, repl;$/;"	m	struct:treap::node	typeref:typename:int	file:
sum	code/Data Structures/Link Cut Tree.cpp	/^  long long val = 0, sum = 0, lazy = 0, subsum = 0, vsum = 0;$/;"	m	struct:node	typeref:typename:long long	file:
sum	code/Data Structures/MOs Algorithm.cpp	/^long long sum;$/;"	v	typeref:typename:long long
sum	code/Data Structures/Segment Tree Beats.cpp	/^  ll sum[4 * N];$/;"	m	struct:SGTBeats	typeref:typename:ll[]	file:
sum	code/Data Structures/Venice Technique.cpp	/^  long long sum = 0;$/;"	m	struct:PQ	typeref:typename:long long	file:
sum	code/Data Structures/Wavelet Tree.cpp	/^  int sum(int l, int r, int k) {$/;"	f	struct:wavelet_tree	typeref:typename:int	file:
sum	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^ll sum[N];$/;"	v	typeref:typename:ll[]
sum	code/Graph Theory/Directed MST.cpp	/^  long long sum = 0;$/;"	m	struct:PQ	typeref:typename:long long	file:
sum	code/Strings/Number of Palindromes in Range.cpp	/^  int sum(int l, int r, int k) {$/;"	f	struct:wavelet_tree	typeref:typename:int	file:
sum	contests/Codeforces/1622/C/sol.cpp	/^int sum = 0, ans = 0;$/;"	v	typeref:typename:int
sum	contests/Codeforces/1622/C_new/sol.cpp	/^int N, K, sum = 0; $/;"	v	typeref:typename:int
sum	contests/USACO/dec_silver_2021/A/A.cpp	/^	int sum = 0;$/;"	m	struct:pi	typeref:typename:int	file:
sum	contests/USACO/dec_silver_2021/A/AA.cpp	/^	int sum = 0;$/;"	m	struct:pi	typeref:typename:int	file:
sum	contests/USACO/dec_silver_2021/A/A_safe.cpp	/^	int sum = 0;$/;"	m	struct:pi	typeref:typename:int	file:
sum	contests/USACO/dec_silver_2021/A/a_save.cpp	/^	int sum = 0;$/;"	m	struct:pi	typeref:typename:int	file:
sum	contests/USACO/dec_silver_2021/A/a_testing.cpp	/^	int sum = 0;$/;"	m	struct:pi	typeref:typename:int	file:
sum	contests/USACO/dec_silver_2021/A/restart_A.cpp	/^	int sum = 0;$/;"	m	struct:pi	typeref:typename:int	file:
sum	practice/usacoguide/silver/binsearch/sabotage.cpp	/^int N, sum = 0;$/;"	v	typeref:typename:int
sum_sigma0	code-library/Number Theory/Sum of The Number of Divisors in cbrt(n).cpp	/^uint128 sum_sigma0(uint64 n) {$/;"	f	typeref:typename:uint128
sum_sigma0	code/Number Theory/Sum of The Number of Divisors in cbrt(n).cpp	/^uint128 sum_sigma0(uint64 n) {$/;"	f	typeref:typename:uint128
sumsq	code-library/Number Theory/Floor Sum of  Arithmetic Progressions.cpp	/^ll sumsq(ll n) {$/;"	f	typeref:typename:ll
sumsq	code-library/Number Theory/Linear Diophantine Equation Three Variables with Nonnegative Solutions.cpp	/^T sumsq(T n) {$/;"	f	typeref:typename:T
sumsq	code-library/Number Theory/Sum of Arithmetic Progression Modular and Divided.cpp	/^long long sumsq(long long n) {$/;"	f	typeref:typename:long long
sumsq	code/Number Theory/Floor Sum of  Arithmetic Progressions.cpp	/^ll sumsq(ll n) {$/;"	f	typeref:typename:ll
sumsq	code/Number Theory/Linear Diophantine Equation Three Variables with Nonnegative Solutions.cpp	/^T sumsq(T n) {$/;"	f	typeref:typename:T
sumsq	code/Number Theory/Sum of Arithmetic Progression Modular and Divided.cpp	/^long long sumsq(long long n) {$/;"	f	typeref:typename:long long
surface_area	code-library/Geometry/Geometry 3D.cpp	/^    double surface_area() {$/;"	f	struct:CH3D	typeref:typename:double	file:
surface_area	code/Geometry/Geometry 3D.cpp	/^    double surface_area() {$/;"	f	struct:CH3D	typeref:typename:double	file:
surreal	code-library/Game Theory/Blue Red Hackenbush.cpp	/^  surreal() {$/;"	f	struct:surreal	file:
surreal	code-library/Game Theory/Blue Red Hackenbush.cpp	/^struct surreal {$/;"	s	file:
surreal	code/Game Theory/Blue Red Hackenbush.cpp	/^  surreal() {$/;"	f	struct:surreal	file:
surreal	code/Game Theory/Blue Red Hackenbush.cpp	/^struct surreal {$/;"	s	file:
suspect	code-library/Number Theory/Prime Factorization Fastest.cpp	/^bool suspect(const uint64_t &a, const uint64_t &s, uint64_t d, const uint64_t &n) {$/;"	f	typeref:typename:bool
suspect	code/Number Theory/Prime Factorization Fastest.cpp	/^bool suspect(const uint64_t &a, const uint64_t &s, uint64_t d, const uint64_t &n) {$/;"	f	typeref:typename:bool
swap	code-library/Miscellaneous/BigInt.cpp	/^  friend void swap(BigInt& a, BigInt& b) {$/;"	f	typeref:typename:void	file:
swap	code/Miscellaneous/BigInt.cpp	/^  friend void swap(BigInt& a, BigInt& b) {$/;"	f	typeref:typename:void	file:
sweepline	code-library/Geometry/Point Location.cpp	/^vector<edge*> sweepline(vector<edge*> planar, vector<PT> queries) {$/;"	f	typeref:typename:vector<edge * >
sweepline	code/Geometry/Point Location.cpp	/^vector<edge*> sweepline(vector<edge*> planar, vector<PT> queries) {$/;"	f	typeref:typename:vector<edge * >
sz	code-library/Data Structures/Binarizing a Tree.cpp	/^int sz[N * 2];$/;"	v	typeref:typename:int[]
sz	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^int sz[N * 2];$/;"	v	typeref:typename:int[]
sz	code-library/Data Structures/Centroid Decomposition.cpp	/^int sz[N];$/;"	v	typeref:typename:int[]
sz	code-library/Data Structures/DSU on Tree.cpp	/^int ans[N], col[N], sz[N], cnt[N];$/;"	v	typeref:typename:int[]
sz	code-library/Data Structures/DSU with Rollbacks.cpp	/^  vector<int> par, sz, w;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
sz	code-library/Data Structures/DSU.cpp	/^  vector<int> par, rnk, sz;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
sz	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int par[N][LG + 1], dep[N], sz[N];$/;"	v	typeref:typename:int[]
sz	code-library/Data Structures/HLD.cpp	/^int par[N][LG + 1], dep[N], sz[N];$/;"	v	typeref:typename:int[]
sz	code-library/Data Structures/Implicit Treap.cpp	/^    int val, sz, prior, lazy, sum, mx, mn, repl;$/;"	m	struct:treap::node	typeref:typename:int	file:
sz	code-library/Data Structures/LCA.cpp	/^int par[N][LG + 1], dep[N], sz[N];$/;"	v	typeref:typename:int[]
sz	code-library/Data Structures/Link Cut Tree.cpp	/^  int sz = 0, ssz = 0, vsz = 0; \/\/ sz -> aux tree size, ssz = subtree size in rep tree, vsz = /;"	m	struct:node	typeref:typename:int	file:
sz	code-library/Data Structures/Persistent Meldable Heap.cpp	/^    int sz; T val;$/;"	m	struct:heap::node	typeref:typename:int	file:
sz	code-library/Data Structures/Persistent UnionFind.cpp	/^  PersistentArray<int> par, sz;$/;"	m	struct:PersistentDSU	typeref:typename:PersistentArray<int>	file:
sz	code-library/Data Structures/Queue Undo Trick.cpp	/^  vector<int> par, sz, w;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
sz	code-library/Data Structures/Segment Tree Merging.cpp	/^    int l, r, sz;$/;"	m	struct:STM::node	typeref:typename:int	file:
sz	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^  vector<int> v, sorted_v; int sz = 0;$/;"	m	struct:Block	typeref:typename:int	file:
sz	code-library/Data Structures/Treap persistent.cpp	/^  int val, prior, sz;$/;"	m	struct:node	typeref:typename:int	file:
sz	code-library/Data Structures/Trie.cpp	/^    int sz;$/;"	m	struct:Trie::node	typeref:typename:int	file:
sz	code-library/Dynamic Programming Optimizations/Persistent CHT.cpp	/^  int p[N][lg], sz;$/;"	m	struct:PersistentCHT	typeref:typename:int	file:
sz	code-library/Dynamic Programming Optimizations/Subset Sum in SQRT.cpp	/^int ans[N], dep[N], sz[N];$/;"	v	typeref:typename:int[]
sz	code-library/Graph Theory/Block Cut Tree.cpp	/^int T, low[N], dis[N], art[N], sz;$/;"	v	typeref:typename:int
sz	code-library/Graph Theory/Boruvka's Algorithm.cpp	/^int t[N * 30][2], sz;$/;"	v	typeref:typename:int
sz	code-library/Graph Theory/Eppsteins Algorithm.cpp	/^    int sz; T val;$/;"	m	struct:heap::node	typeref:typename:int	file:
sz	code-library/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^int fa[N], sz[N];$/;"	v	typeref:typename:int[]
sz	code-library/Graph Theory/LCA.cpp	/^int par[N][LG + 1], dep[N], sz[N];$/;"	v	typeref:typename:int[]
sz	code-library/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^int sz[N];$/;"	v	typeref:typename:int[]
sz	code-library/Graph Theory/Online Articulation Bridges.cpp	/^int n, bridges, par[N], bl[N], comp[N], sz[N];$/;"	v	typeref:typename:int[]
sz	code-library/Graph Theory/Path Intersection.cpp	/^int par[N][20], dep[N], sz[N];$/;"	v	typeref:typename:int[]
sz	code-library/Graph Theory/Path Union.cpp	/^int par[N][20], dep[N], sz[N];$/;"	v	typeref:typename:int[]
sz	code-library/Graph Theory/Tree Orientation.cpp	/^int sz[N];$/;"	v	typeref:typename:int[]
sz	code-library/Graph Theory/Virtual Tree.cpp	/^int par[N][20], dep[N], sz[N], st[N], en[N], T;$/;"	v	typeref:typename:int[]
sz	code-library/Miscellaneous/Bitset Custom.cpp	/^    const static int sz = (S + 63) \/ 64, extra = 64 - sz * 64 + S;$/;"	m	struct:Bitset	typeref:typename:const int	file:
sz	code-library/Miscellaneous/Bitset Custom.cpp	/^const int sz = N \/ 64 + 2;$/;"	v	typeref:typename:const int
sz	code-library/Miscellaneous/Parallel Binary Search.cpp	/^  int sz;$/;"	m	struct:BIT	typeref:typename:int	file:
sz	code-library/Number Theory/Dirichlet Convolution.cpp	/^  int sz, spf[T], prime[T];$/;"	v	namespace:Dirichlet	typeref:typename:int
sz	code-library/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^int sz[N];$/;"	v	typeref:typename:int[]
sz	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  int link[L], sz, to[L][2], dp[L][2], term[L], last[L]; \/\/ each string contains 'a' and 'b'$/;"	m	struct:AhoCorasick	typeref:typename:int	file:
sz	code-library/Strings/Palindromic Tree Persistent.cpp	/^  int sz, last;$/;"	m	struct:PalindromicTree	typeref:typename:int	file:
sz	code-library/Strings/Palindromic Tree.cpp	/^  int sz, last;$/;"	m	struct:PalindromicTree	typeref:typename:int	file:
sz	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  int sz, last;$/;"	m	struct:SuffixAutomaton	typeref:typename:int	file:
sz	code-library/Strings/Suffix Automaton.cpp	/^    int sz, last;$/;"	m	struct:SuffixAutomaton	typeref:typename:int	file:
sz	code/Data Structures/Binarizing a Tree.cpp	/^int sz[N * 2];$/;"	v	typeref:typename:int[]
sz	code/Data Structures/Centroid Decomposition Persistent.cpp	/^int sz[N * 2];$/;"	v	typeref:typename:int[]
sz	code/Data Structures/Centroid Decomposition.cpp	/^int sz[N];$/;"	v	typeref:typename:int[]
sz	code/Data Structures/DSU on Tree.cpp	/^int ans[N], col[N], sz[N], cnt[N];$/;"	v	typeref:typename:int[]
sz	code/Data Structures/DSU with Rollbacks.cpp	/^  vector<int> par, sz, w;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
sz	code/Data Structures/DSU.cpp	/^  vector<int> par, rnk, sz;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
sz	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^int par[N][LG + 1], dep[N], sz[N];$/;"	v	typeref:typename:int[]
sz	code/Data Structures/HLD.cpp	/^int par[N][LG + 1], dep[N], sz[N];$/;"	v	typeref:typename:int[]
sz	code/Data Structures/Implicit Treap.cpp	/^    int val, sz, prior, lazy, sum, mx, mn, repl;$/;"	m	struct:treap::node	typeref:typename:int	file:
sz	code/Data Structures/LCA.cpp	/^int par[N][LG + 1], dep[N], sz[N];$/;"	v	typeref:typename:int[]
sz	code/Data Structures/Link Cut Tree.cpp	/^  int sz = 0, ssz = 0, vsz = 0; \/\/ sz -> aux tree size, ssz = subtree size in rep tree, vsz = /;"	m	struct:node	typeref:typename:int	file:
sz	code/Data Structures/Persistent Meldable Heap.cpp	/^    int sz; T val;$/;"	m	struct:heap::node	typeref:typename:int	file:
sz	code/Data Structures/Persistent UnionFind.cpp	/^  PersistentArray<int> par, sz;$/;"	m	struct:PersistentDSU	typeref:typename:PersistentArray<int>	file:
sz	code/Data Structures/Queue Undo Trick.cpp	/^  vector<int> par, sz, w;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
sz	code/Data Structures/Segment Tree Merging.cpp	/^    int l, r, sz;$/;"	m	struct:STM::node	typeref:typename:int	file:
sz	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^  vector<int> v, sorted_v; int sz = 0;$/;"	m	struct:Block	typeref:typename:int	file:
sz	code/Data Structures/Treap persistent.cpp	/^  int val, prior, sz;$/;"	m	struct:node	typeref:typename:int	file:
sz	code/Data Structures/Trie.cpp	/^    int sz;$/;"	m	struct:Trie::node	typeref:typename:int	file:
sz	code/Dynamic Programming Optimizations/Persistent CHT.cpp	/^  int p[N][lg], sz;$/;"	m	struct:PersistentCHT	typeref:typename:int	file:
sz	code/Dynamic Programming Optimizations/Subset Sum in SQRT.cpp	/^int ans[N], dep[N], sz[N];$/;"	v	typeref:typename:int[]
sz	code/Graph Theory/Block Cut Tree.cpp	/^int T, low[N], dis[N], art[N], sz;$/;"	v	typeref:typename:int
sz	code/Graph Theory/Boruvka's Algorithm.cpp	/^int t[N * 30][2], sz;$/;"	v	typeref:typename:int
sz	code/Graph Theory/Eppsteins Algorithm.cpp	/^    int sz; T val;$/;"	m	struct:heap::node	typeref:typename:int	file:
sz	code/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^int fa[N], sz[N];$/;"	v	typeref:typename:int[]
sz	code/Graph Theory/LCA.cpp	/^int par[N][LG + 1], dep[N], sz[N];$/;"	v	typeref:typename:int[]
sz	code/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^int sz[N];$/;"	v	typeref:typename:int[]
sz	code/Graph Theory/Online Articulation Bridges.cpp	/^int n, bridges, par[N], bl[N], comp[N], sz[N];$/;"	v	typeref:typename:int[]
sz	code/Graph Theory/Path Intersection.cpp	/^int par[N][20], dep[N], sz[N];$/;"	v	typeref:typename:int[]
sz	code/Graph Theory/Path Union.cpp	/^int par[N][20], dep[N], sz[N];$/;"	v	typeref:typename:int[]
sz	code/Graph Theory/Tree Orientation.cpp	/^int sz[N];$/;"	v	typeref:typename:int[]
sz	code/Graph Theory/Virtual Tree.cpp	/^int par[N][20], dep[N], sz[N], st[N], en[N], T;$/;"	v	typeref:typename:int[]
sz	code/Miscellaneous/Bitset Custom.cpp	/^    const static int sz = (S + 63) \/ 64, extra = 64 - sz * 64 + S;$/;"	m	struct:Bitset	typeref:typename:const int	file:
sz	code/Miscellaneous/Bitset Custom.cpp	/^const int sz = N \/ 64 + 2;$/;"	v	typeref:typename:const int
sz	code/Miscellaneous/Parallel Binary Search.cpp	/^  int sz;$/;"	m	struct:BIT	typeref:typename:int	file:
sz	code/Number Theory/Dirichlet Convolution.cpp	/^  int sz, spf[T], prime[T];$/;"	v	namespace:Dirichlet	typeref:typename:int
sz	code/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^int sz[N];$/;"	v	typeref:typename:int[]
sz	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  int link[L], sz, to[L][2], dp[L][2], term[L], last[L]; \/\/ each string contains 'a' and 'b'$/;"	m	struct:AhoCorasick	typeref:typename:int	file:
sz	code/Strings/Palindromic Tree Persistent.cpp	/^  int sz, last;$/;"	m	struct:PalindromicTree	typeref:typename:int	file:
sz	code/Strings/Palindromic Tree.cpp	/^  int sz, last;$/;"	m	struct:PalindromicTree	typeref:typename:int	file:
sz	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  int sz, last;$/;"	m	struct:SuffixAutomaton	typeref:typename:int	file:
sz	code/Strings/Suffix Automaton.cpp	/^    int sz, last;$/;"	m	struct:SuffixAutomaton	typeref:typename:int	file:
t	code-library/Data Structures/BIT 2D with Range Update and Range Query.cpp	/^} t;$/;"	v	typeref:struct:BIT2D
t	code-library/Data Structures/BIT with Range Update and Range Query.cpp	/^} t;$/;"	v	typeref:struct:BIT
t	code-library/Data Structures/BIT.cpp	/^  int n; vector<T> t;$/;"	m	struct:BIT	typeref:typename:vector<T>	file:
t	code-library/Data Structures/Binarizing a Tree.cpp	/^}t[M];$/;"	v	typeref:struct:node[]
t	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^} t[M];$/;"	v	typeref:struct:node[]
t	code-library/Data Structures/Dynamic Diameter Online.cpp	/^    node t[4 * N * 2];$/;"	m	struct:ST	typeref:typename:node[]	file:
t	code-library/Data Structures/Dynamic Diameter Online.cpp	/^}t;$/;"	v	typeref:struct:ST
t	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    }t[400 * N];$/;"	m	struct:PST	typeref:struct:PST::node[]	file:
t	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^PST<1> t;$/;"	v	typeref:typename:PST<1>
t	code-library/Data Structures/HLD.cpp	/^  int t[4 * N], lazy[4 * N];$/;"	m	struct:ST	typeref:typename:int[]	file:
t	code-library/Data Structures/HLD.cpp	/^} t;$/;"	v	typeref:struct:ST
t	code-library/Data Structures/Implicit Treap.cpp	/^treap t;$/;"	v	typeref:typename:treap
t	code-library/Data Structures/Link Cut Tree.cpp	/^  vector<node> t;$/;"	m	struct:LCT	typeref:typename:vector<node>	file:
t	code-library/Data Structures/Link Cut Tree.cpp	/^}t[2];$/;"	v	typeref:struct:LCT[2]
t	code-library/Data Structures/MOs Online.cpp	/^} t[C * (C + 1) \/ 2 + 10], ds;$/;"	v	typeref:struct:MEX[]
t	code-library/Data Structures/MOs with Update.cpp	/^  int l, r, t, id;$/;"	m	struct:query	typeref:typename:int	file:
t	code-library/Data Structures/MOs with Update.cpp	/^int cnt[N], f[N], ans[N], l, r, t;$/;"	v	typeref:typename:int
t	code-library/Data Structures/Permutation Tree.cpp	/^  int t[4 * N], lazy[4 * N];$/;"	m	struct:ST	typeref:typename:int[]	file:
t	code-library/Data Structures/Permutation Tree.cpp	/^} t;$/;"	v	typeref:struct:ST
t	code-library/Data Structures/Reachability Tree.cpp	/^pair<int, int> t[8 * N];$/;"	v	typeref:typename:pair<int,int>[]
t	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  treap t;$/;"	m	struct:ST	typeref:typename:treap	file:
t	code-library/Data Structures/Segment Tree Lazy.cpp	/^  long long t[4 * N], lazy[4 * N];$/;"	m	struct:ST	typeref:typename:long long[]	file:
t	code-library/Data Structures/Segment Tree Merging.cpp	/^  } t[N * 30];$/;"	m	struct:STM	typeref:struct:STM::node[]	file:
t	code-library/Data Structures/Segment Tree Merging.cpp	/^} t;$/;"	v	typeref:struct:STM
t	code-library/Data Structures/Segment Tree NonRecursive.cpp	/^  int t[2 * N];$/;"	m	struct:ST	typeref:typename:int[]	file:
t	code-library/Data Structures/Segment Tree NonRecursive.cpp	/^} t;$/;"	v	typeref:struct:ST
t	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^  } t[300 * N];$/;"	m	struct:PST	typeref:struct:PST::node[]	file:
t	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^} t;$/;"	v	typeref:struct:PST
t	code-library/Data Structures/Segment Tree Persistent.cpp	/^  } t[20 * N];$/;"	m	struct:PST	typeref:struct:PST::node[]	file:
t	code-library/Data Structures/Segment Tree Persistent.cpp	/^} t;$/;"	v	typeref:struct:PST
t	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  mint t[N << 2];$/;"	m	struct:ST	typeref:typename:mint[]	file:
t	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^ST t;$/;"	v	typeref:typename:ST
t	code-library/Data Structures/Segment Tree.cpp	/^  int t[4 * N];$/;"	m	struct:ST	typeref:typename:int[]	file:
t	code-library/Data Structures/Segment Tree.cpp	/^}t;$/;"	v	typeref:struct:ST
t	code-library/Data Structures/Sparse Table.cpp	/^int t[N][18], a[N];$/;"	v	typeref:typename:int[][18]
t	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^}t[2000];$/;"	v	typeref:struct:Block[2000]
t	code-library/Data Structures/Treap.cpp	/^} t[N];$/;"	v	typeref:struct:treap[]
t	code-library/Data Structures/Trie.cpp	/^} t;$/;"	v	typeref:struct:Trie
t	code-library/Data Structures/Wavelet Tree.cpp	/^wavelet_tree t;$/;"	v	typeref:typename:wavelet_tree
t	code-library/Dynamic Programming Optimizations/1D1D DP.cpp	/^int n, s, t[N], f[N];$/;"	v	typeref:typename:int[]
t	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^} t[50 * N];$/;"	v	typeref:struct:LiChaoNode[]
t	code-library/Game Theory/Matching Game On A Graph.cpp	/^  int vis[N], par[N], orig[N], match[N], aux[N], t;$/;"	m	struct:Blossom	typeref:typename:int	file:
t	code-library/Graph Theory/Articulation Bridges.cpp	/^  vector<vector<int>> g, t;$/;"	m	struct:TECC	typeref:typename:vector<vector<int>>	file:
t	code-library/Graph Theory/Blossom Algorithm.cpp	/^  int vis[N], par[N], orig[N], match[N], aux[N], t;$/;"	m	struct:Blossom	typeref:typename:int	file:
t	code-library/Graph Theory/Boruvka's Algorithm.cpp	/^int t[N * 30][2], sz;$/;"	v	typeref:typename:int[][2]
t	code-library/Graph Theory/Dinics Algorithm.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
t	code-library/Graph Theory/Dominator Tree.cpp	/^vector<int> t[N], rg[N], bucket[N]; \/\/t = dominator tree of the nodes reachable from root$/;"	v	typeref:typename:vector<int>[]
t	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  int V, s, t;$/;"	m	struct:Dinic	typeref:typename:int	file:
t	code-library/Graph Theory/L R Flow with Dinic.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
t	code-library/Graph Theory/L R Flow with Dinic.cpp	/^  int n, s, t;$/;"	m	struct:LR_Flow	typeref:typename:int	file:
t	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  int n, s, t, mxid;$/;"	m	struct:MCMF	typeref:typename:int	file:
t	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  int n, s, t;$/;"	m	struct:LR_Flow	typeref:typename:int	file:
t	code-library/Graph Theory/Manhattan MST.cpp	/^} t[N];$/;"	v	typeref:struct:node[]
t	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
t	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
t	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^int s, t, n, m, u[N], v[N], deg[N];$/;"	v	typeref:typename:int
t	code-library/Graph Theory/Min Cost Max Flow.cpp	/^  int n, s, t, mxid;$/;"	m	struct:MCMF	typeref:typename:int	file:
t	code-library/Graph Theory/Min Cut in a Planar Graph.cpp	/^int n, s, t, a[N];$/;"	v	typeref:typename:int
t	code-library/Graph Theory/Path Union.cpp	/^  pair<int, int> t[4 * N];$/;"	m	struct:segtree	typeref:typename:pair<int,int>[]	file:
t	code-library/Graph Theory/Path Union.cpp	/^} t;$/;"	v	typeref:struct:segtree
t	code-library/Graph Theory/Unique Min Cut.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
t	code-library/Graph Theory/Virtual Tree.cpp	/^vector<int> t[N];$/;"	v	typeref:typename:vector<int>[]
t	code-library/Math/Basis Vector Reduced Row Echelon Form.cpp	/^}t;$/;"	v	typeref:struct:Basis
t	code-library/Math/Basis Vector ft Weighted Linearly Independent Vectors.cpp	/^Basis<__int128> t;$/;"	v	typeref:typename:Basis<__int128>
t	code-library/Math/Basis Vector.cpp	/^}t;$/;"	v	typeref:struct:Basis
t	code-library/Math/FWHT in Ternary Base.cpp	/^}t;$/;"	v	typeref:struct:FWHT
t	code-library/Math/FWHT.cpp	/^}t;$/;"	v	typeref:struct:FWHT
t	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^vector<mint> t[N * 4];$/;"	v	typeref:typename:vector<mint>[]
t	code-library/Miscellaneous/Bitset Custom.cpp	/^Bitset<N> bs[101], nw, t;$/;"	v	typeref:typename:Bitset<N>
t	code-library/Miscellaneous/MEX of all Subarrays.cpp	/^  int t[4 * N];$/;"	m	struct:ST	typeref:typename:int[]	file:
t	code-library/Miscellaneous/MEX of all Subarrays.cpp	/^}t;$/;"	v	typeref:struct:ST
t	code-library/Miscellaneous/Parallel Binary Search.cpp	/^  vector<T> t;$/;"	m	struct:BIT	typeref:typename:vector<T>	file:
t	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^} t;$/;"	v	typeref:struct:AhoCorasick
t	code-library/Strings/Palindromic Tree Persistent.cpp	/^  string s; vector<node> t;$/;"	m	struct:PalindromicTree	typeref:typename:vector<node>	file:
t	code-library/Strings/Palindromic Tree Persistent.cpp	/^}t;$/;"	v	typeref:struct:PalindromicTree
t	code-library/Strings/Palindromic Tree.cpp	/^  vector<node> t;$/;"	m	struct:PalindromicTree	typeref:typename:vector<node>	file:
t	code-library/Strings/Palindromic Tree.cpp	/^} t;$/;"	v	typeref:struct:PalindromicTree
t	code-library/Strings/Suffix Array Isomorphic.cpp	/^  vector<vector<int>> t;$/;"	m	struct:IsomorphicSuffixArray	typeref:typename:vector<vector<int>>	file:
t	code-library/Strings/Suffix Array Isomorphic.cpp	/^  vector<vector<int>> t;$/;"	m	struct:SuffixArray	typeref:typename:vector<vector<int>>	file:
t	code-library/Strings/Suffix Array.cpp	/^  vector<vector<int>> t;$/;"	m	struct:SuffixArray	typeref:typename:vector<vector<int>>	file:
t	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  long long t[4 * N], lazy[4 * N];$/;"	m	struct:ST	typeref:typename:long long[]	file:
t	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^vector<node> t;$/;"	v	typeref:typename:vector<node>
t	code-library/Strings/Suffix Automaton.cpp	/^    vector<node> t;$/;"	m	struct:SuffixAutomaton	typeref:typename:vector<node>	file:
t	code/Data Structures/BIT 2D with Range Update and Range Query.cpp	/^} t;$/;"	v	typeref:struct:BIT2D
t	code/Data Structures/BIT with Range Update and Range Query.cpp	/^} t;$/;"	v	typeref:struct:BIT
t	code/Data Structures/BIT.cpp	/^  int n; vector<T> t;$/;"	m	struct:BIT	typeref:typename:vector<T>	file:
t	code/Data Structures/Binarizing a Tree.cpp	/^}t[M];$/;"	v	typeref:struct:node[]
t	code/Data Structures/Centroid Decomposition Persistent.cpp	/^} t[M];$/;"	v	typeref:struct:node[]
t	code/Data Structures/Dynamic Diameter Online.cpp	/^    node t[4 * N * 2];$/;"	m	struct:ST	typeref:typename:node[]	file:
t	code/Data Structures/Dynamic Diameter Online.cpp	/^}t;$/;"	v	typeref:struct:ST
t	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    }t[400 * N];$/;"	m	struct:PST	typeref:struct:PST::node[]	file:
t	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^PST<1> t;$/;"	v	typeref:typename:PST<1>
t	code/Data Structures/HLD.cpp	/^  int t[4 * N], lazy[4 * N];$/;"	m	struct:ST	typeref:typename:int[]	file:
t	code/Data Structures/HLD.cpp	/^} t;$/;"	v	typeref:struct:ST
t	code/Data Structures/Implicit Treap.cpp	/^treap t;$/;"	v	typeref:typename:treap
t	code/Data Structures/Link Cut Tree.cpp	/^  vector<node> t;$/;"	m	struct:LCT	typeref:typename:vector<node>	file:
t	code/Data Structures/Link Cut Tree.cpp	/^}t[2];$/;"	v	typeref:struct:LCT[2]
t	code/Data Structures/MOs Online.cpp	/^} t[C * (C + 1) \/ 2 + 10], ds;$/;"	v	typeref:struct:MEX[]
t	code/Data Structures/MOs with Update.cpp	/^  int l, r, t, id;$/;"	m	struct:query	typeref:typename:int	file:
t	code/Data Structures/MOs with Update.cpp	/^int cnt[N], f[N], ans[N], l, r, t;$/;"	v	typeref:typename:int
t	code/Data Structures/Permutation Tree.cpp	/^  int t[4 * N], lazy[4 * N];$/;"	m	struct:ST	typeref:typename:int[]	file:
t	code/Data Structures/Permutation Tree.cpp	/^} t;$/;"	v	typeref:struct:ST
t	code/Data Structures/Reachability Tree.cpp	/^pair<int, int> t[8 * N];$/;"	v	typeref:typename:pair<int,int>[]
t	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  treap t;$/;"	m	struct:ST	typeref:typename:treap	file:
t	code/Data Structures/Segment Tree Lazy.cpp	/^  long long t[4 * N], lazy[4 * N];$/;"	m	struct:ST	typeref:typename:long long[]	file:
t	code/Data Structures/Segment Tree Merging.cpp	/^  } t[N * 30];$/;"	m	struct:STM	typeref:struct:STM::node[]	file:
t	code/Data Structures/Segment Tree Merging.cpp	/^} t;$/;"	v	typeref:struct:STM
t	code/Data Structures/Segment Tree NonRecursive.cpp	/^  int t[2 * N];$/;"	m	struct:ST	typeref:typename:int[]	file:
t	code/Data Structures/Segment Tree NonRecursive.cpp	/^} t;$/;"	v	typeref:struct:ST
t	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^  } t[300 * N];$/;"	m	struct:PST	typeref:struct:PST::node[]	file:
t	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^} t;$/;"	v	typeref:struct:PST
t	code/Data Structures/Segment Tree Persistent.cpp	/^  } t[20 * N];$/;"	m	struct:PST	typeref:struct:PST::node[]	file:
t	code/Data Structures/Segment Tree Persistent.cpp	/^} t;$/;"	v	typeref:struct:PST
t	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  mint t[N << 2];$/;"	m	struct:ST	typeref:typename:mint[]	file:
t	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^ST t;$/;"	v	typeref:typename:ST
t	code/Data Structures/Segment Tree.cpp	/^  int t[4 * N];$/;"	m	struct:ST	typeref:typename:int[]	file:
t	code/Data Structures/Segment Tree.cpp	/^}t;$/;"	v	typeref:struct:ST
t	code/Data Structures/Sparse Table.cpp	/^int t[N][18], a[N];$/;"	v	typeref:typename:int[][18]
t	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^}t[2000];$/;"	v	typeref:struct:Block[2000]
t	code/Data Structures/Treap.cpp	/^} t[N];$/;"	v	typeref:struct:treap[]
t	code/Data Structures/Trie.cpp	/^} t;$/;"	v	typeref:struct:Trie
t	code/Data Structures/Wavelet Tree.cpp	/^wavelet_tree t;$/;"	v	typeref:typename:wavelet_tree
t	code/Dynamic Programming Optimizations/1D1D DP.cpp	/^int n, s, t[N], f[N];$/;"	v	typeref:typename:int[]
t	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^} t[50 * N];$/;"	v	typeref:struct:LiChaoNode[]
t	code/Game Theory/Matching Game On A Graph.cpp	/^  int vis[N], par[N], orig[N], match[N], aux[N], t;$/;"	m	struct:Blossom	typeref:typename:int	file:
t	code/Graph Theory/Articulation Bridges.cpp	/^  vector<vector<int>> g, t;$/;"	m	struct:TECC	typeref:typename:vector<vector<int>>	file:
t	code/Graph Theory/Blossom Algorithm.cpp	/^  int vis[N], par[N], orig[N], match[N], aux[N], t;$/;"	m	struct:Blossom	typeref:typename:int	file:
t	code/Graph Theory/Boruvka's Algorithm.cpp	/^int t[N * 30][2], sz;$/;"	v	typeref:typename:int[][2]
t	code/Graph Theory/Dinics Algorithm.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
t	code/Graph Theory/Dominator Tree.cpp	/^vector<int> t[N], rg[N], bucket[N]; \/\/t = dominator tree of the nodes reachable from root$/;"	v	typeref:typename:vector<int>[]
t	code/Graph Theory/Gomory Hu Tree.cpp	/^  int V, s, t;$/;"	m	struct:Dinic	typeref:typename:int	file:
t	code/Graph Theory/L R Flow with Dinic.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
t	code/Graph Theory/L R Flow with Dinic.cpp	/^  int n, s, t;$/;"	m	struct:LR_Flow	typeref:typename:int	file:
t	code/Graph Theory/L R Flow with MCMF.cpp	/^  int n, s, t, mxid;$/;"	m	struct:MCMF	typeref:typename:int	file:
t	code/Graph Theory/L R Flow with MCMF.cpp	/^  int n, s, t;$/;"	m	struct:LR_Flow	typeref:typename:int	file:
t	code/Graph Theory/Manhattan MST.cpp	/^} t[N];$/;"	v	typeref:struct:node[]
t	code/Graph Theory/Maximum Closure Problem.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
t	code/Graph Theory/Maximum Density Subgraph.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
t	code/Graph Theory/Maximum Density Subgraph.cpp	/^int s, t, n, m, u[N], v[N], deg[N];$/;"	v	typeref:typename:int
t	code/Graph Theory/Min Cost Max Flow.cpp	/^  int n, s, t, mxid;$/;"	m	struct:MCMF	typeref:typename:int	file:
t	code/Graph Theory/Min Cut in a Planar Graph.cpp	/^int n, s, t, a[N];$/;"	v	typeref:typename:int
t	code/Graph Theory/Path Union.cpp	/^  pair<int, int> t[4 * N];$/;"	m	struct:segtree	typeref:typename:pair<int,int>[]	file:
t	code/Graph Theory/Path Union.cpp	/^} t;$/;"	v	typeref:struct:segtree
t	code/Graph Theory/Unique Min Cut.cpp	/^  int n, s, t, mxid;$/;"	m	struct:Dinic	typeref:typename:int	file:
t	code/Graph Theory/Virtual Tree.cpp	/^vector<int> t[N];$/;"	v	typeref:typename:vector<int>[]
t	code/Math/Basis Vector Reduced Row Echelon Form.cpp	/^}t;$/;"	v	typeref:struct:Basis
t	code/Math/Basis Vector ft Weighted Linearly Independent Vectors.cpp	/^Basis<__int128> t;$/;"	v	typeref:typename:Basis<__int128>
t	code/Math/Basis Vector.cpp	/^}t;$/;"	v	typeref:struct:Basis
t	code/Math/FWHT in Ternary Base.cpp	/^}t;$/;"	v	typeref:struct:FWHT
t	code/Math/FWHT.cpp	/^}t;$/;"	v	typeref:struct:FWHT
t	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^vector<mint> t[N * 4];$/;"	v	typeref:typename:vector<mint>[]
t	code/Miscellaneous/Bitset Custom.cpp	/^Bitset<N> bs[101], nw, t;$/;"	v	typeref:typename:Bitset<N>
t	code/Miscellaneous/MEX of all Subarrays.cpp	/^  int t[4 * N];$/;"	m	struct:ST	typeref:typename:int[]	file:
t	code/Miscellaneous/MEX of all Subarrays.cpp	/^}t;$/;"	v	typeref:struct:ST
t	code/Miscellaneous/Parallel Binary Search.cpp	/^  vector<T> t;$/;"	m	struct:BIT	typeref:typename:vector<T>	file:
t	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^} t;$/;"	v	typeref:struct:AhoCorasick
t	code/Strings/Palindromic Tree Persistent.cpp	/^  string s; vector<node> t;$/;"	m	struct:PalindromicTree	typeref:typename:vector<node>	file:
t	code/Strings/Palindromic Tree Persistent.cpp	/^}t;$/;"	v	typeref:struct:PalindromicTree
t	code/Strings/Palindromic Tree.cpp	/^  vector<node> t;$/;"	m	struct:PalindromicTree	typeref:typename:vector<node>	file:
t	code/Strings/Palindromic Tree.cpp	/^} t;$/;"	v	typeref:struct:PalindromicTree
t	code/Strings/Suffix Array Isomorphic.cpp	/^  vector<vector<int>> t;$/;"	m	struct:IsomorphicSuffixArray	typeref:typename:vector<vector<int>>	file:
t	code/Strings/Suffix Array Isomorphic.cpp	/^  vector<vector<int>> t;$/;"	m	struct:SuffixArray	typeref:typename:vector<vector<int>>	file:
t	code/Strings/Suffix Array.cpp	/^  vector<vector<int>> t;$/;"	m	struct:SuffixArray	typeref:typename:vector<vector<int>>	file:
t	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  long long t[4 * N], lazy[4 * N];$/;"	m	struct:ST	typeref:typename:long long[]	file:
t	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^vector<node> t;$/;"	v	typeref:typename:vector<node>
t	code/Strings/Suffix Automaton.cpp	/^    vector<node> t;$/;"	m	struct:SuffixAutomaton	typeref:typename:vector<node>	file:
t	contests/Codeforces/1560/F1/main1.cpp	/^int t, n, k;$/;"	v	typeref:typename:int
t_a_b_s	practice/cf/random/1700/testing.cpp	/^template <typename T, size_t N> int SIZE(const T (&t)[N]){ return N; } template<typename T> int /;"	v	typeref:typename:int
taken	code-library/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^bool taken[N];$/;"	v	typeref:typename:bool[]
taken	code/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^bool taken[N];$/;"	v	typeref:typename:bool[]
tangent_lines_from_point	code-library/Geometry/Geometry 2D.cpp	/^int tangent_lines_from_point(PT p, double r, PT q, line &u, line &v) {$/;"	f	typeref:typename:int
tangent_lines_from_point	code/Geometry/Geometry 2D.cpp	/^int tangent_lines_from_point(PT p, double r, PT q, line &u, line &v) {$/;"	f	typeref:typename:int
tangents_from_point_to_polygon	code-library/Geometry/Geometry 2D.cpp	/^pair<int, int> tangents_from_point_to_polygon(vector<PT> &p, PT Q){$/;"	f	typeref:typename:pair<int,int>
tangents_from_point_to_polygon	code/Geometry/Geometry 2D.cpp	/^pair<int, int> tangents_from_point_to_polygon(vector<PT> &p, PT Q){$/;"	f	typeref:typename:pair<int,int>
tangents_lines_from_circle	code-library/Geometry/Geometry 2D.cpp	/^int tangents_lines_from_circle(PT c1, double r1, PT c2, double r2, bool inner, line &u, line &v)/;"	f	typeref:typename:int
tangents_lines_from_circle	code/Geometry/Geometry 2D.cpp	/^int tangents_lines_from_circle(PT c1, double r1, PT c2, double r2, bool inner, line &u, line &v)/;"	f	typeref:typename:int
target	code-library/Graph Theory/L R Flow with MCMF.cpp	/^  T target;$/;"	m	struct:LR_Flow	typeref:typename:T	file:
target	code/Graph Theory/L R Flow with MCMF.cpp	/^  T target;$/;"	m	struct:LR_Flow	typeref:typename:T	file:
task	practice/cpbook/ch1/1.4/medium/poi.cpp	/^int task[mxN][mxN];$/;"	v	typeref:typename:int[][]
taskClass	practice/cf/random/1700/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	s	object:languages.java
taskClass	practice/cf/random/1700/1618E/problem.json	/^{"name": "E. Singers' Tour", "group": "Codeforces - Codeforces Round #760 (Div. 3)", "url": "htt/;"	s	object:languages.java
taskClass	practice/cf/random/coloring/problem.json	/^{"name": "A. Dreamoon Likes Coloring", "group": "Codeforces - Codeforces Round #631 (Div. 1) - T/;"	s	object:languages.java
taskClass	practice/cf/random/diane/problem.json	/^{"name": "D. Diane", "group": "Codeforces - Codeforces Round #735 (Div. 2)", "url": "https:\/\/c/;"	s	object:languages.java
taskClass	practice/cf/random/pink/problem.json	/^{"name": "C. Pinkie Pie Eats Patty-cakes", "group": "Codeforces - Codeforces Round #662 (Div. 2)/;"	s	object:languages.java
taskClass	practice/cf/stuff/dec 20 2021/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	s	object:languages.java
taskClass	practice/usacoguide/gold/SP/dining/problem.json	/^{"name": "Problem 1. Fine Dining", "group": "USACO - USACO 2018 December Contest, Gold", "url": /;"	s	object:languages.java
taskClass	practice/usacoguide/gold/SP/visitfj/problem.json	/^{"name": "Problem 1. Why Did the Cow Cross the Road", "group": "USACO - USACO 2017 February Cont/;"	s	object:languages.java
taskClass	practice/usacoguide/gold/bfs/cownav/problem.json	/^{"name": "Problem 3. Cow Navigation", "group": "USACO - USACO 2017 January Contest, Gold", "url"/;"	s	object:languages.java
taskClass	practice/usacoguide/gold/bfs/swap/problem.json	/^{"name": "Swap Game", "group": "CSES - CSES Problem Set", "url": "https:\/\/cses.fi\/problemset\//;"	s	object:languages.java
taskClass	practice/usacoguide/gold/dsu/closing/problem.json	/^{"name": "Problem 2. Closing the Farm", "group": "USACO - USACO 2016 US Open Contest, Gold", "ur/;"	s	object:languages.java
taskClass	practice/usacoguide/gold/dsu/moocast/problem.json	/^{"name": "Problem 1. Moocast", "group": "USACO - USACO 2016 December Contest, Gold", "url": "htt/;"	s	object:languages.java
taskClass	practice/usacoguide/gold/dsu/mootube/problem.json	/^{"name": "Problem 1. MooTube", "group": "USACO - USACO 2018 January Contest, Gold", "url": "http/;"	s	object:languages.java
taskClass	practice/usacoguide/gold/dsu/tractor/problem.json	/^{"name": "Problem 2. Tractor", "group": "USACO - USACO 2013 February Contest, Silver", "url": "h/;"	s	object:languages.java
taskClass	practice/usacoguide/gold/dsu/wormhole/problem.json	/^{"name": "Problem 3. Wormhole Sort", "group": "USACO - USACO 2020 January Contest, Silver", "url/;"	s	object:languages.java
taskClass	practice/usacoguide/silver/idk/lirs/problem.json	/^{"name": "Problem 3. Liars and Truth Tellers", "group": "USACO - USACO 2013 January Contest, Bro/;"	s	object:languages.java
taskClass	practice/usacoguide/silver/idk/maze/problem.json	/^{"name": "Problem 1. Maze Tac Toe", "group": "USACO - USACO 2021 US Open, Silver", "url": "http:/;"	s	object:languages.java
term	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  int link[L], sz, to[L][2], dp[L][2], term[L], last[L]; \/\/ each string contains 'a' and 'b'$/;"	m	struct:AhoCorasick	typeref:typename:int[]	file:
term	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  int link[L], sz, to[L][2], dp[L][2], term[L], last[L]; \/\/ each string contains 'a' and 'b'$/;"	m	struct:AhoCorasick	typeref:typename:int[]	file:
terminal	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  vector<int> terminal;$/;"	m	struct:SuffixAutomaton	typeref:typename:vector<int>	file:
terminal	code-library/Strings/Suffix Automaton.cpp	/^    vector<int> terminal;$/;"	m	struct:SuffixAutomaton	typeref:typename:vector<int>	file:
terminal	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  vector<int> terminal;$/;"	m	struct:SuffixAutomaton	typeref:typename:vector<int>	file:
terminal	code/Strings/Suffix Automaton.cpp	/^    vector<int> terminal;$/;"	m	struct:SuffixAutomaton	typeref:typename:vector<int>	file:
testType	practice/cf/random/1700/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	s
testType	practice/cf/random/1700/1618E/problem.json	/^{"name": "E. Singers' Tour", "group": "Codeforces - Codeforces Round #760 (Div. 3)", "url": "htt/;"	s
testType	practice/cf/random/coloring/problem.json	/^{"name": "A. Dreamoon Likes Coloring", "group": "Codeforces - Codeforces Round #631 (Div. 1) - T/;"	s
testType	practice/cf/random/diane/problem.json	/^{"name": "D. Diane", "group": "Codeforces - Codeforces Round #735 (Div. 2)", "url": "https:\/\/c/;"	s
testType	practice/cf/random/pink/problem.json	/^{"name": "C. Pinkie Pie Eats Patty-cakes", "group": "Codeforces - Codeforces Round #662 (Div. 2)/;"	s
testType	practice/cf/stuff/dec 20 2021/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	s
testType	practice/usacoguide/gold/SP/dining/problem.json	/^{"name": "Problem 1. Fine Dining", "group": "USACO - USACO 2018 December Contest, Gold", "url": /;"	s
testType	practice/usacoguide/gold/SP/visitfj/problem.json	/^{"name": "Problem 1. Why Did the Cow Cross the Road", "group": "USACO - USACO 2017 February Cont/;"	s
testType	practice/usacoguide/gold/bfs/cownav/problem.json	/^{"name": "Problem 3. Cow Navigation", "group": "USACO - USACO 2017 January Contest, Gold", "url"/;"	s
testType	practice/usacoguide/gold/bfs/swap/problem.json	/^{"name": "Swap Game", "group": "CSES - CSES Problem Set", "url": "https:\/\/cses.fi\/problemset\//;"	s
testType	practice/usacoguide/gold/dsu/closing/problem.json	/^{"name": "Problem 2. Closing the Farm", "group": "USACO - USACO 2016 US Open Contest, Gold", "ur/;"	s
testType	practice/usacoguide/gold/dsu/moocast/problem.json	/^{"name": "Problem 1. Moocast", "group": "USACO - USACO 2016 December Contest, Gold", "url": "htt/;"	s
testType	practice/usacoguide/gold/dsu/mootube/problem.json	/^{"name": "Problem 1. MooTube", "group": "USACO - USACO 2018 January Contest, Gold", "url": "http/;"	s
testType	practice/usacoguide/gold/dsu/tractor/problem.json	/^{"name": "Problem 2. Tractor", "group": "USACO - USACO 2013 February Contest, Silver", "url": "h/;"	s
testType	practice/usacoguide/gold/dsu/wormhole/problem.json	/^{"name": "Problem 3. Wormhole Sort", "group": "USACO - USACO 2020 January Contest, Silver", "url/;"	s
testType	practice/usacoguide/silver/idk/lirs/problem.json	/^{"name": "Problem 3. Liars and Truth Tellers", "group": "USACO - USACO 2013 January Contest, Bro/;"	s
testType	practice/usacoguide/silver/idk/maze/problem.json	/^{"name": "Problem 1. Maze Tac Toe", "group": "USACO - USACO 2021 US Open, Silver", "url": "http:/;"	s
tests	code-library/Data Structures/KD Tree.cpp	/^int tests, n;$/;"	v	typeref:typename:int
tests	code/Data Structures/KD Tree.cpp	/^int tests, n;$/;"	v	typeref:typename:int
tests	practice/cf/random/1700/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	a
tests	practice/cf/random/1700/1618E/problem.json	/^{"name": "E. Singers' Tour", "group": "Codeforces - Codeforces Round #760 (Div. 3)", "url": "htt/;"	a
tests	practice/cf/random/coloring/problem.json	/^{"name": "A. Dreamoon Likes Coloring", "group": "Codeforces - Codeforces Round #631 (Div. 1) - T/;"	a
tests	practice/cf/random/diane/problem.json	/^{"name": "D. Diane", "group": "Codeforces - Codeforces Round #735 (Div. 2)", "url": "https:\/\/c/;"	a
tests	practice/cf/random/pink/problem.json	/^{"name": "C. Pinkie Pie Eats Patty-cakes", "group": "Codeforces - Codeforces Round #662 (Div. 2)/;"	a
tests	practice/cf/stuff/dec 20 2021/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	a
tests	practice/usacoguide/gold/SP/dining/problem.json	/^{"name": "Problem 1. Fine Dining", "group": "USACO - USACO 2018 December Contest, Gold", "url": /;"	a
tests	practice/usacoguide/gold/SP/visitfj/problem.json	/^{"name": "Problem 1. Why Did the Cow Cross the Road", "group": "USACO - USACO 2017 February Cont/;"	a
tests	practice/usacoguide/gold/bfs/cownav/problem.json	/^{"name": "Problem 3. Cow Navigation", "group": "USACO - USACO 2017 January Contest, Gold", "url"/;"	a
tests	practice/usacoguide/gold/bfs/swap/problem.json	/^{"name": "Swap Game", "group": "CSES - CSES Problem Set", "url": "https:\/\/cses.fi\/problemset\//;"	a
tests	practice/usacoguide/gold/dsu/closing/problem.json	/^{"name": "Problem 2. Closing the Farm", "group": "USACO - USACO 2016 US Open Contest, Gold", "ur/;"	a
tests	practice/usacoguide/gold/dsu/moocast/problem.json	/^{"name": "Problem 1. Moocast", "group": "USACO - USACO 2016 December Contest, Gold", "url": "htt/;"	a
tests	practice/usacoguide/gold/dsu/mootube/problem.json	/^{"name": "Problem 1. MooTube", "group": "USACO - USACO 2018 January Contest, Gold", "url": "http/;"	a
tests	practice/usacoguide/gold/dsu/tractor/problem.json	/^{"name": "Problem 2. Tractor", "group": "USACO - USACO 2013 February Contest, Silver", "url": "h/;"	a
tests	practice/usacoguide/gold/dsu/wormhole/problem.json	/^{"name": "Problem 3. Wormhole Sort", "group": "USACO - USACO 2020 January Contest, Silver", "url/;"	a
tests	practice/usacoguide/silver/idk/lirs/problem.json	/^{"name": "Problem 3. Liars and Truth Tellers", "group": "USACO - USACO 2013 January Contest, Bro/;"	a
tests	practice/usacoguide/silver/idk/maze/problem.json	/^{"name": "Problem 1. Maze Tac Toe", "group": "USACO - USACO 2021 US Open, Silver", "url": "http:/;"	a
time	code-library/Data Structures/DSU Partially Persistent.cpp	/^  int time = 0; \/\/initial time$/;"	m	struct:DSU	typeref:typename:int	file:
time	code-library/Data Structures/Persistent Trie.cpp	/^  int time;$/;"	m	struct:node_t	typeref:typename:int	file:
time	code/Data Structures/DSU Partially Persistent.cpp	/^  int time = 0; \/\/initial time$/;"	m	struct:DSU	typeref:typename:int	file:
time	code/Data Structures/Persistent Trie.cpp	/^  int time;$/;"	m	struct:node_t	typeref:typename:int	file:
timeLimit	practice/cf/random/1700/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	n
timeLimit	practice/cf/random/1700/1618E/problem.json	/^{"name": "E. Singers' Tour", "group": "Codeforces - Codeforces Round #760 (Div. 3)", "url": "htt/;"	n
timeLimit	practice/cf/random/coloring/problem.json	/^{"name": "A. Dreamoon Likes Coloring", "group": "Codeforces - Codeforces Round #631 (Div. 1) - T/;"	n
timeLimit	practice/cf/random/diane/problem.json	/^{"name": "D. Diane", "group": "Codeforces - Codeforces Round #735 (Div. 2)", "url": "https:\/\/c/;"	n
timeLimit	practice/cf/random/pink/problem.json	/^{"name": "C. Pinkie Pie Eats Patty-cakes", "group": "Codeforces - Codeforces Round #662 (Div. 2)/;"	n
timeLimit	practice/cf/stuff/dec 20 2021/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	n
timeLimit	practice/usacoguide/gold/SP/dining/problem.json	/^{"name": "Problem 1. Fine Dining", "group": "USACO - USACO 2018 December Contest, Gold", "url": /;"	n
timeLimit	practice/usacoguide/gold/SP/visitfj/problem.json	/^{"name": "Problem 1. Why Did the Cow Cross the Road", "group": "USACO - USACO 2017 February Cont/;"	n
timeLimit	practice/usacoguide/gold/bfs/cownav/problem.json	/^{"name": "Problem 3. Cow Navigation", "group": "USACO - USACO 2017 January Contest, Gold", "url"/;"	n
timeLimit	practice/usacoguide/gold/bfs/swap/problem.json	/^{"name": "Swap Game", "group": "CSES - CSES Problem Set", "url": "https:\/\/cses.fi\/problemset\//;"	n
timeLimit	practice/usacoguide/gold/dsu/closing/problem.json	/^{"name": "Problem 2. Closing the Farm", "group": "USACO - USACO 2016 US Open Contest, Gold", "ur/;"	n
timeLimit	practice/usacoguide/gold/dsu/moocast/problem.json	/^{"name": "Problem 1. Moocast", "group": "USACO - USACO 2016 December Contest, Gold", "url": "htt/;"	n
timeLimit	practice/usacoguide/gold/dsu/mootube/problem.json	/^{"name": "Problem 1. MooTube", "group": "USACO - USACO 2018 January Contest, Gold", "url": "http/;"	n
timeLimit	practice/usacoguide/gold/dsu/tractor/problem.json	/^{"name": "Problem 2. Tractor", "group": "USACO - USACO 2013 February Contest, Silver", "url": "h/;"	n
timeLimit	practice/usacoguide/gold/dsu/wormhole/problem.json	/^{"name": "Problem 3. Wormhole Sort", "group": "USACO - USACO 2020 January Contest, Silver", "url/;"	n
timeLimit	practice/usacoguide/silver/idk/lirs/problem.json	/^{"name": "Problem 3. Liars and Truth Tellers", "group": "USACO - USACO 2013 January Contest, Bro/;"	n
timeLimit	practice/usacoguide/silver/idk/maze/problem.json	/^{"name": "Problem 1. Maze Tac Toe", "group": "USACO - USACO 2021 US Open, Silver", "url": "http:/;"	n
timer	code-library/Graph Theory/LCA in O(1).cpp	/^  int timer = 0;$/;"	m	struct:LCA	typeref:typename:int	file:
timer	code/Graph Theory/LCA in O(1).cpp	/^  int timer = 0;$/;"	m	struct:LCA	typeref:typename:int	file:
tmp32	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static vector<R> tmp32;$/;"	m	class:poly	typeref:typename:vector<R>	file:
tmp32	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^vector<R> poly::tmp32;$/;"	m	class:poly	typeref:typename:vector<R>
tmp32	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static vector<R> tmp32;$/;"	m	class:poly	typeref:typename:vector<R>	file:
tmp32	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^vector<R> poly::tmp32;$/;"	m	class:poly	typeref:typename:vector<R>
tmp64	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static vector<R64> tmp64;$/;"	m	class:poly	typeref:typename:vector<R64>	file:
tmp64	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^vector<R64> poly::tmp64;$/;"	m	class:poly	typeref:typename:vector<R64>
tmp64	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  static vector<R64> tmp64;$/;"	m	class:poly	typeref:typename:vector<R64>	file:
tmp64	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^vector<R64> poly::tmp64;$/;"	m	class:poly	typeref:typename:vector<R64>
to	code-library/Data Structures/Persistent Meldable Heap.cpp	/^    int from, to;$/;"	m	struct:heap::node	typeref:typename:int	file:
to	code-library/Data Structures/Persistent Trie.cpp	/^  pnode to[2];$/;"	m	struct:node_t	typeref:typename:pnode[2]	file:
to	code-library/Data Structures/Static to Dynamic Trick.cpp	/^  map<char, int> to[N];$/;"	m	struct:aho_corasick_static	typeref:typename:map<char,int>[]	file:
to	code-library/Graph Theory/Dinics Algorithm.cpp	/^    int to, rev;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
to	code-library/Graph Theory/Eppsteins Algorithm.cpp	/^    int from, to;$/;"	m	struct:heap::node	typeref:typename:int	file:
to	code-library/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^  int from, to, rev;$/;"	m	struct:EDGE	typeref:typename:int	file:
to	code-library/Graph Theory/L R Flow with Dinic.cpp	/^    int to, rev;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
to	code-library/Graph Theory/Maximum Closure Problem.cpp	/^    int to, rev;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
to	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^    int to, rev;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
to	code-library/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^    int to, rev;$/;"	m	struct:mcSFlow::Edge	typeref:typename:int	file:
to	code-library/Graph Theory/Prim's MST.cpp	/^int g[N][N], w[N], to[N], selected[N];$/;"	v	typeref:typename:int[]
to	code-library/Graph Theory/Unique Min Cut.cpp	/^    int to, rev;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
to	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  int link[L], sz, to[L][2], dp[L][2], term[L], last[L]; \/\/ each string contains 'a' and 'b'$/;"	m	struct:AhoCorasick	typeref:typename:int[][2]	file:
to	code-library/Strings/Aho Corasick Dynamic.cpp	/^  map<char, int> to[N];$/;"	m	struct:aho_corasick_static	typeref:typename:map<char,int>[]	file:
to	code/Data Structures/Persistent Meldable Heap.cpp	/^    int from, to;$/;"	m	struct:heap::node	typeref:typename:int	file:
to	code/Data Structures/Persistent Trie.cpp	/^  pnode to[2];$/;"	m	struct:node_t	typeref:typename:pnode[2]	file:
to	code/Data Structures/Static to Dynamic Trick.cpp	/^  map<char, int> to[N];$/;"	m	struct:aho_corasick_static	typeref:typename:map<char,int>[]	file:
to	code/Graph Theory/Dinics Algorithm.cpp	/^    int to, rev;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
to	code/Graph Theory/Eppsteins Algorithm.cpp	/^    int from, to;$/;"	m	struct:heap::node	typeref:typename:int	file:
to	code/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^  int from, to, rev;$/;"	m	struct:EDGE	typeref:typename:int	file:
to	code/Graph Theory/L R Flow with Dinic.cpp	/^    int to, rev;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
to	code/Graph Theory/Maximum Closure Problem.cpp	/^    int to, rev;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
to	code/Graph Theory/Maximum Density Subgraph.cpp	/^    int to, rev;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
to	code/Graph Theory/Min Cost Max Flow with Negative Cycles.cpp	/^    int to, rev;$/;"	m	struct:mcSFlow::Edge	typeref:typename:int	file:
to	code/Graph Theory/Prim's MST.cpp	/^int g[N][N], w[N], to[N], selected[N];$/;"	v	typeref:typename:int[]
to	code/Graph Theory/Unique Min Cut.cpp	/^    int to, rev;$/;"	m	struct:Dinic::edge	typeref:typename:int	file:
to	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  int link[L], sz, to[L][2], dp[L][2], term[L], last[L]; \/\/ each string contains 'a' and 'b'$/;"	m	struct:AhoCorasick	typeref:typename:int[][2]	file:
to	code/Strings/Aho Corasick Dynamic.cpp	/^  map<char, int> to[N];$/;"	m	struct:aho_corasick_static	typeref:typename:map<char,int>[]	file:
to_string	practice/cf/random/1700/testing.cpp	/^template <typename T, size_t N> int SIZE(const T (&t)[N]){ return N; } template<typename T> int /;"	f	typeref:typename:string
tobase3	code-library/Math/FWHT in Ternary Base.cpp	/^  int tobase3(int x) {$/;"	f	struct:FWHT	typeref:typename:int	file:
tobase3	code/Math/FWHT in Ternary Base.cpp	/^  int tobase3(int x) {$/;"	f	struct:FWHT	typeref:typename:int	file:
todoist	dotfiles/macinit.vim	/^let todoist = {$/;"	v
top	code-library/Data Structures/Monotonous Queue.cpp	/^  int top() {$/;"	f	struct:monotonous_queue	typeref:typename:int	file:
top	code-library/Data Structures/Persistent Meldable Heap.cpp	/^  T top() { \/\/ returns the smallest value of the heap$/;"	f	struct:heap	typeref:typename:T	file:
top	code-library/Graph Theory/Chinese Postman Problem.cpp	/^  int n, top;$/;"	m	struct:RandomizedMatching	typeref:typename:int	file:
top	code-library/Graph Theory/Eppsteins Algorithm.cpp	/^  T top() { \/\/ returns the smallest value of the heap$/;"	f	struct:heap	typeref:typename:T	file:
top	code-library/Graph Theory/Randomized Matching Weighted.cpp	/^	int n, top;$/;"	m	struct:RandomizedMatching	typeref:typename:int	file:
top	code/Data Structures/Monotonous Queue.cpp	/^  int top() {$/;"	f	struct:monotonous_queue	typeref:typename:int	file:
top	code/Data Structures/Persistent Meldable Heap.cpp	/^  T top() { \/\/ returns the smallest value of the heap$/;"	f	struct:heap	typeref:typename:T	file:
top	code/Graph Theory/Chinese Postman Problem.cpp	/^  int n, top;$/;"	m	struct:RandomizedMatching	typeref:typename:int	file:
top	code/Graph Theory/Eppsteins Algorithm.cpp	/^  T top() { \/\/ returns the smallest value of the heap$/;"	f	struct:heap	typeref:typename:T	file:
top	code/Graph Theory/Randomized Matching Weighted.cpp	/^	int n, top;$/;"	m	struct:RandomizedMatching	typeref:typename:int	file:
top_tree_node	code-library/Data Structures/Top Tree.cpp	/^struct top_tree_node {$/;"	s	file:
top_tree_node	code/Data Structures/Top Tree.cpp	/^struct top_tree_node {$/;"	s	file:
tot	code-library/Data Structures/Binarizing a Tree.cpp	/^int tot, done[N * 2], cenpar[N * 2];$/;"	v	typeref:typename:int
tot	code-library/Data Structures/Cartesian Tree.cpp	/^int n, tot, st[N], l[N], r[N], vis[N];$/;"	v	typeref:typename:int
tot	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^int tot, done[N * 2], cenpar[N * 2];$/;"	v	typeref:typename:int
tot	code-library/Data Structures/Centroid Decomposition.cpp	/^int tot, done[N], cenpar[N];$/;"	v	typeref:typename:int
tot	code-library/Graph Theory/Boruvka's Algorithm.cpp	/^int el[N * 30], tot[N * 30];$/;"	v	typeref:typename:int[]
tot	code-library/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^int tot, done[N], cenpar[N];$/;"	v	typeref:typename:int
tot	code-library/Graph Theory/Tree Orientation.cpp	/^int tot, done[N];$/;"	v	typeref:typename:int
tot	code-library/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^int n, m, tot, col[N], where[N], par[N];$/;"	v	typeref:typename:int
tot	code-library/Number Theory/Min_25 Sieve.cpp	/^int tot;$/;"	v	typeref:typename:int
tot	code/Data Structures/Binarizing a Tree.cpp	/^int tot, done[N * 2], cenpar[N * 2];$/;"	v	typeref:typename:int
tot	code/Data Structures/Cartesian Tree.cpp	/^int n, tot, st[N], l[N], r[N], vis[N];$/;"	v	typeref:typename:int
tot	code/Data Structures/Centroid Decomposition Persistent.cpp	/^int tot, done[N * 2], cenpar[N * 2];$/;"	v	typeref:typename:int
tot	code/Data Structures/Centroid Decomposition.cpp	/^int tot, done[N], cenpar[N];$/;"	v	typeref:typename:int
tot	code/Graph Theory/Boruvka's Algorithm.cpp	/^int el[N * 30], tot[N * 30];$/;"	v	typeref:typename:int[]
tot	code/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^int tot, done[N], cenpar[N];$/;"	v	typeref:typename:int
tot	code/Graph Theory/Tree Orientation.cpp	/^int tot, done[N];$/;"	v	typeref:typename:int
tot	code/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^int n, m, tot, col[N], where[N], par[N];$/;"	v	typeref:typename:int
tot	code/Number Theory/Min_25 Sieve.cpp	/^int tot;$/;"	v	typeref:typename:int
tot_A	code-library/Data Structures/Top Tree.cpp	/^  int64_t tot_A = 0;$/;"	m	struct:top_tree_node	typeref:typename:int64_t	file:
tot_A	code/Data Structures/Top Tree.cpp	/^  int64_t tot_A = 0;$/;"	m	struct:top_tree_node	typeref:typename:int64_t	file:
tot_ans	code-library/Data Structures/Top Tree.cpp	/^  std::array<int64_t, 2> tot_ans = {0,0};$/;"	m	struct:top_tree_node	typeref:typename:std::array<int64_t,2>	file:
tot_ans	code/Data Structures/Top Tree.cpp	/^  std::array<int64_t, 2> tot_ans = {0,0};$/;"	m	struct:top_tree_node	typeref:typename:std::array<int64_t,2>	file:
tot_sub_d	code-library/Data Structures/Top Tree.cpp	/^  std::array<int64_t, 2> tot_sub_d = {0,0};$/;"	m	struct:top_tree_node	typeref:typename:std::array<int64_t,2>	file:
tot_sub_d	code/Data Structures/Top Tree.cpp	/^  std::array<int64_t, 2> tot_sub_d = {0,0};$/;"	m	struct:top_tree_node	typeref:typename:std::array<int64_t,2>	file:
totient	code-library/Number Theory/Multiplicative Order.cpp	/^ll totient(ll n) {$/;"	f	typeref:typename:ll
totient	code-library/Number Theory/Phi Function.cpp	/^void totient() {$/;"	f	typeref:typename:void
totient	code-library/Number Theory/Primitive Root.cpp	/^int totient(int n) {$/;"	f	typeref:typename:int
totient	code/Number Theory/Multiplicative Order.cpp	/^ll totient(ll n) {$/;"	f	typeref:typename:ll
totient	code/Number Theory/Phi Function.cpp	/^void totient() {$/;"	f	typeref:typename:void
totient	code/Number Theory/Primitive Root.cpp	/^int totient(int n) {$/;"	f	typeref:typename:int
tour	code-library/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  array<vector<int>, 2> tour() {$/;"	f	struct:Euler	typeref:typename:array<vector<int>,2>	file:
tour	code/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  array<vector<int>, 2> tour() {$/;"	f	struct:Euler	typeref:typename:array<vector<int>,2>	file:
tr	code-library/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^vector<pair<pair<int, int>, long long> > tr;$/;"	v	typeref:typename:vector<pair<pair<int,int>,long long>>
tr	code/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^vector<pair<pair<int, int>, long long> > tr;$/;"	v	typeref:typename:vector<pair<pair<int,int>,long long>>
trace	code-library/Graph Theory/Hungarian Algorithm.cpp	/^  int l[N], r[N], arg[N], trace[N];$/;"	m	struct:Hungarian	typeref:typename:int[]	file:
trace	code/Graph Theory/Hungarian Algorithm.cpp	/^  int l[N], r[N], arg[N], trace[N];$/;"	m	struct:Hungarian	typeref:typename:int[]	file:
trans	code-library/Math/Reeds Sloane Algorithm.cpp	/^  vec init, trans;$/;"	m	struct:LinearRecurrence	typeref:typename:vec	file:
trans	code/Math/Reeds Sloane Algorithm.cpp	/^  vec init, trans;$/;"	m	struct:LinearRecurrence	typeref:typename:vec	file:
transform	code-library/Math/FWHT in Any Base.cpp	/^  void transform(vector<int> &a, int n, int k, bool invert) {$/;"	f	namespace:FWHT	typeref:typename:void
transform	code/Math/FWHT in Any Base.cpp	/^  void transform(vector<int> &a, int n, int k, bool invert) {$/;"	f	namespace:FWHT	typeref:typename:void
translate	code-library/Geometry/Geometry 2D.cpp	/^    line translate(PT t) { return {v, c + cross(v, t)}; }$/;"	f	struct:line	typeref:typename:line	file:
translate	code-library/Geometry/Geometry 3D.cpp	/^    plane translate(p3 t) { return {n, d + (n | t)}; }$/;"	f	struct:plane	typeref:typename:plane	file:
translate	code/Geometry/Geometry 2D.cpp	/^    line translate(PT t) { return {v, c + cross(v, t)}; }$/;"	f	struct:line	typeref:typename:line	file:
translate	code/Geometry/Geometry 3D.cpp	/^    plane translate(p3 t) { return {n, d + (n | t)}; }$/;"	f	struct:plane	typeref:typename:plane	file:
transpositions	code-library/Miscellaneous/K-th Root of a Permutation.cpp	/^vector<pair<int, int>> transpositions(vector<vector<int>> &cycles) {$/;"	f	typeref:typename:vector<pair<int,int>>
transpositions	code/Miscellaneous/K-th Root of a Permutation.cpp	/^vector<pair<int, int>> transpositions(vector<vector<int>> &cycles) {$/;"	f	typeref:typename:vector<pair<int,int>>
traverse	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  void traverse(string &s, int id) {$/;"	f	struct:AhoCorasick	typeref:typename:void	file:
traverse	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  void traverse(string &s, int id) {$/;"	f	struct:AhoCorasick	typeref:typename:void	file:
treap	code-library/Data Structures/Implicit Treap.cpp	/^  treap() {$/;"	f	struct:treap	file:
treap	code-library/Data Structures/Implicit Treap.cpp	/^struct treap {$/;"	s	file:
treap	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  treap() {$/;"	f	struct:treap	file:
treap	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^struct treap {$/;"	s	file:
treap	code-library/Data Structures/Treap.cpp	/^  treap() {$/;"	f	struct:treap	file:
treap	code-library/Data Structures/Treap.cpp	/^struct treap {$/;"	s	file:
treap	code/Data Structures/Implicit Treap.cpp	/^  treap() {$/;"	f	struct:treap	file:
treap	code/Data Structures/Implicit Treap.cpp	/^struct treap {$/;"	s	file:
treap	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  treap() {$/;"	f	struct:treap	file:
treap	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^struct treap {$/;"	s	file:
treap	code/Data Structures/Treap.cpp	/^  treap() {$/;"	f	struct:treap	file:
treap	code/Data Structures/Treap.cpp	/^struct treap {$/;"	s	file:
tree	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  vector<edge> tree;$/;"	m	struct:GomoryHuTree	typeref:typename:vector<edge>	file:
tree	code/Graph Theory/Gomory Hu Tree.cpp	/^  vector<edge> tree;$/;"	m	struct:GomoryHuTree	typeref:typename:vector<edge>	file:
triangle_circle_intersection	code-library/Geometry/Geometry 2D.cpp	/^double triangle_circle_intersection(PT c, double r, PT a, PT b) {$/;"	f	typeref:typename:double
triangle_circle_intersection	code/Geometry/Geometry 2D.cpp	/^double triangle_circle_intersection(PT c, double r, PT a, PT b) {$/;"	f	typeref:typename:double
trim	code-library/Miscellaneous/BigInt.cpp	/^  void trim() {$/;"	f	struct:BigInt	typeref:typename:void	file:
trim	code/Miscellaneous/BigInt.cpp	/^  void trim() {$/;"	f	struct:BigInt	typeref:typename:void	file:
truncate	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^  void truncate(int k) {$/;"	f	struct:Block	typeref:typename:void	file:
truncate	code-library/Geometry/All Pair Segment Intersection.cpp	/^    PT truncate(double r) { \/\/ returns a vector with norm r and having same direction$/;"	f	struct:PT	typeref:typename:PT	file:
truncate	code-library/Geometry/Geometry 2D.cpp	/^    PT truncate(double r) { \/\/ returns a vector with norm r and having same direction$/;"	f	struct:PT	typeref:typename:PT	file:
truncate	code-library/Geometry/Geometry 3D.cpp	/^    PT truncate(double r) { \/\/ returns a vector with norm r and having same direction$/;"	f	struct:PT	typeref:typename:PT	file:
truncate	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    PT truncate(double r) { \/\/ returns a vector with norm r and having same direction$/;"	f	struct:PT	typeref:typename:PT	file:
truncate	code-library/Geometry/Half Plane Intersection.cpp	/^    PT truncate(double r) { \/\/ returns a vector with norm r and having same direction$/;"	f	struct:PT	typeref:typename:PT	file:
truncate	code-library/Geometry/Voronoi Diagram.cpp	/^    PT truncate(double r) { \/\/ returns a vector with norm r and having same direction$/;"	f	struct:PT	typeref:typename:PT	file:
truncate	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^  void truncate(int k) {$/;"	f	struct:Block	typeref:typename:void	file:
truncate	code/Geometry/All Pair Segment Intersection.cpp	/^    PT truncate(double r) { \/\/ returns a vector with norm r and having same direction$/;"	f	struct:PT	typeref:typename:PT	file:
truncate	code/Geometry/Geometry 2D.cpp	/^    PT truncate(double r) { \/\/ returns a vector with norm r and having same direction$/;"	f	struct:PT	typeref:typename:PT	file:
truncate	code/Geometry/Geometry 3D.cpp	/^    PT truncate(double r) { \/\/ returns a vector with norm r and having same direction$/;"	f	struct:PT	typeref:typename:PT	file:
truncate	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    PT truncate(double r) { \/\/ returns a vector with norm r and having same direction$/;"	f	struct:PT	typeref:typename:PT	file:
truncate	code/Geometry/Half Plane Intersection.cpp	/^    PT truncate(double r) { \/\/ returns a vector with norm r and having same direction$/;"	f	struct:PT	typeref:typename:PT	file:
truncate	code/Geometry/Voronoi Diagram.cpp	/^    PT truncate(double r) { \/\/ returns a vector with norm r and having same direction$/;"	f	struct:PT	typeref:typename:PT	file:
try_voronoi_edge	code-library/Geometry/Voronoi Diagram.cpp	/^inline void try_voronoi_edge(PT a, PT b, vector<PT> &can) {$/;"	f	typeref:typename:void
try_voronoi_edge	code/Geometry/Voronoi Diagram.cpp	/^inline void try_voronoi_edge(PT a, PT b, vector<PT> &can) {$/;"	f	typeref:typename:void
try_voronoi_vertex	code-library/Geometry/Voronoi Diagram.cpp	/^inline void try_voronoi_vertex(PT a, vector<PT> &can) {$/;"	f	typeref:typename:void
try_voronoi_vertex	code/Geometry/Voronoi Diagram.cpp	/^inline void try_voronoi_vertex(PT a, vector<PT> &can) {$/;"	f	typeref:typename:void
ts	code-library/Graph Theory/2 SAT.cpp	/^  stack<int> ts;$/;"	m	struct:twosat	typeref:typename:stack<int>	file:
ts	code/Graph Theory/2 SAT.cpp	/^  stack<int> ts;$/;"	m	struct:twosat	typeref:typename:stack<int>	file:
twin	code-library/Geometry/Point Location.cpp	/^        edge* twin = nullptr;$/;"	m	struct:DCEL::edge	typeref:typename:edge *	file:
twin	code/Geometry/Point Location.cpp	/^        edge* twin = nullptr;$/;"	m	struct:DCEL::edge	typeref:typename:edge *	file:
twosat	code-library/Graph Theory/2 SAT.cpp	/^  twosat(int vars = 0) {$/;"	f	struct:twosat	file:
twosat	code-library/Graph Theory/2 SAT.cpp	/^struct twosat {$/;"	s	file:
twosat	code/Graph Theory/2 SAT.cpp	/^  twosat(int vars = 0) {$/;"	f	struct:twosat	file:
twosat	code/Graph Theory/2 SAT.cpp	/^struct twosat {$/;"	s	file:
ty	code-library/Data Structures/Permutation Tree.cpp	/^int ty[N * 2]; \/\/ 0 if cut node and 1 if increasing join node, 2 if decreasing join node$/;"	v	typeref:typename:int[]
ty	code-library/Data Structures/Segment Tree Merging.cpp	/^bool ty[N]; \/\/0 - inc; 1 - dec$/;"	v	typeref:typename:bool[]
ty	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^int ty[N], l[N], r[N], x[N];$/;"	v	typeref:typename:int[]
ty	code-library/Geometry/All Pair Segment Intersection.cpp	/^    int ty, id;$/;"	m	struct:event	typeref:typename:int	file:
ty	code-library/Graph Theory/Inverse Graph.cpp	/^int par[N], col[N], vis[N], ty[N], n;$/;"	v	typeref:typename:int[]
ty	code/Data Structures/Permutation Tree.cpp	/^int ty[N * 2]; \/\/ 0 if cut node and 1 if increasing join node, 2 if decreasing join node$/;"	v	typeref:typename:int[]
ty	code/Data Structures/Segment Tree Merging.cpp	/^bool ty[N]; \/\/0 - inc; 1 - dec$/;"	v	typeref:typename:bool[]
ty	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^int ty[N], l[N], r[N], x[N];$/;"	v	typeref:typename:int[]
ty	code/Geometry/All Pair Segment Intersection.cpp	/^    int ty, id;$/;"	m	struct:event	typeref:typename:int	file:
ty	code/Graph Theory/Inverse Graph.cpp	/^int par[N], col[N], vis[N], ty[N], n;$/;"	v	typeref:typename:int[]
type	code-library/Data Structures/DSU with Rollbacks.cpp	/^  bool type;$/;"	m	struct:update	typeref:typename:bool	file:
type	code-library/Data Structures/Queue Undo Trick.cpp	/^  bool type;$/;"	m	struct:update	typeref:typename:bool	file:
type	code-library/Geometry/Point Location.cpp	/^    EventType type; int pos;$/;"	m	struct:Event	typeref:typename:EventType	file:
type	code/Data Structures/DSU with Rollbacks.cpp	/^  bool type;$/;"	m	struct:update	typeref:typename:bool	file:
type	code/Data Structures/Queue Undo Trick.cpp	/^  bool type;$/;"	m	struct:update	typeref:typename:bool	file:
type	code/Geometry/Point Location.cpp	/^    EventType type; int pos;$/;"	m	struct:Event	typeref:typename:EventType	file:
type	practice/cf/random/1700/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	s	object:input
type	practice/cf/random/1700/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	s	object:output
type	practice/cf/random/1700/1618E/problem.json	/^{"name": "E. Singers' Tour", "group": "Codeforces - Codeforces Round #760 (Div. 3)", "url": "htt/;"	s	object:input
type	practice/cf/random/1700/1618E/problem.json	/^{"name": "E. Singers' Tour", "group": "Codeforces - Codeforces Round #760 (Div. 3)", "url": "htt/;"	s	object:output
type	practice/cf/random/coloring/problem.json	/^{"name": "A. Dreamoon Likes Coloring", "group": "Codeforces - Codeforces Round #631 (Div. 1) - T/;"	s	object:input
type	practice/cf/random/coloring/problem.json	/^{"name": "A. Dreamoon Likes Coloring", "group": "Codeforces - Codeforces Round #631 (Div. 1) - T/;"	s	object:output
type	practice/cf/random/diane/problem.json	/^{"name": "D. Diane", "group": "Codeforces - Codeforces Round #735 (Div. 2)", "url": "https:\/\/c/;"	s	object:input
type	practice/cf/random/diane/problem.json	/^{"name": "D. Diane", "group": "Codeforces - Codeforces Round #735 (Div. 2)", "url": "https:\/\/c/;"	s	object:output
type	practice/cf/random/pink/problem.json	/^{"name": "C. Pinkie Pie Eats Patty-cakes", "group": "Codeforces - Codeforces Round #662 (Div. 2)/;"	s	object:input
type	practice/cf/random/pink/problem.json	/^{"name": "C. Pinkie Pie Eats Patty-cakes", "group": "Codeforces - Codeforces Round #662 (Div. 2)/;"	s	object:output
type	practice/cf/stuff/dec 20 2021/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	s	object:input
type	practice/cf/stuff/dec 20 2021/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	s	object:output
type	practice/usacoguide/gold/SP/dining/problem.json	/^{"name": "Problem 1. Fine Dining", "group": "USACO - USACO 2018 December Contest, Gold", "url": /;"	s	object:input
type	practice/usacoguide/gold/SP/dining/problem.json	/^{"name": "Problem 1. Fine Dining", "group": "USACO - USACO 2018 December Contest, Gold", "url": /;"	s	object:output
type	practice/usacoguide/gold/SP/visitfj/problem.json	/^{"name": "Problem 1. Why Did the Cow Cross the Road", "group": "USACO - USACO 2017 February Cont/;"	s	object:input
type	practice/usacoguide/gold/SP/visitfj/problem.json	/^{"name": "Problem 1. Why Did the Cow Cross the Road", "group": "USACO - USACO 2017 February Cont/;"	s	object:output
type	practice/usacoguide/gold/bfs/cownav/problem.json	/^{"name": "Problem 3. Cow Navigation", "group": "USACO - USACO 2017 January Contest, Gold", "url"/;"	s	object:input
type	practice/usacoguide/gold/bfs/cownav/problem.json	/^{"name": "Problem 3. Cow Navigation", "group": "USACO - USACO 2017 January Contest, Gold", "url"/;"	s	object:output
type	practice/usacoguide/gold/bfs/swap/problem.json	/^{"name": "Swap Game", "group": "CSES - CSES Problem Set", "url": "https:\/\/cses.fi\/problemset\//;"	s	object:input
type	practice/usacoguide/gold/bfs/swap/problem.json	/^{"name": "Swap Game", "group": "CSES - CSES Problem Set", "url": "https:\/\/cses.fi\/problemset\//;"	s	object:output
type	practice/usacoguide/gold/dsu/closing/problem.json	/^{"name": "Problem 2. Closing the Farm", "group": "USACO - USACO 2016 US Open Contest, Gold", "ur/;"	s	object:input
type	practice/usacoguide/gold/dsu/closing/problem.json	/^{"name": "Problem 2. Closing the Farm", "group": "USACO - USACO 2016 US Open Contest, Gold", "ur/;"	s	object:output
type	practice/usacoguide/gold/dsu/moocast/problem.json	/^{"name": "Problem 1. Moocast", "group": "USACO - USACO 2016 December Contest, Gold", "url": "htt/;"	s	object:input
type	practice/usacoguide/gold/dsu/moocast/problem.json	/^{"name": "Problem 1. Moocast", "group": "USACO - USACO 2016 December Contest, Gold", "url": "htt/;"	s	object:output
type	practice/usacoguide/gold/dsu/mootube/problem.json	/^{"name": "Problem 1. MooTube", "group": "USACO - USACO 2018 January Contest, Gold", "url": "http/;"	s	object:input
type	practice/usacoguide/gold/dsu/mootube/problem.json	/^{"name": "Problem 1. MooTube", "group": "USACO - USACO 2018 January Contest, Gold", "url": "http/;"	s	object:output
type	practice/usacoguide/gold/dsu/tractor/problem.json	/^{"name": "Problem 2. Tractor", "group": "USACO - USACO 2013 February Contest, Silver", "url": "h/;"	s	object:input
type	practice/usacoguide/gold/dsu/tractor/problem.json	/^{"name": "Problem 2. Tractor", "group": "USACO - USACO 2013 February Contest, Silver", "url": "h/;"	s	object:output
type	practice/usacoguide/gold/dsu/wormhole/problem.json	/^{"name": "Problem 3. Wormhole Sort", "group": "USACO - USACO 2020 January Contest, Silver", "url/;"	s	object:input
type	practice/usacoguide/gold/dsu/wormhole/problem.json	/^{"name": "Problem 3. Wormhole Sort", "group": "USACO - USACO 2020 January Contest, Silver", "url/;"	s	object:output
type	practice/usacoguide/silver/idk/lirs/problem.json	/^{"name": "Problem 3. Liars and Truth Tellers", "group": "USACO - USACO 2013 January Contest, Bro/;"	s	object:input
type	practice/usacoguide/silver/idk/lirs/problem.json	/^{"name": "Problem 3. Liars and Truth Tellers", "group": "USACO - USACO 2013 January Contest, Bro/;"	s	object:output
type	practice/usacoguide/silver/idk/maze/problem.json	/^{"name": "Problem 1. Maze Tac Toe", "group": "USACO - USACO 2021 US Open, Silver", "url": "http:/;"	s	object:input
type	practice/usacoguide/silver/idk/maze/problem.json	/^{"name": "Problem 1. Maze Tac Toe", "group": "USACO - USACO 2021 US Open, Silver", "url": "http:/;"	s	object:output
u	code-library/Data Structures/DSU with Rollbacks.cpp	/^int u[N], v[N], a[N];$/;"	v	typeref:typename:int[]
u	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^    int u, v, rnku, rnkv;$/;"	m	struct:persistent_dsu::state	typeref:typename:int	file:
u	code-library/Data Structures/MOs with DSU.cpp	/^    int u, ru, v, rv;$/;"	m	struct:persistent_dsu::state	typeref:typename:int	file:
u	code-library/Data Structures/MOs with DSU.cpp	/^  int u, v;$/;"	m	struct:edge	typeref:typename:int	file:
u	code-library/Data Structures/Queue Undo Trick.cpp	/^int u[N], v[N], a[N];$/;"	v	typeref:typename:int[]
u	code-library/Data Structures/Sparse Table 2D.cpp	/^int l[N][N], u[N][N];$/;"	v	typeref:typename:int[][]
u	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^    int u, v;$/;"	m	struct:Blossom::edge	typeref:typename:int	file:
u	code-library/Graph Theory/Dijkstra.cpp	/^int u[N], v[N], w[N];$/;"	v	typeref:typename:int[]
u	code-library/Graph Theory/Directed MST.cpp	/^  int u, v; long long w;$/;"	m	struct:edge	typeref:typename:int	file:
u	code-library/Graph Theory/Edge Coloring Simple Graph.cpp	/^int u[N], v[N];$/;"	v	typeref:typename:int[]
u	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  int u, v;$/;"	m	struct:edge	typeref:typename:int	file:
u	code-library/Graph Theory/Johnson's Algorithm.cpp	/^  int u, v;$/;"	m	struct:edge	typeref:typename:int	file:
u	code-library/Graph Theory/L R Flow with Dinic.cpp	/^    int u, v, l, r, id;$/;"	m	struct:LR_Flow::edge	typeref:typename:int	file:
u	code-library/Graph Theory/L R Flow with MCMF.cpp	/^    int u, v;$/;"	m	struct:MCMF::edge	typeref:typename:int	file:
u	code-library/Graph Theory/Manhattan MST.cpp	/^  int u, v, w;$/;"	m	struct:edge	typeref:typename:int	file:
u	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^int s, t, n, m, u[N], v[N], deg[N];$/;"	v	typeref:typename:int[]
u	code-library/Graph Theory/Min Cost Max Flow.cpp	/^    int u, v;$/;"	m	struct:MCMF::edge	typeref:typename:int	file:
u	code-library/Graph Theory/Online Articulation Bridges.cpp	/^int cu, u[N];$/;"	v	typeref:typename:int[]
u	code-library/Number Theory/Maximum Coprime Product.cpp	/^int u[N + 1];$/;"	v	typeref:typename:int[]
u	code-library/Strings/Bit LCS.cpp	/^    long long u[N \/ W + 5];$/;"	m	struct:Bitset	typeref:typename:long long[]	file:
u	code/Data Structures/DSU with Rollbacks.cpp	/^int u[N], v[N], a[N];$/;"	v	typeref:typename:int[]
u	code/Data Structures/Dynamic Connectivity Problem.cpp	/^    int u, v, rnku, rnkv;$/;"	m	struct:persistent_dsu::state	typeref:typename:int	file:
u	code/Data Structures/MOs with DSU.cpp	/^    int u, ru, v, rv;$/;"	m	struct:persistent_dsu::state	typeref:typename:int	file:
u	code/Data Structures/MOs with DSU.cpp	/^  int u, v;$/;"	m	struct:edge	typeref:typename:int	file:
u	code/Data Structures/Queue Undo Trick.cpp	/^int u[N], v[N], a[N];$/;"	v	typeref:typename:int[]
u	code/Data Structures/Sparse Table 2D.cpp	/^int l[N][N], u[N][N];$/;"	v	typeref:typename:int[][]
u	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^    int u, v;$/;"	m	struct:Blossom::edge	typeref:typename:int	file:
u	code/Graph Theory/Dijkstra.cpp	/^int u[N], v[N], w[N];$/;"	v	typeref:typename:int[]
u	code/Graph Theory/Directed MST.cpp	/^  int u, v; long long w;$/;"	m	struct:edge	typeref:typename:int	file:
u	code/Graph Theory/Edge Coloring Simple Graph.cpp	/^int u[N], v[N];$/;"	v	typeref:typename:int[]
u	code/Graph Theory/Gomory Hu Tree.cpp	/^  int u, v;$/;"	m	struct:edge	typeref:typename:int	file:
u	code/Graph Theory/Johnson's Algorithm.cpp	/^  int u, v;$/;"	m	struct:edge	typeref:typename:int	file:
u	code/Graph Theory/L R Flow with Dinic.cpp	/^    int u, v, l, r, id;$/;"	m	struct:LR_Flow::edge	typeref:typename:int	file:
u	code/Graph Theory/L R Flow with MCMF.cpp	/^    int u, v;$/;"	m	struct:MCMF::edge	typeref:typename:int	file:
u	code/Graph Theory/Manhattan MST.cpp	/^  int u, v, w;$/;"	m	struct:edge	typeref:typename:int	file:
u	code/Graph Theory/Maximum Density Subgraph.cpp	/^int s, t, n, m, u[N], v[N], deg[N];$/;"	v	typeref:typename:int[]
u	code/Graph Theory/Min Cost Max Flow.cpp	/^    int u, v;$/;"	m	struct:MCMF::edge	typeref:typename:int	file:
u	code/Graph Theory/Online Articulation Bridges.cpp	/^int cu, u[N];$/;"	v	typeref:typename:int[]
u	code/Number Theory/Maximum Coprime Product.cpp	/^int u[N + 1];$/;"	v	typeref:typename:int[]
u	code/Strings/Bit LCS.cpp	/^    long long u[N \/ W + 5];$/;"	m	struct:Bitset	typeref:typename:long long[]	file:
u128	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^    using u128 = __uint128_t;$/;"	t	struct:poly::fast_div	typeref:typename:__uint128_t	file:
u128	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^    using u128 = __uint128_t;$/;"	t	struct:poly::fast_div	typeref:typename:__uint128_t	file:
u32	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^using u32 = unsigned;$/;"	t	typeref:typename:unsigned	file:
u32	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^using u32 = unsigned;$/;"	t	typeref:typename:unsigned	file:
u64	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^using u64 = unsigned long long;$/;"	t	typeref:typename:unsigned long long	file:
u64	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^using u64 = unsigned long long;$/;"	t	typeref:typename:unsigned long long	file:
uint128	code-library/Number Theory/Sum of The Number of Divisors in cbrt(n).cpp	/^using uint128 = __uint128_t;$/;"	t	typeref:typename:__uint128_t	file:
uint128	code/Number Theory/Sum of The Number of Divisors in cbrt(n).cpp	/^using uint128 = __uint128_t;$/;"	t	typeref:typename:__uint128_t	file:
uint32	code-library/Number Theory/Sum of The Number of Divisors in cbrt(n).cpp	/^using uint32 = unsigned int;$/;"	t	typeref:typename:unsigned int	file:
uint32	code/Number Theory/Sum of The Number of Divisors in cbrt(n).cpp	/^using uint32 = unsigned int;$/;"	t	typeref:typename:unsigned int	file:
uint64	code-library/Number Theory/Sum of The Number of Divisors in cbrt(n).cpp	/^using uint64 = unsigned long long;$/;"	t	typeref:typename:unsigned long long	file:
uint64	code/Number Theory/Sum of The Number of Divisors in cbrt(n).cpp	/^using uint64 = unsigned long long;$/;"	t	typeref:typename:unsigned long long	file:
umii	contests/Codeforces/737/D.cpp	/^#define umii /;"	d	file:
umii	contests/Codeforces/737/E.cpp	/^#define umii /;"	d	file:
undo	code-library/Data Structures/DSU with Rollbacks.cpp	/^  void undo() {$/;"	f	struct:DSU	typeref:typename:void	file:
undo	code-library/Data Structures/Queue Undo Trick.cpp	/^  void undo() {$/;"	f	struct:DSU	typeref:typename:void	file:
undo	code/Data Structures/DSU with Rollbacks.cpp	/^  void undo() {$/;"	f	struct:DSU	typeref:typename:void	file:
undo	code/Data Structures/Queue Undo Trick.cpp	/^  void undo() {$/;"	f	struct:DSU	typeref:typename:void	file:
uni	code-library/Graph Theory/Dynamic MST.cpp	/^  bool uni(int p, int q, vector<pair<int, int>> &snapshot){$/;"	f	struct:disj	typeref:typename:bool	file:
uni	code/Graph Theory/Dynamic MST.cpp	/^  bool uni(int p, int q, vector<pair<int, int>> &snapshot){$/;"	f	struct:disj	typeref:typename:bool	file:
unit	code-library/Geometry/Geometry 3D.cpp	/^    p3 unit() { return *this \/ abs(); }$/;"	f	struct:p3	typeref:typename:p3	file:
unit	code-library/Geometry/Geometry 3D.cpp	/^p3 unit(p3 v) { return v \/ abs(v); }$/;"	f	typeref:typename:p3
unit	code/Geometry/Geometry 3D.cpp	/^    p3 unit() { return *this \/ abs(); }$/;"	f	struct:p3	typeref:typename:p3	file:
unit	code/Geometry/Geometry 3D.cpp	/^p3 unit(p3 v) { return v \/ abs(v); }$/;"	f	typeref:typename:p3
unit_stack	code-library/Graph Theory/3 SAT.cpp	/^  vector<int> unit_stack, pure_stack;$/;"	m	struct:SAT_GOD	typeref:typename:vector<int>	file:
unit_stack	code/Graph Theory/3 SAT.cpp	/^  vector<int> unit_stack, pure_stack;$/;"	m	struct:SAT_GOD	typeref:typename:vector<int>	file:
unite	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^  void unite(int x, int y) {$/;"	f	struct:persistent_dsu	typeref:typename:void	file:
unite	code-library/Data Structures/MOs with DSU.cpp	/^  void unite(int x, int y) {$/;"	f	struct:persistent_dsu	typeref:typename:void	file:
unite	code-library/Graph Theory/Three Edge Connectivity.cpp	/^  void unite(int x, int y) {$/;"	f	struct:Components	typeref:typename:void	file:
unite	code/Data Structures/Dynamic Connectivity Problem.cpp	/^  void unite(int x, int y) {$/;"	f	struct:persistent_dsu	typeref:typename:void	file:
unite	code/Data Structures/MOs with DSU.cpp	/^  void unite(int x, int y) {$/;"	f	struct:persistent_dsu	typeref:typename:void	file:
unite	code/Graph Theory/Three Edge Connectivity.cpp	/^  void unite(int x, int y) {$/;"	f	struct:Components	typeref:typename:void	file:
unite	contests/USACO/dec_silver_2021/B/brute.cpp	/^	bool unite(int x, int y) {  \/\/ union by size$/;"	f	struct:DSU	typeref:typename:bool	file:
unite	practice/usacoguide/gold/dsu/closing/main.cpp	/^	bool unite(int x, int y) {  \/\/ union by size$/;"	f	struct:DSU	typeref:typename:bool	file:
unite	practice/usacoguide/gold/dsu/moocast/main.cpp	/^	bool unite(int x, int y) {  \/\/ union by size$/;"	f	struct:DSU	typeref:typename:bool	file:
unite	practice/usacoguide/gold/dsu/mootube/main.cpp	/^	bool unite(int x, int y) {  \/\/ union by size$/;"	f	struct:DSU	typeref:typename:bool	file:
unite	practice/usacoguide/gold/dsu/tractor/main.cpp	/^	bool unite(int x, int y) {  \/\/ union by size$/;"	f	struct:DSU	typeref:typename:bool	file:
unite	practice/usacoguide/gold/dsu/tractor/mountain.cpp	/^	bool unite(int x, int y) {  \/\/ union by size$/;"	f	struct:DSU	typeref:typename:bool	file:
unite	practice/usacoguide/gold/dsu/wormhole/main.cpp	/^	bool unite(int x, int y) {  \/\/ union by size$/;"	f	struct:DSU	typeref:typename:bool	file:
unite	practice/usacoguide/silver/idk/lirs/main.cpp	/^	bool unite(int x, int y) {  \/\/ union by size$/;"	f	struct:DSU	typeref:typename:bool	file:
up	practice/cpbook/ch1/1.6/card/10388/main2.cpp	/^char up[2][100], down[2][100];$/;"	v	typeref:typename:char[2][100]
upd	code-library/Data Structures/BIT 2D with Range Update and Range Query.cpp	/^  void upd(int x1, int y1, int x2, int y2, long long val) {$/;"	f	struct:BIT2D	typeref:typename:void	file:
upd	code-library/Data Structures/BIT with Range Update and Range Query.cpp	/^  void upd(int l, int r, long long x) {$/;"	f	struct:BIT	typeref:typename:void	file:
upd	code-library/Data Structures/BIT.cpp	/^  void upd(int i, T val) {$/;"	f	struct:BIT	typeref:typename:void	file:
upd	code-library/Data Structures/BIT.cpp	/^  void upd(int l, int r, T val) {$/;"	f	struct:BIT	typeref:typename:void	file:
upd	code-library/Data Structures/Binarizing a Tree.cpp	/^int upd(int cur, int u) { \/\/update node u in cur tree$/;"	f	typeref:typename:int
upd	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^int upd(int cur, int u) { \/\/update node u in cur tree$/;"	f	typeref:typename:int
upd	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^void upd(int n, int b, int e, int i, int j, pair<int, int> &p) {$/;"	f	typeref:typename:void
upd	code-library/Data Structures/Dynamic Diameter Online.cpp	/^    void upd(int n, int b, int e, int i, int j, long long v) {$/;"	f	struct:ST	typeref:typename:void	file:
upd	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    int upd(int pre, int b, int e, int i, int j, int x) {$/;"	f	struct:PST	typeref:typename:int	file:
upd	code-library/Data Structures/HLD.cpp	/^  void upd(int n, int b, int e, int i, int j, int v) {$/;"	f	struct:ST	typeref:typename:void	file:
upd	code-library/Data Structures/Link Cut Tree.cpp	/^  void upd(int u, int v, int x) {$/;"	f	struct:LCT	typeref:typename:void	file:
upd	code-library/Data Structures/Link Cut Tree.cpp	/^  void upd(int u, int x) {$/;"	f	struct:LCT	typeref:typename:void	file:
upd	code-library/Data Structures/MOs Online.cpp	/^inline void upd(int id, int pos, int val) {$/;"	f	typeref:typename:void
upd	code-library/Data Structures/MOs with Update.cpp	/^struct upd {$/;"	s	file:
upd	code-library/Data Structures/Permutation Tree.cpp	/^  void upd(int n, int b, int e, int i, int j, int v) {$/;"	f	struct:ST	typeref:typename:void	file:
upd	code-library/Data Structures/Persistent Array.cpp	/^  int upd(int r, int i, T x) {$/;"	f	struct:PersistentArray	typeref:typename:int	file:
upd	code-library/Data Structures/Persistent Array.cpp	/^  node* upd(node* pre, int i, T x, int l, int r) {$/;"	f	struct:PersistentArray	typeref:typename:node *	file:
upd	code-library/Data Structures/Persistent Queue.cpp	/^  int upd(int r, int i, T x) {$/;"	f	struct:PersistentArray	typeref:typename:int	file:
upd	code-library/Data Structures/Persistent Queue.cpp	/^  node* upd(node* pre, int i, T x, int l, int r) {$/;"	f	struct:PersistentArray	typeref:typename:node *	file:
upd	code-library/Data Structures/Persistent UnionFind.cpp	/^  int upd(int r, int i, T x) {$/;"	f	struct:PersistentArray	typeref:typename:int	file:
upd	code-library/Data Structures/Persistent UnionFind.cpp	/^  node* upd(node* pre, int i, T x, int l, int r) {$/;"	f	struct:PersistentArray	typeref:typename:node *	file:
upd	code-library/Data Structures/Reachability Tree.cpp	/^inline void upd(int n, int l, int r, int ql, int qr, int val) {$/;"	f	typeref:typename:void
upd	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  void upd(int x, int y, long long val) { \/\/set a[x][y] = val$/;"	f	struct:ST	typeref:typename:void	file:
upd	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  void upd(node *t, int pos, long long val) {$/;"	f	struct:treap	typeref:typename:void	file:
upd	code-library/Data Structures/Segment Tree Lazy.cpp	/^  void upd(int n, int b, int e, int i, int j, long long v) {$/;"	f	struct:ST	typeref:typename:void	file:
upd	code-library/Data Structures/Segment Tree NonRecursive.cpp	/^  void upd(int p, int v) {$/;"	f	struct:ST	typeref:typename:void	file:
upd	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^  int upd(int pre, int b, int e, int i, int j) {$/;"	f	struct:PST	typeref:typename:int	file:
upd	code-library/Data Structures/Segment Tree Persistent.cpp	/^  int upd(int pre, int b, int e, int i, int v) {$/;"	f	struct:PST	typeref:typename:int	file:
upd	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  void upd(int n, int b, int e, int i, int j, pair<mint, mint> v) {$/;"	f	struct:ST	typeref:typename:void	file:
upd	code-library/Data Structures/Segment Tree.cpp	/^  void upd(int n, int b, int e, int i, int x) {$/;"	f	struct:ST	typeref:typename:void	file:
upd	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^int upd(int pre, Line nw, int l, int r) {$/;"	f	typeref:typename:int
upd	code-library/Graph Theory/Dijkstra on Segment Tree.cpp	/^void upd(int n, int b, int e, int i, int j, int dir, int u, int w) {$/;"	f	typeref:typename:void
upd	code-library/Graph Theory/Path Union.cpp	/^  void upd(int n, int b, int e, int i, int x) {$/;"	f	struct:segtree	typeref:typename:void	file:
upd	code-library/Miscellaneous/MEX of all Subarrays.cpp	/^  void upd(int n, int b, int e, int i, int x) {$/;"	f	struct:ST	typeref:typename:void	file:
upd	code-library/Miscellaneous/Parallel Binary Search.cpp	/^  void upd(int idx, T val) {$/;"	f	struct:BIT	typeref:typename:void	file:
upd	code-library/Miscellaneous/Parallel Binary Search.cpp	/^  void upd(int l, int r, T val) {$/;"	f	struct:BIT	typeref:typename:void	file:
upd	code-library/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  void upd(int n, int b, int e, int i, int j, int v) {$/;"	f	struct:ST	typeref:typename:void	file:
upd	code/Data Structures/BIT 2D with Range Update and Range Query.cpp	/^  void upd(int x1, int y1, int x2, int y2, long long val) {$/;"	f	struct:BIT2D	typeref:typename:void	file:
upd	code/Data Structures/BIT with Range Update and Range Query.cpp	/^  void upd(int l, int r, long long x) {$/;"	f	struct:BIT	typeref:typename:void	file:
upd	code/Data Structures/BIT.cpp	/^  void upd(int i, T val) {$/;"	f	struct:BIT	typeref:typename:void	file:
upd	code/Data Structures/BIT.cpp	/^  void upd(int l, int r, T val) {$/;"	f	struct:BIT	typeref:typename:void	file:
upd	code/Data Structures/Binarizing a Tree.cpp	/^int upd(int cur, int u) { \/\/update node u in cur tree$/;"	f	typeref:typename:int
upd	code/Data Structures/Centroid Decomposition Persistent.cpp	/^int upd(int cur, int u) { \/\/update node u in cur tree$/;"	f	typeref:typename:int
upd	code/Data Structures/Dynamic Connectivity Problem.cpp	/^void upd(int n, int b, int e, int i, int j, pair<int, int> &p) {$/;"	f	typeref:typename:void
upd	code/Data Structures/Dynamic Diameter Online.cpp	/^    void upd(int n, int b, int e, int i, int j, long long v) {$/;"	f	struct:ST	typeref:typename:void	file:
upd	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    int upd(int pre, int b, int e, int i, int j, int x) {$/;"	f	struct:PST	typeref:typename:int	file:
upd	code/Data Structures/HLD.cpp	/^  void upd(int n, int b, int e, int i, int j, int v) {$/;"	f	struct:ST	typeref:typename:void	file:
upd	code/Data Structures/Link Cut Tree.cpp	/^  void upd(int u, int v, int x) {$/;"	f	struct:LCT	typeref:typename:void	file:
upd	code/Data Structures/Link Cut Tree.cpp	/^  void upd(int u, int x) {$/;"	f	struct:LCT	typeref:typename:void	file:
upd	code/Data Structures/MOs Online.cpp	/^inline void upd(int id, int pos, int val) {$/;"	f	typeref:typename:void
upd	code/Data Structures/MOs with Update.cpp	/^struct upd {$/;"	s	file:
upd	code/Data Structures/Permutation Tree.cpp	/^  void upd(int n, int b, int e, int i, int j, int v) {$/;"	f	struct:ST	typeref:typename:void	file:
upd	code/Data Structures/Persistent Array.cpp	/^  int upd(int r, int i, T x) {$/;"	f	struct:PersistentArray	typeref:typename:int	file:
upd	code/Data Structures/Persistent Array.cpp	/^  node* upd(node* pre, int i, T x, int l, int r) {$/;"	f	struct:PersistentArray	typeref:typename:node *	file:
upd	code/Data Structures/Persistent Queue.cpp	/^  int upd(int r, int i, T x) {$/;"	f	struct:PersistentArray	typeref:typename:int	file:
upd	code/Data Structures/Persistent Queue.cpp	/^  node* upd(node* pre, int i, T x, int l, int r) {$/;"	f	struct:PersistentArray	typeref:typename:node *	file:
upd	code/Data Structures/Persistent UnionFind.cpp	/^  int upd(int r, int i, T x) {$/;"	f	struct:PersistentArray	typeref:typename:int	file:
upd	code/Data Structures/Persistent UnionFind.cpp	/^  node* upd(node* pre, int i, T x, int l, int r) {$/;"	f	struct:PersistentArray	typeref:typename:node *	file:
upd	code/Data Structures/Reachability Tree.cpp	/^inline void upd(int n, int l, int r, int ql, int qr, int val) {$/;"	f	typeref:typename:void
upd	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  void upd(int x, int y, long long val) { \/\/set a[x][y] = val$/;"	f	struct:ST	typeref:typename:void	file:
upd	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  void upd(node *t, int pos, long long val) {$/;"	f	struct:treap	typeref:typename:void	file:
upd	code/Data Structures/Segment Tree Lazy.cpp	/^  void upd(int n, int b, int e, int i, int j, long long v) {$/;"	f	struct:ST	typeref:typename:void	file:
upd	code/Data Structures/Segment Tree NonRecursive.cpp	/^  void upd(int p, int v) {$/;"	f	struct:ST	typeref:typename:void	file:
upd	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^  int upd(int pre, int b, int e, int i, int j) {$/;"	f	struct:PST	typeref:typename:int	file:
upd	code/Data Structures/Segment Tree Persistent.cpp	/^  int upd(int pre, int b, int e, int i, int v) {$/;"	f	struct:PST	typeref:typename:int	file:
upd	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  void upd(int n, int b, int e, int i, int j, pair<mint, mint> v) {$/;"	f	struct:ST	typeref:typename:void	file:
upd	code/Data Structures/Segment Tree.cpp	/^  void upd(int n, int b, int e, int i, int x) {$/;"	f	struct:ST	typeref:typename:void	file:
upd	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^int upd(int pre, Line nw, int l, int r) {$/;"	f	typeref:typename:int
upd	code/Graph Theory/Dijkstra on Segment Tree.cpp	/^void upd(int n, int b, int e, int i, int j, int dir, int u, int w) {$/;"	f	typeref:typename:void
upd	code/Graph Theory/Path Union.cpp	/^  void upd(int n, int b, int e, int i, int x) {$/;"	f	struct:segtree	typeref:typename:void	file:
upd	code/Miscellaneous/MEX of all Subarrays.cpp	/^  void upd(int n, int b, int e, int i, int x) {$/;"	f	struct:ST	typeref:typename:void	file:
upd	code/Miscellaneous/Parallel Binary Search.cpp	/^  void upd(int idx, T val) {$/;"	f	struct:BIT	typeref:typename:void	file:
upd	code/Miscellaneous/Parallel Binary Search.cpp	/^  void upd(int l, int r, T val) {$/;"	f	struct:BIT	typeref:typename:void	file:
upd	code/Strings/Suffix Automaton Distinct Substring Queries in Range.cpp	/^  void upd(int n, int b, int e, int i, int j, int v) {$/;"	f	struct:ST	typeref:typename:void	file:
upd1	code-library/Data Structures/BIT 2D with Range Update and Range Query.cpp	/^  void upd1(int x, int y1, int y2, long long mul, long long add) {$/;"	f	struct:BIT2D	typeref:typename:void	file:
upd1	code/Data Structures/BIT 2D with Range Update and Range Query.cpp	/^  void upd1(int x, int y1, int y2, long long mul, long long add) {$/;"	f	struct:BIT2D	typeref:typename:void	file:
upd2	code-library/Data Structures/BIT 2D with Range Update and Range Query.cpp	/^  void upd2(long long t[N][N][2], int x, int y, long long mul, long long add) {$/;"	f	struct:BIT2D	typeref:typename:void	file:
upd2	code/Data Structures/BIT 2D with Range Update and Range Query.cpp	/^  void upd2(long long t[N][N][2], int x, int y, long long mul, long long add) {$/;"	f	struct:BIT2D	typeref:typename:void	file:
update	code-library/Data Structures/BIT with Range Update and Range Query.cpp	/^  void update(int i, long long mul, long long add) {$/;"	f	struct:BIT	typeref:typename:void	file:
update	code-library/Data Structures/DSU with Rollbacks.cpp	/^  update(int _x, int _y) {$/;"	f	struct:update	file:
update	code-library/Data Structures/DSU with Rollbacks.cpp	/^struct update {$/;"	s	file:
update	code-library/Data Structures/Implicit Treap.cpp	/^  void update(int qL, int qR, int val) {$/;"	f	struct:treap	typeref:typename:void	file:
update	code-library/Data Structures/MOs with Update.cpp	/^inline void update(int pos, int x) {$/;"	f	typeref:typename:void
update	code-library/Data Structures/Queue Undo Trick.cpp	/^  update(int _x, int _y) {$/;"	f	struct:update	file:
update	code-library/Data Structures/Queue Undo Trick.cpp	/^struct update {$/;"	s	file:
update	code-library/Data Structures/SQRT Tree.cpp	/^  inline void update(int x, const SqrtTreeItem &item) {$/;"	f	struct:SqrtTree	typeref:typename:void	file:
update	code-library/Data Structures/SQRT Tree.cpp	/^  void update(int layer, int lBound, int rBound, int betweenOffs, int x) {$/;"	f	struct:SqrtTree	typeref:typename:void	file:
update	code-library/Data Structures/Segment Tree Beats.cpp	/^  void update(int k) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
update	code-library/Data Structures/Top Tree.cpp	/^  void update() {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
update	code-library/Number Theory/Maximum Coprime Product.cpp	/^void update(int x, int a) {$/;"	f	typeref:typename:void
update	code/Data Structures/BIT with Range Update and Range Query.cpp	/^  void update(int i, long long mul, long long add) {$/;"	f	struct:BIT	typeref:typename:void	file:
update	code/Data Structures/DSU with Rollbacks.cpp	/^  update(int _x, int _y) {$/;"	f	struct:update	file:
update	code/Data Structures/DSU with Rollbacks.cpp	/^struct update {$/;"	s	file:
update	code/Data Structures/Implicit Treap.cpp	/^  void update(int qL, int qR, int val) {$/;"	f	struct:treap	typeref:typename:void	file:
update	code/Data Structures/MOs with Update.cpp	/^inline void update(int pos, int x) {$/;"	f	typeref:typename:void
update	code/Data Structures/Queue Undo Trick.cpp	/^  update(int _x, int _y) {$/;"	f	struct:update	file:
update	code/Data Structures/Queue Undo Trick.cpp	/^struct update {$/;"	s	file:
update	code/Data Structures/SQRT Tree.cpp	/^  inline void update(int x, const SqrtTreeItem &item) {$/;"	f	struct:SqrtTree	typeref:typename:void	file:
update	code/Data Structures/SQRT Tree.cpp	/^  void update(int layer, int lBound, int rBound, int betweenOffs, int x) {$/;"	f	struct:SqrtTree	typeref:typename:void	file:
update	code/Data Structures/Segment Tree Beats.cpp	/^  void update(int k) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
update	code/Data Structures/Top Tree.cpp	/^  void update() {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
update	code/Number Theory/Maximum Coprime Product.cpp	/^void update(int x, int a) {$/;"	f	typeref:typename:void
update	contests/USACO/dec_silver_2021/A/A_safe.cpp	/^void update(int BITree[], int l, int r, int n, int val)$/;"	f	typeref:typename:void
updateBIT	contests/USACO/dec_silver_2021/A/A_safe.cpp	/^void updateBIT(int BITree[], int n, int index, int val)$/;"	f	typeref:typename:void
updateBetweenZero	code-library/Data Structures/SQRT Tree.cpp	/^  inline void updateBetweenZero(int bid) {$/;"	f	struct:SqrtTree	typeref:typename:void	file:
updateBetweenZero	code/Data Structures/SQRT Tree.cpp	/^  inline void updateBetweenZero(int bid) {$/;"	f	struct:SqrtTree	typeref:typename:void	file:
update_all	code-library/Data Structures/Top Tree.cpp	/^  void update_all() {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
update_all	code/Data Structures/Top Tree.cpp	/^  void update_all() {$/;"	f	struct:top_tree_node	typeref:typename:void	file:
update_max	code-library/Data Structures/Segment Tree Beats.cpp	/^  void update_max(int a, int b, ll x) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
update_max	code/Data Structures/Segment Tree Beats.cpp	/^  void update_max(int a, int b, ll x) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
update_min	code-library/Data Structures/Segment Tree Beats.cpp	/^  void update_min(int a, int b, ll x) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
update_min	code/Data Structures/Segment Tree Beats.cpp	/^  void update_min(int a, int b, ll x) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
update_node_max	code-library/Data Structures/Segment Tree Beats.cpp	/^  void update_node_max(int k, ll x) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
update_node_max	code/Data Structures/Segment Tree Beats.cpp	/^  void update_node_max(int k, ll x) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
update_node_min	code-library/Data Structures/Segment Tree Beats.cpp	/^  void update_node_min(int k, ll x) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
update_node_min	code/Data Structures/Segment Tree Beats.cpp	/^  void update_node_min(int k, ll x) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
update_parent	code-library/Data Structures/Implicit Treap.cpp	/^  void update_parent(pnode &t) {$/;"	f	struct:treap	typeref:typename:void	file:
update_parent	code/Data Structures/Implicit Treap.cpp	/^  void update_parent(pnode &t) {$/;"	f	struct:treap	typeref:typename:void	file:
update_size	code-library/Data Structures/Implicit Treap.cpp	/^  void update_size(pnode &t) {$/;"	f	struct:treap	typeref:typename:void	file:
update_size	code-library/Data Structures/Treap persistent.cpp	/^void update_size(node* &t) {$/;"	f	namespace:PersistentTreap	typeref:typename:void
update_size	code/Data Structures/Implicit Treap.cpp	/^  void update_size(pnode &t) {$/;"	f	struct:treap	typeref:typename:void	file:
update_size	code/Data Structures/Treap persistent.cpp	/^void update_size(node* &t) {$/;"	f	namespace:PersistentTreap	typeref:typename:void
update_slack	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  inline void update_slack(int u, int x) {$/;"	f	struct:Blossom	typeref:typename:void	file:
update_slack	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  inline void update_slack(int u, int x) {$/;"	f	struct:Blossom	typeref:typename:void	file:
update_val	code-library/Data Structures/Segment Tree Beats.cpp	/^  void update_val(int a, int b, ll x) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
update_val	code/Data Structures/Segment Tree Beats.cpp	/^  void update_val(int a, int b, ll x) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
updateall	code-library/Data Structures/Segment Tree Beats.cpp	/^  void updateall(int k, ll x) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
updateall	code/Data Structures/Segment Tree Beats.cpp	/^  void updateall(int k, ll x) {$/;"	f	struct:SGTBeats	typeref:typename:void	file:
upper_bound	code-library/Strings/Suffix Array.cpp	/^  int upper_bound(string &t) {$/;"	f	struct:SuffixArray	typeref:typename:int	file:
upper_bound	code/Strings/Suffix Array.cpp	/^  int upper_bound(string &t) {$/;"	f	struct:SuffixArray	typeref:typename:int	file:
url	practice/cf/random/1700/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	s
url	practice/cf/random/1700/1618E/problem.json	/^{"name": "E. Singers' Tour", "group": "Codeforces - Codeforces Round #760 (Div. 3)", "url": "htt/;"	s
url	practice/cf/random/coloring/problem.json	/^{"name": "A. Dreamoon Likes Coloring", "group": "Codeforces - Codeforces Round #631 (Div. 1) - T/;"	s
url	practice/cf/random/diane/problem.json	/^{"name": "D. Diane", "group": "Codeforces - Codeforces Round #735 (Div. 2)", "url": "https:\/\/c/;"	s
url	practice/cf/random/pink/problem.json	/^{"name": "C. Pinkie Pie Eats Patty-cakes", "group": "Codeforces - Codeforces Round #662 (Div. 2)/;"	s
url	practice/cf/stuff/dec 20 2021/1608C/problem.json	/^{"name": "C. Game Master", "group": "Codeforces - Codeforces Round #758 (Div.1 + Div. 2)", "url"/;"	s
url	practice/usacoguide/gold/SP/dining/problem.json	/^{"name": "Problem 1. Fine Dining", "group": "USACO - USACO 2018 December Contest, Gold", "url": /;"	s
url	practice/usacoguide/gold/SP/visitfj/problem.json	/^{"name": "Problem 1. Why Did the Cow Cross the Road", "group": "USACO - USACO 2017 February Cont/;"	s
url	practice/usacoguide/gold/bfs/cownav/problem.json	/^{"name": "Problem 3. Cow Navigation", "group": "USACO - USACO 2017 January Contest, Gold", "url"/;"	s
url	practice/usacoguide/gold/bfs/swap/problem.json	/^{"name": "Swap Game", "group": "CSES - CSES Problem Set", "url": "https:\/\/cses.fi\/problemset\//;"	s
url	practice/usacoguide/gold/dsu/closing/problem.json	/^{"name": "Problem 2. Closing the Farm", "group": "USACO - USACO 2016 US Open Contest, Gold", "ur/;"	s
url	practice/usacoguide/gold/dsu/moocast/problem.json	/^{"name": "Problem 1. Moocast", "group": "USACO - USACO 2016 December Contest, Gold", "url": "htt/;"	s
url	practice/usacoguide/gold/dsu/mootube/problem.json	/^{"name": "Problem 1. MooTube", "group": "USACO - USACO 2018 January Contest, Gold", "url": "http/;"	s
url	practice/usacoguide/gold/dsu/tractor/problem.json	/^{"name": "Problem 2. Tractor", "group": "USACO - USACO 2013 February Contest, Silver", "url": "h/;"	s
url	practice/usacoguide/gold/dsu/wormhole/problem.json	/^{"name": "Problem 3. Wormhole Sort", "group": "USACO - USACO 2020 January Contest, Silver", "url/;"	s
url	practice/usacoguide/silver/idk/lirs/problem.json	/^{"name": "Problem 3. Liars and Truth Tellers", "group": "USACO - USACO 2013 January Contest, Bro/;"	s
url	practice/usacoguide/silver/idk/maze/problem.json	/^{"name": "Problem 1. Maze Tac Toe", "group": "USACO - USACO 2021 US Open, Silver", "url": "http:/;"	s
used	code-library/Graph Theory/Articulation Bridges.cpp	/^  vector<bool> used;$/;"	m	struct:TECC	typeref:typename:vector<bool>	file:
used	code-library/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  vector<bool> used;$/;"	m	struct:EdgeColoring	typeref:typename:vector<bool>	file:
used	code-library/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  vector<bool> used;$/;"	m	struct:Euler	typeref:typename:vector<bool>	file:
used	code/Graph Theory/Articulation Bridges.cpp	/^  vector<bool> used;$/;"	m	struct:TECC	typeref:typename:vector<bool>	file:
used	code/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  vector<bool> used;$/;"	m	struct:EdgeColoring	typeref:typename:vector<bool>	file:
used	code/Graph Theory/Edge Coloring Bipartite Graph Faster.cpp	/^  vector<bool> used;$/;"	m	struct:Euler	typeref:typename:vector<bool>	file:
v	code-library/Data Structures/DSU with Rollbacks.cpp	/^int u[N], v[N], a[N];$/;"	v	typeref:typename:int[]
v	code-library/Data Structures/Dynamic Connectivity Problem.cpp	/^    int u, v, rnku, rnkv;$/;"	m	struct:persistent_dsu::state	typeref:typename:int	file:
v	code-library/Data Structures/MOs with DSU.cpp	/^    int u, ru, v, rv;$/;"	m	struct:persistent_dsu::state	typeref:typename:int	file:
v	code-library/Data Structures/MOs with DSU.cpp	/^  int u, v;$/;"	m	struct:edge	typeref:typename:int	file:
v	code-library/Data Structures/Queue Undo Trick.cpp	/^int u[N], v[N], a[N];$/;"	v	typeref:typename:int[]
v	code-library/Data Structures/SQRT Tree.cpp	/^  vector<SqrtTreeItem> v;$/;"	m	struct:SqrtTree	typeref:typename:vector<SqrtTreeItem>	file:
v	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^  vector<int> v, sorted_v; int sz = 0;$/;"	m	struct:Block	typeref:typename:vector<int>	file:
v	code-library/Dynamic Programming Optimizations/Digit DP.cpp	/^vector<int> v;$/;"	v	typeref:typename:vector<int>
v	code-library/Geometry/Geometry 2D.cpp	/^    PT v; double c;  \/\/line form: direction vec [cross] (x, y) = c $/;"	m	struct:line	typeref:typename:PT	file:
v	code-library/Geometry/Geometry 3D.cpp	/^    int v;$/;"	m	struct:edge	typeref:typename:int	file:
v	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^    int u, v;$/;"	m	struct:Blossom::edge	typeref:typename:int	file:
v	code-library/Graph Theory/Dijkstra.cpp	/^int u[N], v[N], w[N];$/;"	v	typeref:typename:int[]
v	code-library/Graph Theory/Directed MST.cpp	/^  int u, v; long long w;$/;"	m	struct:edge	typeref:typename:int	file:
v	code-library/Graph Theory/Edge Coloring Simple Graph.cpp	/^int u[N], v[N];$/;"	v	typeref:typename:int[]
v	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  const int v;  \/\/ neighbour$/;"	m	struct:S	typeref:typename:const int	file:
v	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  int u, v;$/;"	m	struct:edge	typeref:typename:int	file:
v	code-library/Graph Theory/Johnson's Algorithm.cpp	/^  int u, v;$/;"	m	struct:edge	typeref:typename:int	file:
v	code-library/Graph Theory/L R Flow with Dinic.cpp	/^    int u, v, l, r, id;$/;"	m	struct:LR_Flow::edge	typeref:typename:int	file:
v	code-library/Graph Theory/L R Flow with MCMF.cpp	/^    int u, v;$/;"	m	struct:MCMF::edge	typeref:typename:int	file:
v	code-library/Graph Theory/Manhattan MST.cpp	/^  int u, v, w;$/;"	m	struct:edge	typeref:typename:int	file:
v	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^int s, t, n, m, u[N], v[N], deg[N];$/;"	v	typeref:typename:int[]
v	code-library/Graph Theory/Min Cost Max Flow.cpp	/^    int u, v;$/;"	m	struct:MCMF::edge	typeref:typename:int	file:
v	code-library/Math/Determinant of Sparse Matrix.cpp	/^struct Elem { int x, y; mint v; };$/;"	m	struct:Elem	typeref:typename:mint	file:
v	code-library/Number Theory/Smallest Number Having Exactly K Divisors.cpp	/^vector<long long> v;$/;"	v	typeref:typename:vector<long long>
v	code-library/Strings/String Matching using Bitsets.cpp	/^vector<int> v;$/;"	v	typeref:typename:vector<int>
v	code/Data Structures/DSU with Rollbacks.cpp	/^int u[N], v[N], a[N];$/;"	v	typeref:typename:int[]
v	code/Data Structures/Dynamic Connectivity Problem.cpp	/^    int u, v, rnku, rnkv;$/;"	m	struct:persistent_dsu::state	typeref:typename:int	file:
v	code/Data Structures/MOs with DSU.cpp	/^    int u, ru, v, rv;$/;"	m	struct:persistent_dsu::state	typeref:typename:int	file:
v	code/Data Structures/MOs with DSU.cpp	/^  int u, v;$/;"	m	struct:edge	typeref:typename:int	file:
v	code/Data Structures/Queue Undo Trick.cpp	/^int u[N], v[N], a[N];$/;"	v	typeref:typename:int[]
v	code/Data Structures/SQRT Tree.cpp	/^  vector<SqrtTreeItem> v;$/;"	m	struct:SqrtTree	typeref:typename:vector<SqrtTreeItem>	file:
v	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^  vector<int> v, sorted_v; int sz = 0;$/;"	m	struct:Block	typeref:typename:vector<int>	file:
v	code/Dynamic Programming Optimizations/Digit DP.cpp	/^vector<int> v;$/;"	v	typeref:typename:vector<int>
v	code/Geometry/Geometry 2D.cpp	/^    PT v; double c;  \/\/line form: direction vec [cross] (x, y) = c $/;"	m	struct:line	typeref:typename:PT	file:
v	code/Geometry/Geometry 3D.cpp	/^    int v;$/;"	m	struct:edge	typeref:typename:int	file:
v	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^    int u, v;$/;"	m	struct:Blossom::edge	typeref:typename:int	file:
v	code/Graph Theory/Dijkstra.cpp	/^int u[N], v[N], w[N];$/;"	v	typeref:typename:int[]
v	code/Graph Theory/Directed MST.cpp	/^  int u, v; long long w;$/;"	m	struct:edge	typeref:typename:int	file:
v	code/Graph Theory/Edge Coloring Simple Graph.cpp	/^int u[N], v[N];$/;"	v	typeref:typename:int[]
v	code/Graph Theory/Gomory Hu Tree.cpp	/^  const int v;  \/\/ neighbour$/;"	m	struct:S	typeref:typename:const int	file:
v	code/Graph Theory/Gomory Hu Tree.cpp	/^  int u, v;$/;"	m	struct:edge	typeref:typename:int	file:
v	code/Graph Theory/Johnson's Algorithm.cpp	/^  int u, v;$/;"	m	struct:edge	typeref:typename:int	file:
v	code/Graph Theory/L R Flow with Dinic.cpp	/^    int u, v, l, r, id;$/;"	m	struct:LR_Flow::edge	typeref:typename:int	file:
v	code/Graph Theory/L R Flow with MCMF.cpp	/^    int u, v;$/;"	m	struct:MCMF::edge	typeref:typename:int	file:
v	code/Graph Theory/Manhattan MST.cpp	/^  int u, v, w;$/;"	m	struct:edge	typeref:typename:int	file:
v	code/Graph Theory/Maximum Density Subgraph.cpp	/^int s, t, n, m, u[N], v[N], deg[N];$/;"	v	typeref:typename:int[]
v	code/Graph Theory/Min Cost Max Flow.cpp	/^    int u, v;$/;"	m	struct:MCMF::edge	typeref:typename:int	file:
v	code/Math/Determinant of Sparse Matrix.cpp	/^struct Elem { int x, y; mint v; };$/;"	m	struct:Elem	typeref:typename:mint	file:
v	code/Number Theory/Smallest Number Having Exactly K Divisors.cpp	/^vector<long long> v;$/;"	v	typeref:typename:vector<long long>
v	code/Strings/String Matching using Bitsets.cpp	/^vector<int> v;$/;"	v	typeref:typename:vector<int>
v	practice/cf/random/1700/6.cpp	/^ 	int v; explicit operator int() const { return v; }$/;"	m	struct:mi	typeref:typename:int	file:
v	practice/cf/random/i_hate_math_problems/1422C.cpp	/^ 	int v; explicit operator int() const { return v; } $/;"	m	struct:mi	typeref:typename:int	file:
v	practice/usacoguide/gold/introDP/arraydescription.cpp	/^ 	int v; explicit operator int() const { return v; } $/;"	m	struct:mi	typeref:typename:int	file:
val	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^        int l = 0, r = 0; mint lf = 0, ls = 0; mint val = 0;$/;"	m	struct:PST::node	typeref:typename:mint	file:
val	code-library/Data Structures/Implicit Treap.cpp	/^    int val, sz, prior, lazy, sum, mx, mn, repl;$/;"	m	struct:treap::node	typeref:typename:int	file:
val	code-library/Data Structures/Link Cut Tree.cpp	/^  long long val = 0, sum = 0, lazy = 0, subsum = 0, vsum = 0;$/;"	m	struct:node	typeref:typename:long long	file:
val	code-library/Data Structures/Persistent Meldable Heap.cpp	/^    int sz; T val;$/;"	m	struct:heap::node	typeref:typename:T	file:
val	code-library/Data Structures/Reachability Tree.cpp	/^  int n, par[2 * N], sp[LG + 1][2 * N], val[2 * N], rid[2 * N];$/;"	m	struct:RT	typeref:typename:int[]	file:
val	code-library/Data Structures/Segment Tree 2D Dynamic.cpp	/^  long long val, g;$/;"	m	struct:node	typeref:typename:long long	file:
val	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^    mint val = 0;$/;"	m	struct:PST::node	typeref:typename:mint	file:
val	code-library/Data Structures/Segment Tree Persistent.cpp	/^    int l = 0, r = 0, val = 0;$/;"	m	struct:PST::node	typeref:typename:int	file:
val	code-library/Data Structures/Treap persistent.cpp	/^  int val, prior, sz;$/;"	m	struct:node	typeref:typename:int	file:
val	code-library/Game Theory/Blue Red Hackenbush.cpp	/^  int val, w; \/\/ val=integer part$/;"	m	struct:surreal	typeref:typename:int	file:
val	code-library/Graph Theory/3 CYCLE and 4 CYCLE.cpp	/^int val[N];$/;"	v	typeref:typename:int[]
val	code-library/Graph Theory/Eppsteins Algorithm.cpp	/^    int sz; T val;$/;"	m	struct:heap::node	typeref:typename:T	file:
val	code-library/Graph Theory/Manhattan MST.cpp	/^  int val, id;$/;"	m	struct:node	typeref:typename:int	file:
val	code-library/Math/Simplex Algorithm.cpp	/^  long double val[MAXV], ar[MAXC][MAXV];$/;"	v	namespace:lp	typeref:typename:long double[]
val	code-library/Number Theory/Prime Factorization Fastest.cpp	/^  uint64_t val() const { return reduce(n); }$/;"	f	struct:Mint	typeref:typename:uint64_t	file:
val	code-library/Number Theory/Prime Number System.cpp	/^  int val() {$/;"	f	struct:base	typeref:typename:int	file:
val	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^        int l = 0, r = 0; mint lf = 0, ls = 0; mint val = 0;$/;"	m	struct:PST::node	typeref:typename:mint	file:
val	code/Data Structures/Implicit Treap.cpp	/^    int val, sz, prior, lazy, sum, mx, mn, repl;$/;"	m	struct:treap::node	typeref:typename:int	file:
val	code/Data Structures/Link Cut Tree.cpp	/^  long long val = 0, sum = 0, lazy = 0, subsum = 0, vsum = 0;$/;"	m	struct:node	typeref:typename:long long	file:
val	code/Data Structures/Persistent Meldable Heap.cpp	/^    int sz; T val;$/;"	m	struct:heap::node	typeref:typename:T	file:
val	code/Data Structures/Reachability Tree.cpp	/^  int n, par[2 * N], sp[LG + 1][2 * N], val[2 * N], rid[2 * N];$/;"	m	struct:RT	typeref:typename:int[]	file:
val	code/Data Structures/Segment Tree 2D Dynamic.cpp	/^  long long val, g;$/;"	m	struct:node	typeref:typename:long long	file:
val	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^    mint val = 0;$/;"	m	struct:PST::node	typeref:typename:mint	file:
val	code/Data Structures/Segment Tree Persistent.cpp	/^    int l = 0, r = 0, val = 0;$/;"	m	struct:PST::node	typeref:typename:int	file:
val	code/Data Structures/Treap persistent.cpp	/^  int val, prior, sz;$/;"	m	struct:node	typeref:typename:int	file:
val	code/Game Theory/Blue Red Hackenbush.cpp	/^  int val, w; \/\/ val=integer part$/;"	m	struct:surreal	typeref:typename:int	file:
val	code/Graph Theory/3 CYCLE and 4 CYCLE.cpp	/^int val[N];$/;"	v	typeref:typename:int[]
val	code/Graph Theory/Eppsteins Algorithm.cpp	/^    int sz; T val;$/;"	m	struct:heap::node	typeref:typename:T	file:
val	code/Graph Theory/Manhattan MST.cpp	/^  int val, id;$/;"	m	struct:node	typeref:typename:int	file:
val	code/Math/Simplex Algorithm.cpp	/^  long double val[MAXV], ar[MAXC][MAXV];$/;"	v	namespace:lp	typeref:typename:long double[]
val	code/Number Theory/Prime Factorization Fastest.cpp	/^  uint64_t val() const { return reduce(n); }$/;"	f	struct:Mint	typeref:typename:uint64_t	file:
val	code/Number Theory/Prime Number System.cpp	/^  int val() {$/;"	f	struct:base	typeref:typename:int	file:
valid	code-library/Geometry/Delaunay Triangulation.cpp	/^	#define valid(/;"	d	file:
valid	code-library/Geometry/Voronoi Diagram.cpp	/^	#define valid(/;"	d	file:
valid	code/Geometry/Delaunay Triangulation.cpp	/^	#define valid(/;"	d	file:
valid	code/Geometry/Voronoi Diagram.cpp	/^	#define valid(/;"	d	file:
valid	practice/usacoguide/gold/dsu/tractor/main.cpp	/^bool valid(int x) {$/;"	f	typeref:typename:bool
validSegment	code-library/Geometry/Geometry 3D.cpp	/^bool validSegment(p3 a, p3 b) {$/;"	f	typeref:typename:bool
validSegment	code/Geometry/Geometry 3D.cpp	/^bool validSegment(p3 a, p3 b) {$/;"	f	typeref:typename:bool
vals	practice/cpbook/ch1/1.6/reallife/medium/01091/restartmain.cpp	/^map<string, int> vals;$/;"	v	typeref:typename:map<string,int>
value	code-library/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Data Structures/Interval Set.cpp	/^  map<pair<int, int>, T> value;\/\/{r,l}=val$/;"	m	struct:interval_set	typeref:typename:map<pair<int,int>,T>	file:
value	code-library/Data Structures/KD Tree.cpp	/^  int axis, value;$/;"	m	struct:kd_node	typeref:typename:int	file:
value	code-library/Data Structures/Segment Tree Persistent Lazy.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Graph Theory/Chromatic Polynoimial.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^    int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Graph Theory/Number of Arborescence.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Graph Theory/Number of DAG.cpp	/^    int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Graph Theory/Tree Isomorphism.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Math/BerleKamp Massey.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Math/Characteristic Polynomial Faster.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Math/Determinant of Sparse Matrix.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Math/FWHT in Ternary Base.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Math/Faulhaber Formula Fastest.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^    int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Math/Hafnian of a Matrix.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Math/Lagrange Interpolation Brute.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Math/Lagrange Interpolation.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Math/Linear Recurrence.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Math/Polynomial Sum.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Math/Polynomial.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Math/Subset Sum Problem.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Math/The Slime Trick.cpp	/^    int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Math/Thomas Algorithm.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Math/Vandermonde Matrix.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Number Theory/Bell Number.cpp	/^    int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Number Theory/Combinatorics Basics.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Number Theory/Dirichlet Convolution.cpp	/^    int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Number Theory/Lucas Theorem.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Number Theory/Min_25 Sieve.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Number Theory/Partition Function.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Number Theory/Phi Field.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Number Theory/Prefix Sum Queries of nCi.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code-library/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Data Structures/HLD with Persistent Lazy Propagation.cpp	/^    int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Data Structures/Interval Set.cpp	/^  map<pair<int, int>, T> value;\/\/{r,l}=val$/;"	m	struct:interval_set	typeref:typename:map<pair<int,int>,T>	file:
value	code/Data Structures/KD Tree.cpp	/^  int axis, value;$/;"	m	struct:kd_node	typeref:typename:int	file:
value	code/Data Structures/Segment Tree Persistent Lazy.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Data Structures/Segment Tree with Arithmetic Progression.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Graph Theory/Chromatic Polynoimial.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Graph Theory/Counting Labeled Graphs.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Graph Theory/Hafnian of a Matrix.cpp	/^    int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Graph Theory/Number of Arborescence.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Graph Theory/Number of DAG.cpp	/^    int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Graph Theory/Tree Isomorphism.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Math/BerleKamp Massey.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Math/Characteristic Polynomial Faster.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Math/Determinant of Sparse Matrix.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Math/FWHT in Ternary Base.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Math/Faulhaber Formula Fastest.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Math/Generating Function of a Linear Recurrence.cpp	/^    int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Math/Hafnian of a Matrix.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Math/Lagrange Interpolation Brute.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Math/Lagrange Interpolation.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Math/Linear Recurrence.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Math/Number of Solutions of A Equation MITM.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Math/Polynomial Sum.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Math/Polynomial.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Math/Subset Sum Problem.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Math/The Slime Trick.cpp	/^    int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Math/Thomas Algorithm.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Math/Vandermonde Matrix.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Number Theory/Bell Number.cpp	/^    int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Number Theory/Combinatorics Basics.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Number Theory/Dirichlet Convolution.cpp	/^    int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Number Theory/Generalized Floor Sum of Arithmetic Progressions.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Number Theory/Lucas Theorem.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Number Theory/Min_25 Sieve.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Number Theory/Partition Function.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Number Theory/Phi Field.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Number Theory/Prefix Sum Queries of nCi.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/Number Theory/Sum of Arithmetic Progression Powers Divided.cpp	/^    int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	code/modint.hpp	/^    int value;$/;"	m	struct:Mint	typeref:typename:int
value	practice/cf/random/i_hate_math_problems/1462E2.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	practice/cf/random/i_hate_math_problems/testing.cpp	/^  int32_t value;$/;"	m	struct:modint	typeref:typename:int32_t	file:
value	practice/december2021/DP/counting_towers/sol.cpp	/^    int value;$/;"	m	struct:Modular	typeref:typename:int	file:
vc	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^bool vc[N];$/;"	v	typeref:typename:bool[]
vc	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^bool vc[N];$/;"	v	typeref:typename:bool[]
vec	code-library/Data Structures/Centroid Decomposition.cpp	/^vector<int> vec;$/;"	v	typeref:typename:vector<int>
vec	code-library/Graph Theory/Boruvka's Algorithm.cpp	/^vector<int> vec[N];$/;"	v	typeref:typename:vector<int>[]
vec	code-library/Graph Theory/Kuhns Algorithm.cpp	/^vector<int> g[N], r[N], G[N], vec; \/\/G is the condensed graph$/;"	v	typeref:typename:vector<int>
vec	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  vector<int> vec, idx;$/;"	m	struct:MaximumClosure	typeref:typename:vector<int>	file:
vec	code-library/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^vector<int> vec;$/;"	v	typeref:typename:vector<int>
vec	code-library/Graph Theory/SCC.cpp	/^vector<int> g[N], r[N], G[N], vec; \/\/G is the condensed graph$/;"	v	typeref:typename:vector<int>
vec	code-library/Math/Reeds Sloane Algorithm.cpp	/^  using vec = vector<ll>;$/;"	t	struct:LinearRecurrence	typeref:typename:vector<ll>	file:
vec	code/Data Structures/Centroid Decomposition.cpp	/^vector<int> vec;$/;"	v	typeref:typename:vector<int>
vec	code/Graph Theory/Boruvka's Algorithm.cpp	/^vector<int> vec[N];$/;"	v	typeref:typename:vector<int>[]
vec	code/Graph Theory/Kuhns Algorithm.cpp	/^vector<int> g[N], r[N], G[N], vec; \/\/G is the condensed graph$/;"	v	typeref:typename:vector<int>
vec	code/Graph Theory/Maximum Closure Problem.cpp	/^  vector<int> vec, idx;$/;"	m	struct:MaximumClosure	typeref:typename:vector<int>	file:
vec	code/Graph Theory/Number of Paths of Each Length in a Tree.cpp	/^vector<int> vec;$/;"	v	typeref:typename:vector<int>
vec	code/Graph Theory/SCC.cpp	/^vector<int> g[N], r[N], G[N], vec; \/\/G is the condensed graph$/;"	v	typeref:typename:vector<int>
vec	code/Math/Reeds Sloane Algorithm.cpp	/^  using vec = vector<ll>;$/;"	t	struct:LinearRecurrence	typeref:typename:vector<ll>	file:
vec_add	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  inline static void vec_add(R64* res, int s, const R* f, R c) {$/;"	f	class:poly	typeref:typename:void	file:
vec_add	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  inline static void vec_add(R64* res, int s, const R* f, R c) {$/;"	f	class:poly	typeref:typename:void	file:
vec_sub	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  inline static void vec_sub(R64* res, int s, const R* f, R c) {$/;"	f	class:poly	typeref:typename:void	file:
vec_sub	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  inline static void vec_sub(R64* res, int s, const R* f, R c) {$/;"	f	class:poly	typeref:typename:void	file:
vectorOK	code-library/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^bool vectorOK (int i) {$/;"	f	typeref:typename:bool
vectorOK	code-library/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^bool vectorOK (int out, int in) {$/;"	f	typeref:typename:bool
vectorOK	code/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^bool vectorOK (int i) {$/;"	f	typeref:typename:bool
vectorOK	code/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^bool vectorOK (int out, int in) {$/;"	f	typeref:typename:bool
verify_matrix_recurrence	code-library/Math/Determinant of Sparse Matrix.cpp	/^void verify_matrix_recurrence(int n, Mat a, vector<Elem> M) {$/;"	f	typeref:typename:void
verify_matrix_recurrence	code/Math/Determinant of Sparse Matrix.cpp	/^void verify_matrix_recurrence(int n, Mat a, vector<Elem> M) {$/;"	f	typeref:typename:void
version	code-library/Data Structures/Persistent Trie.cpp	/^pnode version[N];$/;"	v	typeref:typename:pnode[]
version	code/Data Structures/Persistent Trie.cpp	/^pnode version[N];$/;"	v	typeref:typename:pnode[]
vertext_coloring	code-library/Graph Theory/Chordal Graph.cpp	/^vector<int> vertext_coloring(int n, vector<int>& ord) {$/;"	f	typeref:typename:vector<int>
vertext_coloring	code/Graph Theory/Chordal Graph.cpp	/^vector<int> vertext_coloring(int n, vector<int>& ord) {$/;"	f	typeref:typename:vector<int>
vi	code-library/Math/Polynomial Factorization.cpp	/^using vi = vector<int>;$/;"	t	typeref:typename:vector<int>	file:
vi	code/Math/Polynomial Factorization.cpp	/^using vi = vector<int>;$/;"	t	typeref:typename:vector<int>	file:
vi	practice/usacoguide/gold/introDP/711C.cpp	/^typedef vector<int> vi;$/;"	t	typeref:typename:vector<int>	file:
vis	code-library/Data Structures/Cartesian Tree.cpp	/^int n, tot, st[N], l[N], r[N], vis[N];$/;"	v	typeref:typename:int[]
vis	code-library/Data Structures/MOs on tree.cpp	/^bool vis[N];$/;"	v	typeref:typename:bool[]
vis	code-library/Game Theory/Blue Red Hackenbush.cpp	/^int id[N], vis[N];$/;"	v	typeref:typename:int[]
vis	code-library/Game Theory/Matching Game On A Graph.cpp	/^  int vis[N], par[N], orig[N], match[N], aux[N], t;$/;"	m	struct:Blossom	typeref:typename:int[]	file:
vis	code-library/Graph Theory/2 SAT.cpp	/^  vector<bool> vis, res;$/;"	m	struct:twosat	typeref:typename:vector<bool>	file:
vis	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^  int n, n_x, match[N * 2], slack[N * 2], st[N * 2], pa[N * 2], flower_from[N * 2][N * 2], S[N */;"	m	struct:Blossom	typeref:typename:int[]	file:
vis	code-library/Graph Theory/Blossom Algorithm.cpp	/^  int vis[N], par[N], orig[N], match[N], aux[N], t;$/;"	m	struct:Blossom	typeref:typename:int[]	file:
vis	code-library/Graph Theory/Chinese Postman Problem.cpp	/^  int mat[N], stk[N], id[N], vis[N];$/;"	m	struct:RandomizedMatching	typeref:typename:int[]	file:
vis	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^bool vis[N][N];$/;"	v	typeref:typename:bool[][]
vis	code-library/Graph Theory/Cycle Detection.cpp	/^int vis[N], par[N], e_id[N];$/;"	v	typeref:typename:int[]
vis	code-library/Graph Theory/Euler Path Undirected.cpp	/^int vis[N * N]; \/\/number of edges$/;"	v	typeref:typename:int[]
vis	code-library/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^bool vis[N * 4];$/;"	v	typeref:typename:bool[]
vis	code-library/Graph Theory/Inverse Graph.cpp	/^int par[N], col[N], vis[N], ty[N], n;$/;"	v	typeref:typename:int[]
vis	code-library/Graph Theory/Kirchoffs Theorem.cpp	/^int w[N][N], deg[N], vis[N];$/;"	v	typeref:typename:int[]
vis	code-library/Graph Theory/Kuhns Algorithm.cpp	/^  vector<bool> vis;$/;"	m	struct:Kuhn	typeref:typename:vector<bool>	file:
vis	code-library/Graph Theory/Kuhns Algorithm.cpp	/^bool vis[N];$/;"	v	typeref:typename:bool[]
vis	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  vector<bool> vis;$/;"	m	struct:MaximumClosure	typeref:typename:vector<bool>	file:
vis	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^bool vis[N];$/;"	v	typeref:typename:bool[]
vis	code-library/Graph Theory/Maximum Independant Set.cpp	/^bool vis[N];$/;"	v	typeref:typename:bool[]
vis	code-library/Graph Theory/Minimum Mean Weight Cycle.cpp	/^bool vis[N];$/;"	v	typeref:typename:bool[]
vis	code-library/Graph Theory/Minimum Weight Cycle For Each Edge.cpp	/^int d[N], vis[N], par[N];$/;"	v	typeref:typename:int[]
vis	code-library/Graph Theory/Minimum Weight Cycle For Each Vertex.cpp	/^int g[N][N], d[N], vis[N], par[N];$/;"	v	typeref:typename:int[]
vis	code-library/Graph Theory/Randomized Matching Unweighted.cpp	/^  int n, match[N], vis[N], T = 0;$/;"	m	struct:RandomizedMatching	typeref:typename:int[]	file:
vis	code-library/Graph Theory/Randomized Matching Weighted.cpp	/^	int mat[N], stk[N], id[N], vis[N];$/;"	m	struct:RandomizedMatching	typeref:typename:int[]	file:
vis	code-library/Graph Theory/SCC.cpp	/^bool vis[N];$/;"	v	typeref:typename:bool[]
vis	code-library/Graph Theory/SPFA.cpp	/^bool vis[N];$/;"	v	typeref:typename:bool[]
vis	code-library/Graph Theory/Steiner Tree Problem.cpp	/^bool vis[N];$/;"	v	typeref:typename:bool[]
vis	code-library/Graph Theory/Stoer Wagner Algorithm.cpp	/^  bool vis[N];$/;"	m	struct:StoerWagner	typeref:typename:bool[]	file:
vis	code-library/Graph Theory/System Of Difference Constraints.cpp	/^bool vis[N];$/;"	v	typeref:typename:bool[]
vis	code-library/Graph Theory/Unique Min Cut.cpp	/^bool vis[N];$/;"	v	typeref:typename:bool[]
vis	code-library/Math/All Possible Perfect Matching XOR Values.cpp	/^int a[N][N], p[N], n, vis[N];$/;"	v	typeref:typename:int[]
vis	code-library/Math/Basis Vector Reduced Row Echelon Form.cpp	/^bool vis[N];$/;"	v	typeref:typename:bool[]
vis	code-library/Number Theory/Mobius Function.cpp	/^bool vis[N];$/;"	v	typeref:typename:bool[]
vis	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  vector<bool> vis;$/;"	m	struct:Kuhn	typeref:typename:vector<bool>	file:
vis	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^bool vis[N][2];$/;"	v	typeref:typename:bool[][2]
vis	code/Data Structures/Cartesian Tree.cpp	/^int n, tot, st[N], l[N], r[N], vis[N];$/;"	v	typeref:typename:int[]
vis	code/Data Structures/MOs on tree.cpp	/^bool vis[N];$/;"	v	typeref:typename:bool[]
vis	code/Game Theory/Blue Red Hackenbush.cpp	/^int id[N], vis[N];$/;"	v	typeref:typename:int[]
vis	code/Game Theory/Matching Game On A Graph.cpp	/^  int vis[N], par[N], orig[N], match[N], aux[N], t;$/;"	m	struct:Blossom	typeref:typename:int[]	file:
vis	code/Graph Theory/2 SAT.cpp	/^  vector<bool> vis, res;$/;"	m	struct:twosat	typeref:typename:vector<bool>	file:
vis	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^  int n, n_x, match[N * 2], slack[N * 2], st[N * 2], pa[N * 2], flower_from[N * 2][N * 2], S[N */;"	m	struct:Blossom	typeref:typename:int[]	file:
vis	code/Graph Theory/Blossom Algorithm.cpp	/^  int vis[N], par[N], orig[N], match[N], aux[N], t;$/;"	m	struct:Blossom	typeref:typename:int[]	file:
vis	code/Graph Theory/Chinese Postman Problem.cpp	/^  int mat[N], stk[N], id[N], vis[N];$/;"	m	struct:RandomizedMatching	typeref:typename:int[]	file:
vis	code/Graph Theory/Counting Labeled Graphs.cpp	/^bool vis[N][N];$/;"	v	typeref:typename:bool[][]
vis	code/Graph Theory/Cycle Detection.cpp	/^int vis[N], par[N], e_id[N];$/;"	v	typeref:typename:int[]
vis	code/Graph Theory/Euler Path Undirected.cpp	/^int vis[N * N]; \/\/number of edges$/;"	v	typeref:typename:int[]
vis	code/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^bool vis[N * 4];$/;"	v	typeref:typename:bool[]
vis	code/Graph Theory/Inverse Graph.cpp	/^int par[N], col[N], vis[N], ty[N], n;$/;"	v	typeref:typename:int[]
vis	code/Graph Theory/Kirchoffs Theorem.cpp	/^int w[N][N], deg[N], vis[N];$/;"	v	typeref:typename:int[]
vis	code/Graph Theory/Kuhns Algorithm.cpp	/^  vector<bool> vis;$/;"	m	struct:Kuhn	typeref:typename:vector<bool>	file:
vis	code/Graph Theory/Kuhns Algorithm.cpp	/^bool vis[N];$/;"	v	typeref:typename:bool[]
vis	code/Graph Theory/Maximum Closure Problem.cpp	/^  vector<bool> vis;$/;"	m	struct:MaximumClosure	typeref:typename:vector<bool>	file:
vis	code/Graph Theory/Maximum Density Subgraph.cpp	/^bool vis[N];$/;"	v	typeref:typename:bool[]
vis	code/Graph Theory/Maximum Independant Set.cpp	/^bool vis[N];$/;"	v	typeref:typename:bool[]
vis	code/Graph Theory/Minimum Mean Weight Cycle.cpp	/^bool vis[N];$/;"	v	typeref:typename:bool[]
vis	code/Graph Theory/Minimum Weight Cycle For Each Edge.cpp	/^int d[N], vis[N], par[N];$/;"	v	typeref:typename:int[]
vis	code/Graph Theory/Minimum Weight Cycle For Each Vertex.cpp	/^int g[N][N], d[N], vis[N], par[N];$/;"	v	typeref:typename:int[]
vis	code/Graph Theory/Randomized Matching Unweighted.cpp	/^  int n, match[N], vis[N], T = 0;$/;"	m	struct:RandomizedMatching	typeref:typename:int[]	file:
vis	code/Graph Theory/Randomized Matching Weighted.cpp	/^	int mat[N], stk[N], id[N], vis[N];$/;"	m	struct:RandomizedMatching	typeref:typename:int[]	file:
vis	code/Graph Theory/SCC.cpp	/^bool vis[N];$/;"	v	typeref:typename:bool[]
vis	code/Graph Theory/SPFA.cpp	/^bool vis[N];$/;"	v	typeref:typename:bool[]
vis	code/Graph Theory/Steiner Tree Problem.cpp	/^bool vis[N];$/;"	v	typeref:typename:bool[]
vis	code/Graph Theory/Stoer Wagner Algorithm.cpp	/^  bool vis[N];$/;"	m	struct:StoerWagner	typeref:typename:bool[]	file:
vis	code/Graph Theory/System Of Difference Constraints.cpp	/^bool vis[N];$/;"	v	typeref:typename:bool[]
vis	code/Graph Theory/Unique Min Cut.cpp	/^bool vis[N];$/;"	v	typeref:typename:bool[]
vis	code/Math/All Possible Perfect Matching XOR Values.cpp	/^int a[N][N], p[N], n, vis[N];$/;"	v	typeref:typename:int[]
vis	code/Math/Basis Vector Reduced Row Echelon Form.cpp	/^bool vis[N];$/;"	v	typeref:typename:bool[]
vis	code/Number Theory/Mobius Function.cpp	/^bool vis[N];$/;"	v	typeref:typename:bool[]
vis	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  vector<bool> vis;$/;"	m	struct:Kuhn	typeref:typename:vector<bool>	file:
vis	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^bool vis[N][2];$/;"	v	typeref:typename:bool[][2]
vis	practice/cf/random/1700/1476D.cpp	/^int vis = 0;$/;"	v	typeref:typename:int
vis	practice/usacoguide/gold/bfs/graphgirth2.cpp	/^int vis[2505];$/;"	v	typeref:typename:int[2505]
vis	practice/usacoguide/gold/dsu/tractor/main.cpp	/^bool vis[mxN][mxN];$/;"	v	typeref:typename:bool[][]
visit	practice/cpbook/ch1/1.6/chess/chess/realsol.cpp	/^void visit(pair<int, int> start, int xdir, int ydir, bool x) {$/;"	f	typeref:typename:void
visited	contests/AtCoder/231/D.cpp	/^bool visited[mxN];$/;"	v	typeref:typename:bool[]
visited	contests/LIT2021/C.cpp	/^int visited[mxN][mxN][mxN][mxN];$/;"	v	typeref:typename:int[][][][]
visited	practice/cf/random/1700/test1.cpp	/^bool visited[mxN];$/;"	v	typeref:typename:bool[]
visited	practice/usacoguide/gold/bfs/mecho/main.cpp	/^bool visited[mxN][mxN];$/;"	v	typeref:typename:bool[][]
visited	practice/usacoguide/gold/dsu/closing/main.cpp	/^bool visited[mxN];$/;"	v	typeref:typename:bool[]
visited	practice/usacoguide/silver/idk/maze/main.cpp	/^bool visited[mxN][mxN][100000];$/;"	v	typeref:typename:bool[][][100000]
visited_board	practice/usacoguide/silver/idk/maze/main.cpp	/^bool visited_board[100000];$/;"	v	typeref:typename:bool[100000]
visiting	practice/usacoguide/gold/introDP/time.cpp	/^bool visiting[mxN][mxN];$/;"	v	typeref:typename:bool[][]
vit	practice/usacoguide/gold/introDP/711C.cpp	/^typedef vector<int>::iterator vit;$/;"	t	typeref:typename:vector<int>::iterator	file:
vlli	contests/Codeforces/737/D.cpp	/^#define vlli /;"	d	file:
vlli	contests/Codeforces/737/E.cpp	/^#define vlli /;"	d	file:
volume	code-library/Geometry/Geometry 3D.cpp	/^    double volume() {$/;"	f	struct:CH3D	typeref:typename:double	file:
volume	code-library/Geometry/Geometry 3D.cpp	/^    double volume(p3 a, p3 b, p3 c, p3 d) {$/;"	f	struct:CH3D	typeref:typename:double	file:
volume	code/Geometry/Geometry 3D.cpp	/^    double volume() {$/;"	f	struct:CH3D	typeref:typename:double	file:
volume	code/Geometry/Geometry 3D.cpp	/^    double volume(p3 a, p3 b, p3 c, p3 d) {$/;"	f	struct:CH3D	typeref:typename:double	file:
vsum	code-library/Data Structures/Link Cut Tree.cpp	/^  long long val = 0, sum = 0, lazy = 0, subsum = 0, vsum = 0;$/;"	m	struct:node	typeref:typename:long long	file:
vsum	code/Data Structures/Link Cut Tree.cpp	/^  long long val = 0, sum = 0, lazy = 0, subsum = 0, vsum = 0;$/;"	m	struct:node	typeref:typename:long long	file:
vsz	code-library/Data Structures/Link Cut Tree.cpp	/^  int sz = 0, ssz = 0, vsz = 0; \/\/ sz -> aux tree size, ssz = subtree size in rep tree, vsz = /;"	m	struct:node	typeref:typename:int	file:
vsz	code/Data Structures/Link Cut Tree.cpp	/^  int sz = 0, ssz = 0, vsz = 0; \/\/ sz -> aux tree size, ssz = subtree size in rep tree, vsz = /;"	m	struct:node	typeref:typename:int	file:
vv	code-library/Math/Vandermonde Matrix.cpp	/^#define vv /;"	d	file:
vv	code/Math/Vandermonde Matrix.cpp	/^#define vv /;"	d	file:
w	code-library/Data Structures/DSU with Rollbacks.cpp	/^  vector<int> par, sz, w;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
w	code-library/Data Structures/Queue Undo Trick.cpp	/^  vector<int> par, sz, w;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
w	code-library/Dynamic Programming Optimizations/1D1D DP.cpp	/^int w(int i, int x) {$/;"	f	typeref:typename:int
w	code-library/Game Theory/Blue Red Hackenbush.cpp	/^  int val, w; \/\/ val=integer part$/;"	m	struct:surreal	typeref:typename:int	file:
w	code-library/Graph Theory/Blossom Algorithm Weighted.cpp	/^    long long w;$/;"	m	struct:Blossom::edge	typeref:typename:long long	file:
w	code-library/Graph Theory/Chinese Postman Problem.cpp	/^long long w[N][N];$/;"	v	typeref:typename:long long[][]
w	code-library/Graph Theory/Dijkstra.cpp	/^int u[N], v[N], w[N];$/;"	v	typeref:typename:int[]
w	code-library/Graph Theory/Dinics Algorithm.cpp	/^    long long flow, w;$/;"	m	struct:Dinic::edge	typeref:typename:long long	file:
w	code-library/Graph Theory/Directed MST.cpp	/^  int u, v; long long w;$/;"	m	struct:edge	typeref:typename:long long	file:
w	code-library/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^  long long w;$/;"	m	struct:EDGE	typeref:typename:long long	file:
w	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  long long w;$/;"	m	struct:edge	typeref:typename:long long	file:
w	code-library/Graph Theory/Gomory Hu Tree.cpp	/^  vector<int> p, w, c;$/;"	m	struct:GomoryHuTree	typeref:typename:vector<int>	file:
w	code-library/Graph Theory/Johnson's Algorithm.cpp	/^  long long w;$/;"	m	struct:edge	typeref:typename:long long	file:
w	code-library/Graph Theory/Kirchoffs Theorem.cpp	/^int w[N][N], deg[N], vis[N];$/;"	v	typeref:typename:int[][]
w	code-library/Graph Theory/L R Flow with Dinic.cpp	/^    long long flow, w;$/;"	m	struct:Dinic::edge	typeref:typename:long long	file:
w	code-library/Graph Theory/Manhattan MST.cpp	/^  int u, v, w;$/;"	m	struct:edge	typeref:typename:int	file:
w	code-library/Graph Theory/Maximum Closure Problem.cpp	/^    long long flow, w;$/;"	m	struct:Dinic::edge	typeref:typename:long long	file:
w	code-library/Graph Theory/Maximum Closure Problem.cpp	/^  vector<long long> w;$/;"	m	struct:MaximumClosure	typeref:typename:vector<long long>	file:
w	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^    double flow, w;$/;"	m	struct:Dinic::edge	typeref:typename:double	file:
w	code-library/Graph Theory/Prim's MST.cpp	/^int g[N][N], w[N], to[N], selected[N];$/;"	v	typeref:typename:int[]
w	code-library/Graph Theory/Stable Marriage Problem.cpp	/^int m[N][N], w[N][N], id[N], marry[N], ans[N], pref[N][N];$/;"	v	typeref:typename:int[][]
w	code-library/Graph Theory/Unique Min Cut.cpp	/^    long long flow, w;$/;"	m	struct:Dinic::edge	typeref:typename:long long	file:
w	code-library/Math/FWHT in Ternary Base.cpp	/^} w(0, 1), w2(mod - 1, mod - 1);$/;"	v	typeref:struct:cmplx
w	code-library/Math/NTT.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
w	code-library/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
w	code-library/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
w	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
w	code-library/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
w	code/Data Structures/DSU with Rollbacks.cpp	/^  vector<int> par, sz, w;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
w	code/Data Structures/Queue Undo Trick.cpp	/^  vector<int> par, sz, w;$/;"	m	struct:DSU	typeref:typename:vector<int>	file:
w	code/Dynamic Programming Optimizations/1D1D DP.cpp	/^int w(int i, int x) {$/;"	f	typeref:typename:int
w	code/Game Theory/Blue Red Hackenbush.cpp	/^  int val, w; \/\/ val=integer part$/;"	m	struct:surreal	typeref:typename:int	file:
w	code/Graph Theory/Blossom Algorithm Weighted.cpp	/^    long long w;$/;"	m	struct:Blossom::edge	typeref:typename:long long	file:
w	code/Graph Theory/Chinese Postman Problem.cpp	/^long long w[N][N];$/;"	v	typeref:typename:long long[][]
w	code/Graph Theory/Dijkstra.cpp	/^int u[N], v[N], w[N];$/;"	v	typeref:typename:int[]
w	code/Graph Theory/Dinics Algorithm.cpp	/^    long long flow, w;$/;"	m	struct:Dinic::edge	typeref:typename:long long	file:
w	code/Graph Theory/Directed MST.cpp	/^  int u, v; long long w;$/;"	m	struct:edge	typeref:typename:long long	file:
w	code/Graph Theory/Gomory Hu Tree of Planar Graph.cpp	/^  long long w;$/;"	m	struct:EDGE	typeref:typename:long long	file:
w	code/Graph Theory/Gomory Hu Tree.cpp	/^  long long w;$/;"	m	struct:edge	typeref:typename:long long	file:
w	code/Graph Theory/Gomory Hu Tree.cpp	/^  vector<int> p, w, c;$/;"	m	struct:GomoryHuTree	typeref:typename:vector<int>	file:
w	code/Graph Theory/Johnson's Algorithm.cpp	/^  long long w;$/;"	m	struct:edge	typeref:typename:long long	file:
w	code/Graph Theory/Kirchoffs Theorem.cpp	/^int w[N][N], deg[N], vis[N];$/;"	v	typeref:typename:int[][]
w	code/Graph Theory/L R Flow with Dinic.cpp	/^    long long flow, w;$/;"	m	struct:Dinic::edge	typeref:typename:long long	file:
w	code/Graph Theory/Manhattan MST.cpp	/^  int u, v, w;$/;"	m	struct:edge	typeref:typename:int	file:
w	code/Graph Theory/Maximum Closure Problem.cpp	/^    long long flow, w;$/;"	m	struct:Dinic::edge	typeref:typename:long long	file:
w	code/Graph Theory/Maximum Closure Problem.cpp	/^  vector<long long> w;$/;"	m	struct:MaximumClosure	typeref:typename:vector<long long>	file:
w	code/Graph Theory/Maximum Density Subgraph.cpp	/^    double flow, w;$/;"	m	struct:Dinic::edge	typeref:typename:double	file:
w	code/Graph Theory/Prim's MST.cpp	/^int g[N][N], w[N], to[N], selected[N];$/;"	v	typeref:typename:int[]
w	code/Graph Theory/Stable Marriage Problem.cpp	/^int m[N][N], w[N][N], id[N], marry[N], ans[N], pref[N][N];$/;"	v	typeref:typename:int[][]
w	code/Graph Theory/Unique Min Cut.cpp	/^    long long flow, w;$/;"	m	struct:Dinic::edge	typeref:typename:long long	file:
w	code/Math/FWHT in Ternary Base.cpp	/^} w(0, 1), w2(mod - 1, mod - 1);$/;"	v	typeref:struct:cmplx
w	code/Math/NTT.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
w	code/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
w	code/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
w	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
w	code/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
w2	code-library/Math/FWHT in Ternary Base.cpp	/^} w(0, 1), w2(mod - 1, mod - 1);$/;"	v	typeref:struct:cmplx
w2	code/Math/FWHT in Ternary Base.cpp	/^} w(0, 1), w2(mod - 1, mod - 1);$/;"	v	typeref:struct:cmplx
want	code-library/Miscellaneous/Parallel Binary Search.cpp	/^int amount[N], want[N], st[N], en[N], l[N], r[N], ans[N];$/;"	v	typeref:typename:int[]
want	code/Miscellaneous/Parallel Binary Search.cpp	/^int amount[N], want[N], st[N], en[N], l[N], r[N], ans[N];$/;"	v	typeref:typename:int[]
wavelet_tree	code-library/Data Structures/Wavelet Tree.cpp	/^  wavelet_tree() {$/;"	f	struct:wavelet_tree	file:
wavelet_tree	code-library/Data Structures/Wavelet Tree.cpp	/^struct wavelet_tree {$/;"	s	file:
wavelet_tree	code-library/Strings/Number of Palindromes in Range.cpp	/^  wavelet_tree() {$/;"	f	struct:wavelet_tree	file:
wavelet_tree	code-library/Strings/Number of Palindromes in Range.cpp	/^struct wavelet_tree {$/;"	s	file:
wavelet_tree	code/Data Structures/Wavelet Tree.cpp	/^  wavelet_tree() {$/;"	f	struct:wavelet_tree	file:
wavelet_tree	code/Data Structures/Wavelet Tree.cpp	/^struct wavelet_tree {$/;"	s	file:
wavelet_tree	code/Strings/Number of Palindromes in Range.cpp	/^  wavelet_tree() {$/;"	f	struct:wavelet_tree	file:
wavelet_tree	code/Strings/Number of Palindromes in Range.cpp	/^struct wavelet_tree {$/;"	s	file:
weight	practice/usacoguide/gold/introDP/mooney.cpp	/^vector<int> adj[mxN], weight(mxN);$/;"	v	typeref:typename:vector<int>
where	code-library/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^int n, m, tot, col[N], where[N], par[N];$/;"	v	typeref:typename:int[]
where	code/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^int n, m, tot, col[N], where[N], par[N];$/;"	v	typeref:typename:int[]
width	code-library/Geometry/Geometry 2D.cpp	/^double width(vector<PT> &p) {$/;"	f	typeref:typename:double
width	code/Geometry/Geometry 2D.cpp	/^double width(vector<PT> &p) {$/;"	f	typeref:typename:double
win	practice/usacoguide/silver/idk/maze/main.cpp	/^bool win(int hash) {$/;"	f	typeref:typename:bool
winding_number	code-library/Geometry/Geometry 2D.cpp	/^int winding_number(vector<PT> &p, const PT& z) { \/\/ O(n)$/;"	f	typeref:typename:int
winding_number	code-library/Geometry/Voronoi Diagram.cpp	/^int winding_number(vector<PT> &p, const PT& z) { \/\/ O(n)$/;"	f	typeref:typename:int
winding_number	code/Geometry/Geometry 2D.cpp	/^int winding_number(vector<PT> &p, const PT& z) { \/\/ O(n)$/;"	f	typeref:typename:int
winding_number	code/Geometry/Voronoi Diagram.cpp	/^int winding_number(vector<PT> &p, const PT& z) { \/\/ O(n)$/;"	f	typeref:typename:int
winding_number_3D	code-library/Geometry/Geometry 3D.cpp	/^int winding_number_3D(vector<vector<p3>> fs) {$/;"	f	typeref:typename:int
winding_number_3D	code/Geometry/Geometry 3D.cpp	/^int winding_number_3D(vector<vector<p3>> fs) {$/;"	f	typeref:typename:int
wins1	practice/cpbook/ch1/1.6/reallife/medium/tenis/main.cpp	/^int wins1 = 0, wins2 = 0;$/;"	v	typeref:typename:int
wins2	practice/cpbook/ch1/1.6/reallife/medium/tenis/main.cpp	/^int wins1 = 0, wins2 = 0;$/;"	v	typeref:typename:int
without	code-library/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^vector <ll> basis, without[L];$/;"	v	typeref:typename:vector<ll>[]
without	code/Miscellaneous/Matroid Intersection Color Linear Matroid.cpp	/^vector <ll> basis, without[L];$/;"	v	typeref:typename:vector<ll>[]
wn	code-library/Math/NTT.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
wn	code-library/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
wn	code-library/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
wn	code-library/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
wn	code-library/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
wn	code/Math/NTT.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
wn	code/Number Theory/Stirling Number of the First Kind for Fixed k.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
wn	code/Number Theory/Stirling Number of the First Kind for Fixed n.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
wn	code/Number Theory/Stirling Number of the Second Kind for Fixed n.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
wn	code/Number Theory/Sum of nCi over a Fixed Congruence Class.cpp	/^int lim, rev[N], w[N], wn[N], inv_lim;$/;"	v	typeref:typename:int[]
word_bits	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^static const int word_bits = 8 * sizeof(word_t);$/;"	v	namespace:ntt	typeref:typename:const int	file:
word_bits	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^static const int word_bits = 8 * sizeof(word_t);$/;"	v	namespace:ntt	typeref:typename:const int	file:
word_t	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  using word_t = u64;$/;"	t	namespace:ntt	typeref:typename:u64	file:
word_t	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  using word_t = u64;$/;"	t	namespace:ntt	typeref:typename:u64	file:
wt	code-library/Math/Basis Vector ft Weighted Linearly Independent Vectors.cpp	/^  long long wt[B];$/;"	m	struct:Basis	typeref:typename:long long[]	file:
wt	code-library/Math/FWHT.cpp	/^  void wt(int *a, int n, int flag = XOR) {$/;"	f	struct:FWHT	typeref:typename:void	file:
wt	code/Math/Basis Vector ft Weighted Linearly Independent Vectors.cpp	/^  long long wt[B];$/;"	m	struct:Basis	typeref:typename:long long[]	file:
wt	code/Math/FWHT.cpp	/^  void wt(int *a, int n, int flag = XOR) {$/;"	f	struct:FWHT	typeref:typename:void	file:
x	code-library/Data Structures/DSU with Rollbacks.cpp	/^  int x, y;$/;"	m	struct:update	typeref:typename:int	file:
x	code-library/Data Structures/Persistent Array.cpp	/^    node* l, * r; T x;$/;"	m	struct:PersistentArray::node	typeref:typename:T	file:
x	code-library/Data Structures/Persistent Queue.cpp	/^    node* l, * r; T x;$/;"	m	struct:PersistentArray::node	typeref:typename:T	file:
x	code-library/Data Structures/Persistent UnionFind.cpp	/^    node* l, * r; T x;$/;"	m	struct:PersistentArray::node	typeref:typename:T	file:
x	code-library/Data Structures/Queue Undo Trick.cpp	/^  int x, y;$/;"	m	struct:update	typeref:typename:int	file:
x	code-library/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^int ty[N], l[N], r[N], x[N];$/;"	v	typeref:typename:int[]
x	code-library/Dynamic Programming Optimizations/Persistent CHT.cpp	/^  int x, y;$/;"	m	struct:PT	typeref:typename:int	file:
x	code-library/Dynamic Programming Optimizations/Subset Union of Bitsets.cpp	/^int x[N], y[N], c[N], dp[1 << 20], msk[N], ans[N];$/;"	v	typeref:typename:int[]
x	code-library/Geometry/All Pair Segment Intersection.cpp	/^    double x, y;$/;"	m	struct:PT	typeref:typename:double	file:
x	code-library/Geometry/All Pair Segment Intersection.cpp	/^    double x;$/;"	m	struct:event	typeref:typename:double	file:
x	code-library/Geometry/Closest Pair of Points.cpp	/^#define x /;"	d	file:
x	code-library/Geometry/Convec Hull Dynamic.cpp	/^    int x, y;$/;"	m	struct:PT	typeref:typename:int	file:
x	code-library/Geometry/Delaunay Triangulation.cpp	/^    double x, y;$/;"	m	struct:dPT	typeref:typename:double	file:
x	code-library/Geometry/Delaunay Triangulation.cpp	/^    long long x, y;$/;"	m	struct:PT	typeref:typename:long long	file:
x	code-library/Geometry/Geometry 2D.cpp	/^    double x, y;$/;"	m	struct:PT	typeref:typename:double	file:
x	code-library/Geometry/Geometry 2D.cpp	/^    double x[2020], y[2020], r[2020];$/;"	m	struct:CircleUnion	typeref:typename:double[2020]	file:
x	code-library/Geometry/Geometry 3D.cpp	/^    double x, y, z;$/;"	m	struct:p3	typeref:typename:double	file:
x	code-library/Geometry/Geometry 3D.cpp	/^    double x, y;$/;"	m	struct:PT	typeref:typename:double	file:
x	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    double x, y;$/;"	m	struct:Angle	typeref:typename:double	file:
x	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    double x, y;$/;"	m	struct:PT	typeref:typename:double	file:
x	code-library/Geometry/Half Plane Intersection.cpp	/^    double x, y;$/;"	m	struct:PT	typeref:typename:double	file:
x	code-library/Geometry/Onion Decomposition.cpp	/^    long long x,y;$/;"	m	struct:PT	typeref:typename:long long	file:
x	code-library/Geometry/Point Location.cpp	/^    ll x, y;$/;"	m	struct:PT	typeref:typename:ll	file:
x	code-library/Geometry/Voronoi Diagram.cpp	/^    double x, y;$/;"	m	struct:PT	typeref:typename:double	file:
x	code-library/Geometry/Voronoi Diagram.cpp	/^    long long x, y;$/;"	m	struct:P	typeref:typename:long long	file:
x	code-library/Graph Theory/3 SAT.cpp	/^  vector<bool> x;$/;"	m	struct:SAT_GOD	typeref:typename:vector<bool>	file:
x	code-library/Graph Theory/Manhattan MST.cpp	/^  int x, y, id;$/;"	m	struct:PT	typeref:typename:int	file:
x	code-library/Math/Determinant of Sparse Matrix.cpp	/^struct Elem { int x, y; mint v; };$/;"	m	struct:Elem	typeref:typename:int	file:
x	code-library/Math/Faulhaber Formula Fastest.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
x	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
x	code-library/Math/Linear Recurrence Fastest.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
x	code-library/Math/NTT Online.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
x	code-library/Math/NTT With Any Prime MOD.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
x	code-library/Math/Polynomial with Binomial Coefficients.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
x	code-library/Math/Polynomial.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
x	code-library/Math/Subset Sum Problem.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
x	code-library/Miscellaneous/BigInt.cpp	/^  T x, y;$/;"	m	struct:cplx	typeref:typename:T	file:
x	code-library/Miscellaneous/Subset Union of Bitsets.cpp	/^int x[N], y[N], c[N], dp[1 << 20], msk[N], ans[N];$/;"	v	typeref:typename:int[]
x	code-library/Number Theory/Bell Number.cpp	/^    double x, y;$/;"	m	struct:base	typeref:typename:double	file:
x	code-library/Number Theory/Linear Diophantine Equation with Nonnegative Solutions.cpp	/^  int n, x;$/;"	m	struct:LDE	typeref:typename:int	file:
x	code-library/Number Theory/Rational Approximation.py	/^x = 3232.45622121$/;"	v
x	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    double x, y;$/;"	m	struct:base	typeref:typename:double	file:
x	code-library/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^    double x, y;$/;"	m	struct:base	typeref:typename:double	file:
x	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^    u64 m, s, x;$/;"	m	struct:poly::fast_div	typeref:typename:u64	file:
x	code-library/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  word_t x;$/;"	m	class:ntt::Mod	typeref:typename:word_t	file:
x	code-library/Strings/Bit LCS.cpp	/^} row, bs[SIGMA], x;$/;"	v	typeref:struct:Bitset
x	code/Data Structures/DSU with Rollbacks.cpp	/^  int x, y;$/;"	m	struct:update	typeref:typename:int	file:
x	code/Data Structures/Persistent Array.cpp	/^    node* l, * r; T x;$/;"	m	struct:PersistentArray::node	typeref:typename:T	file:
x	code/Data Structures/Persistent Queue.cpp	/^    node* l, * r; T x;$/;"	m	struct:PersistentArray::node	typeref:typename:T	file:
x	code/Data Structures/Persistent UnionFind.cpp	/^    node* l, * r; T x;$/;"	m	struct:PersistentArray::node	typeref:typename:T	file:
x	code/Data Structures/Queue Undo Trick.cpp	/^  int x, y;$/;"	m	struct:update	typeref:typename:int	file:
x	code/Data Structures/Square Root Decomposition With Reverse Update.cpp	/^int ty[N], l[N], r[N], x[N];$/;"	v	typeref:typename:int[]
x	code/Dynamic Programming Optimizations/Persistent CHT.cpp	/^  int x, y;$/;"	m	struct:PT	typeref:typename:int	file:
x	code/Dynamic Programming Optimizations/Subset Union of Bitsets.cpp	/^int x[N], y[N], c[N], dp[1 << 20], msk[N], ans[N];$/;"	v	typeref:typename:int[]
x	code/Geometry/All Pair Segment Intersection.cpp	/^    double x, y;$/;"	m	struct:PT	typeref:typename:double	file:
x	code/Geometry/All Pair Segment Intersection.cpp	/^    double x;$/;"	m	struct:event	typeref:typename:double	file:
x	code/Geometry/Closest Pair of Points.cpp	/^#define x /;"	d	file:
x	code/Geometry/Convec Hull Dynamic.cpp	/^    int x, y;$/;"	m	struct:PT	typeref:typename:int	file:
x	code/Geometry/Delaunay Triangulation.cpp	/^    double x, y;$/;"	m	struct:dPT	typeref:typename:double	file:
x	code/Geometry/Delaunay Triangulation.cpp	/^    long long x, y;$/;"	m	struct:PT	typeref:typename:long long	file:
x	code/Geometry/Geometry 2D.cpp	/^    double x, y;$/;"	m	struct:PT	typeref:typename:double	file:
x	code/Geometry/Geometry 2D.cpp	/^    double x[2020], y[2020], r[2020];$/;"	m	struct:CircleUnion	typeref:typename:double[2020]	file:
x	code/Geometry/Geometry 3D.cpp	/^    double x, y, z;$/;"	m	struct:p3	typeref:typename:double	file:
x	code/Geometry/Geometry 3D.cpp	/^    double x, y;$/;"	m	struct:PT	typeref:typename:double	file:
x	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    double x, y;$/;"	m	struct:Angle	typeref:typename:double	file:
x	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    double x, y;$/;"	m	struct:PT	typeref:typename:double	file:
x	code/Geometry/Half Plane Intersection.cpp	/^    double x, y;$/;"	m	struct:PT	typeref:typename:double	file:
x	code/Geometry/Onion Decomposition.cpp	/^    long long x,y;$/;"	m	struct:PT	typeref:typename:long long	file:
x	code/Geometry/Point Location.cpp	/^    ll x, y;$/;"	m	struct:PT	typeref:typename:ll	file:
x	code/Geometry/Voronoi Diagram.cpp	/^    double x, y;$/;"	m	struct:PT	typeref:typename:double	file:
x	code/Geometry/Voronoi Diagram.cpp	/^    long long x, y;$/;"	m	struct:P	typeref:typename:long long	file:
x	code/Graph Theory/3 SAT.cpp	/^  vector<bool> x;$/;"	m	struct:SAT_GOD	typeref:typename:vector<bool>	file:
x	code/Graph Theory/Manhattan MST.cpp	/^  int x, y, id;$/;"	m	struct:PT	typeref:typename:int	file:
x	code/Math/Determinant of Sparse Matrix.cpp	/^struct Elem { int x, y; mint v; };$/;"	m	struct:Elem	typeref:typename:int	file:
x	code/Math/Faulhaber Formula Fastest.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
x	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
x	code/Math/Linear Recurrence Fastest.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
x	code/Math/NTT Online.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
x	code/Math/NTT With Any Prime MOD.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
x	code/Math/Polynomial with Binomial Coefficients.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
x	code/Math/Polynomial.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
x	code/Math/Subset Sum Problem.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
x	code/Miscellaneous/BigInt.cpp	/^  T x, y;$/;"	m	struct:cplx	typeref:typename:T	file:
x	code/Miscellaneous/Subset Union of Bitsets.cpp	/^int x[N], y[N], c[N], dp[1 << 20], msk[N], ans[N];$/;"	v	typeref:typename:int[]
x	code/Number Theory/Bell Number.cpp	/^    double x, y;$/;"	m	struct:base	typeref:typename:double	file:
x	code/Number Theory/Linear Diophantine Equation with Nonnegative Solutions.cpp	/^  int n, x;$/;"	m	struct:LDE	typeref:typename:int	file:
x	code/Number Theory/Rational Approximation.py	/^x = 3232.45622121$/;"	v
x	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    double x, y;$/;"	m	struct:base	typeref:typename:double	file:
x	code/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^    double x, y;$/;"	m	struct:base	typeref:typename:double	file:
x	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^    u64 m, s, x;$/;"	m	struct:poly::fast_div	typeref:typename:u64	file:
x	code/Number Theory/Sum of nCi for a Fixed Large n.cpp	/^  word_t x;$/;"	m	class:ntt::Mod	typeref:typename:word_t	file:
x	code/Strings/Bit LCS.cpp	/^} row, bs[SIGMA], x;$/;"	v	typeref:struct:Bitset
x	contests/LIT2021/C.cpp	/^    int x, y;$/;"	m	struct:P	typeref:typename:int	file:
y	code-library/Data Structures/DSU with Rollbacks.cpp	/^  int x, y;$/;"	m	struct:update	typeref:typename:int	file:
y	code-library/Data Structures/Queue Undo Trick.cpp	/^  int x, y;$/;"	m	struct:update	typeref:typename:int	file:
y	code-library/Dynamic Programming Optimizations/Persistent CHT.cpp	/^  int x, y;$/;"	m	struct:PT	typeref:typename:int	file:
y	code-library/Dynamic Programming Optimizations/Subset Union of Bitsets.cpp	/^int x[N], y[N], c[N], dp[1 << 20], msk[N], ans[N];$/;"	v	typeref:typename:int[]
y	code-library/Geometry/All Pair Segment Intersection.cpp	/^    double x, y;$/;"	m	struct:PT	typeref:typename:double	file:
y	code-library/Geometry/Closest Pair of Points.cpp	/^#define y /;"	d	file:
y	code-library/Geometry/Convec Hull Dynamic.cpp	/^    int x, y;$/;"	m	struct:PT	typeref:typename:int	file:
y	code-library/Geometry/Delaunay Triangulation.cpp	/^    double x, y;$/;"	m	struct:dPT	typeref:typename:double	file:
y	code-library/Geometry/Delaunay Triangulation.cpp	/^    long long x, y;$/;"	m	struct:PT	typeref:typename:long long	file:
y	code-library/Geometry/Geometry 2D.cpp	/^    double x, y;$/;"	m	struct:PT	typeref:typename:double	file:
y	code-library/Geometry/Geometry 2D.cpp	/^    double x[2020], y[2020], r[2020];$/;"	m	struct:CircleUnion	typeref:typename:double[2020]	file:
y	code-library/Geometry/Geometry 3D.cpp	/^    double x, y, z;$/;"	m	struct:p3	typeref:typename:double	file:
y	code-library/Geometry/Geometry 3D.cpp	/^    double x, y;$/;"	m	struct:PT	typeref:typename:double	file:
y	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    double x, y;$/;"	m	struct:Angle	typeref:typename:double	file:
y	code-library/Geometry/Half Plane Intersection Dynamic.cpp	/^    double x, y;$/;"	m	struct:PT	typeref:typename:double	file:
y	code-library/Geometry/Half Plane Intersection.cpp	/^    double x, y;$/;"	m	struct:PT	typeref:typename:double	file:
y	code-library/Geometry/Onion Decomposition.cpp	/^    long long x,y;$/;"	m	struct:PT	typeref:typename:long long	file:
y	code-library/Geometry/Point Location.cpp	/^    ll x, y;$/;"	m	struct:PT	typeref:typename:ll	file:
y	code-library/Geometry/Voronoi Diagram.cpp	/^    double x, y;$/;"	m	struct:PT	typeref:typename:double	file:
y	code-library/Geometry/Voronoi Diagram.cpp	/^    long long x, y;$/;"	m	struct:P	typeref:typename:long long	file:
y	code-library/Graph Theory/Manhattan MST.cpp	/^  int x, y, id;$/;"	m	struct:PT	typeref:typename:int	file:
y	code-library/Math/Determinant of Sparse Matrix.cpp	/^struct Elem { int x, y; mint v; };$/;"	m	struct:Elem	typeref:typename:int	file:
y	code-library/Math/Faulhaber Formula Fastest.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
y	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
y	code-library/Math/Linear Recurrence Fastest.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
y	code-library/Math/NTT Online.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
y	code-library/Math/NTT With Any Prime MOD.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
y	code-library/Math/Polynomial with Binomial Coefficients.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
y	code-library/Math/Polynomial.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
y	code-library/Math/Subset Sum Problem.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
y	code-library/Miscellaneous/BigInt.cpp	/^  T x, y;$/;"	m	struct:cplx	typeref:typename:T	file:
y	code-library/Miscellaneous/Subset Union of Bitsets.cpp	/^int x[N], y[N], c[N], dp[1 << 20], msk[N], ans[N];$/;"	v	typeref:typename:int[]
y	code-library/Number Theory/Bell Number.cpp	/^    double x, y;$/;"	m	struct:base	typeref:typename:double	file:
y	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    double x, y;$/;"	m	struct:base	typeref:typename:double	file:
y	code-library/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^    double x, y;$/;"	m	struct:base	typeref:typename:double	file:
y	code/Data Structures/DSU with Rollbacks.cpp	/^  int x, y;$/;"	m	struct:update	typeref:typename:int	file:
y	code/Data Structures/Queue Undo Trick.cpp	/^  int x, y;$/;"	m	struct:update	typeref:typename:int	file:
y	code/Dynamic Programming Optimizations/Persistent CHT.cpp	/^  int x, y;$/;"	m	struct:PT	typeref:typename:int	file:
y	code/Dynamic Programming Optimizations/Subset Union of Bitsets.cpp	/^int x[N], y[N], c[N], dp[1 << 20], msk[N], ans[N];$/;"	v	typeref:typename:int[]
y	code/Geometry/All Pair Segment Intersection.cpp	/^    double x, y;$/;"	m	struct:PT	typeref:typename:double	file:
y	code/Geometry/Closest Pair of Points.cpp	/^#define y /;"	d	file:
y	code/Geometry/Convec Hull Dynamic.cpp	/^    int x, y;$/;"	m	struct:PT	typeref:typename:int	file:
y	code/Geometry/Delaunay Triangulation.cpp	/^    double x, y;$/;"	m	struct:dPT	typeref:typename:double	file:
y	code/Geometry/Delaunay Triangulation.cpp	/^    long long x, y;$/;"	m	struct:PT	typeref:typename:long long	file:
y	code/Geometry/Geometry 2D.cpp	/^    double x, y;$/;"	m	struct:PT	typeref:typename:double	file:
y	code/Geometry/Geometry 2D.cpp	/^    double x[2020], y[2020], r[2020];$/;"	m	struct:CircleUnion	typeref:typename:double[2020]	file:
y	code/Geometry/Geometry 3D.cpp	/^    double x, y, z;$/;"	m	struct:p3	typeref:typename:double	file:
y	code/Geometry/Geometry 3D.cpp	/^    double x, y;$/;"	m	struct:PT	typeref:typename:double	file:
y	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    double x, y;$/;"	m	struct:Angle	typeref:typename:double	file:
y	code/Geometry/Half Plane Intersection Dynamic.cpp	/^    double x, y;$/;"	m	struct:PT	typeref:typename:double	file:
y	code/Geometry/Half Plane Intersection.cpp	/^    double x, y;$/;"	m	struct:PT	typeref:typename:double	file:
y	code/Geometry/Onion Decomposition.cpp	/^    long long x,y;$/;"	m	struct:PT	typeref:typename:long long	file:
y	code/Geometry/Point Location.cpp	/^    ll x, y;$/;"	m	struct:PT	typeref:typename:ll	file:
y	code/Geometry/Voronoi Diagram.cpp	/^    double x, y;$/;"	m	struct:PT	typeref:typename:double	file:
y	code/Geometry/Voronoi Diagram.cpp	/^    long long x, y;$/;"	m	struct:P	typeref:typename:long long	file:
y	code/Graph Theory/Manhattan MST.cpp	/^  int x, y, id;$/;"	m	struct:PT	typeref:typename:int	file:
y	code/Math/Determinant of Sparse Matrix.cpp	/^struct Elem { int x, y; mint v; };$/;"	m	struct:Elem	typeref:typename:int	file:
y	code/Math/Faulhaber Formula Fastest.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
y	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
y	code/Math/Linear Recurrence Fastest.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
y	code/Math/NTT Online.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
y	code/Math/NTT With Any Prime MOD.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
y	code/Math/Polynomial with Binomial Coefficients.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
y	code/Math/Polynomial.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
y	code/Math/Subset Sum Problem.cpp	/^  double x, y;$/;"	m	struct:base	typeref:typename:double	file:
y	code/Miscellaneous/BigInt.cpp	/^  T x, y;$/;"	m	struct:cplx	typeref:typename:T	file:
y	code/Miscellaneous/Subset Union of Bitsets.cpp	/^int x[N], y[N], c[N], dp[1 << 20], msk[N], ans[N];$/;"	v	typeref:typename:int[]
y	code/Number Theory/Bell Number.cpp	/^    double x, y;$/;"	m	struct:base	typeref:typename:double	file:
y	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^    double x, y;$/;"	m	struct:base	typeref:typename:double	file:
y	code/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^    double x, y;$/;"	m	struct:base	typeref:typename:double	file:
y	contests/LIT2021/C.cpp	/^    int x, y;$/;"	m	struct:P	typeref:typename:int	file:
yo	code-library/Data Structures/Binarizing a Tree.cpp	/^void yo(int u, int p, long long nw, int l) {$/;"	f	typeref:typename:void
yo	code-library/Data Structures/Centroid Decomposition Persistent.cpp	/^void yo(int u, int p, long long nw, int l) {$/;"	f	typeref:typename:void
yo	code-library/Data Structures/MOs on tree.cpp	/^inline void yo(int u) {$/;"	f	typeref:typename:void
yo	code-library/Data Structures/Sparse Table 2D.cpp	/^int yo(int x1, int y1, int x2, int y2) {$/;"	f	typeref:typename:int
yo	code-library/Dynamic Programming Optimizations/Connected Component DP.cpp	/^int yo(int i, int c, int sum, int ends) { \/\/(id, components, sum, borders)$/;"	f	typeref:typename:int
yo	code-library/Dynamic Programming Optimizations/Digit DP.cpp	/^int yo(int i, int mask, int rem, int f) {$/;"	f	typeref:typename:int
yo	code-library/Dynamic Programming Optimizations/Divide and Conquer Optimization.cpp	/^void yo(int i, int l, int r, int optl, int optr) {$/;"	f	typeref:typename:void
yo	code-library/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^void yo(int u, int pre = 0) {$/;"	f	typeref:typename:void
yo	code-library/Dynamic Programming Optimizations/XOR Equation.cpp	/^int yo(int i, int par, int f) {$/;"	f	typeref:typename:int
yo	code-library/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^vector<mint> yo(int n, int k) {$/;"	f	typeref:typename:vector<mint>
yo	code-library/Geometry/Voronoi Diagram.cpp	/^inline void yo(PT a, vector<PT> &can) {$/;"	f	typeref:typename:void
yo	code-library/Graph Theory/Counting Labeled Graphs.cpp	/^mint yo(int n, int k) {$/;"	f	typeref:typename:mint
yo	code-library/Graph Theory/Dominator Tree.cpp	/^void yo(int u, int pre = 0) {$/;"	f	typeref:typename:void
yo	code-library/Graph Theory/Hafnian of a Matrix.cpp	/^    vector<mint> yo(const vector<vector<vector<mint>>>& v) {$/;"	f	struct:Hafnian	typeref:typename:vector<mint>	file:
yo	code-library/Graph Theory/Kuhns Algorithm.cpp	/^  bool yo(int u) {$/;"	f	struct:Kuhn	typeref:typename:bool	file:
yo	code-library/Graph Theory/Maximum Density Subgraph.cpp	/^bool yo(double g) {$/;"	f	typeref:typename:bool
yo	code-library/Graph Theory/Maximum Independant Set.cpp	/^int yo() {$/;"	f	typeref:typename:int
yo	code-library/Graph Theory/Tree Isomorphism.cpp	/^  mint yo(int u, int pre = 0) {$/;"	f	struct:Tree	typeref:typename:mint	file:
yo	code-library/Graph Theory/Virtual Tree.cpp	/^int yo(int u) {$/;"	f	typeref:typename:int
yo	code-library/Math/All Possible Perfect Matching XOR Values.cpp	/^void yo(int cur) {$/;"	f	typeref:typename:void
yo	code-library/Math/BerleKamp Massey.cpp	/^int yo(int i, int last) {$/;"	f	typeref:typename:int
yo	code-library/Math/Characteristic Polynomial Faster.cpp	/^mint yo(vector<vector<mint>> a, mint x) {$/;"	f	typeref:typename:mint
yo	code-library/Math/Faulhaber Formula Fastest.cpp	/^void yo(int l, int r, poly &up, poly &down) {$/;"	f	typeref:typename:void
yo	code-library/Math/Generating Function of a Linear Recurrence.cpp	/^mint yo(vector<mint> a, vector<mint> c) {$/;"	f	typeref:typename:mint
yo	code-library/Math/Hafnian of a Matrix.cpp	/^  vector<mint> yo(const vector<vector<vector<mint>>>& v) {$/;"	f	namespace:Hafnian	typeref:typename:vector<mint>
yo	code-library/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^vector<mint> yo(int id, int l, int r, vector<mint> &p) {$/;"	f	typeref:typename:vector<mint>
yo	code-library/Math/NTT Online.cpp	/^void yo(int l, int r) {$/;"	f	typeref:typename:void
yo	code-library/Math/Number of Solutions of A Equation MITM.cpp	/^mint yo(vector<long long> a, long long s) {$/;"	f	typeref:typename:mint
yo	code-library/Math/Polynomial Sum.cpp	/^mint yo(vector<mint> S, long long n, mint a, int k) {$/;"	f	typeref:typename:mint
yo	code-library/Miscellaneous/Schreier–Sims algorithm.cpp	/^  int yo(vector<int> p, bool add_to_group = 1){$/;"	f	struct:Group	typeref:typename:int	file:
yo	code-library/Miscellaneous/XOR Equation Arbitrary Range.cpp	/^int yo(int i, int par, int f) {$/;"	f	typeref:typename:int
yo	code-library/Number Theory/K Divisors.cpp	/^  long long yo(long long n, int k) {$/;"	f	namespace:pcf	typeref:typename:long long
yo	code-library/Number Theory/LCM of Fibonacci Numbers.cpp	/^int yo(vector<int> a) {$/;"	f	typeref:typename:int
yo	code-library/Number Theory/Linear Diophantine Equation Three Variables with Nonnegative Solutions.cpp	/^T yo(T a, T b, T c, T n) {$/;"	f	typeref:typename:T
yo	code-library/Number Theory/Min_25 Sieve.cpp	/^T yo(ll x, int j) {$/;"	f	typeref:typename:T
yo	code-library/Number Theory/Number of Distinct Kth Powers Modulo n.cpp	/^ll yo(ll k, ll n) {$/;"	f	typeref:typename:ll
yo	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^mint yo(vector<long long> a, long long s) {$/;"	f	typeref:typename:mint
yo	code-library/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^mint yo(int n, int s, int l, int r) { $/;"	f	typeref:typename:mint
yo	code-library/Number Theory/Partition Function.cpp	/^vector<mint> yo(int n) {$/;"	f	typeref:typename:vector<mint>
yo	code-library/Number Theory/Power Tower.cpp	/^ll yo(ll l, ll r, ll m) {$/;"	f	typeref:typename:ll
yo	code-library/Number Theory/Prime Counting Function.cpp	/^  long long yo(long long n, int k) {$/;"	f	namespace:pcf	typeref:typename:long long
yo	code-library/Number Theory/Smallest Number Having Exactly K Divisors.cpp	/^pair<double, int> yo(int i, long long n) { \/\/ it solves for odd divisors$/;"	f	typeref:typename:pair<double,int>
yo	code-library/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^void yo(int l, int r, poly &ans){$/;"	f	typeref:typename:void
yo	code-library/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^vector<int> yo(int n, vector<int> a) {$/;"	f	typeref:typename:vector<int>
yo	code-library/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  bool yo(int u) {$/;"	f	struct:Kuhn	typeref:typename:bool	file:
yo	code-library/Strings/Bit LCS.cpp	/^    void yo(const Bitset &r) {$/;"	f	struct:Bitset	typeref:typename:void	file:
yo	code-library/Strings/Cyclic LCS.cpp	/^int yo(string s, string t) {$/;"	f	typeref:typename:int
yo	code-library/Strings/Prefix Automaton.cpp	/^int yo(int i, int j)$/;"	f	typeref:typename:int
yo	code/Data Structures/Binarizing a Tree.cpp	/^void yo(int u, int p, long long nw, int l) {$/;"	f	typeref:typename:void
yo	code/Data Structures/Centroid Decomposition Persistent.cpp	/^void yo(int u, int p, long long nw, int l) {$/;"	f	typeref:typename:void
yo	code/Data Structures/MOs on tree.cpp	/^inline void yo(int u) {$/;"	f	typeref:typename:void
yo	code/Data Structures/Sparse Table 2D.cpp	/^int yo(int x1, int y1, int x2, int y2) {$/;"	f	typeref:typename:int
yo	code/Dynamic Programming Optimizations/Connected Component DP.cpp	/^int yo(int i, int c, int sum, int ends) { \/\/(id, components, sum, borders)$/;"	f	typeref:typename:int
yo	code/Dynamic Programming Optimizations/Digit DP.cpp	/^int yo(int i, int mask, int rem, int f) {$/;"	f	typeref:typename:int
yo	code/Dynamic Programming Optimizations/Divide and Conquer Optimization.cpp	/^void yo(int i, int l, int r, int optl, int optr) {$/;"	f	typeref:typename:void
yo	code/Dynamic Programming Optimizations/Persistent Li Chao Tree.cpp	/^void yo(int u, int pre = 0) {$/;"	f	typeref:typename:void
yo	code/Dynamic Programming Optimizations/XOR Equation.cpp	/^int yo(int i, int par, int f) {$/;"	f	typeref:typename:int
yo	code/Dynamic Programming Optimizations/x2 +1 trick.cpp	/^vector<mint> yo(int n, int k) {$/;"	f	typeref:typename:vector<mint>
yo	code/Geometry/Voronoi Diagram.cpp	/^inline void yo(PT a, vector<PT> &can) {$/;"	f	typeref:typename:void
yo	code/Graph Theory/Counting Labeled Graphs.cpp	/^mint yo(int n, int k) {$/;"	f	typeref:typename:mint
yo	code/Graph Theory/Dominator Tree.cpp	/^void yo(int u, int pre = 0) {$/;"	f	typeref:typename:void
yo	code/Graph Theory/Hafnian of a Matrix.cpp	/^    vector<mint> yo(const vector<vector<vector<mint>>>& v) {$/;"	f	struct:Hafnian	typeref:typename:vector<mint>	file:
yo	code/Graph Theory/Kuhns Algorithm.cpp	/^  bool yo(int u) {$/;"	f	struct:Kuhn	typeref:typename:bool	file:
yo	code/Graph Theory/Maximum Density Subgraph.cpp	/^bool yo(double g) {$/;"	f	typeref:typename:bool
yo	code/Graph Theory/Maximum Independant Set.cpp	/^int yo() {$/;"	f	typeref:typename:int
yo	code/Graph Theory/Tree Isomorphism.cpp	/^  mint yo(int u, int pre = 0) {$/;"	f	struct:Tree	typeref:typename:mint	file:
yo	code/Graph Theory/Virtual Tree.cpp	/^int yo(int u) {$/;"	f	typeref:typename:int
yo	code/Math/All Possible Perfect Matching XOR Values.cpp	/^void yo(int cur) {$/;"	f	typeref:typename:void
yo	code/Math/BerleKamp Massey.cpp	/^int yo(int i, int last) {$/;"	f	typeref:typename:int
yo	code/Math/Characteristic Polynomial Faster.cpp	/^mint yo(vector<vector<mint>> a, mint x) {$/;"	f	typeref:typename:mint
yo	code/Math/Faulhaber Formula Fastest.cpp	/^void yo(int l, int r, poly &up, poly &down) {$/;"	f	typeref:typename:void
yo	code/Math/Generating Function of a Linear Recurrence.cpp	/^mint yo(vector<mint> a, vector<mint> c) {$/;"	f	typeref:typename:mint
yo	code/Math/Hafnian of a Matrix.cpp	/^  vector<mint> yo(const vector<vector<vector<mint>>>& v) {$/;"	f	namespace:Hafnian	typeref:typename:vector<mint>
yo	code/Math/Lagrange Interpolation with Polynomial Extraction.cpp	/^vector<mint> yo(int id, int l, int r, vector<mint> &p) {$/;"	f	typeref:typename:vector<mint>
yo	code/Math/NTT Online.cpp	/^void yo(int l, int r) {$/;"	f	typeref:typename:void
yo	code/Math/Number of Solutions of A Equation MITM.cpp	/^mint yo(vector<long long> a, long long s) {$/;"	f	typeref:typename:mint
yo	code/Math/Polynomial Sum.cpp	/^mint yo(vector<mint> S, long long n, mint a, int k) {$/;"	f	typeref:typename:mint
yo	code/Miscellaneous/Schreier–Sims algorithm.cpp	/^  int yo(vector<int> p, bool add_to_group = 1){$/;"	f	struct:Group	typeref:typename:int	file:
yo	code/Miscellaneous/XOR Equation Arbitrary Range.cpp	/^int yo(int i, int par, int f) {$/;"	f	typeref:typename:int
yo	code/Number Theory/K Divisors.cpp	/^  long long yo(long long n, int k) {$/;"	f	namespace:pcf	typeref:typename:long long
yo	code/Number Theory/LCM of Fibonacci Numbers.cpp	/^int yo(vector<int> a) {$/;"	f	typeref:typename:int
yo	code/Number Theory/Linear Diophantine Equation Three Variables with Nonnegative Solutions.cpp	/^T yo(T a, T b, T c, T n) {$/;"	f	typeref:typename:T
yo	code/Number Theory/Min_25 Sieve.cpp	/^T yo(ll x, int j) {$/;"	f	typeref:typename:T
yo	code/Number Theory/Number of Distinct Kth Powers Modulo n.cpp	/^ll yo(ll k, ll n) {$/;"	f	typeref:typename:ll
yo	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation with Variable Upper Bound Constraints.cpp	/^mint yo(vector<long long> a, long long s) {$/;"	f	typeref:typename:mint
yo	code/Number Theory/Number of Solutions to a Basic Linear Algebraic Equation.cpp	/^mint yo(int n, int s, int l, int r) { $/;"	f	typeref:typename:mint
yo	code/Number Theory/Partition Function.cpp	/^vector<mint> yo(int n) {$/;"	f	typeref:typename:vector<mint>
yo	code/Number Theory/Power Tower.cpp	/^ll yo(ll l, ll r, ll m) {$/;"	f	typeref:typename:ll
yo	code/Number Theory/Prime Counting Function.cpp	/^  long long yo(long long n, int k) {$/;"	f	namespace:pcf	typeref:typename:long long
yo	code/Number Theory/Smallest Number Having Exactly K Divisors.cpp	/^pair<double, int> yo(int i, long long n) { \/\/ it solves for odd divisors$/;"	f	typeref:typename:pair<double,int>
yo	code/Number Theory/Stirling Number of the Second Kind for Fixed k.cpp	/^void yo(int l, int r, poly &ans){$/;"	f	typeref:typename:void
yo	code/Number Theory/Sum of C(a(i), k) for each k from 1 to n.cpp	/^vector<int> yo(int n, vector<int> a) {$/;"	f	typeref:typename:vector<int>
yo	code/Strings/Aho Corasick All Pair Occurrence Relation.cpp	/^  bool yo(int u) {$/;"	f	struct:Kuhn	typeref:typename:bool	file:
yo	code/Strings/Bit LCS.cpp	/^    void yo(const Bitset &r) {$/;"	f	struct:Bitset	typeref:typename:void	file:
yo	code/Strings/Cyclic LCS.cpp	/^int yo(string s, string t) {$/;"	f	typeref:typename:int
yo	code/Strings/Prefix Automaton.cpp	/^int yo(int i, int j)$/;"	f	typeref:typename:int
z	code-library/Geometry/Geometry 3D.cpp	/^    double x, y, z;$/;"	m	struct:p3	typeref:typename:double	file:
z	code-library/Math/Integration (Romberg).cpp	/^int z, d;$/;"	v	typeref:typename:int
z	code-library/Math/Integration (Simpsons).cpp	/^int z, d;$/;"	v	typeref:typename:int
z	code-library/Math/Inverse of A Matrix modulo 2.cpp	/^bitset<N> z;$/;"	v	typeref:typename:bitset<N>
z	code-library/Miscellaneous/Bitset Custom.cpp	/^unsigned long long o[64][64], z[64][64];$/;"	v	typeref:typename:unsigned long long[64][64]
z	code/Geometry/Geometry 3D.cpp	/^    double x, y, z;$/;"	m	struct:p3	typeref:typename:double	file:
z	code/Math/Integration (Romberg).cpp	/^int z, d;$/;"	v	typeref:typename:int
z	code/Math/Integration (Simpsons).cpp	/^int z, d;$/;"	v	typeref:typename:int
z	code/Math/Inverse of A Matrix modulo 2.cpp	/^bitset<N> z;$/;"	v	typeref:typename:bitset<N>
z	code/Miscellaneous/Bitset Custom.cpp	/^unsigned long long o[64][64], z[64][64];$/;"	v	typeref:typename:unsigned long long[64][64]
z_function	code-library/Strings/Z Algorithm.cpp	/^vector<int> z_function(string s) {$/;"	f	typeref:typename:vector<int>
z_function	code/Strings/Z Algorithm.cpp	/^vector<int> z_function(string s) {$/;"	f	typeref:typename:vector<int>
zero	code-library/Geometry/Geometry 3D.cpp	/^}zero(0, 0, 0);$/;"	v	typeref:struct:p3
zero	code-library/Miscellaneous/BigInt.cpp	/^  bool zero() const {$/;"	f	struct:BigInt	typeref:typename:bool	file:
zero	code/Geometry/Geometry 3D.cpp	/^}zero(0, 0, 0);$/;"	v	typeref:struct:p3
zero	code/Miscellaneous/BigInt.cpp	/^  bool zero() const {$/;"	f	struct:BigInt	typeref:typename:bool	file:
zeta_transform	code-library/Dynamic Programming Optimizations/SOS convolutions.cpp	/^vector<int> zeta_transform(vector<int> f) {$/;"	f	namespace:SOS	typeref:typename:vector<int>
zeta_transform	code/Dynamic Programming Optimizations/SOS convolutions.cpp	/^vector<int> zeta_transform(vector<int> f) {$/;"	f	namespace:SOS	typeref:typename:vector<int>
zeta_transform_for_supermasks	code-library/Dynamic Programming Optimizations/SOS convolutions.cpp	/^vector<int> zeta_transform_for_supermasks(vector<int> f) {$/;"	f	namespace:SOS	typeref:typename:vector<int>
zeta_transform_for_supermasks	code/Dynamic Programming Optimizations/SOS convolutions.cpp	/^vector<int> zeta_transform_for_supermasks(vector<int> f) {$/;"	f	namespace:SOS	typeref:typename:vector<int>
{	dotfiles/macinit.vim	/^inoremap { {}<Left>$/;"	m
{<CR>	dotfiles/macinit.vim	/^inoremap {<CR> {<CR>}<Esc>O<space><BS>$/;"	m
{{	dotfiles/macinit.vim	/^inoremap {{ {$/;"	m
{}	dotfiles/macinit.vim	/^inoremap {} {}$/;"	m
~wavelet_tree	code-library/Data Structures/Wavelet Tree.cpp	/^  ~wavelet_tree() {$/;"	f	struct:wavelet_tree	file:
~wavelet_tree	code-library/Strings/Number of Palindromes in Range.cpp	/^  ~wavelet_tree() {$/;"	f	struct:wavelet_tree	file:
~wavelet_tree	code/Data Structures/Wavelet Tree.cpp	/^  ~wavelet_tree() {$/;"	f	struct:wavelet_tree	file:
~wavelet_tree	code/Strings/Number of Palindromes in Range.cpp	/^  ~wavelet_tree() {$/;"	f	struct:wavelet_tree	file:
